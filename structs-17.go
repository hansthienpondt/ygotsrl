/*
Package ygotsrl is a generated package which contains definitions
of structs which represent a YANG schema. The generated schema can be
compressed by a series of transformations (compression was false
in this case).

This package was generated by /home/hans/go/pkg/mod/github.com/openconfig/ygot@v0.29.17/genutil/names.go
using the following YANG input files:
	- work/srlinux-yang-models/srl_nokia/models/acl/srl_nokia-acl-policers.yang
	- work/srlinux-yang-models/srl_nokia/models/acl/srl_nokia-acl-qos.yang
	- work/srlinux-yang-models/srl_nokia/models/acl/srl_nokia-acl.yang
	- work/srlinux-yang-models/srl_nokia/models/acl/srl_nokia-packet-match-types.yang
	- work/srlinux-yang-models/srl_nokia/models/bfd/srl_nokia-bfd.yang
	- work/srlinux-yang-models/srl_nokia/models/bfd/srl_nokia-micro-bfd.yang
	- work/srlinux-yang-models/srl_nokia/models/common/srl_nokia-common.yang
	- work/srlinux-yang-models/srl_nokia/models/common/srl_nokia-extensions.yang
	- work/srlinux-yang-models/srl_nokia/models/common/srl_nokia-features.yang
	- work/srlinux-yang-models/srl_nokia/models/ethcfm/srl_nokia-ethcfm-types.yang
	- work/srlinux-yang-models/srl_nokia/models/ethcfm/srl_nokia-ethcfm.yang
	- work/srlinux-yang-models/srl_nokia/models/ethcfm/srl_nokia-oam-pm-ethcfm.yang
	- work/srlinux-yang-models/srl_nokia/models/grpc/srl_nokia-gnsi-authz.yang
	- work/srlinux-yang-models/srl_nokia/models/grpc/srl_nokia-gnsi-certz.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-if-ip.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-if-mpls.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-bridge-table-mac-duplication-entries.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-bridge-table-mac-learning-entries.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-bridge-table-mac-table.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-bridge-table-statistics.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-bridge-table.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-ethernet-segment-association.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-ip-dhcp-relay.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-ip-dhcp-server.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-ip-dhcp.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-ip-vrrp.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-l2cp.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-lag.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-local-mirror-destination.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-nbr-evpn.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-nbr-virtual-ip-discovery.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-nbr.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-p4rt.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-router-adv.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-vlans.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-vxdp.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-lacp.yang
	- work/srlinux-yang-models/srl_nokia/models/ipamps/srl_nokia-ippm-source-udp-pool.yang
	- work/srlinux-yang-models/srl_nokia/models/ipamps/srl_nokia-link-measurement.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-aggregate-routes.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bgp-evpn-bgp-instance-mpls-bridge-table-multicast-destinations.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bgp-evpn-bgp-instance-mpls-bridge-table-statistics.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bgp-evpn-bgp-instance-mpls-bridge-table-unicast-destinations.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bgp-evpn-bgp-instance-mpls-vpws-destinations.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bgp-evpn.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bgp-ipvpn.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bgp-vpn.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bgp.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table-mac-duplication-entries.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table-mac-duplication.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table-mac-learning-entries.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table-mac-learning.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table-mac-limit.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table-mac-table.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table-proxy-arp-nd.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table-reserved-macs.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table-shg.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table-static-mac.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-connection-point.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-icmp.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-igmp-snooping.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-igmp-types.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-igmp.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-ip-route-tables.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-isis-lsdb-types.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-isis-lsdb.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-isis.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-ldp.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-linux.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-maintenance-policies.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-mld-snooping.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-mld.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-mpls-route-tables.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-mpls.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-multicast-mfib-tables.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-mvpn-l3.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-network-instance-mtu.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-network-instance.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-next-hop-groups.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-ospf-lsdb.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-ospf-types.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-ospf.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-ospfv3-lsas.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-pcep.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-pim.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-policy-forwarding.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-rib-bgp.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-segment-routing.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-static-routes.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-tcp-udp.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-te-policies.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-traffic-engineering.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-tunnel-tables.yang
	- work/srlinux-yang-models/srl_nokia/models/oam/srl_nokia-lsp-ping-trace.yang
	- work/srlinux-yang-models/srl_nokia/models/oam/srl_nokia-oam-pm-ip.yang
	- work/srlinux-yang-models/srl_nokia/models/oam/srl_nokia-oam-pm-types.yang
	- work/srlinux-yang-models/srl_nokia/models/oam/srl_nokia-oam-pm.yang
	- work/srlinux-yang-models/srl_nokia/models/oam/srl_nokia-oam.yang
	- work/srlinux-yang-models/srl_nokia/models/oam/srl_nokia-stamp.yang
	- work/srlinux-yang-models/srl_nokia/models/oam/srl_nokia-twamp.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-acl.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-cgroup.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-chassis.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-control.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-cpu.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-datapath-resources.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-disk.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-fabric.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-fan.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-healthz.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-lc.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-linecard-fib.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-memory.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-mtu.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-p4rt.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-pipeline-counters.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-psu.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-qos.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-redundancy.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-resource-mgmt.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-resource-monitoring.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-secure-boot.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-tcam.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-tpm.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-vxdp.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform.yang
	- work/srlinux-yang-models/srl_nokia/models/qos/srl_nokia-qos-policers.yang
	- work/srlinux-yang-models/srl_nokia/models/qos/srl_nokia-qos.yang
	- work/srlinux-yang-models/srl_nokia/models/routing-policy/srl_nokia-policy-types.yang
	- work/srlinux-yang-models/srl_nokia/models/routing-policy/srl_nokia-routing-policy.yang
	- work/srlinux-yang-models/srl_nokia/models/sync/srl_nokia-sync-freq.yang
	- work/srlinux-yang-models/srl_nokia/models/sync/srl_nokia-sync-interfaces.yang
	- work/srlinux-yang-models/srl_nokia/models/sync/srl_nokia-sync-ptp.yang
	- work/srlinux-yang-models/srl_nokia/models/sync/srl_nokia-sync-types.yang
	- work/srlinux-yang-models/srl_nokia/models/sync/srl_nokia-sync.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-aaa-password.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-aaa-radius.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-aaa-tacacs.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-aaa-types.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-aaa.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-app-mgmt.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-boot.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-configuration-role.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-configuration.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-dhcp-server.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-dns.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-event-handler.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-ftp.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-gnmi-server.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-gribi-server.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-json-rpc.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-keychains.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-license.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-lldp-types.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-lldp.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-load-balancing.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-logging.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-maintenance-mode.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-mirroring.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-mpls-label-management.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-mpls-services-evpn-label-management.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-mpls-services-network-instance-label-management.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-mtu.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-ntp.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-openconfig.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-p4rt-server.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-packet-link-qual.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-ra_guard.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-sflow.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-snmp-trace.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-snmp.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-ssh.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system-banner.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system-bridge-table-proxy-arp.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system-bridge-table.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system-info.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system-multicast-mfib-table.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system-multicast.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system-name.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system-network-instance-bgp-evpn-ethernet-segments.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system-network-instance-bgp-vpn.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system-network-instance.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system-protocols.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-timezone.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-tls.yang
	- work/srlinux-yang-models/srl_nokia/models/transport-security/srl_nokia-macsec.yang
	- work/srlinux-yang-models/srl_nokia/models/transport-security/srl_nokia-transport-security.yang
	- work/srlinux-yang-models/srl_nokia/models/tunnel/srl_nokia-tunnel-interfaces-vxlan-interface-bridge-table-multicast-destinations.yang
	- work/srlinux-yang-models/srl_nokia/models/tunnel/srl_nokia-tunnel-interfaces-vxlan-interface-bridge-table-unicast-destinations.yang
	- work/srlinux-yang-models/srl_nokia/models/tunnel/srl_nokia-tunnel-interfaces-vxlan-interface-bridge-table-unicast-es-destination-vteps.yang
	- work/srlinux-yang-models/srl_nokia/models/tunnel/srl_nokia-tunnel-interfaces-vxlan-interface-bridge-table.yang
	- work/srlinux-yang-models/srl_nokia/models/tunnel/srl_nokia-tunnel-interfaces.yang
	- work/srlinux-yang-models/srl_nokia/models/tunnel/srl_nokia-tunnel.yang
	- work/srlinux-yang-models/srl_nokia/models/tunnel/srl_nokia-vxlan-tunnel-vtep.yang
Imported modules were sourced from:
	- work/srlinux-yang-models/...
*/
package ygotsrl

import (
	"fmt"
	"reflect"

	"github.com/openconfig/ygot/ygot"
	"github.com/openconfig/ygot/ytypes"
)

// SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation_Host_Options represents the /srl_nokia-system/system/dhcp-server/network-instance/dhcpv4/static-allocation/host/options YANG schema element.
type SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation_Host_Options struct {
	BootfileName      *string  `path:"bootfile-name" module:"srl_nokia-dhcp-server"`
	DnsServer         []string `path:"dns-server" module:"srl_nokia-dhcp-server"`
	DomainName        *string  `path:"domain-name" module:"srl_nokia-dhcp-server"`
	Hostname          *string  `path:"hostname" module:"srl_nokia-dhcp-server"`
	NtpServer         []string `path:"ntp-server" module:"srl_nokia-dhcp-server"`
	Router            *string  `path:"router" module:"srl_nokia-dhcp-server"`
	ServerId          *string  `path:"server-id" module:"srl_nokia-dhcp-server"`
	TftpServerAddress []string `path:"tftp-server-address" module:"srl_nokia-dhcp-server"`
	TftpServerName    *string  `path:"tftp-server-name" module:"srl_nokia-dhcp-server"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation_Host_Options implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation_Host_Options) IsYANGGoStruct() {
}

// GetBootfileName retrieves the value of the leaf BootfileName from the SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation_Host_Options
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if BootfileName is set, it can
// safely use t.GetBootfileName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.BootfileName == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation_Host_Options) GetBootfileName() string {
	if t == nil || t.BootfileName == nil {
		return ""
	}
	return *t.BootfileName
}

// GetDnsServer retrieves the value of the leaf DnsServer from the SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation_Host_Options
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DnsServer is set, it can
// safely use t.GetDnsServer() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DnsServer == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation_Host_Options) GetDnsServer() []string {
	if t == nil || t.DnsServer == nil {
		return nil
	}
	return t.DnsServer
}

// GetDomainName retrieves the value of the leaf DomainName from the SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation_Host_Options
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DomainName is set, it can
// safely use t.GetDomainName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DomainName == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation_Host_Options) GetDomainName() string {
	if t == nil || t.DomainName == nil {
		return ""
	}
	return *t.DomainName
}

// GetHostname retrieves the value of the leaf Hostname from the SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation_Host_Options
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Hostname is set, it can
// safely use t.GetHostname() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Hostname == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation_Host_Options) GetHostname() string {
	if t == nil || t.Hostname == nil {
		return ""
	}
	return *t.Hostname
}

// GetNtpServer retrieves the value of the leaf NtpServer from the SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation_Host_Options
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NtpServer is set, it can
// safely use t.GetNtpServer() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NtpServer == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation_Host_Options) GetNtpServer() []string {
	if t == nil || t.NtpServer == nil {
		return nil
	}
	return t.NtpServer
}

// GetRouter retrieves the value of the leaf Router from the SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation_Host_Options
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Router is set, it can
// safely use t.GetRouter() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Router == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation_Host_Options) GetRouter() string {
	if t == nil || t.Router == nil {
		return ""
	}
	return *t.Router
}

// GetServerId retrieves the value of the leaf ServerId from the SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation_Host_Options
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ServerId is set, it can
// safely use t.GetServerId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ServerId == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation_Host_Options) GetServerId() string {
	if t == nil || t.ServerId == nil {
		return ""
	}
	return *t.ServerId
}

// GetTftpServerAddress retrieves the value of the leaf TftpServerAddress from the SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation_Host_Options
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TftpServerAddress is set, it can
// safely use t.GetTftpServerAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TftpServerAddress == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation_Host_Options) GetTftpServerAddress() []string {
	if t == nil || t.TftpServerAddress == nil {
		return nil
	}
	return t.TftpServerAddress
}

// GetTftpServerName retrieves the value of the leaf TftpServerName from the SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation_Host_Options
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TftpServerName is set, it can
// safely use t.GetTftpServerName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TftpServerName == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation_Host_Options) GetTftpServerName() string {
	if t == nil || t.TftpServerName == nil {
		return ""
	}
	return *t.TftpServerName
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation_Host_Options
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation_Host_Options) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation_Host_Options) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation_Host_Options"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation_Host_Options) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation_Host_Options) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation_Host_Options.
func (*SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation_Host_Options) ΛBelongingModule() string {
	return "srl_nokia-dhcp-server"
}

// SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_TraceOptions represents the /srl_nokia-system/system/dhcp-server/network-instance/dhcpv4/trace-options YANG schema element.
type SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_TraceOptions struct {
	Trace []E_SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_TraceOptions_Trace `path:"trace" module:"srl_nokia-dhcp-server"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_TraceOptions implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_TraceOptions) IsYANGGoStruct() {}

// GetTrace retrieves the value of the leaf Trace from the SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_TraceOptions
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Trace is set, it can
// safely use t.GetTrace() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Trace == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_TraceOptions) GetTrace() []E_SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_TraceOptions_Trace {
	if t == nil || t.Trace == nil {
		return nil
	}
	return t.Trace
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_TraceOptions
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_TraceOptions) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_TraceOptions) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_TraceOptions"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_TraceOptions) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_TraceOptions) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_TraceOptions.
func (*SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_TraceOptions) ΛBelongingModule() string {
	return "srl_nokia-dhcp-server"
}

// SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6 represents the /srl_nokia-system/system/dhcp-server/network-instance/dhcpv6 YANG schema element.
type SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6 struct {
	AdminState       E_SrlNokiaCommon_AdminState                                               `path:"admin-state" module:"srl_nokia-dhcp-server"`
	Options          *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_Options          `path:"options" module:"srl_nokia-dhcp-server"`
	StaticAllocation *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation `path:"static-allocation" module:"srl_nokia-dhcp-server"`
	TraceOptions     *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_TraceOptions     `path:"trace-options" module:"srl_nokia-dhcp-server"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6 implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6) IsYANGGoStruct() {}

// GetOrCreateOptions retrieves the value of the Options field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6) GetOrCreateOptions() *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_Options {
	if t.Options != nil {
		return t.Options
	}
	t.Options = &SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_Options{}
	return t.Options
}

// GetOrCreateStaticAllocation retrieves the value of the StaticAllocation field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6) GetOrCreateStaticAllocation() *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation {
	if t.StaticAllocation != nil {
		return t.StaticAllocation
	}
	t.StaticAllocation = &SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation{}
	return t.StaticAllocation
}

// GetOrCreateTraceOptions retrieves the value of the TraceOptions field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6) GetOrCreateTraceOptions() *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_TraceOptions {
	if t.TraceOptions != nil {
		return t.TraceOptions
	}
	t.TraceOptions = &SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_TraceOptions{}
	return t.TraceOptions
}

// GetOptions returns the value of the Options struct pointer
// from SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6. If the receiver or the field Options is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6) GetOptions() *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_Options {
	if t != nil && t.Options != nil {
		return t.Options
	}
	return nil
}

// GetStaticAllocation returns the value of the StaticAllocation struct pointer
// from SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6. If the receiver or the field StaticAllocation is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6) GetStaticAllocation() *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation {
	if t != nil && t.StaticAllocation != nil {
		return t.StaticAllocation
	}
	return nil
}

// GetTraceOptions returns the value of the TraceOptions struct pointer
// from SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6. If the receiver or the field TraceOptions is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6) GetTraceOptions() *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_TraceOptions {
	if t != nil && t.TraceOptions != nil {
		return t.TraceOptions
	}
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_disable
	}
	return t.AdminState
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_disable
	}
	t.Options.PopulateDefaults()
	t.StaticAllocation.PopulateDefaults()
	t.TraceOptions.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6.
func (*SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6) ΛBelongingModule() string {
	return "srl_nokia-dhcp-server"
}

// SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_Options represents the /srl_nokia-system/system/dhcp-server/network-instance/dhcpv6/options YANG schema element.
type SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_Options struct {
	DnsServer []string `path:"dns-server" module:"srl_nokia-dhcp-server"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_Options implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_Options) IsYANGGoStruct() {}

// GetDnsServer retrieves the value of the leaf DnsServer from the SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_Options
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DnsServer is set, it can
// safely use t.GetDnsServer() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DnsServer == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_Options) GetDnsServer() []string {
	if t == nil || t.DnsServer == nil {
		return nil
	}
	return t.DnsServer
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_Options
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_Options) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_Options) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_Options"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_Options) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_Options) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_Options.
func (*SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_Options) ΛBelongingModule() string {
	return "srl_nokia-dhcp-server"
}

// SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation represents the /srl_nokia-system/system/dhcp-server/network-instance/dhcpv6/static-allocation YANG schema element.
type SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation struct {
	Host map[string]*SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation_Host `path:"host" module:"srl_nokia-dhcp-server"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation) IsYANGGoStruct() {}

// NewHost creates a new entry in the Host list of the
// SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation) NewHost(
	Mac string,
) (*SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation_Host, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Host == nil {
		t.Host = make(map[string]*SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation_Host)
	}

	key := Mac

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Host[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Host", key)
	}

	t.Host[key] = &SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation_Host{
		Mac: &Mac,
	}

	return t.Host[key], nil
}

// RenameHost renames an entry in the list Host within
// the SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation) RenameHost(oldK, newK string) error {
	if _, ok := t.Host[newK]; ok {
		return fmt.Errorf("key %v already exists in Host", newK)
	}

	e, ok := t.Host[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Host", oldK)
	}
	e.Mac = &newK

	t.Host[newK] = e
	delete(t.Host, oldK)
	return nil
}

// GetOrCreateHost retrieves the value with the specified keys from
// the receiver SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation) GetOrCreateHost(
	Mac string,
) *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation_Host {
	key := Mac

	if v, ok := t.Host[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewHost(Mac)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateHost got unexpected error: %v", err))
	}
	return v
}

// GetHost retrieves the value with the specified key from
// the Host map field of SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation) GetHost(
	Mac string,
) *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation_Host {
	if t == nil {
		return nil
	}

	key := Mac

	if lm, ok := t.Host[key]; ok {
		return lm
	}
	return nil
}

// DeleteHost deletes the value with the specified keys from
// the receiver SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation) DeleteHost(Mac string) {
	key := Mac

	delete(t.Host, key)
}

// AppendHost appends the supplied SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation_Host struct to the
// list Host of SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation. If the key value(s) specified in
// the supplied SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation_Host already exist in the list, an error is
// returned.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation) AppendHost(
	v *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation_Host,
) error {
	if v.Mac == nil {
		return fmt.Errorf("invalid nil key received for Mac")
	}

	key := *v.Mac

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Host == nil {
		t.Host = make(map[string]*SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation_Host)
	}

	if _, ok := t.Host[key]; ok {
		return fmt.Errorf("duplicate key for list Host %v", key)
	}

	t.Host[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Host {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation.
func (*SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation) ΛBelongingModule() string {
	return "srl_nokia-dhcp-server"
}

// SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation_Host represents the /srl_nokia-system/system/dhcp-server/network-instance/dhcpv6/static-allocation/host YANG schema element.
type SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation_Host struct {
	IpAddress *string                                                                                `path:"ip-address" module:"srl_nokia-dhcp-server"`
	Mac       *string                                                                                `path:"mac" module:"srl_nokia-dhcp-server"`
	Options   *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation_Host_Options `path:"options" module:"srl_nokia-dhcp-server"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation_Host implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation_Host) IsYANGGoStruct() {
}

// GetOrCreateOptions retrieves the value of the Options field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation_Host) GetOrCreateOptions() *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation_Host_Options {
	if t.Options != nil {
		return t.Options
	}
	t.Options = &SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation_Host_Options{}
	return t.Options
}

// GetOptions returns the value of the Options struct pointer
// from SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation_Host. If the receiver or the field Options is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation_Host) GetOptions() *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation_Host_Options {
	if t != nil && t.Options != nil {
		return t.Options
	}
	return nil
}

// GetIpAddress retrieves the value of the leaf IpAddress from the SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation_Host
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IpAddress is set, it can
// safely use t.GetIpAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IpAddress == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation_Host) GetIpAddress() string {
	if t == nil || t.IpAddress == nil {
		return ""
	}
	return *t.IpAddress
}

// GetMac retrieves the value of the leaf Mac from the SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation_Host
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Mac is set, it can
// safely use t.GetMac() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Mac == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation_Host) GetMac() string {
	if t == nil || t.Mac == nil {
		return ""
	}
	return *t.Mac
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation_Host
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation_Host) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Options.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation_Host struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation_Host) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Mac == nil {
		return nil, fmt.Errorf("nil value for key Mac")
	}

	return map[string]interface{}{
		"mac": *t.Mac,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation_Host) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation_Host"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation_Host) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation_Host) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation_Host.
func (*SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation_Host) ΛBelongingModule() string {
	return "srl_nokia-dhcp-server"
}

// SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation_Host_Options represents the /srl_nokia-system/system/dhcp-server/network-instance/dhcpv6/static-allocation/host/options YANG schema element.
type SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation_Host_Options struct {
	DnsServer []string `path:"dns-server" module:"srl_nokia-dhcp-server"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation_Host_Options implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation_Host_Options) IsYANGGoStruct() {
}

// GetDnsServer retrieves the value of the leaf DnsServer from the SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation_Host_Options
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DnsServer is set, it can
// safely use t.GetDnsServer() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DnsServer == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation_Host_Options) GetDnsServer() []string {
	if t == nil || t.DnsServer == nil {
		return nil
	}
	return t.DnsServer
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation_Host_Options
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation_Host_Options) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation_Host_Options) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation_Host_Options"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation_Host_Options) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation_Host_Options) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation_Host_Options.
func (*SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation_Host_Options) ΛBelongingModule() string {
	return "srl_nokia-dhcp-server"
}

// SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_TraceOptions represents the /srl_nokia-system/system/dhcp-server/network-instance/dhcpv6/trace-options YANG schema element.
type SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_TraceOptions struct {
	Trace []E_SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_TraceOptions_Trace `path:"trace" module:"srl_nokia-dhcp-server"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_TraceOptions implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_TraceOptions) IsYANGGoStruct() {}

// GetTrace retrieves the value of the leaf Trace from the SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_TraceOptions
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Trace is set, it can
// safely use t.GetTrace() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Trace == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_TraceOptions) GetTrace() []E_SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_TraceOptions_Trace {
	if t == nil || t.Trace == nil {
		return nil
	}
	return t.Trace
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_TraceOptions
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_TraceOptions) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_TraceOptions) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_TraceOptions"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_TraceOptions) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_TraceOptions) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_TraceOptions.
func (*SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_TraceOptions) ΛBelongingModule() string {
	return "srl_nokia-dhcp-server"
}

// SrlNokiaSystem_System_Dns represents the /srl_nokia-system/system/dns YANG schema element.
type SrlNokiaSystem_System_Dns struct {
	HostEntry       map[string]*SrlNokiaSystem_System_Dns_HostEntry `path:"host-entry" module:"srl_nokia-dns"`
	NetworkInstance *string                                         `path:"network-instance" module:"srl_nokia-dns"`
	SearchList      []string                                        `path:"search-list" module:"srl_nokia-dns"`
	ServerList      []string                                        `path:"server-list" module:"srl_nokia-dns"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Dns implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Dns) IsYANGGoStruct() {}

// NewHostEntry creates a new entry in the HostEntry list of the
// SrlNokiaSystem_System_Dns struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_Dns) NewHostEntry(Name string) (*SrlNokiaSystem_System_Dns_HostEntry, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.HostEntry == nil {
		t.HostEntry = make(map[string]*SrlNokiaSystem_System_Dns_HostEntry)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.HostEntry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list HostEntry", key)
	}

	t.HostEntry[key] = &SrlNokiaSystem_System_Dns_HostEntry{
		Name: &Name,
	}

	return t.HostEntry[key], nil
}

// RenameHostEntry renames an entry in the list HostEntry within
// the SrlNokiaSystem_System_Dns struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaSystem_System_Dns) RenameHostEntry(oldK, newK string) error {
	if _, ok := t.HostEntry[newK]; ok {
		return fmt.Errorf("key %v already exists in HostEntry", newK)
	}

	e, ok := t.HostEntry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in HostEntry", oldK)
	}
	e.Name = &newK

	t.HostEntry[newK] = e
	delete(t.HostEntry, oldK)
	return nil
}

// GetOrCreateHostEntry retrieves the value with the specified keys from
// the receiver SrlNokiaSystem_System_Dns. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaSystem_System_Dns) GetOrCreateHostEntry(Name string) *SrlNokiaSystem_System_Dns_HostEntry {
	key := Name

	if v, ok := t.HostEntry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewHostEntry(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateHostEntry got unexpected error: %v", err))
	}
	return v
}

// GetHostEntry retrieves the value with the specified key from
// the HostEntry map field of SrlNokiaSystem_System_Dns. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaSystem_System_Dns) GetHostEntry(Name string) *SrlNokiaSystem_System_Dns_HostEntry {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.HostEntry[key]; ok {
		return lm
	}
	return nil
}

// DeleteHostEntry deletes the value with the specified keys from
// the receiver SrlNokiaSystem_System_Dns. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaSystem_System_Dns) DeleteHostEntry(Name string) {
	key := Name

	delete(t.HostEntry, key)
}

// AppendHostEntry appends the supplied SrlNokiaSystem_System_Dns_HostEntry struct to the
// list HostEntry of SrlNokiaSystem_System_Dns. If the key value(s) specified in
// the supplied SrlNokiaSystem_System_Dns_HostEntry already exist in the list, an error is
// returned.
func (t *SrlNokiaSystem_System_Dns) AppendHostEntry(v *SrlNokiaSystem_System_Dns_HostEntry) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.HostEntry == nil {
		t.HostEntry = make(map[string]*SrlNokiaSystem_System_Dns_HostEntry)
	}

	if _, ok := t.HostEntry[key]; ok {
		return fmt.Errorf("duplicate key for list HostEntry %v", key)
	}

	t.HostEntry[key] = v
	return nil
}

// GetNetworkInstance retrieves the value of the leaf NetworkInstance from the SrlNokiaSystem_System_Dns
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NetworkInstance is set, it can
// safely use t.GetNetworkInstance() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NetworkInstance == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Dns) GetNetworkInstance() string {
	if t == nil || t.NetworkInstance == nil {
		return ""
	}
	return *t.NetworkInstance
}

// GetSearchList retrieves the value of the leaf SearchList from the SrlNokiaSystem_System_Dns
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SearchList is set, it can
// safely use t.GetSearchList() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SearchList == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Dns) GetSearchList() []string {
	if t == nil || t.SearchList == nil {
		return nil
	}
	return t.SearchList
}

// GetServerList retrieves the value of the leaf ServerList from the SrlNokiaSystem_System_Dns
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ServerList is set, it can
// safely use t.GetServerList() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ServerList == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Dns) GetServerList() []string {
	if t == nil || t.ServerList == nil {
		return nil
	}
	return t.ServerList
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Dns
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Dns) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.HostEntry {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Dns) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Dns"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Dns) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Dns) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Dns.
func (*SrlNokiaSystem_System_Dns) ΛBelongingModule() string {
	return "srl_nokia-dns"
}

// SrlNokiaSystem_System_Dns_HostEntry represents the /srl_nokia-system/system/dns/host-entry YANG schema element.
type SrlNokiaSystem_System_Dns_HostEntry struct {
	Ipv4Address *string `path:"ipv4-address" module:"srl_nokia-dns"`
	Ipv6Address *string `path:"ipv6-address" module:"srl_nokia-dns"`
	Name        *string `path:"name" module:"srl_nokia-dns"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Dns_HostEntry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Dns_HostEntry) IsYANGGoStruct() {}

// GetIpv4Address retrieves the value of the leaf Ipv4Address from the SrlNokiaSystem_System_Dns_HostEntry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ipv4Address is set, it can
// safely use t.GetIpv4Address() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ipv4Address == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Dns_HostEntry) GetIpv4Address() string {
	if t == nil || t.Ipv4Address == nil {
		return ""
	}
	return *t.Ipv4Address
}

// GetIpv6Address retrieves the value of the leaf Ipv6Address from the SrlNokiaSystem_System_Dns_HostEntry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ipv6Address is set, it can
// safely use t.GetIpv6Address() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ipv6Address == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Dns_HostEntry) GetIpv6Address() string {
	if t == nil || t.Ipv6Address == nil {
		return ""
	}
	return *t.Ipv6Address
}

// GetName retrieves the value of the leaf Name from the SrlNokiaSystem_System_Dns_HostEntry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Dns_HostEntry) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Dns_HostEntry
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Dns_HostEntry) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_Dns_HostEntry struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_Dns_HostEntry) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Dns_HostEntry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Dns_HostEntry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Dns_HostEntry) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Dns_HostEntry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Dns_HostEntry.
func (*SrlNokiaSystem_System_Dns_HostEntry) ΛBelongingModule() string {
	return "srl_nokia-dns"
}

// SrlNokiaSystem_System_EventHandler represents the /srl_nokia-system/system/event-handler YANG schema element.
type SrlNokiaSystem_System_EventHandler struct {
	Instance  map[string]*SrlNokiaSystem_System_EventHandler_Instance `path:"instance" module:"srl_nokia-event-handler"`
	RunAsUser *string                                                 `path:"run-as-user" module:"srl_nokia-event-handler"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_EventHandler implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_EventHandler) IsYANGGoStruct() {}

// NewInstance creates a new entry in the Instance list of the
// SrlNokiaSystem_System_EventHandler struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_EventHandler) NewInstance(Name string) (*SrlNokiaSystem_System_EventHandler_Instance, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Instance == nil {
		t.Instance = make(map[string]*SrlNokiaSystem_System_EventHandler_Instance)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Instance[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Instance", key)
	}

	t.Instance[key] = &SrlNokiaSystem_System_EventHandler_Instance{
		Name: &Name,
	}

	return t.Instance[key], nil
}

// RenameInstance renames an entry in the list Instance within
// the SrlNokiaSystem_System_EventHandler struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaSystem_System_EventHandler) RenameInstance(oldK, newK string) error {
	if _, ok := t.Instance[newK]; ok {
		return fmt.Errorf("key %v already exists in Instance", newK)
	}

	e, ok := t.Instance[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Instance", oldK)
	}
	e.Name = &newK

	t.Instance[newK] = e
	delete(t.Instance, oldK)
	return nil
}

// GetOrCreateInstance retrieves the value with the specified keys from
// the receiver SrlNokiaSystem_System_EventHandler. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaSystem_System_EventHandler) GetOrCreateInstance(Name string) *SrlNokiaSystem_System_EventHandler_Instance {
	key := Name

	if v, ok := t.Instance[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInstance(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInstance got unexpected error: %v", err))
	}
	return v
}

// GetInstance retrieves the value with the specified key from
// the Instance map field of SrlNokiaSystem_System_EventHandler. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaSystem_System_EventHandler) GetInstance(Name string) *SrlNokiaSystem_System_EventHandler_Instance {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Instance[key]; ok {
		return lm
	}
	return nil
}

// DeleteInstance deletes the value with the specified keys from
// the receiver SrlNokiaSystem_System_EventHandler. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaSystem_System_EventHandler) DeleteInstance(Name string) {
	key := Name

	delete(t.Instance, key)
}

// AppendInstance appends the supplied SrlNokiaSystem_System_EventHandler_Instance struct to the
// list Instance of SrlNokiaSystem_System_EventHandler. If the key value(s) specified in
// the supplied SrlNokiaSystem_System_EventHandler_Instance already exist in the list, an error is
// returned.
func (t *SrlNokiaSystem_System_EventHandler) AppendInstance(v *SrlNokiaSystem_System_EventHandler_Instance) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Instance == nil {
		t.Instance = make(map[string]*SrlNokiaSystem_System_EventHandler_Instance)
	}

	if _, ok := t.Instance[key]; ok {
		return fmt.Errorf("duplicate key for list Instance %v", key)
	}

	t.Instance[key] = v
	return nil
}

// GetRunAsUser retrieves the value of the leaf RunAsUser from the SrlNokiaSystem_System_EventHandler
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RunAsUser is set, it can
// safely use t.GetRunAsUser() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RunAsUser == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_EventHandler) GetRunAsUser() string {
	if t == nil || t.RunAsUser == nil {
		return ""
	}
	return *t.RunAsUser
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_EventHandler
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_EventHandler) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Instance {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_EventHandler) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_EventHandler"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_EventHandler) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_EventHandler) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_EventHandler.
func (*SrlNokiaSystem_System_EventHandler) ΛBelongingModule() string {
	return "srl_nokia-event-handler"
}

// SrlNokiaSystem_System_EventHandler_Instance represents the /srl_nokia-system/system/event-handler/instance YANG schema element.
type SrlNokiaSystem_System_EventHandler_Instance struct {
	AdminState    E_SrlNokiaCommon_AdminState                          `path:"admin-state" module:"srl_nokia-event-handler"`
	Name          *string                                              `path:"name" module:"srl_nokia-event-handler"`
	Options       *SrlNokiaSystem_System_EventHandler_Instance_Options `path:"options" module:"srl_nokia-event-handler"`
	Paths         []string                                             `path:"paths" module:"srl_nokia-event-handler"`
	UpythonScript *string                                              `path:"upython-script" module:"srl_nokia-event-handler"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_EventHandler_Instance implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_EventHandler_Instance) IsYANGGoStruct() {}

// GetOrCreateOptions retrieves the value of the Options field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_EventHandler_Instance) GetOrCreateOptions() *SrlNokiaSystem_System_EventHandler_Instance_Options {
	if t.Options != nil {
		return t.Options
	}
	t.Options = &SrlNokiaSystem_System_EventHandler_Instance_Options{}
	return t.Options
}

// GetOptions returns the value of the Options struct pointer
// from SrlNokiaSystem_System_EventHandler_Instance. If the receiver or the field Options is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_EventHandler_Instance) GetOptions() *SrlNokiaSystem_System_EventHandler_Instance_Options {
	if t != nil && t.Options != nil {
		return t.Options
	}
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaSystem_System_EventHandler_Instance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_EventHandler_Instance) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_disable
	}
	return t.AdminState
}

// GetName retrieves the value of the leaf Name from the SrlNokiaSystem_System_EventHandler_Instance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_EventHandler_Instance) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetPaths retrieves the value of the leaf Paths from the SrlNokiaSystem_System_EventHandler_Instance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Paths is set, it can
// safely use t.GetPaths() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Paths == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_EventHandler_Instance) GetPaths() []string {
	if t == nil || t.Paths == nil {
		return nil
	}
	return t.Paths
}

// GetUpythonScript retrieves the value of the leaf UpythonScript from the SrlNokiaSystem_System_EventHandler_Instance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if UpythonScript is set, it can
// safely use t.GetUpythonScript() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.UpythonScript == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_EventHandler_Instance) GetUpythonScript() string {
	if t == nil || t.UpythonScript == nil {
		return ""
	}
	return *t.UpythonScript
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_EventHandler_Instance
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_EventHandler_Instance) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_disable
	}
	t.Options.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_EventHandler_Instance struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_EventHandler_Instance) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_EventHandler_Instance) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_EventHandler_Instance"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_EventHandler_Instance) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_EventHandler_Instance) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_EventHandler_Instance.
func (*SrlNokiaSystem_System_EventHandler_Instance) ΛBelongingModule() string {
	return "srl_nokia-event-handler"
}

// SrlNokiaSystem_System_EventHandler_Instance_Options represents the /srl_nokia-system/system/event-handler/instance/options YANG schema element.
type SrlNokiaSystem_System_EventHandler_Instance_Options struct {
	Object map[string]*SrlNokiaSystem_System_EventHandler_Instance_Options_Object `path:"object" module:"srl_nokia-event-handler"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_EventHandler_Instance_Options implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_EventHandler_Instance_Options) IsYANGGoStruct() {}

// NewObject creates a new entry in the Object list of the
// SrlNokiaSystem_System_EventHandler_Instance_Options struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_EventHandler_Instance_Options) NewObject(Name string) (*SrlNokiaSystem_System_EventHandler_Instance_Options_Object, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Object == nil {
		t.Object = make(map[string]*SrlNokiaSystem_System_EventHandler_Instance_Options_Object)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Object[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Object", key)
	}

	t.Object[key] = &SrlNokiaSystem_System_EventHandler_Instance_Options_Object{
		Name: &Name,
	}

	return t.Object[key], nil
}

// RenameObject renames an entry in the list Object within
// the SrlNokiaSystem_System_EventHandler_Instance_Options struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaSystem_System_EventHandler_Instance_Options) RenameObject(oldK, newK string) error {
	if _, ok := t.Object[newK]; ok {
		return fmt.Errorf("key %v already exists in Object", newK)
	}

	e, ok := t.Object[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Object", oldK)
	}
	e.Name = &newK

	t.Object[newK] = e
	delete(t.Object, oldK)
	return nil
}

// GetOrCreateObject retrieves the value with the specified keys from
// the receiver SrlNokiaSystem_System_EventHandler_Instance_Options. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaSystem_System_EventHandler_Instance_Options) GetOrCreateObject(Name string) *SrlNokiaSystem_System_EventHandler_Instance_Options_Object {
	key := Name

	if v, ok := t.Object[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewObject(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateObject got unexpected error: %v", err))
	}
	return v
}

// GetObject retrieves the value with the specified key from
// the Object map field of SrlNokiaSystem_System_EventHandler_Instance_Options. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaSystem_System_EventHandler_Instance_Options) GetObject(Name string) *SrlNokiaSystem_System_EventHandler_Instance_Options_Object {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Object[key]; ok {
		return lm
	}
	return nil
}

// DeleteObject deletes the value with the specified keys from
// the receiver SrlNokiaSystem_System_EventHandler_Instance_Options. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaSystem_System_EventHandler_Instance_Options) DeleteObject(Name string) {
	key := Name

	delete(t.Object, key)
}

// AppendObject appends the supplied SrlNokiaSystem_System_EventHandler_Instance_Options_Object struct to the
// list Object of SrlNokiaSystem_System_EventHandler_Instance_Options. If the key value(s) specified in
// the supplied SrlNokiaSystem_System_EventHandler_Instance_Options_Object already exist in the list, an error is
// returned.
func (t *SrlNokiaSystem_System_EventHandler_Instance_Options) AppendObject(
	v *SrlNokiaSystem_System_EventHandler_Instance_Options_Object,
) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Object == nil {
		t.Object = make(map[string]*SrlNokiaSystem_System_EventHandler_Instance_Options_Object)
	}

	if _, ok := t.Object[key]; ok {
		return fmt.Errorf("duplicate key for list Object %v", key)
	}

	t.Object[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_EventHandler_Instance_Options
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_EventHandler_Instance_Options) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Object {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_EventHandler_Instance_Options) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_EventHandler_Instance_Options"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_EventHandler_Instance_Options) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_EventHandler_Instance_Options) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_EventHandler_Instance_Options.
func (*SrlNokiaSystem_System_EventHandler_Instance_Options) ΛBelongingModule() string {
	return "srl_nokia-event-handler"
}

// SrlNokiaSystem_System_EventHandler_Instance_Options_Object represents the /srl_nokia-system/system/event-handler/instance/options/object YANG schema element.
type SrlNokiaSystem_System_EventHandler_Instance_Options_Object struct {
	Name   *string  `path:"name" module:"srl_nokia-event-handler"`
	Value  *string  `path:"value" module:"srl_nokia-event-handler"`
	Values []string `path:"values" module:"srl_nokia-event-handler"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_EventHandler_Instance_Options_Object implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_EventHandler_Instance_Options_Object) IsYANGGoStruct() {}

// GetName retrieves the value of the leaf Name from the SrlNokiaSystem_System_EventHandler_Instance_Options_Object
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_EventHandler_Instance_Options_Object) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetValue retrieves the value of the leaf Value from the SrlNokiaSystem_System_EventHandler_Instance_Options_Object
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Value is set, it can
// safely use t.GetValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Value == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_EventHandler_Instance_Options_Object) GetValue() string {
	if t == nil || t.Value == nil {
		return ""
	}
	return *t.Value
}

// GetValues retrieves the value of the leaf Values from the SrlNokiaSystem_System_EventHandler_Instance_Options_Object
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Values is set, it can
// safely use t.GetValues() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Values == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_EventHandler_Instance_Options_Object) GetValues() []string {
	if t == nil || t.Values == nil {
		return nil
	}
	return t.Values
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_EventHandler_Instance_Options_Object
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_EventHandler_Instance_Options_Object) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_EventHandler_Instance_Options_Object struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_EventHandler_Instance_Options_Object) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_EventHandler_Instance_Options_Object) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_EventHandler_Instance_Options_Object"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_EventHandler_Instance_Options_Object) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_EventHandler_Instance_Options_Object) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_EventHandler_Instance_Options_Object.
func (*SrlNokiaSystem_System_EventHandler_Instance_Options_Object) ΛBelongingModule() string {
	return "srl_nokia-event-handler"
}

// SrlNokiaSystem_System_FtpServer represents the /srl_nokia-system/system/ftp-server YANG schema element.
type SrlNokiaSystem_System_FtpServer struct {
	NetworkInstance map[string]*SrlNokiaSystem_System_FtpServer_NetworkInstance `path:"network-instance" module:"srl_nokia-ftp"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_FtpServer implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_FtpServer) IsYANGGoStruct() {}

// NewNetworkInstance creates a new entry in the NetworkInstance list of the
// SrlNokiaSystem_System_FtpServer struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_FtpServer) NewNetworkInstance(Name string) (*SrlNokiaSystem_System_FtpServer_NetworkInstance, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NetworkInstance == nil {
		t.NetworkInstance = make(map[string]*SrlNokiaSystem_System_FtpServer_NetworkInstance)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.NetworkInstance[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list NetworkInstance", key)
	}

	t.NetworkInstance[key] = &SrlNokiaSystem_System_FtpServer_NetworkInstance{
		Name: &Name,
	}

	return t.NetworkInstance[key], nil
}

// RenameNetworkInstance renames an entry in the list NetworkInstance within
// the SrlNokiaSystem_System_FtpServer struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaSystem_System_FtpServer) RenameNetworkInstance(oldK, newK string) error {
	if _, ok := t.NetworkInstance[newK]; ok {
		return fmt.Errorf("key %v already exists in NetworkInstance", newK)
	}

	e, ok := t.NetworkInstance[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in NetworkInstance", oldK)
	}
	e.Name = &newK

	t.NetworkInstance[newK] = e
	delete(t.NetworkInstance, oldK)
	return nil
}

// GetOrCreateNetworkInstance retrieves the value with the specified keys from
// the receiver SrlNokiaSystem_System_FtpServer. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaSystem_System_FtpServer) GetOrCreateNetworkInstance(Name string) *SrlNokiaSystem_System_FtpServer_NetworkInstance {
	key := Name

	if v, ok := t.NetworkInstance[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNetworkInstance(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNetworkInstance got unexpected error: %v", err))
	}
	return v
}

// GetNetworkInstance retrieves the value with the specified key from
// the NetworkInstance map field of SrlNokiaSystem_System_FtpServer. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaSystem_System_FtpServer) GetNetworkInstance(Name string) *SrlNokiaSystem_System_FtpServer_NetworkInstance {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.NetworkInstance[key]; ok {
		return lm
	}
	return nil
}

// DeleteNetworkInstance deletes the value with the specified keys from
// the receiver SrlNokiaSystem_System_FtpServer. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaSystem_System_FtpServer) DeleteNetworkInstance(Name string) {
	key := Name

	delete(t.NetworkInstance, key)
}

// AppendNetworkInstance appends the supplied SrlNokiaSystem_System_FtpServer_NetworkInstance struct to the
// list NetworkInstance of SrlNokiaSystem_System_FtpServer. If the key value(s) specified in
// the supplied SrlNokiaSystem_System_FtpServer_NetworkInstance already exist in the list, an error is
// returned.
func (t *SrlNokiaSystem_System_FtpServer) AppendNetworkInstance(v *SrlNokiaSystem_System_FtpServer_NetworkInstance) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NetworkInstance == nil {
		t.NetworkInstance = make(map[string]*SrlNokiaSystem_System_FtpServer_NetworkInstance)
	}

	if _, ok := t.NetworkInstance[key]; ok {
		return fmt.Errorf("duplicate key for list NetworkInstance %v", key)
	}

	t.NetworkInstance[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_FtpServer
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_FtpServer) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.NetworkInstance {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_FtpServer) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_FtpServer"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_FtpServer) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_FtpServer) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_FtpServer.
func (*SrlNokiaSystem_System_FtpServer) ΛBelongingModule() string {
	return "srl_nokia-ftp"
}

// SrlNokiaSystem_System_FtpServer_NetworkInstance represents the /srl_nokia-system/system/ftp-server/network-instance YANG schema element.
type SrlNokiaSystem_System_FtpServer_NetworkInstance struct {
	AdminState    E_SrlNokiaCommon_AdminState `path:"admin-state" module:"srl_nokia-ftp"`
	Name          *string                     `path:"name" module:"srl_nokia-ftp"`
	SessionLimit  *uint8                      `path:"session-limit" module:"srl_nokia-ftp"`
	SourceAddress *string                     `path:"source-address" module:"srl_nokia-ftp"`
	Timeout       *uint16                     `path:"timeout" module:"srl_nokia-ftp"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_FtpServer_NetworkInstance implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_FtpServer_NetworkInstance) IsYANGGoStruct() {}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaSystem_System_FtpServer_NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_FtpServer_NetworkInstance) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_disable
	}
	return t.AdminState
}

// GetName retrieves the value of the leaf Name from the SrlNokiaSystem_System_FtpServer_NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_FtpServer_NetworkInstance) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetSessionLimit retrieves the value of the leaf SessionLimit from the SrlNokiaSystem_System_FtpServer_NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SessionLimit is set, it can
// safely use t.GetSessionLimit() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SessionLimit == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_FtpServer_NetworkInstance) GetSessionLimit() uint8 {
	if t == nil || t.SessionLimit == nil {
		return 20
	}
	return *t.SessionLimit
}

// GetSourceAddress retrieves the value of the leaf SourceAddress from the SrlNokiaSystem_System_FtpServer_NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SourceAddress is set, it can
// safely use t.GetSourceAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SourceAddress == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_FtpServer_NetworkInstance) GetSourceAddress() string {
	if t == nil || t.SourceAddress == nil {
		return "::"
	}
	return *t.SourceAddress
}

// GetTimeout retrieves the value of the leaf Timeout from the SrlNokiaSystem_System_FtpServer_NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Timeout is set, it can
// safely use t.GetTimeout() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Timeout == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_FtpServer_NetworkInstance) GetTimeout() uint16 {
	if t == nil || t.Timeout == nil {
		return 300
	}
	return *t.Timeout
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_FtpServer_NetworkInstance
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_FtpServer_NetworkInstance) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_disable
	}
	if t.SessionLimit == nil {
		var v uint8 = 20
		t.SessionLimit = &v
	}
	if t.SourceAddress == nil {
		var v string = "::"
		t.SourceAddress = &v
	}
	if t.Timeout == nil {
		var v uint16 = 300
		t.Timeout = &v
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_FtpServer_NetworkInstance struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_FtpServer_NetworkInstance) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_FtpServer_NetworkInstance) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_FtpServer_NetworkInstance"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_FtpServer_NetworkInstance) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_FtpServer_NetworkInstance) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_FtpServer_NetworkInstance.
func (*SrlNokiaSystem_System_FtpServer_NetworkInstance) ΛBelongingModule() string {
	return "srl_nokia-ftp"
}

// SrlNokiaSystem_System_GnmiServer represents the /srl_nokia-system/system/gnmi-server YANG schema element.
type SrlNokiaSystem_System_GnmiServer struct {
	AdminState                           E_SrlNokiaCommon_AdminState                                  `path:"admin-state" module:"srl_nokia-gnmi-server"`
	CommitConfirmedTimeout               *uint32                                                      `path:"commit-confirmed-timeout" module:"srl_nokia-gnmi-server"`
	CommitSave                           *bool                                                        `path:"commit-save" module:"srl_nokia-gnmi-server"`
	IncludeDefaultsInConfigOnlyResponses *bool                                                        `path:"include-defaults-in-config-only-responses" module:"srl_nokia-gnmi-server"`
	NetworkInstance                      map[string]*SrlNokiaSystem_System_GnmiServer_NetworkInstance `path:"network-instance" module:"srl_nokia-gnmi-server"`
	RateLimit                            *uint16                                                      `path:"rate-limit" module:"srl_nokia-gnmi-server"`
	SessionLimit                         *uint16                                                      `path:"session-limit" module:"srl_nokia-gnmi-server"`
	Timeout                              *uint16                                                      `path:"timeout" module:"srl_nokia-gnmi-server"`
	TraceOptions                         []E_SrlNokiaSystem_System_GnmiServer_TraceOptions            `path:"trace-options" module:"srl_nokia-gnmi-server"`
	UnixSocket                           *SrlNokiaSystem_System_GnmiServer_UnixSocket                 `path:"unix-socket" module:"srl_nokia-gnmi-server"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_GnmiServer implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_GnmiServer) IsYANGGoStruct() {}

// NewNetworkInstance creates a new entry in the NetworkInstance list of the
// SrlNokiaSystem_System_GnmiServer struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_GnmiServer) NewNetworkInstance(Name string) (*SrlNokiaSystem_System_GnmiServer_NetworkInstance, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NetworkInstance == nil {
		t.NetworkInstance = make(map[string]*SrlNokiaSystem_System_GnmiServer_NetworkInstance)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.NetworkInstance[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list NetworkInstance", key)
	}

	t.NetworkInstance[key] = &SrlNokiaSystem_System_GnmiServer_NetworkInstance{
		Name: &Name,
	}

	return t.NetworkInstance[key], nil
}

// RenameNetworkInstance renames an entry in the list NetworkInstance within
// the SrlNokiaSystem_System_GnmiServer struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaSystem_System_GnmiServer) RenameNetworkInstance(oldK, newK string) error {
	if _, ok := t.NetworkInstance[newK]; ok {
		return fmt.Errorf("key %v already exists in NetworkInstance", newK)
	}

	e, ok := t.NetworkInstance[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in NetworkInstance", oldK)
	}
	e.Name = &newK

	t.NetworkInstance[newK] = e
	delete(t.NetworkInstance, oldK)
	return nil
}

// GetOrCreateNetworkInstance retrieves the value with the specified keys from
// the receiver SrlNokiaSystem_System_GnmiServer. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaSystem_System_GnmiServer) GetOrCreateNetworkInstance(Name string) *SrlNokiaSystem_System_GnmiServer_NetworkInstance {
	key := Name

	if v, ok := t.NetworkInstance[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNetworkInstance(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNetworkInstance got unexpected error: %v", err))
	}
	return v
}

// GetNetworkInstance retrieves the value with the specified key from
// the NetworkInstance map field of SrlNokiaSystem_System_GnmiServer. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaSystem_System_GnmiServer) GetNetworkInstance(Name string) *SrlNokiaSystem_System_GnmiServer_NetworkInstance {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.NetworkInstance[key]; ok {
		return lm
	}
	return nil
}

// DeleteNetworkInstance deletes the value with the specified keys from
// the receiver SrlNokiaSystem_System_GnmiServer. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaSystem_System_GnmiServer) DeleteNetworkInstance(Name string) {
	key := Name

	delete(t.NetworkInstance, key)
}

// AppendNetworkInstance appends the supplied SrlNokiaSystem_System_GnmiServer_NetworkInstance struct to the
// list NetworkInstance of SrlNokiaSystem_System_GnmiServer. If the key value(s) specified in
// the supplied SrlNokiaSystem_System_GnmiServer_NetworkInstance already exist in the list, an error is
// returned.
func (t *SrlNokiaSystem_System_GnmiServer) AppendNetworkInstance(
	v *SrlNokiaSystem_System_GnmiServer_NetworkInstance,
) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NetworkInstance == nil {
		t.NetworkInstance = make(map[string]*SrlNokiaSystem_System_GnmiServer_NetworkInstance)
	}

	if _, ok := t.NetworkInstance[key]; ok {
		return fmt.Errorf("duplicate key for list NetworkInstance %v", key)
	}

	t.NetworkInstance[key] = v
	return nil
}

// GetOrCreateUnixSocket retrieves the value of the UnixSocket field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_GnmiServer) GetOrCreateUnixSocket() *SrlNokiaSystem_System_GnmiServer_UnixSocket {
	if t.UnixSocket != nil {
		return t.UnixSocket
	}
	t.UnixSocket = &SrlNokiaSystem_System_GnmiServer_UnixSocket{}
	return t.UnixSocket
}

// GetUnixSocket returns the value of the UnixSocket struct pointer
// from SrlNokiaSystem_System_GnmiServer. If the receiver or the field UnixSocket is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_GnmiServer) GetUnixSocket() *SrlNokiaSystem_System_GnmiServer_UnixSocket {
	if t != nil && t.UnixSocket != nil {
		return t.UnixSocket
	}
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaSystem_System_GnmiServer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_GnmiServer) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_disable
	}
	return t.AdminState
}

// GetCommitConfirmedTimeout retrieves the value of the leaf CommitConfirmedTimeout from the SrlNokiaSystem_System_GnmiServer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if CommitConfirmedTimeout is set, it can
// safely use t.GetCommitConfirmedTimeout() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.CommitConfirmedTimeout == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_GnmiServer) GetCommitConfirmedTimeout() uint32 {
	if t == nil || t.CommitConfirmedTimeout == nil {
		return 0
	}
	return *t.CommitConfirmedTimeout
}

// GetCommitSave retrieves the value of the leaf CommitSave from the SrlNokiaSystem_System_GnmiServer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if CommitSave is set, it can
// safely use t.GetCommitSave() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.CommitSave == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_GnmiServer) GetCommitSave() bool {
	if t == nil || t.CommitSave == nil {
		return false
	}
	return *t.CommitSave
}

// GetIncludeDefaultsInConfigOnlyResponses retrieves the value of the leaf IncludeDefaultsInConfigOnlyResponses from the SrlNokiaSystem_System_GnmiServer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IncludeDefaultsInConfigOnlyResponses is set, it can
// safely use t.GetIncludeDefaultsInConfigOnlyResponses() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IncludeDefaultsInConfigOnlyResponses == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_GnmiServer) GetIncludeDefaultsInConfigOnlyResponses() bool {
	if t == nil || t.IncludeDefaultsInConfigOnlyResponses == nil {
		return false
	}
	return *t.IncludeDefaultsInConfigOnlyResponses
}

// GetRateLimit retrieves the value of the leaf RateLimit from the SrlNokiaSystem_System_GnmiServer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RateLimit is set, it can
// safely use t.GetRateLimit() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RateLimit == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_GnmiServer) GetRateLimit() uint16 {
	if t == nil || t.RateLimit == nil {
		return 60
	}
	return *t.RateLimit
}

// GetSessionLimit retrieves the value of the leaf SessionLimit from the SrlNokiaSystem_System_GnmiServer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SessionLimit is set, it can
// safely use t.GetSessionLimit() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SessionLimit == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_GnmiServer) GetSessionLimit() uint16 {
	if t == nil || t.SessionLimit == nil {
		return 20
	}
	return *t.SessionLimit
}

// GetTimeout retrieves the value of the leaf Timeout from the SrlNokiaSystem_System_GnmiServer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Timeout is set, it can
// safely use t.GetTimeout() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Timeout == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_GnmiServer) GetTimeout() uint16 {
	if t == nil || t.Timeout == nil {
		return 7200
	}
	return *t.Timeout
}

// GetTraceOptions retrieves the value of the leaf TraceOptions from the SrlNokiaSystem_System_GnmiServer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TraceOptions is set, it can
// safely use t.GetTraceOptions() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TraceOptions == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_GnmiServer) GetTraceOptions() []E_SrlNokiaSystem_System_GnmiServer_TraceOptions {
	if t == nil || t.TraceOptions == nil {
		return nil
	}
	return t.TraceOptions
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_GnmiServer
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_GnmiServer) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_disable
	}
	if t.CommitConfirmedTimeout == nil {
		var v uint32 = 0
		t.CommitConfirmedTimeout = &v
	}
	if t.CommitSave == nil {
		var v bool = false
		t.CommitSave = &v
	}
	if t.IncludeDefaultsInConfigOnlyResponses == nil {
		var v bool = false
		t.IncludeDefaultsInConfigOnlyResponses = &v
	}
	if t.RateLimit == nil {
		var v uint16 = 60
		t.RateLimit = &v
	}
	if t.SessionLimit == nil {
		var v uint16 = 20
		t.SessionLimit = &v
	}
	if t.Timeout == nil {
		var v uint16 = 7200
		t.Timeout = &v
	}
	t.UnixSocket.PopulateDefaults()
	for _, e := range t.NetworkInstance {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_GnmiServer) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_GnmiServer"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_GnmiServer) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_GnmiServer) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_GnmiServer.
func (*SrlNokiaSystem_System_GnmiServer) ΛBelongingModule() string {
	return "srl_nokia-gnmi-server"
}

// SrlNokiaSystem_System_GnmiServer_NetworkInstance represents the /srl_nokia-system/system/gnmi-server/network-instance YANG schema element.
type SrlNokiaSystem_System_GnmiServer_NetworkInstance struct {
	AdminState        E_SrlNokiaCommon_AdminState                                   `path:"admin-state" module:"srl_nokia-gnmi-server"`
	DefaultTlsProfile *bool                                                         `path:"default-tls-profile" module:"srl_nokia-gnmi-server"`
	Name              *string                                                       `path:"name" module:"srl_nokia-gnmi-server"`
	Port              *uint16                                                       `path:"port" module:"srl_nokia-gnmi-server"`
	Services          []E_SrlNokiaGnmiServer_GrpcService                            `path:"services" module:"srl_nokia-gnmi-server"`
	SourceAddress     []string                                                      `path:"source-address" module:"srl_nokia-gnmi-server"`
	TlsProfile        *string                                                       `path:"tls-profile" module:"srl_nokia-gnmi-server"`
	UseAuthentication *bool                                                         `path:"use-authentication" module:"srl_nokia-gnmi-server"`
	YangModels        E_SrlNokiaSystem_System_GnmiServer_NetworkInstance_YangModels `path:"yang-models" module:"srl_nokia-gnmi-server"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_GnmiServer_NetworkInstance implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_GnmiServer_NetworkInstance) IsYANGGoStruct() {}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaSystem_System_GnmiServer_NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_GnmiServer_NetworkInstance) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_disable
	}
	return t.AdminState
}

// GetDefaultTlsProfile retrieves the value of the leaf DefaultTlsProfile from the SrlNokiaSystem_System_GnmiServer_NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DefaultTlsProfile is set, it can
// safely use t.GetDefaultTlsProfile() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DefaultTlsProfile == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_GnmiServer_NetworkInstance) GetDefaultTlsProfile() bool {
	if t == nil || t.DefaultTlsProfile == nil {
		return false
	}
	return *t.DefaultTlsProfile
}

// GetName retrieves the value of the leaf Name from the SrlNokiaSystem_System_GnmiServer_NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_GnmiServer_NetworkInstance) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetPort retrieves the value of the leaf Port from the SrlNokiaSystem_System_GnmiServer_NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Port is set, it can
// safely use t.GetPort() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Port == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_GnmiServer_NetworkInstance) GetPort() uint16 {
	if t == nil || t.Port == nil {
		return 57400
	}
	return *t.Port
}

// GetServices retrieves the value of the leaf Services from the SrlNokiaSystem_System_GnmiServer_NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Services is set, it can
// safely use t.GetServices() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Services == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_GnmiServer_NetworkInstance) GetServices() []E_SrlNokiaGnmiServer_GrpcService {
	if t == nil || t.Services == nil {
		return nil
	}
	return t.Services
}

// GetSourceAddress retrieves the value of the leaf SourceAddress from the SrlNokiaSystem_System_GnmiServer_NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SourceAddress is set, it can
// safely use t.GetSourceAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SourceAddress == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_GnmiServer_NetworkInstance) GetSourceAddress() []string {
	if t == nil || t.SourceAddress == nil {
		return []string{"::"}
	}
	return t.SourceAddress
}

// GetTlsProfile retrieves the value of the leaf TlsProfile from the SrlNokiaSystem_System_GnmiServer_NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TlsProfile is set, it can
// safely use t.GetTlsProfile() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TlsProfile == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_GnmiServer_NetworkInstance) GetTlsProfile() string {
	if t == nil || t.TlsProfile == nil {
		return ""
	}
	return *t.TlsProfile
}

// GetUseAuthentication retrieves the value of the leaf UseAuthentication from the SrlNokiaSystem_System_GnmiServer_NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if UseAuthentication is set, it can
// safely use t.GetUseAuthentication() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.UseAuthentication == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_GnmiServer_NetworkInstance) GetUseAuthentication() bool {
	if t == nil || t.UseAuthentication == nil {
		return true
	}
	return *t.UseAuthentication
}

// GetYangModels retrieves the value of the leaf YangModels from the SrlNokiaSystem_System_GnmiServer_NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if YangModels is set, it can
// safely use t.GetYangModels() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.YangModels == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_GnmiServer_NetworkInstance) GetYangModels() E_SrlNokiaSystem_System_GnmiServer_NetworkInstance_YangModels {
	if t == nil || t.YangModels == 0 {
		return SrlNokiaSystem_System_GnmiServer_NetworkInstance_YangModels_native
	}
	return t.YangModels
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_GnmiServer_NetworkInstance
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_GnmiServer_NetworkInstance) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_disable
	}
	if t.DefaultTlsProfile == nil {
		var v bool = false
		t.DefaultTlsProfile = &v
	}
	if t.Port == nil {
		var v uint16 = 57400
		t.Port = &v
	}
	if t.SourceAddress == nil {
		t.SourceAddress = []string{"::"}
	}
	if t.UseAuthentication == nil {
		var v bool = true
		t.UseAuthentication = &v
	}
	if t.YangModels == 0 {
		t.YangModels = SrlNokiaSystem_System_GnmiServer_NetworkInstance_YangModels_native
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_GnmiServer_NetworkInstance struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_GnmiServer_NetworkInstance) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_GnmiServer_NetworkInstance) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_GnmiServer_NetworkInstance"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_GnmiServer_NetworkInstance) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_GnmiServer_NetworkInstance) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_GnmiServer_NetworkInstance.
func (*SrlNokiaSystem_System_GnmiServer_NetworkInstance) ΛBelongingModule() string {
	return "srl_nokia-gnmi-server"
}

// SrlNokiaSystem_System_GnmiServer_UnixSocket represents the /srl_nokia-system/system/gnmi-server/unix-socket YANG schema element.
type SrlNokiaSystem_System_GnmiServer_UnixSocket struct {
	AdminState        E_SrlNokiaCommon_AdminState                                   `path:"admin-state" module:"srl_nokia-gnmi-server"`
	DefaultTlsProfile *bool                                                         `path:"default-tls-profile" module:"srl_nokia-gnmi-server"`
	Services          []E_SrlNokiaGnmiServer_GrpcService                            `path:"services" module:"srl_nokia-gnmi-server"`
	TlsProfile        *string                                                       `path:"tls-profile" module:"srl_nokia-gnmi-server"`
	UseAuthentication *bool                                                         `path:"use-authentication" module:"srl_nokia-gnmi-server"`
	YangModels        E_SrlNokiaSystem_System_GnmiServer_NetworkInstance_YangModels `path:"yang-models" module:"srl_nokia-gnmi-server"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_GnmiServer_UnixSocket implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_GnmiServer_UnixSocket) IsYANGGoStruct() {}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaSystem_System_GnmiServer_UnixSocket
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_GnmiServer_UnixSocket) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_disable
	}
	return t.AdminState
}

// GetDefaultTlsProfile retrieves the value of the leaf DefaultTlsProfile from the SrlNokiaSystem_System_GnmiServer_UnixSocket
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DefaultTlsProfile is set, it can
// safely use t.GetDefaultTlsProfile() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DefaultTlsProfile == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_GnmiServer_UnixSocket) GetDefaultTlsProfile() bool {
	if t == nil || t.DefaultTlsProfile == nil {
		return false
	}
	return *t.DefaultTlsProfile
}

// GetServices retrieves the value of the leaf Services from the SrlNokiaSystem_System_GnmiServer_UnixSocket
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Services is set, it can
// safely use t.GetServices() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Services == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_GnmiServer_UnixSocket) GetServices() []E_SrlNokiaGnmiServer_GrpcService {
	if t == nil || t.Services == nil {
		return nil
	}
	return t.Services
}

// GetTlsProfile retrieves the value of the leaf TlsProfile from the SrlNokiaSystem_System_GnmiServer_UnixSocket
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TlsProfile is set, it can
// safely use t.GetTlsProfile() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TlsProfile == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_GnmiServer_UnixSocket) GetTlsProfile() string {
	if t == nil || t.TlsProfile == nil {
		return ""
	}
	return *t.TlsProfile
}

// GetUseAuthentication retrieves the value of the leaf UseAuthentication from the SrlNokiaSystem_System_GnmiServer_UnixSocket
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if UseAuthentication is set, it can
// safely use t.GetUseAuthentication() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.UseAuthentication == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_GnmiServer_UnixSocket) GetUseAuthentication() bool {
	if t == nil || t.UseAuthentication == nil {
		return true
	}
	return *t.UseAuthentication
}

// GetYangModels retrieves the value of the leaf YangModels from the SrlNokiaSystem_System_GnmiServer_UnixSocket
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if YangModels is set, it can
// safely use t.GetYangModels() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.YangModels == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_GnmiServer_UnixSocket) GetYangModels() E_SrlNokiaSystem_System_GnmiServer_NetworkInstance_YangModels {
	if t == nil || t.YangModels == 0 {
		return SrlNokiaSystem_System_GnmiServer_NetworkInstance_YangModels_native
	}
	return t.YangModels
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_GnmiServer_UnixSocket
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_GnmiServer_UnixSocket) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_disable
	}
	if t.DefaultTlsProfile == nil {
		var v bool = false
		t.DefaultTlsProfile = &v
	}
	if t.UseAuthentication == nil {
		var v bool = true
		t.UseAuthentication = &v
	}
	if t.YangModels == 0 {
		t.YangModels = SrlNokiaSystem_System_GnmiServer_NetworkInstance_YangModels_native
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_GnmiServer_UnixSocket) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_GnmiServer_UnixSocket"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_GnmiServer_UnixSocket) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_GnmiServer_UnixSocket) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_GnmiServer_UnixSocket.
func (*SrlNokiaSystem_System_GnmiServer_UnixSocket) ΛBelongingModule() string {
	return "srl_nokia-gnmi-server"
}

// SrlNokiaSystem_System_GribiServer represents the /srl_nokia-system/system/gribi-server YANG schema element.
type SrlNokiaSystem_System_GribiServer struct {
	AdminState      E_SrlNokiaCommon_AdminState                                   `path:"admin-state" module:"srl_nokia-gribi-server"`
	NetworkInstance map[string]*SrlNokiaSystem_System_GribiServer_NetworkInstance `path:"network-instance" module:"srl_nokia-gribi-server"`
	RateLimit       *uint16                                                       `path:"rate-limit" module:"srl_nokia-gribi-server"`
	SessionLimit    *uint16                                                       `path:"session-limit" module:"srl_nokia-gribi-server"`
	Timeout         *uint16                                                       `path:"timeout" module:"srl_nokia-gribi-server"`
	TraceOptions    []E_SrlNokiaSystem_System_GribiServer_TraceOptions            `path:"trace-options" module:"srl_nokia-gribi-server"`
	UnixSocket      *SrlNokiaSystem_System_GribiServer_UnixSocket                 `path:"unix-socket" module:"srl_nokia-gribi-server"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_GribiServer implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_GribiServer) IsYANGGoStruct() {}

// NewNetworkInstance creates a new entry in the NetworkInstance list of the
// SrlNokiaSystem_System_GribiServer struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_GribiServer) NewNetworkInstance(Name string) (*SrlNokiaSystem_System_GribiServer_NetworkInstance, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NetworkInstance == nil {
		t.NetworkInstance = make(map[string]*SrlNokiaSystem_System_GribiServer_NetworkInstance)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.NetworkInstance[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list NetworkInstance", key)
	}

	t.NetworkInstance[key] = &SrlNokiaSystem_System_GribiServer_NetworkInstance{
		Name: &Name,
	}

	return t.NetworkInstance[key], nil
}

// RenameNetworkInstance renames an entry in the list NetworkInstance within
// the SrlNokiaSystem_System_GribiServer struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaSystem_System_GribiServer) RenameNetworkInstance(oldK, newK string) error {
	if _, ok := t.NetworkInstance[newK]; ok {
		return fmt.Errorf("key %v already exists in NetworkInstance", newK)
	}

	e, ok := t.NetworkInstance[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in NetworkInstance", oldK)
	}
	e.Name = &newK

	t.NetworkInstance[newK] = e
	delete(t.NetworkInstance, oldK)
	return nil
}

// GetOrCreateNetworkInstance retrieves the value with the specified keys from
// the receiver SrlNokiaSystem_System_GribiServer. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaSystem_System_GribiServer) GetOrCreateNetworkInstance(Name string) *SrlNokiaSystem_System_GribiServer_NetworkInstance {
	key := Name

	if v, ok := t.NetworkInstance[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNetworkInstance(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNetworkInstance got unexpected error: %v", err))
	}
	return v
}

// GetNetworkInstance retrieves the value with the specified key from
// the NetworkInstance map field of SrlNokiaSystem_System_GribiServer. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaSystem_System_GribiServer) GetNetworkInstance(Name string) *SrlNokiaSystem_System_GribiServer_NetworkInstance {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.NetworkInstance[key]; ok {
		return lm
	}
	return nil
}

// DeleteNetworkInstance deletes the value with the specified keys from
// the receiver SrlNokiaSystem_System_GribiServer. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaSystem_System_GribiServer) DeleteNetworkInstance(Name string) {
	key := Name

	delete(t.NetworkInstance, key)
}

// AppendNetworkInstance appends the supplied SrlNokiaSystem_System_GribiServer_NetworkInstance struct to the
// list NetworkInstance of SrlNokiaSystem_System_GribiServer. If the key value(s) specified in
// the supplied SrlNokiaSystem_System_GribiServer_NetworkInstance already exist in the list, an error is
// returned.
func (t *SrlNokiaSystem_System_GribiServer) AppendNetworkInstance(
	v *SrlNokiaSystem_System_GribiServer_NetworkInstance,
) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NetworkInstance == nil {
		t.NetworkInstance = make(map[string]*SrlNokiaSystem_System_GribiServer_NetworkInstance)
	}

	if _, ok := t.NetworkInstance[key]; ok {
		return fmt.Errorf("duplicate key for list NetworkInstance %v", key)
	}

	t.NetworkInstance[key] = v
	return nil
}

// GetOrCreateUnixSocket retrieves the value of the UnixSocket field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_GribiServer) GetOrCreateUnixSocket() *SrlNokiaSystem_System_GribiServer_UnixSocket {
	if t.UnixSocket != nil {
		return t.UnixSocket
	}
	t.UnixSocket = &SrlNokiaSystem_System_GribiServer_UnixSocket{}
	return t.UnixSocket
}

// GetUnixSocket returns the value of the UnixSocket struct pointer
// from SrlNokiaSystem_System_GribiServer. If the receiver or the field UnixSocket is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_GribiServer) GetUnixSocket() *SrlNokiaSystem_System_GribiServer_UnixSocket {
	if t != nil && t.UnixSocket != nil {
		return t.UnixSocket
	}
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaSystem_System_GribiServer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_GribiServer) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_disable
	}
	return t.AdminState
}

// GetRateLimit retrieves the value of the leaf RateLimit from the SrlNokiaSystem_System_GribiServer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RateLimit is set, it can
// safely use t.GetRateLimit() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RateLimit == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_GribiServer) GetRateLimit() uint16 {
	if t == nil || t.RateLimit == nil {
		return 60
	}
	return *t.RateLimit
}

// GetSessionLimit retrieves the value of the leaf SessionLimit from the SrlNokiaSystem_System_GribiServer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SessionLimit is set, it can
// safely use t.GetSessionLimit() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SessionLimit == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_GribiServer) GetSessionLimit() uint16 {
	if t == nil || t.SessionLimit == nil {
		return 20
	}
	return *t.SessionLimit
}

// GetTimeout retrieves the value of the leaf Timeout from the SrlNokiaSystem_System_GribiServer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Timeout is set, it can
// safely use t.GetTimeout() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Timeout == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_GribiServer) GetTimeout() uint16 {
	if t == nil || t.Timeout == nil {
		return 7200
	}
	return *t.Timeout
}

// GetTraceOptions retrieves the value of the leaf TraceOptions from the SrlNokiaSystem_System_GribiServer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TraceOptions is set, it can
// safely use t.GetTraceOptions() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TraceOptions == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_GribiServer) GetTraceOptions() []E_SrlNokiaSystem_System_GribiServer_TraceOptions {
	if t == nil || t.TraceOptions == nil {
		return nil
	}
	return t.TraceOptions
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_GribiServer
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_GribiServer) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_disable
	}
	if t.RateLimit == nil {
		var v uint16 = 60
		t.RateLimit = &v
	}
	if t.SessionLimit == nil {
		var v uint16 = 20
		t.SessionLimit = &v
	}
	if t.Timeout == nil {
		var v uint16 = 7200
		t.Timeout = &v
	}
	t.UnixSocket.PopulateDefaults()
	for _, e := range t.NetworkInstance {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_GribiServer) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_GribiServer"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_GribiServer) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_GribiServer) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_GribiServer.
func (*SrlNokiaSystem_System_GribiServer) ΛBelongingModule() string {
	return "srl_nokia-gribi-server"
}

// SrlNokiaSystem_System_GribiServer_NetworkInstance represents the /srl_nokia-system/system/gribi-server/network-instance YANG schema element.
type SrlNokiaSystem_System_GribiServer_NetworkInstance struct {
	AdminState        E_SrlNokiaCommon_AdminState `path:"admin-state" module:"srl_nokia-gribi-server"`
	Name              *string                     `path:"name" module:"srl_nokia-gribi-server"`
	Port              *uint16                     `path:"port" module:"srl_nokia-gribi-server"`
	SourceAddress     []string                    `path:"source-address" module:"srl_nokia-gribi-server"`
	TlsProfile        *string                     `path:"tls-profile" module:"srl_nokia-gribi-server"`
	UseAuthentication *bool                       `path:"use-authentication" module:"srl_nokia-gribi-server"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_GribiServer_NetworkInstance implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_GribiServer_NetworkInstance) IsYANGGoStruct() {}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaSystem_System_GribiServer_NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_GribiServer_NetworkInstance) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_disable
	}
	return t.AdminState
}

// GetName retrieves the value of the leaf Name from the SrlNokiaSystem_System_GribiServer_NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_GribiServer_NetworkInstance) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetPort retrieves the value of the leaf Port from the SrlNokiaSystem_System_GribiServer_NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Port is set, it can
// safely use t.GetPort() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Port == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_GribiServer_NetworkInstance) GetPort() uint16 {
	if t == nil || t.Port == nil {
		return 57401
	}
	return *t.Port
}

// GetSourceAddress retrieves the value of the leaf SourceAddress from the SrlNokiaSystem_System_GribiServer_NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SourceAddress is set, it can
// safely use t.GetSourceAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SourceAddress == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_GribiServer_NetworkInstance) GetSourceAddress() []string {
	if t == nil || t.SourceAddress == nil {
		return nil
	}
	return t.SourceAddress
}

// GetTlsProfile retrieves the value of the leaf TlsProfile from the SrlNokiaSystem_System_GribiServer_NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TlsProfile is set, it can
// safely use t.GetTlsProfile() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TlsProfile == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_GribiServer_NetworkInstance) GetTlsProfile() string {
	if t == nil || t.TlsProfile == nil {
		return ""
	}
	return *t.TlsProfile
}

// GetUseAuthentication retrieves the value of the leaf UseAuthentication from the SrlNokiaSystem_System_GribiServer_NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if UseAuthentication is set, it can
// safely use t.GetUseAuthentication() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.UseAuthentication == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_GribiServer_NetworkInstance) GetUseAuthentication() bool {
	if t == nil || t.UseAuthentication == nil {
		return true
	}
	return *t.UseAuthentication
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_GribiServer_NetworkInstance
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_GribiServer_NetworkInstance) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_disable
	}
	if t.Port == nil {
		var v uint16 = 57401
		t.Port = &v
	}
	if t.UseAuthentication == nil {
		var v bool = true
		t.UseAuthentication = &v
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_GribiServer_NetworkInstance struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_GribiServer_NetworkInstance) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_GribiServer_NetworkInstance) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_GribiServer_NetworkInstance"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_GribiServer_NetworkInstance) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_GribiServer_NetworkInstance) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_GribiServer_NetworkInstance.
func (*SrlNokiaSystem_System_GribiServer_NetworkInstance) ΛBelongingModule() string {
	return "srl_nokia-gribi-server"
}

// SrlNokiaSystem_System_GribiServer_UnixSocket represents the /srl_nokia-system/system/gribi-server/unix-socket YANG schema element.
type SrlNokiaSystem_System_GribiServer_UnixSocket struct {
	AdminState        E_SrlNokiaCommon_AdminState `path:"admin-state" module:"srl_nokia-gribi-server"`
	TlsProfile        *string                     `path:"tls-profile" module:"srl_nokia-gribi-server"`
	UseAuthentication *bool                       `path:"use-authentication" module:"srl_nokia-gribi-server"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_GribiServer_UnixSocket implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_GribiServer_UnixSocket) IsYANGGoStruct() {}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaSystem_System_GribiServer_UnixSocket
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_GribiServer_UnixSocket) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_disable
	}
	return t.AdminState
}

// GetTlsProfile retrieves the value of the leaf TlsProfile from the SrlNokiaSystem_System_GribiServer_UnixSocket
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TlsProfile is set, it can
// safely use t.GetTlsProfile() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TlsProfile == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_GribiServer_UnixSocket) GetTlsProfile() string {
	if t == nil || t.TlsProfile == nil {
		return ""
	}
	return *t.TlsProfile
}

// GetUseAuthentication retrieves the value of the leaf UseAuthentication from the SrlNokiaSystem_System_GribiServer_UnixSocket
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if UseAuthentication is set, it can
// safely use t.GetUseAuthentication() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.UseAuthentication == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_GribiServer_UnixSocket) GetUseAuthentication() bool {
	if t == nil || t.UseAuthentication == nil {
		return true
	}
	return *t.UseAuthentication
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_GribiServer_UnixSocket
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_GribiServer_UnixSocket) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_disable
	}
	if t.UseAuthentication == nil {
		var v bool = true
		t.UseAuthentication = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_GribiServer_UnixSocket) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_GribiServer_UnixSocket"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_GribiServer_UnixSocket) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_GribiServer_UnixSocket) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_GribiServer_UnixSocket.
func (*SrlNokiaSystem_System_GribiServer_UnixSocket) ΛBelongingModule() string {
	return "srl_nokia-gribi-server"
}

// SrlNokiaSystem_System_Information represents the /srl_nokia-system/system/information YANG schema element.
type SrlNokiaSystem_System_Information struct {
	Contact          *string `path:"contact" module:"srl_nokia-system-info"`
	Location         *string `path:"location" module:"srl_nokia-system-info"`
	ProtobufMetadata Binary  `path:"protobuf-metadata" module:"srl_nokia-system-info"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Information implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Information) IsYANGGoStruct() {}

// GetContact retrieves the value of the leaf Contact from the SrlNokiaSystem_System_Information
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Contact is set, it can
// safely use t.GetContact() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Contact == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Information) GetContact() string {
	if t == nil || t.Contact == nil {
		return ""
	}
	return *t.Contact
}

// GetLocation retrieves the value of the leaf Location from the SrlNokiaSystem_System_Information
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Location is set, it can
// safely use t.GetLocation() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Location == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Information) GetLocation() string {
	if t == nil || t.Location == nil {
		return ""
	}
	return *t.Location
}

// GetProtobufMetadata retrieves the value of the leaf ProtobufMetadata from the SrlNokiaSystem_System_Information
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ProtobufMetadata is set, it can
// safely use t.GetProtobufMetadata() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ProtobufMetadata == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Information) GetProtobufMetadata() Binary {
	if t == nil || t.ProtobufMetadata == nil {
		return nil
	}
	return t.ProtobufMetadata
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Information
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Information) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Information) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Information"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Information) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Information) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Information.
func (*SrlNokiaSystem_System_Information) ΛBelongingModule() string {
	return "srl_nokia-system-info"
}

// SrlNokiaSystem_System_JsonRpcServer represents the /srl_nokia-system/system/json-rpc-server YANG schema element.
type SrlNokiaSystem_System_JsonRpcServer struct {
	AdminState             E_SrlNokiaCommon_AdminState                                     `path:"admin-state" module:"srl_nokia-json-rpc"`
	CommitConfirmedTimeout *uint32                                                         `path:"commit-confirmed-timeout" module:"srl_nokia-json-rpc"`
	NetworkInstance        map[string]*SrlNokiaSystem_System_JsonRpcServer_NetworkInstance `path:"network-instance" module:"srl_nokia-json-rpc"`
	TraceOptions           []E_SrlNokiaSystem_System_JsonRpcServer_TraceOptions            `path:"trace-options" module:"srl_nokia-json-rpc"`
	UnixSocket             *SrlNokiaSystem_System_JsonRpcServer_UnixSocket                 `path:"unix-socket" module:"srl_nokia-json-rpc"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_JsonRpcServer implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_JsonRpcServer) IsYANGGoStruct() {}

// NewNetworkInstance creates a new entry in the NetworkInstance list of the
// SrlNokiaSystem_System_JsonRpcServer struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_JsonRpcServer) NewNetworkInstance(Name string) (*SrlNokiaSystem_System_JsonRpcServer_NetworkInstance, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NetworkInstance == nil {
		t.NetworkInstance = make(map[string]*SrlNokiaSystem_System_JsonRpcServer_NetworkInstance)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.NetworkInstance[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list NetworkInstance", key)
	}

	t.NetworkInstance[key] = &SrlNokiaSystem_System_JsonRpcServer_NetworkInstance{
		Name: &Name,
	}

	return t.NetworkInstance[key], nil
}

// RenameNetworkInstance renames an entry in the list NetworkInstance within
// the SrlNokiaSystem_System_JsonRpcServer struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaSystem_System_JsonRpcServer) RenameNetworkInstance(oldK, newK string) error {
	if _, ok := t.NetworkInstance[newK]; ok {
		return fmt.Errorf("key %v already exists in NetworkInstance", newK)
	}

	e, ok := t.NetworkInstance[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in NetworkInstance", oldK)
	}
	e.Name = &newK

	t.NetworkInstance[newK] = e
	delete(t.NetworkInstance, oldK)
	return nil
}

// GetOrCreateNetworkInstance retrieves the value with the specified keys from
// the receiver SrlNokiaSystem_System_JsonRpcServer. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaSystem_System_JsonRpcServer) GetOrCreateNetworkInstance(Name string) *SrlNokiaSystem_System_JsonRpcServer_NetworkInstance {
	key := Name

	if v, ok := t.NetworkInstance[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNetworkInstance(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNetworkInstance got unexpected error: %v", err))
	}
	return v
}

// GetNetworkInstance retrieves the value with the specified key from
// the NetworkInstance map field of SrlNokiaSystem_System_JsonRpcServer. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaSystem_System_JsonRpcServer) GetNetworkInstance(Name string) *SrlNokiaSystem_System_JsonRpcServer_NetworkInstance {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.NetworkInstance[key]; ok {
		return lm
	}
	return nil
}

// DeleteNetworkInstance deletes the value with the specified keys from
// the receiver SrlNokiaSystem_System_JsonRpcServer. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaSystem_System_JsonRpcServer) DeleteNetworkInstance(Name string) {
	key := Name

	delete(t.NetworkInstance, key)
}

// AppendNetworkInstance appends the supplied SrlNokiaSystem_System_JsonRpcServer_NetworkInstance struct to the
// list NetworkInstance of SrlNokiaSystem_System_JsonRpcServer. If the key value(s) specified in
// the supplied SrlNokiaSystem_System_JsonRpcServer_NetworkInstance already exist in the list, an error is
// returned.
func (t *SrlNokiaSystem_System_JsonRpcServer) AppendNetworkInstance(
	v *SrlNokiaSystem_System_JsonRpcServer_NetworkInstance,
) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NetworkInstance == nil {
		t.NetworkInstance = make(map[string]*SrlNokiaSystem_System_JsonRpcServer_NetworkInstance)
	}

	if _, ok := t.NetworkInstance[key]; ok {
		return fmt.Errorf("duplicate key for list NetworkInstance %v", key)
	}

	t.NetworkInstance[key] = v
	return nil
}

// GetOrCreateUnixSocket retrieves the value of the UnixSocket field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_JsonRpcServer) GetOrCreateUnixSocket() *SrlNokiaSystem_System_JsonRpcServer_UnixSocket {
	if t.UnixSocket != nil {
		return t.UnixSocket
	}
	t.UnixSocket = &SrlNokiaSystem_System_JsonRpcServer_UnixSocket{}
	return t.UnixSocket
}

// GetUnixSocket returns the value of the UnixSocket struct pointer
// from SrlNokiaSystem_System_JsonRpcServer. If the receiver or the field UnixSocket is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_JsonRpcServer) GetUnixSocket() *SrlNokiaSystem_System_JsonRpcServer_UnixSocket {
	if t != nil && t.UnixSocket != nil {
		return t.UnixSocket
	}
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaSystem_System_JsonRpcServer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_JsonRpcServer) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_disable
	}
	return t.AdminState
}

// GetCommitConfirmedTimeout retrieves the value of the leaf CommitConfirmedTimeout from the SrlNokiaSystem_System_JsonRpcServer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if CommitConfirmedTimeout is set, it can
// safely use t.GetCommitConfirmedTimeout() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.CommitConfirmedTimeout == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_JsonRpcServer) GetCommitConfirmedTimeout() uint32 {
	if t == nil || t.CommitConfirmedTimeout == nil {
		return 0
	}
	return *t.CommitConfirmedTimeout
}

// GetTraceOptions retrieves the value of the leaf TraceOptions from the SrlNokiaSystem_System_JsonRpcServer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TraceOptions is set, it can
// safely use t.GetTraceOptions() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TraceOptions == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_JsonRpcServer) GetTraceOptions() []E_SrlNokiaSystem_System_JsonRpcServer_TraceOptions {
	if t == nil || t.TraceOptions == nil {
		return nil
	}
	return t.TraceOptions
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_JsonRpcServer
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_JsonRpcServer) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_disable
	}
	if t.CommitConfirmedTimeout == nil {
		var v uint32 = 0
		t.CommitConfirmedTimeout = &v
	}
	t.UnixSocket.PopulateDefaults()
	for _, e := range t.NetworkInstance {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_JsonRpcServer) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_JsonRpcServer"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_JsonRpcServer) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_JsonRpcServer) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_JsonRpcServer.
func (*SrlNokiaSystem_System_JsonRpcServer) ΛBelongingModule() string {
	return "srl_nokia-json-rpc"
}

// SrlNokiaSystem_System_JsonRpcServer_NetworkInstance represents the /srl_nokia-system/system/json-rpc-server/network-instance YANG schema element.
type SrlNokiaSystem_System_JsonRpcServer_NetworkInstance struct {
	Http  *SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Http  `path:"http" module:"srl_nokia-json-rpc" yangPresence:"true"`
	Https *SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Https `path:"https" module:"srl_nokia-json-rpc" yangPresence:"true"`
	Name  *string                                                    `path:"name" module:"srl_nokia-json-rpc"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_JsonRpcServer_NetworkInstance implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_JsonRpcServer_NetworkInstance) IsYANGGoStruct() {}

// GetOrCreateHttp retrieves the value of the Http field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_JsonRpcServer_NetworkInstance) GetOrCreateHttp() *SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Http {
	if t.Http != nil {
		return t.Http
	}
	t.Http = &SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Http{}
	return t.Http
}

// GetOrCreateHttps retrieves the value of the Https field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_JsonRpcServer_NetworkInstance) GetOrCreateHttps() *SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Https {
	if t.Https != nil {
		return t.Https
	}
	t.Https = &SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Https{}
	return t.Https
}

// GetHttp returns the value of the Http struct pointer
// from SrlNokiaSystem_System_JsonRpcServer_NetworkInstance. If the receiver or the field Http is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_JsonRpcServer_NetworkInstance) GetHttp() *SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Http {
	if t != nil && t.Http != nil {
		return t.Http
	}
	return nil
}

// GetHttps returns the value of the Https struct pointer
// from SrlNokiaSystem_System_JsonRpcServer_NetworkInstance. If the receiver or the field Https is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_JsonRpcServer_NetworkInstance) GetHttps() *SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Https {
	if t != nil && t.Https != nil {
		return t.Https
	}
	return nil
}

// GetName retrieves the value of the leaf Name from the SrlNokiaSystem_System_JsonRpcServer_NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_JsonRpcServer_NetworkInstance) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_JsonRpcServer_NetworkInstance
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_JsonRpcServer_NetworkInstance) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Http.PopulateDefaults()
	t.Https.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_JsonRpcServer_NetworkInstance struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_JsonRpcServer_NetworkInstance) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_JsonRpcServer_NetworkInstance) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_JsonRpcServer_NetworkInstance"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_JsonRpcServer_NetworkInstance) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_JsonRpcServer_NetworkInstance) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_JsonRpcServer_NetworkInstance.
func (*SrlNokiaSystem_System_JsonRpcServer_NetworkInstance) ΛBelongingModule() string {
	return "srl_nokia-json-rpc"
}

// SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Http represents the /srl_nokia-system/system/json-rpc-server/network-instance/http YANG schema element.
type SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Http struct {
	AdminState        E_SrlNokiaCommon_AdminState `path:"admin-state" module:"srl_nokia-json-rpc"`
	Port              *uint16                     `path:"port" module:"srl_nokia-json-rpc"`
	SessionLimit      *uint16                     `path:"session-limit" module:"srl_nokia-json-rpc"`
	SourceAddress     []string                    `path:"source-address" module:"srl_nokia-json-rpc"`
	UseAuthentication *bool                       `path:"use-authentication" module:"srl_nokia-json-rpc"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Http implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Http) IsYANGGoStruct() {}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Http
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Http) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_disable
	}
	return t.AdminState
}

// GetPort retrieves the value of the leaf Port from the SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Http
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Port is set, it can
// safely use t.GetPort() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Port == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Http) GetPort() uint16 {
	if t == nil || t.Port == nil {
		return 80
	}
	return *t.Port
}

// GetSessionLimit retrieves the value of the leaf SessionLimit from the SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Http
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SessionLimit is set, it can
// safely use t.GetSessionLimit() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SessionLimit == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Http) GetSessionLimit() uint16 {
	if t == nil || t.SessionLimit == nil {
		return 10
	}
	return *t.SessionLimit
}

// GetSourceAddress retrieves the value of the leaf SourceAddress from the SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Http
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SourceAddress is set, it can
// safely use t.GetSourceAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SourceAddress == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Http) GetSourceAddress() []string {
	if t == nil || t.SourceAddress == nil {
		return []string{"::"}
	}
	return t.SourceAddress
}

// GetUseAuthentication retrieves the value of the leaf UseAuthentication from the SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Http
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if UseAuthentication is set, it can
// safely use t.GetUseAuthentication() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.UseAuthentication == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Http) GetUseAuthentication() bool {
	if t == nil || t.UseAuthentication == nil {
		return true
	}
	return *t.UseAuthentication
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Http
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Http) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_disable
	}
	if t.Port == nil {
		var v uint16 = 80
		t.Port = &v
	}
	if t.SessionLimit == nil {
		var v uint16 = 10
		t.SessionLimit = &v
	}
	if t.SourceAddress == nil {
		t.SourceAddress = []string{"::"}
	}
	if t.UseAuthentication == nil {
		var v bool = true
		t.UseAuthentication = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Http) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Http"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Http) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Http) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Http.
func (*SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Http) ΛBelongingModule() string {
	return "srl_nokia-json-rpc"
}

// SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Https represents the /srl_nokia-system/system/json-rpc-server/network-instance/https YANG schema element.
type SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Https struct {
	AdminState        E_SrlNokiaCommon_AdminState `path:"admin-state" module:"srl_nokia-json-rpc"`
	Port              *uint16                     `path:"port" module:"srl_nokia-json-rpc"`
	SessionLimit      *uint16                     `path:"session-limit" module:"srl_nokia-json-rpc"`
	SourceAddress     []string                    `path:"source-address" module:"srl_nokia-json-rpc"`
	TlsProfile        *string                     `path:"tls-profile" module:"srl_nokia-json-rpc"`
	UseAuthentication *bool                       `path:"use-authentication" module:"srl_nokia-json-rpc"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Https implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Https) IsYANGGoStruct() {}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Https
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Https) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_disable
	}
	return t.AdminState
}

// GetPort retrieves the value of the leaf Port from the SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Https
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Port is set, it can
// safely use t.GetPort() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Port == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Https) GetPort() uint16 {
	if t == nil || t.Port == nil {
		return 443
	}
	return *t.Port
}

// GetSessionLimit retrieves the value of the leaf SessionLimit from the SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Https
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SessionLimit is set, it can
// safely use t.GetSessionLimit() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SessionLimit == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Https) GetSessionLimit() uint16 {
	if t == nil || t.SessionLimit == nil {
		return 10
	}
	return *t.SessionLimit
}

// GetSourceAddress retrieves the value of the leaf SourceAddress from the SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Https
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SourceAddress is set, it can
// safely use t.GetSourceAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SourceAddress == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Https) GetSourceAddress() []string {
	if t == nil || t.SourceAddress == nil {
		return []string{"::"}
	}
	return t.SourceAddress
}

// GetTlsProfile retrieves the value of the leaf TlsProfile from the SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Https
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TlsProfile is set, it can
// safely use t.GetTlsProfile() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TlsProfile == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Https) GetTlsProfile() string {
	if t == nil || t.TlsProfile == nil {
		return ""
	}
	return *t.TlsProfile
}

// GetUseAuthentication retrieves the value of the leaf UseAuthentication from the SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Https
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if UseAuthentication is set, it can
// safely use t.GetUseAuthentication() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.UseAuthentication == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Https) GetUseAuthentication() bool {
	if t == nil || t.UseAuthentication == nil {
		return true
	}
	return *t.UseAuthentication
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Https
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Https) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_disable
	}
	if t.Port == nil {
		var v uint16 = 443
		t.Port = &v
	}
	if t.SessionLimit == nil {
		var v uint16 = 10
		t.SessionLimit = &v
	}
	if t.SourceAddress == nil {
		t.SourceAddress = []string{"::"}
	}
	if t.UseAuthentication == nil {
		var v bool = true
		t.UseAuthentication = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Https) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Https"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Https) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Https) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Https.
func (*SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Https) ΛBelongingModule() string {
	return "srl_nokia-json-rpc"
}

// SrlNokiaSystem_System_JsonRpcServer_UnixSocket represents the /srl_nokia-system/system/json-rpc-server/unix-socket YANG schema element.
type SrlNokiaSystem_System_JsonRpcServer_UnixSocket struct {
	AdminState        E_SrlNokiaCommon_AdminState `path:"admin-state" module:"srl_nokia-json-rpc"`
	TlsProfile        *string                     `path:"tls-profile" module:"srl_nokia-json-rpc"`
	UseAuthentication *bool                       `path:"use-authentication" module:"srl_nokia-json-rpc"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_JsonRpcServer_UnixSocket implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_JsonRpcServer_UnixSocket) IsYANGGoStruct() {}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaSystem_System_JsonRpcServer_UnixSocket
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_JsonRpcServer_UnixSocket) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_disable
	}
	return t.AdminState
}

// GetTlsProfile retrieves the value of the leaf TlsProfile from the SrlNokiaSystem_System_JsonRpcServer_UnixSocket
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TlsProfile is set, it can
// safely use t.GetTlsProfile() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TlsProfile == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_JsonRpcServer_UnixSocket) GetTlsProfile() string {
	if t == nil || t.TlsProfile == nil {
		return ""
	}
	return *t.TlsProfile
}

// GetUseAuthentication retrieves the value of the leaf UseAuthentication from the SrlNokiaSystem_System_JsonRpcServer_UnixSocket
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if UseAuthentication is set, it can
// safely use t.GetUseAuthentication() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.UseAuthentication == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_JsonRpcServer_UnixSocket) GetUseAuthentication() bool {
	if t == nil || t.UseAuthentication == nil {
		return true
	}
	return *t.UseAuthentication
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_JsonRpcServer_UnixSocket
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_JsonRpcServer_UnixSocket) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_disable
	}
	if t.UseAuthentication == nil {
		var v bool = true
		t.UseAuthentication = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_JsonRpcServer_UnixSocket) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_JsonRpcServer_UnixSocket"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_JsonRpcServer_UnixSocket) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_JsonRpcServer_UnixSocket) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_JsonRpcServer_UnixSocket.
func (*SrlNokiaSystem_System_JsonRpcServer_UnixSocket) ΛBelongingModule() string {
	return "srl_nokia-json-rpc"
}

// SrlNokiaSystem_System_Lacp represents the /srl_nokia-system/system/lacp YANG schema element.
type SrlNokiaSystem_System_Lacp struct {
	SystemId       *string `path:"system-id" module:"srl_nokia-lacp"`
	SystemPriority *uint16 `path:"system-priority" module:"srl_nokia-lacp"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Lacp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Lacp) IsYANGGoStruct() {}

// GetSystemId retrieves the value of the leaf SystemId from the SrlNokiaSystem_System_Lacp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SystemId is set, it can
// safely use t.GetSystemId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SystemId == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Lacp) GetSystemId() string {
	if t == nil || t.SystemId == nil {
		return ""
	}
	return *t.SystemId
}

// GetSystemPriority retrieves the value of the leaf SystemPriority from the SrlNokiaSystem_System_Lacp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SystemPriority is set, it can
// safely use t.GetSystemPriority() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SystemPriority == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Lacp) GetSystemPriority() uint16 {
	if t == nil || t.SystemPriority == nil {
		return 0
	}
	return *t.SystemPriority
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Lacp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Lacp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Lacp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Lacp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Lacp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Lacp) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Lacp.
func (*SrlNokiaSystem_System_Lacp) ΛBelongingModule() string {
	return "srl_nokia-lacp"
}

// SrlNokiaSystem_System_License represents the /srl_nokia-system/system/license YANG schema element.
type SrlNokiaSystem_System_License struct {
	AdminState  E_SrlNokiaCommon_AdminState `path:"admin-state" module:"srl_nokia-license"`
	Data        *string                     `path:"data" module:"srl_nokia-license"`
	Description *string                     `path:"description" module:"srl_nokia-license"`
	Id          *string                     `path:"id" module:"srl_nokia-license"`
	Preferred   *bool                       `path:"preferred" module:"srl_nokia-license"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_License implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_License) IsYANGGoStruct() {}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaSystem_System_License
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_License) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_disable
	}
	return t.AdminState
}

// GetData retrieves the value of the leaf Data from the SrlNokiaSystem_System_License
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Data is set, it can
// safely use t.GetData() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Data == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_License) GetData() string {
	if t == nil || t.Data == nil {
		return ""
	}
	return *t.Data
}

// GetDescription retrieves the value of the leaf Description from the SrlNokiaSystem_System_License
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_License) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetId retrieves the value of the leaf Id from the SrlNokiaSystem_System_License
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Id is set, it can
// safely use t.GetId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Id == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_License) GetId() string {
	if t == nil || t.Id == nil {
		return ""
	}
	return *t.Id
}

// GetPreferred retrieves the value of the leaf Preferred from the SrlNokiaSystem_System_License
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Preferred is set, it can
// safely use t.GetPreferred() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Preferred == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_License) GetPreferred() bool {
	if t == nil || t.Preferred == nil {
		return false
	}
	return *t.Preferred
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_License
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_License) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_disable
	}
	if t.Preferred == nil {
		var v bool = false
		t.Preferred = &v
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_License struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_License) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Id == nil {
		return nil, fmt.Errorf("nil value for key Id")
	}

	return map[string]interface{}{
		"id": *t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_License) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_License"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_License) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_License) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_License.
func (*SrlNokiaSystem_System_License) ΛBelongingModule() string {
	return "srl_nokia-license"
}

// SrlNokiaSystem_System_Lldp represents the /srl_nokia-system/system/lldp YANG schema element.
type SrlNokiaSystem_System_Lldp struct {
	AdminState        E_SrlNokiaCommon_AdminState                              `path:"admin-state" module:"srl_nokia-lldp"`
	BgpAutoDiscovery  *SrlNokiaSystem_System_Lldp_BgpAutoDiscovery             `path:"bgp-auto-discovery" module:"srl_nokia-lldp" yangPresence:"true"`
	HelloTimer        *uint64                                                  `path:"hello-timer" module:"srl_nokia-lldp"`
	HoldMultiplier    *uint8                                                   `path:"hold-multiplier" module:"srl_nokia-lldp"`
	Interface         map[string]*SrlNokiaSystem_System_Lldp_Interface         `path:"interface" module:"srl_nokia-lldp"`
	ManagementAddress map[string]*SrlNokiaSystem_System_Lldp_ManagementAddress `path:"management-address" module:"srl_nokia-lldp"`
	TraceOptions      []E_SrlNokiaSystem_System_Lldp_TraceOptions              `path:"trace-options" module:"srl_nokia-lldp"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Lldp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Lldp) IsYANGGoStruct() {}

// NewInterface creates a new entry in the Interface list of the
// SrlNokiaSystem_System_Lldp struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_Lldp) NewInterface(Name string) (*SrlNokiaSystem_System_Lldp_Interface, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*SrlNokiaSystem_System_Lldp_Interface)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Interface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Interface", key)
	}

	t.Interface[key] = &SrlNokiaSystem_System_Lldp_Interface{
		Name: &Name,
	}

	return t.Interface[key], nil
}

// RenameInterface renames an entry in the list Interface within
// the SrlNokiaSystem_System_Lldp struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaSystem_System_Lldp) RenameInterface(oldK, newK string) error {
	if _, ok := t.Interface[newK]; ok {
		return fmt.Errorf("key %v already exists in Interface", newK)
	}

	e, ok := t.Interface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Interface", oldK)
	}
	e.Name = &newK

	t.Interface[newK] = e
	delete(t.Interface, oldK)
	return nil
}

// GetOrCreateInterface retrieves the value with the specified keys from
// the receiver SrlNokiaSystem_System_Lldp. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaSystem_System_Lldp) GetOrCreateInterface(Name string) *SrlNokiaSystem_System_Lldp_Interface {
	key := Name

	if v, ok := t.Interface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInterface(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInterface got unexpected error: %v", err))
	}
	return v
}

// GetInterface retrieves the value with the specified key from
// the Interface map field of SrlNokiaSystem_System_Lldp. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaSystem_System_Lldp) GetInterface(Name string) *SrlNokiaSystem_System_Lldp_Interface {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Interface[key]; ok {
		return lm
	}
	return nil
}

// DeleteInterface deletes the value with the specified keys from
// the receiver SrlNokiaSystem_System_Lldp. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaSystem_System_Lldp) DeleteInterface(Name string) {
	key := Name

	delete(t.Interface, key)
}

// AppendInterface appends the supplied SrlNokiaSystem_System_Lldp_Interface struct to the
// list Interface of SrlNokiaSystem_System_Lldp. If the key value(s) specified in
// the supplied SrlNokiaSystem_System_Lldp_Interface already exist in the list, an error is
// returned.
func (t *SrlNokiaSystem_System_Lldp) AppendInterface(v *SrlNokiaSystem_System_Lldp_Interface) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*SrlNokiaSystem_System_Lldp_Interface)
	}

	if _, ok := t.Interface[key]; ok {
		return fmt.Errorf("duplicate key for list Interface %v", key)
	}

	t.Interface[key] = v
	return nil
}

// NewManagementAddress creates a new entry in the ManagementAddress list of the
// SrlNokiaSystem_System_Lldp struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_Lldp) NewManagementAddress(Subinterface string) (*SrlNokiaSystem_System_Lldp_ManagementAddress, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ManagementAddress == nil {
		t.ManagementAddress = make(map[string]*SrlNokiaSystem_System_Lldp_ManagementAddress)
	}

	key := Subinterface

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.ManagementAddress[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list ManagementAddress", key)
	}

	t.ManagementAddress[key] = &SrlNokiaSystem_System_Lldp_ManagementAddress{
		Subinterface: &Subinterface,
	}

	return t.ManagementAddress[key], nil
}

// RenameManagementAddress renames an entry in the list ManagementAddress within
// the SrlNokiaSystem_System_Lldp struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaSystem_System_Lldp) RenameManagementAddress(oldK, newK string) error {
	if _, ok := t.ManagementAddress[newK]; ok {
		return fmt.Errorf("key %v already exists in ManagementAddress", newK)
	}

	e, ok := t.ManagementAddress[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in ManagementAddress", oldK)
	}
	e.Subinterface = &newK

	t.ManagementAddress[newK] = e
	delete(t.ManagementAddress, oldK)
	return nil
}

// GetOrCreateManagementAddress retrieves the value with the specified keys from
// the receiver SrlNokiaSystem_System_Lldp. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaSystem_System_Lldp) GetOrCreateManagementAddress(Subinterface string) *SrlNokiaSystem_System_Lldp_ManagementAddress {
	key := Subinterface

	if v, ok := t.ManagementAddress[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewManagementAddress(Subinterface)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateManagementAddress got unexpected error: %v", err))
	}
	return v
}

// GetManagementAddress retrieves the value with the specified key from
// the ManagementAddress map field of SrlNokiaSystem_System_Lldp. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaSystem_System_Lldp) GetManagementAddress(Subinterface string) *SrlNokiaSystem_System_Lldp_ManagementAddress {
	if t == nil {
		return nil
	}

	key := Subinterface

	if lm, ok := t.ManagementAddress[key]; ok {
		return lm
	}
	return nil
}

// DeleteManagementAddress deletes the value with the specified keys from
// the receiver SrlNokiaSystem_System_Lldp. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaSystem_System_Lldp) DeleteManagementAddress(Subinterface string) {
	key := Subinterface

	delete(t.ManagementAddress, key)
}

// AppendManagementAddress appends the supplied SrlNokiaSystem_System_Lldp_ManagementAddress struct to the
// list ManagementAddress of SrlNokiaSystem_System_Lldp. If the key value(s) specified in
// the supplied SrlNokiaSystem_System_Lldp_ManagementAddress already exist in the list, an error is
// returned.
func (t *SrlNokiaSystem_System_Lldp) AppendManagementAddress(v *SrlNokiaSystem_System_Lldp_ManagementAddress) error {
	if v.Subinterface == nil {
		return fmt.Errorf("invalid nil key received for Subinterface")
	}

	key := *v.Subinterface

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ManagementAddress == nil {
		t.ManagementAddress = make(map[string]*SrlNokiaSystem_System_Lldp_ManagementAddress)
	}

	if _, ok := t.ManagementAddress[key]; ok {
		return fmt.Errorf("duplicate key for list ManagementAddress %v", key)
	}

	t.ManagementAddress[key] = v
	return nil
}

// GetOrCreateBgpAutoDiscovery retrieves the value of the BgpAutoDiscovery field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_Lldp) GetOrCreateBgpAutoDiscovery() *SrlNokiaSystem_System_Lldp_BgpAutoDiscovery {
	if t.BgpAutoDiscovery != nil {
		return t.BgpAutoDiscovery
	}
	t.BgpAutoDiscovery = &SrlNokiaSystem_System_Lldp_BgpAutoDiscovery{}
	return t.BgpAutoDiscovery
}

// GetBgpAutoDiscovery returns the value of the BgpAutoDiscovery struct pointer
// from SrlNokiaSystem_System_Lldp. If the receiver or the field BgpAutoDiscovery is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_Lldp) GetBgpAutoDiscovery() *SrlNokiaSystem_System_Lldp_BgpAutoDiscovery {
	if t != nil && t.BgpAutoDiscovery != nil {
		return t.BgpAutoDiscovery
	}
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaSystem_System_Lldp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Lldp) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_enable
	}
	return t.AdminState
}

// GetHelloTimer retrieves the value of the leaf HelloTimer from the SrlNokiaSystem_System_Lldp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if HelloTimer is set, it can
// safely use t.GetHelloTimer() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.HelloTimer == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Lldp) GetHelloTimer() uint64 {
	if t == nil || t.HelloTimer == nil {
		return 30
	}
	return *t.HelloTimer
}

// GetHoldMultiplier retrieves the value of the leaf HoldMultiplier from the SrlNokiaSystem_System_Lldp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if HoldMultiplier is set, it can
// safely use t.GetHoldMultiplier() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.HoldMultiplier == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Lldp) GetHoldMultiplier() uint8 {
	if t == nil || t.HoldMultiplier == nil {
		return 4
	}
	return *t.HoldMultiplier
}

// GetTraceOptions retrieves the value of the leaf TraceOptions from the SrlNokiaSystem_System_Lldp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TraceOptions is set, it can
// safely use t.GetTraceOptions() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TraceOptions == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Lldp) GetTraceOptions() []E_SrlNokiaSystem_System_Lldp_TraceOptions {
	if t == nil || t.TraceOptions == nil {
		return nil
	}
	return t.TraceOptions
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Lldp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Lldp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_enable
	}
	if t.HelloTimer == nil {
		var v uint64 = 30
		t.HelloTimer = &v
	}
	if t.HoldMultiplier == nil {
		var v uint8 = 4
		t.HoldMultiplier = &v
	}
	t.BgpAutoDiscovery.PopulateDefaults()
	for _, e := range t.Interface {
		e.PopulateDefaults()
	}
	for _, e := range t.ManagementAddress {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Lldp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Lldp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Lldp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Lldp) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Lldp.
func (*SrlNokiaSystem_System_Lldp) ΛBelongingModule() string {
	return "srl_nokia-lldp"
}

// SrlNokiaSystem_System_Lldp_BgpAutoDiscovery represents the /srl_nokia-system/system/lldp/bgp-auto-discovery YANG schema element.
type SrlNokiaSystem_System_Lldp_BgpAutoDiscovery struct {
	AdminState      E_SrlNokiaCommon_AdminState `path:"admin-state" module:"srl_nokia-lldp"`
	GroupId         *uint32                     `path:"group-id" module:"srl_nokia-lldp"`
	NetworkInstance []string                    `path:"network-instance" module:"srl_nokia-lldp"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Lldp_BgpAutoDiscovery implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Lldp_BgpAutoDiscovery) IsYANGGoStruct() {}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaSystem_System_Lldp_BgpAutoDiscovery
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Lldp_BgpAutoDiscovery) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_disable
	}
	return t.AdminState
}

// GetGroupId retrieves the value of the leaf GroupId from the SrlNokiaSystem_System_Lldp_BgpAutoDiscovery
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if GroupId is set, it can
// safely use t.GetGroupId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.GroupId == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Lldp_BgpAutoDiscovery) GetGroupId() uint32 {
	if t == nil || t.GroupId == nil {
		return 0
	}
	return *t.GroupId
}

// GetNetworkInstance retrieves the value of the leaf NetworkInstance from the SrlNokiaSystem_System_Lldp_BgpAutoDiscovery
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NetworkInstance is set, it can
// safely use t.GetNetworkInstance() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NetworkInstance == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Lldp_BgpAutoDiscovery) GetNetworkInstance() []string {
	if t == nil || t.NetworkInstance == nil {
		return nil
	}
	return t.NetworkInstance
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Lldp_BgpAutoDiscovery
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Lldp_BgpAutoDiscovery) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_disable
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Lldp_BgpAutoDiscovery) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Lldp_BgpAutoDiscovery"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Lldp_BgpAutoDiscovery) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Lldp_BgpAutoDiscovery) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Lldp_BgpAutoDiscovery.
func (*SrlNokiaSystem_System_Lldp_BgpAutoDiscovery) ΛBelongingModule() string {
	return "srl_nokia-lldp"
}

// SrlNokiaSystem_System_Lldp_Interface represents the /srl_nokia-system/system/lldp/interface YANG schema element.
type SrlNokiaSystem_System_Lldp_Interface struct {
	AdminState       E_SrlNokiaCommon_AdminState                            `path:"admin-state" module:"srl_nokia-lldp"`
	BgpAutoDiscovery *SrlNokiaSystem_System_Lldp_Interface_BgpAutoDiscovery `path:"bgp-auto-discovery" module:"srl_nokia-lldp" yangPresence:"true"`
	Name             *string                                                `path:"name" module:"srl_nokia-lldp"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Lldp_Interface implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Lldp_Interface) IsYANGGoStruct() {}

// GetOrCreateBgpAutoDiscovery retrieves the value of the BgpAutoDiscovery field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_Lldp_Interface) GetOrCreateBgpAutoDiscovery() *SrlNokiaSystem_System_Lldp_Interface_BgpAutoDiscovery {
	if t.BgpAutoDiscovery != nil {
		return t.BgpAutoDiscovery
	}
	t.BgpAutoDiscovery = &SrlNokiaSystem_System_Lldp_Interface_BgpAutoDiscovery{}
	return t.BgpAutoDiscovery
}

// GetBgpAutoDiscovery returns the value of the BgpAutoDiscovery struct pointer
// from SrlNokiaSystem_System_Lldp_Interface. If the receiver or the field BgpAutoDiscovery is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_Lldp_Interface) GetBgpAutoDiscovery() *SrlNokiaSystem_System_Lldp_Interface_BgpAutoDiscovery {
	if t != nil && t.BgpAutoDiscovery != nil {
		return t.BgpAutoDiscovery
	}
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaSystem_System_Lldp_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Lldp_Interface) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_enable
	}
	return t.AdminState
}

// GetName retrieves the value of the leaf Name from the SrlNokiaSystem_System_Lldp_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Lldp_Interface) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Lldp_Interface
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Lldp_Interface) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_enable
	}
	t.BgpAutoDiscovery.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_Lldp_Interface struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_Lldp_Interface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Lldp_Interface) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Lldp_Interface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Lldp_Interface) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Lldp_Interface) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Lldp_Interface.
func (*SrlNokiaSystem_System_Lldp_Interface) ΛBelongingModule() string {
	return "srl_nokia-lldp"
}

// SrlNokiaSystem_System_Lldp_Interface_BgpAutoDiscovery represents the /srl_nokia-system/system/lldp/interface/bgp-auto-discovery YANG schema element.
type SrlNokiaSystem_System_Lldp_Interface_BgpAutoDiscovery struct {
	AdminState     E_SrlNokiaCommon_AdminState `path:"admin-state" module:"srl_nokia-lldp"`
	GroupId        *uint32                     `path:"group-id" module:"srl_nokia-lldp"`
	PeeringAddress []string                    `path:"peering-address" module:"srl_nokia-lldp"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Lldp_Interface_BgpAutoDiscovery implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Lldp_Interface_BgpAutoDiscovery) IsYANGGoStruct() {}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaSystem_System_Lldp_Interface_BgpAutoDiscovery
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Lldp_Interface_BgpAutoDiscovery) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_enable
	}
	return t.AdminState
}

// GetGroupId retrieves the value of the leaf GroupId from the SrlNokiaSystem_System_Lldp_Interface_BgpAutoDiscovery
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if GroupId is set, it can
// safely use t.GetGroupId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.GroupId == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Lldp_Interface_BgpAutoDiscovery) GetGroupId() uint32 {
	if t == nil || t.GroupId == nil {
		return 0
	}
	return *t.GroupId
}

// GetPeeringAddress retrieves the value of the leaf PeeringAddress from the SrlNokiaSystem_System_Lldp_Interface_BgpAutoDiscovery
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PeeringAddress is set, it can
// safely use t.GetPeeringAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PeeringAddress == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Lldp_Interface_BgpAutoDiscovery) GetPeeringAddress() []string {
	if t == nil || t.PeeringAddress == nil {
		return nil
	}
	return t.PeeringAddress
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Lldp_Interface_BgpAutoDiscovery
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Lldp_Interface_BgpAutoDiscovery) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_enable
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Lldp_Interface_BgpAutoDiscovery) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Lldp_Interface_BgpAutoDiscovery"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Lldp_Interface_BgpAutoDiscovery) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Lldp_Interface_BgpAutoDiscovery) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Lldp_Interface_BgpAutoDiscovery.
func (*SrlNokiaSystem_System_Lldp_Interface_BgpAutoDiscovery) ΛBelongingModule() string {
	return "srl_nokia-lldp"
}

// SrlNokiaSystem_System_Lldp_ManagementAddress represents the /srl_nokia-system/system/lldp/management-address YANG schema element.
type SrlNokiaSystem_System_Lldp_ManagementAddress struct {
	Subinterface *string                                     `path:"subinterface" module:"srl_nokia-lldp"`
	Type         []E_SrlNokiaLldpTypes_ManagementAddressType `path:"type" module:"srl_nokia-lldp"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Lldp_ManagementAddress implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Lldp_ManagementAddress) IsYANGGoStruct() {}

// GetSubinterface retrieves the value of the leaf Subinterface from the SrlNokiaSystem_System_Lldp_ManagementAddress
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Subinterface is set, it can
// safely use t.GetSubinterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Subinterface == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Lldp_ManagementAddress) GetSubinterface() string {
	if t == nil || t.Subinterface == nil {
		return ""
	}
	return *t.Subinterface
}

// GetType retrieves the value of the leaf Type from the SrlNokiaSystem_System_Lldp_ManagementAddress
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Type is set, it can
// safely use t.GetType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Type == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Lldp_ManagementAddress) GetType() []E_SrlNokiaLldpTypes_ManagementAddressType {
	if t == nil || t.Type == nil {
		return nil
	}
	return t.Type
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Lldp_ManagementAddress
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Lldp_ManagementAddress) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_Lldp_ManagementAddress struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_Lldp_ManagementAddress) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Subinterface == nil {
		return nil, fmt.Errorf("nil value for key Subinterface")
	}

	return map[string]interface{}{
		"subinterface": *t.Subinterface,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Lldp_ManagementAddress) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Lldp_ManagementAddress"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Lldp_ManagementAddress) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Lldp_ManagementAddress) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Lldp_ManagementAddress.
func (*SrlNokiaSystem_System_Lldp_ManagementAddress) ΛBelongingModule() string {
	return "srl_nokia-lldp"
}

// SrlNokiaSystem_System_LoadBalancing represents the /srl_nokia-system/system/load-balancing YANG schema element.
type SrlNokiaSystem_System_LoadBalancing struct {
	HashOptions *SrlNokiaSystem_System_LoadBalancing_HashOptions `path:"hash-options" module:"srl_nokia-load-balancing"`
	LsrProfile  E_SrlNokiaSystem_System_LoadBalancing_LsrProfile `path:"lsr-profile" module:"srl_nokia-load-balancing"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_LoadBalancing implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_LoadBalancing) IsYANGGoStruct() {}

// GetOrCreateHashOptions retrieves the value of the HashOptions field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_LoadBalancing) GetOrCreateHashOptions() *SrlNokiaSystem_System_LoadBalancing_HashOptions {
	if t.HashOptions != nil {
		return t.HashOptions
	}
	t.HashOptions = &SrlNokiaSystem_System_LoadBalancing_HashOptions{}
	return t.HashOptions
}

// GetHashOptions returns the value of the HashOptions struct pointer
// from SrlNokiaSystem_System_LoadBalancing. If the receiver or the field HashOptions is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_LoadBalancing) GetHashOptions() *SrlNokiaSystem_System_LoadBalancing_HashOptions {
	if t != nil && t.HashOptions != nil {
		return t.HashOptions
	}
	return nil
}

// GetLsrProfile retrieves the value of the leaf LsrProfile from the SrlNokiaSystem_System_LoadBalancing
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LsrProfile is set, it can
// safely use t.GetLsrProfile() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LsrProfile == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_LoadBalancing) GetLsrProfile() E_SrlNokiaSystem_System_LoadBalancing_LsrProfile {
	if t == nil || t.LsrProfile == 0 {
		return SrlNokiaSystem_System_LoadBalancing_LsrProfile_label_stack
	}
	return t.LsrProfile
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_LoadBalancing
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_LoadBalancing) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.LsrProfile == 0 {
		t.LsrProfile = SrlNokiaSystem_System_LoadBalancing_LsrProfile_label_stack
	}
	t.HashOptions.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_LoadBalancing) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_LoadBalancing"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_LoadBalancing) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_LoadBalancing) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_LoadBalancing.
func (*SrlNokiaSystem_System_LoadBalancing) ΛBelongingModule() string {
	return "srl_nokia-load-balancing"
}

// SrlNokiaSystem_System_LoadBalancing_HashOptions represents the /srl_nokia-system/system/load-balancing/hash-options YANG schema element.
type SrlNokiaSystem_System_LoadBalancing_HashOptions struct {
	DestinationAddress *bool   `path:"destination-address" module:"srl_nokia-load-balancing"`
	DestinationPort    *bool   `path:"destination-port" module:"srl_nokia-load-balancing"`
	HashSeed           *uint16 `path:"hash-seed" module:"srl_nokia-load-balancing"`
	Ipv6FlowLabel      *bool   `path:"ipv6-flow-label" module:"srl_nokia-load-balancing"`
	MplsLabelStack     *bool   `path:"mpls-label-stack" module:"srl_nokia-load-balancing"`
	Protocol           *bool   `path:"protocol" module:"srl_nokia-load-balancing"`
	SourceAddress      *bool   `path:"source-address" module:"srl_nokia-load-balancing"`
	SourcePort         *bool   `path:"source-port" module:"srl_nokia-load-balancing"`
	Vlan               *bool   `path:"vlan" module:"srl_nokia-load-balancing"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_LoadBalancing_HashOptions implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_LoadBalancing_HashOptions) IsYANGGoStruct() {}

// GetDestinationAddress retrieves the value of the leaf DestinationAddress from the SrlNokiaSystem_System_LoadBalancing_HashOptions
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DestinationAddress is set, it can
// safely use t.GetDestinationAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DestinationAddress == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_LoadBalancing_HashOptions) GetDestinationAddress() bool {
	if t == nil || t.DestinationAddress == nil {
		return true
	}
	return *t.DestinationAddress
}

// GetDestinationPort retrieves the value of the leaf DestinationPort from the SrlNokiaSystem_System_LoadBalancing_HashOptions
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DestinationPort is set, it can
// safely use t.GetDestinationPort() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DestinationPort == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_LoadBalancing_HashOptions) GetDestinationPort() bool {
	if t == nil || t.DestinationPort == nil {
		return true
	}
	return *t.DestinationPort
}

// GetHashSeed retrieves the value of the leaf HashSeed from the SrlNokiaSystem_System_LoadBalancing_HashOptions
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if HashSeed is set, it can
// safely use t.GetHashSeed() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.HashSeed == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_LoadBalancing_HashOptions) GetHashSeed() uint16 {
	if t == nil || t.HashSeed == nil {
		return 0
	}
	return *t.HashSeed
}

// GetIpv6FlowLabel retrieves the value of the leaf Ipv6FlowLabel from the SrlNokiaSystem_System_LoadBalancing_HashOptions
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ipv6FlowLabel is set, it can
// safely use t.GetIpv6FlowLabel() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ipv6FlowLabel == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_LoadBalancing_HashOptions) GetIpv6FlowLabel() bool {
	if t == nil || t.Ipv6FlowLabel == nil {
		return false
	}
	return *t.Ipv6FlowLabel
}

// GetMplsLabelStack retrieves the value of the leaf MplsLabelStack from the SrlNokiaSystem_System_LoadBalancing_HashOptions
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MplsLabelStack is set, it can
// safely use t.GetMplsLabelStack() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MplsLabelStack == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_LoadBalancing_HashOptions) GetMplsLabelStack() bool {
	if t == nil || t.MplsLabelStack == nil {
		return false
	}
	return *t.MplsLabelStack
}

// GetProtocol retrieves the value of the leaf Protocol from the SrlNokiaSystem_System_LoadBalancing_HashOptions
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Protocol is set, it can
// safely use t.GetProtocol() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Protocol == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_LoadBalancing_HashOptions) GetProtocol() bool {
	if t == nil || t.Protocol == nil {
		return true
	}
	return *t.Protocol
}

// GetSourceAddress retrieves the value of the leaf SourceAddress from the SrlNokiaSystem_System_LoadBalancing_HashOptions
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SourceAddress is set, it can
// safely use t.GetSourceAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SourceAddress == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_LoadBalancing_HashOptions) GetSourceAddress() bool {
	if t == nil || t.SourceAddress == nil {
		return true
	}
	return *t.SourceAddress
}

// GetSourcePort retrieves the value of the leaf SourcePort from the SrlNokiaSystem_System_LoadBalancing_HashOptions
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SourcePort is set, it can
// safely use t.GetSourcePort() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SourcePort == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_LoadBalancing_HashOptions) GetSourcePort() bool {
	if t == nil || t.SourcePort == nil {
		return true
	}
	return *t.SourcePort
}

// GetVlan retrieves the value of the leaf Vlan from the SrlNokiaSystem_System_LoadBalancing_HashOptions
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Vlan is set, it can
// safely use t.GetVlan() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Vlan == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_LoadBalancing_HashOptions) GetVlan() bool {
	if t == nil || t.Vlan == nil {
		return true
	}
	return *t.Vlan
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_LoadBalancing_HashOptions
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_LoadBalancing_HashOptions) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.DestinationAddress == nil {
		var v bool = true
		t.DestinationAddress = &v
	}
	if t.DestinationPort == nil {
		var v bool = true
		t.DestinationPort = &v
	}
	if t.HashSeed == nil {
		var v uint16 = 0
		t.HashSeed = &v
	}
	if t.Ipv6FlowLabel == nil {
		var v bool = false
		t.Ipv6FlowLabel = &v
	}
	if t.MplsLabelStack == nil {
		var v bool = false
		t.MplsLabelStack = &v
	}
	if t.Protocol == nil {
		var v bool = true
		t.Protocol = &v
	}
	if t.SourceAddress == nil {
		var v bool = true
		t.SourceAddress = &v
	}
	if t.SourcePort == nil {
		var v bool = true
		t.SourcePort = &v
	}
	if t.Vlan == nil {
		var v bool = true
		t.Vlan = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_LoadBalancing_HashOptions) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_LoadBalancing_HashOptions"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_LoadBalancing_HashOptions) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_LoadBalancing_HashOptions) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_LoadBalancing_HashOptions.
func (*SrlNokiaSystem_System_LoadBalancing_HashOptions) ΛBelongingModule() string {
	return "srl_nokia-load-balancing"
}

// SrlNokiaSystem_System_Logging represents the /srl_nokia-system/system/logging YANG schema element.
type SrlNokiaSystem_System_Logging struct {
	Buffer            map[string]*SrlNokiaSystem_System_Logging_Buffer       `path:"buffer" module:"srl_nokia-logging"`
	Console           *SrlNokiaSystem_System_Logging_Console                 `path:"console" module:"srl_nokia-logging"`
	File              map[string]*SrlNokiaSystem_System_Logging_File         `path:"file" module:"srl_nokia-logging"`
	Filter            map[string]*SrlNokiaSystem_System_Logging_Filter       `path:"filter" module:"srl_nokia-logging"`
	NetworkInstance   *string                                                `path:"network-instance" module:"srl_nokia-logging"`
	RemoteServer      map[string]*SrlNokiaSystem_System_Logging_RemoteServer `path:"remote-server" module:"srl_nokia-logging"`
	SubsystemFacility E_SrlNokiaLogging_FacilityNameTypeSubset               `path:"subsystem-facility" module:"srl_nokia-logging"`
	UseFqdn           *bool                                                  `path:"use-fqdn" module:"srl_nokia-logging"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Logging implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Logging) IsYANGGoStruct() {}

// NewBuffer creates a new entry in the Buffer list of the
// SrlNokiaSystem_System_Logging struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_Logging) NewBuffer(BufferName string) (*SrlNokiaSystem_System_Logging_Buffer, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Buffer == nil {
		t.Buffer = make(map[string]*SrlNokiaSystem_System_Logging_Buffer)
	}

	key := BufferName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Buffer[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Buffer", key)
	}

	t.Buffer[key] = &SrlNokiaSystem_System_Logging_Buffer{
		BufferName: &BufferName,
	}

	return t.Buffer[key], nil
}

// RenameBuffer renames an entry in the list Buffer within
// the SrlNokiaSystem_System_Logging struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaSystem_System_Logging) RenameBuffer(oldK, newK string) error {
	if _, ok := t.Buffer[newK]; ok {
		return fmt.Errorf("key %v already exists in Buffer", newK)
	}

	e, ok := t.Buffer[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Buffer", oldK)
	}
	e.BufferName = &newK

	t.Buffer[newK] = e
	delete(t.Buffer, oldK)
	return nil
}

// GetOrCreateBuffer retrieves the value with the specified keys from
// the receiver SrlNokiaSystem_System_Logging. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaSystem_System_Logging) GetOrCreateBuffer(BufferName string) *SrlNokiaSystem_System_Logging_Buffer {
	key := BufferName

	if v, ok := t.Buffer[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewBuffer(BufferName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateBuffer got unexpected error: %v", err))
	}
	return v
}

// GetBuffer retrieves the value with the specified key from
// the Buffer map field of SrlNokiaSystem_System_Logging. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaSystem_System_Logging) GetBuffer(BufferName string) *SrlNokiaSystem_System_Logging_Buffer {
	if t == nil {
		return nil
	}

	key := BufferName

	if lm, ok := t.Buffer[key]; ok {
		return lm
	}
	return nil
}

// DeleteBuffer deletes the value with the specified keys from
// the receiver SrlNokiaSystem_System_Logging. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaSystem_System_Logging) DeleteBuffer(BufferName string) {
	key := BufferName

	delete(t.Buffer, key)
}

// AppendBuffer appends the supplied SrlNokiaSystem_System_Logging_Buffer struct to the
// list Buffer of SrlNokiaSystem_System_Logging. If the key value(s) specified in
// the supplied SrlNokiaSystem_System_Logging_Buffer already exist in the list, an error is
// returned.
func (t *SrlNokiaSystem_System_Logging) AppendBuffer(v *SrlNokiaSystem_System_Logging_Buffer) error {
	if v.BufferName == nil {
		return fmt.Errorf("invalid nil key received for BufferName")
	}

	key := *v.BufferName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Buffer == nil {
		t.Buffer = make(map[string]*SrlNokiaSystem_System_Logging_Buffer)
	}

	if _, ok := t.Buffer[key]; ok {
		return fmt.Errorf("duplicate key for list Buffer %v", key)
	}

	t.Buffer[key] = v
	return nil
}

// NewFile creates a new entry in the File list of the
// SrlNokiaSystem_System_Logging struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_Logging) NewFile(FileName string) (*SrlNokiaSystem_System_Logging_File, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.File == nil {
		t.File = make(map[string]*SrlNokiaSystem_System_Logging_File)
	}

	key := FileName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.File[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list File", key)
	}

	t.File[key] = &SrlNokiaSystem_System_Logging_File{
		FileName: &FileName,
	}

	return t.File[key], nil
}

// RenameFile renames an entry in the list File within
// the SrlNokiaSystem_System_Logging struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaSystem_System_Logging) RenameFile(oldK, newK string) error {
	if _, ok := t.File[newK]; ok {
		return fmt.Errorf("key %v already exists in File", newK)
	}

	e, ok := t.File[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in File", oldK)
	}
	e.FileName = &newK

	t.File[newK] = e
	delete(t.File, oldK)
	return nil
}

// GetOrCreateFile retrieves the value with the specified keys from
// the receiver SrlNokiaSystem_System_Logging. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaSystem_System_Logging) GetOrCreateFile(FileName string) *SrlNokiaSystem_System_Logging_File {
	key := FileName

	if v, ok := t.File[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewFile(FileName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateFile got unexpected error: %v", err))
	}
	return v
}

// GetFile retrieves the value with the specified key from
// the File map field of SrlNokiaSystem_System_Logging. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaSystem_System_Logging) GetFile(FileName string) *SrlNokiaSystem_System_Logging_File {
	if t == nil {
		return nil
	}

	key := FileName

	if lm, ok := t.File[key]; ok {
		return lm
	}
	return nil
}

// DeleteFile deletes the value with the specified keys from
// the receiver SrlNokiaSystem_System_Logging. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaSystem_System_Logging) DeleteFile(FileName string) {
	key := FileName

	delete(t.File, key)
}

// AppendFile appends the supplied SrlNokiaSystem_System_Logging_File struct to the
// list File of SrlNokiaSystem_System_Logging. If the key value(s) specified in
// the supplied SrlNokiaSystem_System_Logging_File already exist in the list, an error is
// returned.
func (t *SrlNokiaSystem_System_Logging) AppendFile(v *SrlNokiaSystem_System_Logging_File) error {
	if v.FileName == nil {
		return fmt.Errorf("invalid nil key received for FileName")
	}

	key := *v.FileName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.File == nil {
		t.File = make(map[string]*SrlNokiaSystem_System_Logging_File)
	}

	if _, ok := t.File[key]; ok {
		return fmt.Errorf("duplicate key for list File %v", key)
	}

	t.File[key] = v
	return nil
}

// NewFilter creates a new entry in the Filter list of the
// SrlNokiaSystem_System_Logging struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_Logging) NewFilter(FilterName string) (*SrlNokiaSystem_System_Logging_Filter, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Filter == nil {
		t.Filter = make(map[string]*SrlNokiaSystem_System_Logging_Filter)
	}

	key := FilterName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Filter[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Filter", key)
	}

	t.Filter[key] = &SrlNokiaSystem_System_Logging_Filter{
		FilterName: &FilterName,
	}

	return t.Filter[key], nil
}

// RenameFilter renames an entry in the list Filter within
// the SrlNokiaSystem_System_Logging struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaSystem_System_Logging) RenameFilter(oldK, newK string) error {
	if _, ok := t.Filter[newK]; ok {
		return fmt.Errorf("key %v already exists in Filter", newK)
	}

	e, ok := t.Filter[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Filter", oldK)
	}
	e.FilterName = &newK

	t.Filter[newK] = e
	delete(t.Filter, oldK)
	return nil
}

// GetOrCreateFilter retrieves the value with the specified keys from
// the receiver SrlNokiaSystem_System_Logging. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaSystem_System_Logging) GetOrCreateFilter(FilterName string) *SrlNokiaSystem_System_Logging_Filter {
	key := FilterName

	if v, ok := t.Filter[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewFilter(FilterName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateFilter got unexpected error: %v", err))
	}
	return v
}

// GetFilter retrieves the value with the specified key from
// the Filter map field of SrlNokiaSystem_System_Logging. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaSystem_System_Logging) GetFilter(FilterName string) *SrlNokiaSystem_System_Logging_Filter {
	if t == nil {
		return nil
	}

	key := FilterName

	if lm, ok := t.Filter[key]; ok {
		return lm
	}
	return nil
}

// DeleteFilter deletes the value with the specified keys from
// the receiver SrlNokiaSystem_System_Logging. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaSystem_System_Logging) DeleteFilter(FilterName string) {
	key := FilterName

	delete(t.Filter, key)
}

// AppendFilter appends the supplied SrlNokiaSystem_System_Logging_Filter struct to the
// list Filter of SrlNokiaSystem_System_Logging. If the key value(s) specified in
// the supplied SrlNokiaSystem_System_Logging_Filter already exist in the list, an error is
// returned.
func (t *SrlNokiaSystem_System_Logging) AppendFilter(v *SrlNokiaSystem_System_Logging_Filter) error {
	if v.FilterName == nil {
		return fmt.Errorf("invalid nil key received for FilterName")
	}

	key := *v.FilterName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Filter == nil {
		t.Filter = make(map[string]*SrlNokiaSystem_System_Logging_Filter)
	}

	if _, ok := t.Filter[key]; ok {
		return fmt.Errorf("duplicate key for list Filter %v", key)
	}

	t.Filter[key] = v
	return nil
}

// NewRemoteServer creates a new entry in the RemoteServer list of the
// SrlNokiaSystem_System_Logging struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_Logging) NewRemoteServer(Host string) (*SrlNokiaSystem_System_Logging_RemoteServer, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.RemoteServer == nil {
		t.RemoteServer = make(map[string]*SrlNokiaSystem_System_Logging_RemoteServer)
	}

	key := Host

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.RemoteServer[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list RemoteServer", key)
	}

	t.RemoteServer[key] = &SrlNokiaSystem_System_Logging_RemoteServer{
		Host: &Host,
	}

	return t.RemoteServer[key], nil
}

// RenameRemoteServer renames an entry in the list RemoteServer within
// the SrlNokiaSystem_System_Logging struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaSystem_System_Logging) RenameRemoteServer(oldK, newK string) error {
	if _, ok := t.RemoteServer[newK]; ok {
		return fmt.Errorf("key %v already exists in RemoteServer", newK)
	}

	e, ok := t.RemoteServer[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in RemoteServer", oldK)
	}
	e.Host = &newK

	t.RemoteServer[newK] = e
	delete(t.RemoteServer, oldK)
	return nil
}

// GetOrCreateRemoteServer retrieves the value with the specified keys from
// the receiver SrlNokiaSystem_System_Logging. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaSystem_System_Logging) GetOrCreateRemoteServer(Host string) *SrlNokiaSystem_System_Logging_RemoteServer {
	key := Host

	if v, ok := t.RemoteServer[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewRemoteServer(Host)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateRemoteServer got unexpected error: %v", err))
	}
	return v
}

// GetRemoteServer retrieves the value with the specified key from
// the RemoteServer map field of SrlNokiaSystem_System_Logging. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaSystem_System_Logging) GetRemoteServer(Host string) *SrlNokiaSystem_System_Logging_RemoteServer {
	if t == nil {
		return nil
	}

	key := Host

	if lm, ok := t.RemoteServer[key]; ok {
		return lm
	}
	return nil
}

// DeleteRemoteServer deletes the value with the specified keys from
// the receiver SrlNokiaSystem_System_Logging. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaSystem_System_Logging) DeleteRemoteServer(Host string) {
	key := Host

	delete(t.RemoteServer, key)
}

// AppendRemoteServer appends the supplied SrlNokiaSystem_System_Logging_RemoteServer struct to the
// list RemoteServer of SrlNokiaSystem_System_Logging. If the key value(s) specified in
// the supplied SrlNokiaSystem_System_Logging_RemoteServer already exist in the list, an error is
// returned.
func (t *SrlNokiaSystem_System_Logging) AppendRemoteServer(v *SrlNokiaSystem_System_Logging_RemoteServer) error {
	if v.Host == nil {
		return fmt.Errorf("invalid nil key received for Host")
	}

	key := *v.Host

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.RemoteServer == nil {
		t.RemoteServer = make(map[string]*SrlNokiaSystem_System_Logging_RemoteServer)
	}

	if _, ok := t.RemoteServer[key]; ok {
		return fmt.Errorf("duplicate key for list RemoteServer %v", key)
	}

	t.RemoteServer[key] = v
	return nil
}

// GetOrCreateConsole retrieves the value of the Console field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_Logging) GetOrCreateConsole() *SrlNokiaSystem_System_Logging_Console {
	if t.Console != nil {
		return t.Console
	}
	t.Console = &SrlNokiaSystem_System_Logging_Console{}
	return t.Console
}

// GetConsole returns the value of the Console struct pointer
// from SrlNokiaSystem_System_Logging. If the receiver or the field Console is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_Logging) GetConsole() *SrlNokiaSystem_System_Logging_Console {
	if t != nil && t.Console != nil {
		return t.Console
	}
	return nil
}

// GetNetworkInstance retrieves the value of the leaf NetworkInstance from the SrlNokiaSystem_System_Logging
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NetworkInstance is set, it can
// safely use t.GetNetworkInstance() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NetworkInstance == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Logging) GetNetworkInstance() string {
	if t == nil || t.NetworkInstance == nil {
		return ""
	}
	return *t.NetworkInstance
}

// GetSubsystemFacility retrieves the value of the leaf SubsystemFacility from the SrlNokiaSystem_System_Logging
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SubsystemFacility is set, it can
// safely use t.GetSubsystemFacility() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SubsystemFacility == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Logging) GetSubsystemFacility() E_SrlNokiaLogging_FacilityNameTypeSubset {
	if t == nil || t.SubsystemFacility == 0 {
		return SrlNokiaLogging_FacilityNameTypeSubset_local6
	}
	return t.SubsystemFacility
}

// GetUseFqdn retrieves the value of the leaf UseFqdn from the SrlNokiaSystem_System_Logging
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if UseFqdn is set, it can
// safely use t.GetUseFqdn() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.UseFqdn == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Logging) GetUseFqdn() bool {
	if t == nil || t.UseFqdn == nil {
		return false
	}
	return *t.UseFqdn
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Logging
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Logging) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.SubsystemFacility == 0 {
		t.SubsystemFacility = SrlNokiaLogging_FacilityNameTypeSubset_local6
	}
	if t.UseFqdn == nil {
		var v bool = false
		t.UseFqdn = &v
	}
	t.Console.PopulateDefaults()
	for _, e := range t.Buffer {
		e.PopulateDefaults()
	}
	for _, e := range t.File {
		e.PopulateDefaults()
	}
	for _, e := range t.Filter {
		e.PopulateDefaults()
	}
	for _, e := range t.RemoteServer {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Logging"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Logging) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Logging.
func (*SrlNokiaSystem_System_Logging) ΛBelongingModule() string {
	return "srl_nokia-logging"
}

// SrlNokiaSystem_System_Logging_Buffer represents the /srl_nokia-system/system/logging/buffer YANG schema element.
type SrlNokiaSystem_System_Logging_Buffer struct {
	BufferName *string                                                                                 `path:"buffer-name" module:"srl_nokia-logging"`
	Facility   map[E_SrlNokiaLogging_FacilityNameType]*SrlNokiaSystem_System_Logging_Buffer_Facility   `path:"facility" module:"srl_nokia-logging"`
	Filter     []string                                                                                `path:"filter" module:"srl_nokia-logging"`
	Format     *string                                                                                 `path:"format" module:"srl_nokia-logging"`
	Persist    *uint32                                                                                 `path:"persist" module:"srl_nokia-logging"`
	Rotate     *uint16                                                                                 `path:"rotate" module:"srl_nokia-logging"`
	Size       *string                                                                                 `path:"size" module:"srl_nokia-logging"`
	Subsystem  map[E_SrlNokiaLogging_SubsystemNameType]*SrlNokiaSystem_System_Logging_Buffer_Subsystem `path:"subsystem" module:"srl_nokia-logging"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Logging_Buffer implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Logging_Buffer) IsYANGGoStruct() {}

// NewFacility creates a new entry in the Facility list of the
// SrlNokiaSystem_System_Logging_Buffer struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_Logging_Buffer) NewFacility(FacilityName E_SrlNokiaLogging_FacilityNameType) (*SrlNokiaSystem_System_Logging_Buffer_Facility, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Facility == nil {
		t.Facility = make(map[E_SrlNokiaLogging_FacilityNameType]*SrlNokiaSystem_System_Logging_Buffer_Facility)
	}

	key := FacilityName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Facility[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Facility", key)
	}

	t.Facility[key] = &SrlNokiaSystem_System_Logging_Buffer_Facility{
		FacilityName: FacilityName,
	}

	return t.Facility[key], nil
}

// RenameFacility renames an entry in the list Facility within
// the SrlNokiaSystem_System_Logging_Buffer struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaSystem_System_Logging_Buffer) RenameFacility(oldK, newK E_SrlNokiaLogging_FacilityNameType) error {
	if _, ok := t.Facility[newK]; ok {
		return fmt.Errorf("key %v already exists in Facility", newK)
	}

	e, ok := t.Facility[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Facility", oldK)
	}
	e.FacilityName = newK

	t.Facility[newK] = e
	delete(t.Facility, oldK)
	return nil
}

// GetOrCreateFacility retrieves the value with the specified keys from
// the receiver SrlNokiaSystem_System_Logging_Buffer. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaSystem_System_Logging_Buffer) GetOrCreateFacility(
	FacilityName E_SrlNokiaLogging_FacilityNameType,
) *SrlNokiaSystem_System_Logging_Buffer_Facility {
	key := FacilityName

	if v, ok := t.Facility[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewFacility(FacilityName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateFacility got unexpected error: %v", err))
	}
	return v
}

// GetFacility retrieves the value with the specified key from
// the Facility map field of SrlNokiaSystem_System_Logging_Buffer. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaSystem_System_Logging_Buffer) GetFacility(FacilityName E_SrlNokiaLogging_FacilityNameType) *SrlNokiaSystem_System_Logging_Buffer_Facility {
	if t == nil {
		return nil
	}

	key := FacilityName

	if lm, ok := t.Facility[key]; ok {
		return lm
	}
	return nil
}

// DeleteFacility deletes the value with the specified keys from
// the receiver SrlNokiaSystem_System_Logging_Buffer. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaSystem_System_Logging_Buffer) DeleteFacility(FacilityName E_SrlNokiaLogging_FacilityNameType) {
	key := FacilityName

	delete(t.Facility, key)
}

// AppendFacility appends the supplied SrlNokiaSystem_System_Logging_Buffer_Facility struct to the
// list Facility of SrlNokiaSystem_System_Logging_Buffer. If the key value(s) specified in
// the supplied SrlNokiaSystem_System_Logging_Buffer_Facility already exist in the list, an error is
// returned.
func (t *SrlNokiaSystem_System_Logging_Buffer) AppendFacility(v *SrlNokiaSystem_System_Logging_Buffer_Facility) error {
	key := v.FacilityName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Facility == nil {
		t.Facility = make(map[E_SrlNokiaLogging_FacilityNameType]*SrlNokiaSystem_System_Logging_Buffer_Facility)
	}

	if _, ok := t.Facility[key]; ok {
		return fmt.Errorf("duplicate key for list Facility %v", key)
	}

	t.Facility[key] = v
	return nil
}

// NewSubsystem creates a new entry in the Subsystem list of the
// SrlNokiaSystem_System_Logging_Buffer struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_Logging_Buffer) NewSubsystem(
	SubsystemName E_SrlNokiaLogging_SubsystemNameType,
) (*SrlNokiaSystem_System_Logging_Buffer_Subsystem, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Subsystem == nil {
		t.Subsystem = make(map[E_SrlNokiaLogging_SubsystemNameType]*SrlNokiaSystem_System_Logging_Buffer_Subsystem)
	}

	key := SubsystemName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Subsystem[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Subsystem", key)
	}

	t.Subsystem[key] = &SrlNokiaSystem_System_Logging_Buffer_Subsystem{
		SubsystemName: SubsystemName,
	}

	return t.Subsystem[key], nil
}

// RenameSubsystem renames an entry in the list Subsystem within
// the SrlNokiaSystem_System_Logging_Buffer struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaSystem_System_Logging_Buffer) RenameSubsystem(oldK, newK E_SrlNokiaLogging_SubsystemNameType) error {
	if _, ok := t.Subsystem[newK]; ok {
		return fmt.Errorf("key %v already exists in Subsystem", newK)
	}

	e, ok := t.Subsystem[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Subsystem", oldK)
	}
	e.SubsystemName = newK

	t.Subsystem[newK] = e
	delete(t.Subsystem, oldK)
	return nil
}

// GetOrCreateSubsystem retrieves the value with the specified keys from
// the receiver SrlNokiaSystem_System_Logging_Buffer. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaSystem_System_Logging_Buffer) GetOrCreateSubsystem(
	SubsystemName E_SrlNokiaLogging_SubsystemNameType,
) *SrlNokiaSystem_System_Logging_Buffer_Subsystem {
	key := SubsystemName

	if v, ok := t.Subsystem[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewSubsystem(SubsystemName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateSubsystem got unexpected error: %v", err))
	}
	return v
}

// GetSubsystem retrieves the value with the specified key from
// the Subsystem map field of SrlNokiaSystem_System_Logging_Buffer. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaSystem_System_Logging_Buffer) GetSubsystem(
	SubsystemName E_SrlNokiaLogging_SubsystemNameType,
) *SrlNokiaSystem_System_Logging_Buffer_Subsystem {
	if t == nil {
		return nil
	}

	key := SubsystemName

	if lm, ok := t.Subsystem[key]; ok {
		return lm
	}
	return nil
}

// DeleteSubsystem deletes the value with the specified keys from
// the receiver SrlNokiaSystem_System_Logging_Buffer. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaSystem_System_Logging_Buffer) DeleteSubsystem(SubsystemName E_SrlNokiaLogging_SubsystemNameType) {
	key := SubsystemName

	delete(t.Subsystem, key)
}

// AppendSubsystem appends the supplied SrlNokiaSystem_System_Logging_Buffer_Subsystem struct to the
// list Subsystem of SrlNokiaSystem_System_Logging_Buffer. If the key value(s) specified in
// the supplied SrlNokiaSystem_System_Logging_Buffer_Subsystem already exist in the list, an error is
// returned.
func (t *SrlNokiaSystem_System_Logging_Buffer) AppendSubsystem(v *SrlNokiaSystem_System_Logging_Buffer_Subsystem) error {
	key := v.SubsystemName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Subsystem == nil {
		t.Subsystem = make(map[E_SrlNokiaLogging_SubsystemNameType]*SrlNokiaSystem_System_Logging_Buffer_Subsystem)
	}

	if _, ok := t.Subsystem[key]; ok {
		return fmt.Errorf("duplicate key for list Subsystem %v", key)
	}

	t.Subsystem[key] = v
	return nil
}

// GetBufferName retrieves the value of the leaf BufferName from the SrlNokiaSystem_System_Logging_Buffer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if BufferName is set, it can
// safely use t.GetBufferName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.BufferName == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Logging_Buffer) GetBufferName() string {
	if t == nil || t.BufferName == nil {
		return ""
	}
	return *t.BufferName
}

// GetFilter retrieves the value of the leaf Filter from the SrlNokiaSystem_System_Logging_Buffer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Filter is set, it can
// safely use t.GetFilter() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Filter == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Logging_Buffer) GetFilter() []string {
	if t == nil || t.Filter == nil {
		return nil
	}
	return t.Filter
}

// GetFormat retrieves the value of the leaf Format from the SrlNokiaSystem_System_Logging_Buffer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Format is set, it can
// safely use t.GetFormat() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Format == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Logging_Buffer) GetFormat() string {
	if t == nil || t.Format == nil {
		return "%TIMEGENERATED:::date-rfc3339% %HOSTNAME% %SYSLOGTAG%%MSG:::sp-if-no-1st-sp%%MSG:::drop-last-lf%\\n"
	}
	return *t.Format
}

// GetPersist retrieves the value of the leaf Persist from the SrlNokiaSystem_System_Logging_Buffer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Persist is set, it can
// safely use t.GetPersist() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Persist == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Logging_Buffer) GetPersist() uint32 {
	if t == nil || t.Persist == nil {
		return 0
	}
	return *t.Persist
}

// GetRotate retrieves the value of the leaf Rotate from the SrlNokiaSystem_System_Logging_Buffer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Rotate is set, it can
// safely use t.GetRotate() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Rotate == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Logging_Buffer) GetRotate() uint16 {
	if t == nil || t.Rotate == nil {
		return 4
	}
	return *t.Rotate
}

// GetSize retrieves the value of the leaf Size from the SrlNokiaSystem_System_Logging_Buffer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Size is set, it can
// safely use t.GetSize() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Size == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Logging_Buffer) GetSize() string {
	if t == nil || t.Size == nil {
		return "10M"
	}
	return *t.Size
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Logging_Buffer
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Logging_Buffer) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Format == nil {
		var v string = "%TIMEGENERATED:::date-rfc3339% %HOSTNAME% %SYSLOGTAG%%MSG:::sp-if-no-1st-sp%%MSG:::drop-last-lf%\\n"
		t.Format = &v
	}
	if t.Persist == nil {
		var v uint32 = 0
		t.Persist = &v
	}
	if t.Rotate == nil {
		var v uint16 = 4
		t.Rotate = &v
	}
	if t.Size == nil {
		var v string = "10M"
		t.Size = &v
	}
	for _, e := range t.Facility {
		e.PopulateDefaults()
	}
	for _, e := range t.Subsystem {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_Logging_Buffer struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_Logging_Buffer) ΛListKeyMap() (map[string]interface{}, error) {
	if t.BufferName == nil {
		return nil, fmt.Errorf("nil value for key BufferName")
	}

	return map[string]interface{}{
		"buffer-name": *t.BufferName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_Buffer) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Logging_Buffer"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_Buffer) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Logging_Buffer) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Logging_Buffer.
func (*SrlNokiaSystem_System_Logging_Buffer) ΛBelongingModule() string {
	return "srl_nokia-logging"
}

// SrlNokiaSystem_System_Logging_Buffer_Facility represents the /srl_nokia-system/system/logging/buffer/facility YANG schema element.
type SrlNokiaSystem_System_Logging_Buffer_Facility struct {
	FacilityName E_SrlNokiaLogging_FacilityNameType                      `path:"facility-name" module:"srl_nokia-logging"`
	Priority     *SrlNokiaSystem_System_Logging_Buffer_Facility_Priority `path:"priority" module:"srl_nokia-logging"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Logging_Buffer_Facility implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Logging_Buffer_Facility) IsYANGGoStruct() {}

// GetOrCreatePriority retrieves the value of the Priority field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_Logging_Buffer_Facility) GetOrCreatePriority() *SrlNokiaSystem_System_Logging_Buffer_Facility_Priority {
	if t.Priority != nil {
		return t.Priority
	}
	t.Priority = &SrlNokiaSystem_System_Logging_Buffer_Facility_Priority{}
	return t.Priority
}

// GetPriority returns the value of the Priority struct pointer
// from SrlNokiaSystem_System_Logging_Buffer_Facility. If the receiver or the field Priority is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_Logging_Buffer_Facility) GetPriority() *SrlNokiaSystem_System_Logging_Buffer_Facility_Priority {
	if t != nil && t.Priority != nil {
		return t.Priority
	}
	return nil
}

// GetFacilityName retrieves the value of the leaf FacilityName from the SrlNokiaSystem_System_Logging_Buffer_Facility
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FacilityName is set, it can
// safely use t.GetFacilityName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FacilityName == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Logging_Buffer_Facility) GetFacilityName() E_SrlNokiaLogging_FacilityNameType {
	if t == nil || t.FacilityName == 0 {
		return 0
	}
	return t.FacilityName
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Logging_Buffer_Facility
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Logging_Buffer_Facility) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Priority.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_Logging_Buffer_Facility struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_Logging_Buffer_Facility) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"facility-name": t.FacilityName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_Buffer_Facility) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Logging_Buffer_Facility"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_Buffer_Facility) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Logging_Buffer_Facility) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Logging_Buffer_Facility.
func (*SrlNokiaSystem_System_Logging_Buffer_Facility) ΛBelongingModule() string {
	return "srl_nokia-logging"
}

// SrlNokiaSystem_System_Logging_Buffer_Facility_Priority represents the /srl_nokia-system/system/logging/buffer/facility/priority YANG schema element.
type SrlNokiaSystem_System_Logging_Buffer_Facility_Priority struct {
	MatchAbove E_SrlNokiaLogging_PriorityType   `path:"match-above" module:"srl_nokia-logging"`
	MatchExact []E_SrlNokiaLogging_PriorityType `path:"match-exact" module:"srl_nokia-logging"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Logging_Buffer_Facility_Priority implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Logging_Buffer_Facility_Priority) IsYANGGoStruct() {}

// GetMatchAbove retrieves the value of the leaf MatchAbove from the SrlNokiaSystem_System_Logging_Buffer_Facility_Priority
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MatchAbove is set, it can
// safely use t.GetMatchAbove() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MatchAbove == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Logging_Buffer_Facility_Priority) GetMatchAbove() E_SrlNokiaLogging_PriorityType {
	if t == nil || t.MatchAbove == 0 {
		return 0
	}
	return t.MatchAbove
}

// GetMatchExact retrieves the value of the leaf MatchExact from the SrlNokiaSystem_System_Logging_Buffer_Facility_Priority
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MatchExact is set, it can
// safely use t.GetMatchExact() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MatchExact == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Logging_Buffer_Facility_Priority) GetMatchExact() []E_SrlNokiaLogging_PriorityType {
	if t == nil || t.MatchExact == nil {
		return nil
	}
	return t.MatchExact
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Logging_Buffer_Facility_Priority
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Logging_Buffer_Facility_Priority) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_Buffer_Facility_Priority) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Logging_Buffer_Facility_Priority"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_Buffer_Facility_Priority) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Logging_Buffer_Facility_Priority) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Logging_Buffer_Facility_Priority.
func (*SrlNokiaSystem_System_Logging_Buffer_Facility_Priority) ΛBelongingModule() string {
	return "srl_nokia-logging"
}

// SrlNokiaSystem_System_Logging_Buffer_Subsystem represents the /srl_nokia-system/system/logging/buffer/subsystem YANG schema element.
type SrlNokiaSystem_System_Logging_Buffer_Subsystem struct {
	Priority      *SrlNokiaSystem_System_Logging_Buffer_Subsystem_Priority `path:"priority" module:"srl_nokia-logging"`
	SubsystemName E_SrlNokiaLogging_SubsystemNameType                      `path:"subsystem-name" module:"srl_nokia-logging"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Logging_Buffer_Subsystem implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Logging_Buffer_Subsystem) IsYANGGoStruct() {}

// GetOrCreatePriority retrieves the value of the Priority field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_Logging_Buffer_Subsystem) GetOrCreatePriority() *SrlNokiaSystem_System_Logging_Buffer_Subsystem_Priority {
	if t.Priority != nil {
		return t.Priority
	}
	t.Priority = &SrlNokiaSystem_System_Logging_Buffer_Subsystem_Priority{}
	return t.Priority
}

// GetPriority returns the value of the Priority struct pointer
// from SrlNokiaSystem_System_Logging_Buffer_Subsystem. If the receiver or the field Priority is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_Logging_Buffer_Subsystem) GetPriority() *SrlNokiaSystem_System_Logging_Buffer_Subsystem_Priority {
	if t != nil && t.Priority != nil {
		return t.Priority
	}
	return nil
}

// GetSubsystemName retrieves the value of the leaf SubsystemName from the SrlNokiaSystem_System_Logging_Buffer_Subsystem
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SubsystemName is set, it can
// safely use t.GetSubsystemName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SubsystemName == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Logging_Buffer_Subsystem) GetSubsystemName() E_SrlNokiaLogging_SubsystemNameType {
	if t == nil || t.SubsystemName == 0 {
		return 0
	}
	return t.SubsystemName
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Logging_Buffer_Subsystem
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Logging_Buffer_Subsystem) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Priority.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_Logging_Buffer_Subsystem struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_Logging_Buffer_Subsystem) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"subsystem-name": t.SubsystemName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_Buffer_Subsystem) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Logging_Buffer_Subsystem"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_Buffer_Subsystem) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Logging_Buffer_Subsystem) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Logging_Buffer_Subsystem.
func (*SrlNokiaSystem_System_Logging_Buffer_Subsystem) ΛBelongingModule() string {
	return "srl_nokia-logging"
}

// SrlNokiaSystem_System_Logging_Buffer_Subsystem_Priority represents the /srl_nokia-system/system/logging/buffer/subsystem/priority YANG schema element.
type SrlNokiaSystem_System_Logging_Buffer_Subsystem_Priority struct {
	MatchAbove E_SrlNokiaLogging_PriorityType   `path:"match-above" module:"srl_nokia-logging"`
	MatchExact []E_SrlNokiaLogging_PriorityType `path:"match-exact" module:"srl_nokia-logging"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Logging_Buffer_Subsystem_Priority implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Logging_Buffer_Subsystem_Priority) IsYANGGoStruct() {}

// GetMatchAbove retrieves the value of the leaf MatchAbove from the SrlNokiaSystem_System_Logging_Buffer_Subsystem_Priority
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MatchAbove is set, it can
// safely use t.GetMatchAbove() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MatchAbove == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Logging_Buffer_Subsystem_Priority) GetMatchAbove() E_SrlNokiaLogging_PriorityType {
	if t == nil || t.MatchAbove == 0 {
		return 0
	}
	return t.MatchAbove
}

// GetMatchExact retrieves the value of the leaf MatchExact from the SrlNokiaSystem_System_Logging_Buffer_Subsystem_Priority
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MatchExact is set, it can
// safely use t.GetMatchExact() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MatchExact == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Logging_Buffer_Subsystem_Priority) GetMatchExact() []E_SrlNokiaLogging_PriorityType {
	if t == nil || t.MatchExact == nil {
		return nil
	}
	return t.MatchExact
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Logging_Buffer_Subsystem_Priority
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Logging_Buffer_Subsystem_Priority) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_Buffer_Subsystem_Priority) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Logging_Buffer_Subsystem_Priority"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_Buffer_Subsystem_Priority) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Logging_Buffer_Subsystem_Priority) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Logging_Buffer_Subsystem_Priority.
func (*SrlNokiaSystem_System_Logging_Buffer_Subsystem_Priority) ΛBelongingModule() string {
	return "srl_nokia-logging"
}

// SrlNokiaSystem_System_Logging_Console represents the /srl_nokia-system/system/logging/console YANG schema element.
type SrlNokiaSystem_System_Logging_Console struct {
	Facility  map[E_SrlNokiaLogging_FacilityNameType]*SrlNokiaSystem_System_Logging_Console_Facility   `path:"facility" module:"srl_nokia-logging"`
	Filter    []string                                                                                 `path:"filter" module:"srl_nokia-logging"`
	Format    *string                                                                                  `path:"format" module:"srl_nokia-logging"`
	Subsystem map[E_SrlNokiaLogging_SubsystemNameType]*SrlNokiaSystem_System_Logging_Console_Subsystem `path:"subsystem" module:"srl_nokia-logging"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Logging_Console implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Logging_Console) IsYANGGoStruct() {}

// NewFacility creates a new entry in the Facility list of the
// SrlNokiaSystem_System_Logging_Console struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_Logging_Console) NewFacility(
	FacilityName E_SrlNokiaLogging_FacilityNameType,
) (*SrlNokiaSystem_System_Logging_Console_Facility, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Facility == nil {
		t.Facility = make(map[E_SrlNokiaLogging_FacilityNameType]*SrlNokiaSystem_System_Logging_Console_Facility)
	}

	key := FacilityName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Facility[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Facility", key)
	}

	t.Facility[key] = &SrlNokiaSystem_System_Logging_Console_Facility{
		FacilityName: FacilityName,
	}

	return t.Facility[key], nil
}

// RenameFacility renames an entry in the list Facility within
// the SrlNokiaSystem_System_Logging_Console struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaSystem_System_Logging_Console) RenameFacility(oldK, newK E_SrlNokiaLogging_FacilityNameType) error {
	if _, ok := t.Facility[newK]; ok {
		return fmt.Errorf("key %v already exists in Facility", newK)
	}

	e, ok := t.Facility[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Facility", oldK)
	}
	e.FacilityName = newK

	t.Facility[newK] = e
	delete(t.Facility, oldK)
	return nil
}

// GetOrCreateFacility retrieves the value with the specified keys from
// the receiver SrlNokiaSystem_System_Logging_Console. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaSystem_System_Logging_Console) GetOrCreateFacility(
	FacilityName E_SrlNokiaLogging_FacilityNameType,
) *SrlNokiaSystem_System_Logging_Console_Facility {
	key := FacilityName

	if v, ok := t.Facility[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewFacility(FacilityName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateFacility got unexpected error: %v", err))
	}
	return v
}

// GetFacility retrieves the value with the specified key from
// the Facility map field of SrlNokiaSystem_System_Logging_Console. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaSystem_System_Logging_Console) GetFacility(
	FacilityName E_SrlNokiaLogging_FacilityNameType,
) *SrlNokiaSystem_System_Logging_Console_Facility {
	if t == nil {
		return nil
	}

	key := FacilityName

	if lm, ok := t.Facility[key]; ok {
		return lm
	}
	return nil
}

// DeleteFacility deletes the value with the specified keys from
// the receiver SrlNokiaSystem_System_Logging_Console. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaSystem_System_Logging_Console) DeleteFacility(FacilityName E_SrlNokiaLogging_FacilityNameType) {
	key := FacilityName

	delete(t.Facility, key)
}

// AppendFacility appends the supplied SrlNokiaSystem_System_Logging_Console_Facility struct to the
// list Facility of SrlNokiaSystem_System_Logging_Console. If the key value(s) specified in
// the supplied SrlNokiaSystem_System_Logging_Console_Facility already exist in the list, an error is
// returned.
func (t *SrlNokiaSystem_System_Logging_Console) AppendFacility(v *SrlNokiaSystem_System_Logging_Console_Facility) error {
	key := v.FacilityName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Facility == nil {
		t.Facility = make(map[E_SrlNokiaLogging_FacilityNameType]*SrlNokiaSystem_System_Logging_Console_Facility)
	}

	if _, ok := t.Facility[key]; ok {
		return fmt.Errorf("duplicate key for list Facility %v", key)
	}

	t.Facility[key] = v
	return nil
}

// NewSubsystem creates a new entry in the Subsystem list of the
// SrlNokiaSystem_System_Logging_Console struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_Logging_Console) NewSubsystem(
	SubsystemName E_SrlNokiaLogging_SubsystemNameType,
) (*SrlNokiaSystem_System_Logging_Console_Subsystem, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Subsystem == nil {
		t.Subsystem = make(map[E_SrlNokiaLogging_SubsystemNameType]*SrlNokiaSystem_System_Logging_Console_Subsystem)
	}

	key := SubsystemName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Subsystem[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Subsystem", key)
	}

	t.Subsystem[key] = &SrlNokiaSystem_System_Logging_Console_Subsystem{
		SubsystemName: SubsystemName,
	}

	return t.Subsystem[key], nil
}

// RenameSubsystem renames an entry in the list Subsystem within
// the SrlNokiaSystem_System_Logging_Console struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaSystem_System_Logging_Console) RenameSubsystem(oldK, newK E_SrlNokiaLogging_SubsystemNameType) error {
	if _, ok := t.Subsystem[newK]; ok {
		return fmt.Errorf("key %v already exists in Subsystem", newK)
	}

	e, ok := t.Subsystem[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Subsystem", oldK)
	}
	e.SubsystemName = newK

	t.Subsystem[newK] = e
	delete(t.Subsystem, oldK)
	return nil
}

// GetOrCreateSubsystem retrieves the value with the specified keys from
// the receiver SrlNokiaSystem_System_Logging_Console. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaSystem_System_Logging_Console) GetOrCreateSubsystem(
	SubsystemName E_SrlNokiaLogging_SubsystemNameType,
) *SrlNokiaSystem_System_Logging_Console_Subsystem {
	key := SubsystemName

	if v, ok := t.Subsystem[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewSubsystem(SubsystemName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateSubsystem got unexpected error: %v", err))
	}
	return v
}

// GetSubsystem retrieves the value with the specified key from
// the Subsystem map field of SrlNokiaSystem_System_Logging_Console. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaSystem_System_Logging_Console) GetSubsystem(
	SubsystemName E_SrlNokiaLogging_SubsystemNameType,
) *SrlNokiaSystem_System_Logging_Console_Subsystem {
	if t == nil {
		return nil
	}

	key := SubsystemName

	if lm, ok := t.Subsystem[key]; ok {
		return lm
	}
	return nil
}

// DeleteSubsystem deletes the value with the specified keys from
// the receiver SrlNokiaSystem_System_Logging_Console. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaSystem_System_Logging_Console) DeleteSubsystem(SubsystemName E_SrlNokiaLogging_SubsystemNameType) {
	key := SubsystemName

	delete(t.Subsystem, key)
}

// AppendSubsystem appends the supplied SrlNokiaSystem_System_Logging_Console_Subsystem struct to the
// list Subsystem of SrlNokiaSystem_System_Logging_Console. If the key value(s) specified in
// the supplied SrlNokiaSystem_System_Logging_Console_Subsystem already exist in the list, an error is
// returned.
func (t *SrlNokiaSystem_System_Logging_Console) AppendSubsystem(v *SrlNokiaSystem_System_Logging_Console_Subsystem) error {
	key := v.SubsystemName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Subsystem == nil {
		t.Subsystem = make(map[E_SrlNokiaLogging_SubsystemNameType]*SrlNokiaSystem_System_Logging_Console_Subsystem)
	}

	if _, ok := t.Subsystem[key]; ok {
		return fmt.Errorf("duplicate key for list Subsystem %v", key)
	}

	t.Subsystem[key] = v
	return nil
}

// GetFilter retrieves the value of the leaf Filter from the SrlNokiaSystem_System_Logging_Console
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Filter is set, it can
// safely use t.GetFilter() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Filter == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Logging_Console) GetFilter() []string {
	if t == nil || t.Filter == nil {
		return nil
	}
	return t.Filter
}

// GetFormat retrieves the value of the leaf Format from the SrlNokiaSystem_System_Logging_Console
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Format is set, it can
// safely use t.GetFormat() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Format == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Logging_Console) GetFormat() string {
	if t == nil || t.Format == nil {
		return "%TIMEGENERATED:::date-rfc3339% %HOSTNAME% %SYSLOGTAG%%MSG:::sp-if-no-1st-sp%%MSG:::drop-last-lf%\\n"
	}
	return *t.Format
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Logging_Console
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Logging_Console) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Format == nil {
		var v string = "%TIMEGENERATED:::date-rfc3339% %HOSTNAME% %SYSLOGTAG%%MSG:::sp-if-no-1st-sp%%MSG:::drop-last-lf%\\n"
		t.Format = &v
	}
	for _, e := range t.Facility {
		e.PopulateDefaults()
	}
	for _, e := range t.Subsystem {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_Console) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Logging_Console"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_Console) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Logging_Console) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Logging_Console.
func (*SrlNokiaSystem_System_Logging_Console) ΛBelongingModule() string {
	return "srl_nokia-logging"
}

// SrlNokiaSystem_System_Logging_Console_Facility represents the /srl_nokia-system/system/logging/console/facility YANG schema element.
type SrlNokiaSystem_System_Logging_Console_Facility struct {
	FacilityName E_SrlNokiaLogging_FacilityNameType                       `path:"facility-name" module:"srl_nokia-logging"`
	Priority     *SrlNokiaSystem_System_Logging_Console_Facility_Priority `path:"priority" module:"srl_nokia-logging"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Logging_Console_Facility implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Logging_Console_Facility) IsYANGGoStruct() {}

// GetOrCreatePriority retrieves the value of the Priority field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_Logging_Console_Facility) GetOrCreatePriority() *SrlNokiaSystem_System_Logging_Console_Facility_Priority {
	if t.Priority != nil {
		return t.Priority
	}
	t.Priority = &SrlNokiaSystem_System_Logging_Console_Facility_Priority{}
	return t.Priority
}

// GetPriority returns the value of the Priority struct pointer
// from SrlNokiaSystem_System_Logging_Console_Facility. If the receiver or the field Priority is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_Logging_Console_Facility) GetPriority() *SrlNokiaSystem_System_Logging_Console_Facility_Priority {
	if t != nil && t.Priority != nil {
		return t.Priority
	}
	return nil
}

// GetFacilityName retrieves the value of the leaf FacilityName from the SrlNokiaSystem_System_Logging_Console_Facility
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FacilityName is set, it can
// safely use t.GetFacilityName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FacilityName == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Logging_Console_Facility) GetFacilityName() E_SrlNokiaLogging_FacilityNameType {
	if t == nil || t.FacilityName == 0 {
		return 0
	}
	return t.FacilityName
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Logging_Console_Facility
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Logging_Console_Facility) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Priority.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_Logging_Console_Facility struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_Logging_Console_Facility) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"facility-name": t.FacilityName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_Console_Facility) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Logging_Console_Facility"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_Console_Facility) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Logging_Console_Facility) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Logging_Console_Facility.
func (*SrlNokiaSystem_System_Logging_Console_Facility) ΛBelongingModule() string {
	return "srl_nokia-logging"
}

// SrlNokiaSystem_System_Logging_Console_Facility_Priority represents the /srl_nokia-system/system/logging/console/facility/priority YANG schema element.
type SrlNokiaSystem_System_Logging_Console_Facility_Priority struct {
	MatchAbove E_SrlNokiaLogging_PriorityType   `path:"match-above" module:"srl_nokia-logging"`
	MatchExact []E_SrlNokiaLogging_PriorityType `path:"match-exact" module:"srl_nokia-logging"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Logging_Console_Facility_Priority implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Logging_Console_Facility_Priority) IsYANGGoStruct() {}

// GetMatchAbove retrieves the value of the leaf MatchAbove from the SrlNokiaSystem_System_Logging_Console_Facility_Priority
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MatchAbove is set, it can
// safely use t.GetMatchAbove() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MatchAbove == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Logging_Console_Facility_Priority) GetMatchAbove() E_SrlNokiaLogging_PriorityType {
	if t == nil || t.MatchAbove == 0 {
		return 0
	}
	return t.MatchAbove
}

// GetMatchExact retrieves the value of the leaf MatchExact from the SrlNokiaSystem_System_Logging_Console_Facility_Priority
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MatchExact is set, it can
// safely use t.GetMatchExact() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MatchExact == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Logging_Console_Facility_Priority) GetMatchExact() []E_SrlNokiaLogging_PriorityType {
	if t == nil || t.MatchExact == nil {
		return nil
	}
	return t.MatchExact
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Logging_Console_Facility_Priority
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Logging_Console_Facility_Priority) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_Console_Facility_Priority) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Logging_Console_Facility_Priority"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_Console_Facility_Priority) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Logging_Console_Facility_Priority) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Logging_Console_Facility_Priority.
func (*SrlNokiaSystem_System_Logging_Console_Facility_Priority) ΛBelongingModule() string {
	return "srl_nokia-logging"
}

// SrlNokiaSystem_System_Logging_Console_Subsystem represents the /srl_nokia-system/system/logging/console/subsystem YANG schema element.
type SrlNokiaSystem_System_Logging_Console_Subsystem struct {
	Priority      *SrlNokiaSystem_System_Logging_Console_Subsystem_Priority `path:"priority" module:"srl_nokia-logging"`
	SubsystemName E_SrlNokiaLogging_SubsystemNameType                       `path:"subsystem-name" module:"srl_nokia-logging"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Logging_Console_Subsystem implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Logging_Console_Subsystem) IsYANGGoStruct() {}

// GetOrCreatePriority retrieves the value of the Priority field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_Logging_Console_Subsystem) GetOrCreatePriority() *SrlNokiaSystem_System_Logging_Console_Subsystem_Priority {
	if t.Priority != nil {
		return t.Priority
	}
	t.Priority = &SrlNokiaSystem_System_Logging_Console_Subsystem_Priority{}
	return t.Priority
}

// GetPriority returns the value of the Priority struct pointer
// from SrlNokiaSystem_System_Logging_Console_Subsystem. If the receiver or the field Priority is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_Logging_Console_Subsystem) GetPriority() *SrlNokiaSystem_System_Logging_Console_Subsystem_Priority {
	if t != nil && t.Priority != nil {
		return t.Priority
	}
	return nil
}

// GetSubsystemName retrieves the value of the leaf SubsystemName from the SrlNokiaSystem_System_Logging_Console_Subsystem
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SubsystemName is set, it can
// safely use t.GetSubsystemName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SubsystemName == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Logging_Console_Subsystem) GetSubsystemName() E_SrlNokiaLogging_SubsystemNameType {
	if t == nil || t.SubsystemName == 0 {
		return 0
	}
	return t.SubsystemName
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Logging_Console_Subsystem
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Logging_Console_Subsystem) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Priority.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_Logging_Console_Subsystem struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_Logging_Console_Subsystem) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"subsystem-name": t.SubsystemName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_Console_Subsystem) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Logging_Console_Subsystem"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_Console_Subsystem) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Logging_Console_Subsystem) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Logging_Console_Subsystem.
func (*SrlNokiaSystem_System_Logging_Console_Subsystem) ΛBelongingModule() string {
	return "srl_nokia-logging"
}

// SrlNokiaSystem_System_Logging_Console_Subsystem_Priority represents the /srl_nokia-system/system/logging/console/subsystem/priority YANG schema element.
type SrlNokiaSystem_System_Logging_Console_Subsystem_Priority struct {
	MatchAbove E_SrlNokiaLogging_PriorityType   `path:"match-above" module:"srl_nokia-logging"`
	MatchExact []E_SrlNokiaLogging_PriorityType `path:"match-exact" module:"srl_nokia-logging"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Logging_Console_Subsystem_Priority implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Logging_Console_Subsystem_Priority) IsYANGGoStruct() {}

// GetMatchAbove retrieves the value of the leaf MatchAbove from the SrlNokiaSystem_System_Logging_Console_Subsystem_Priority
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MatchAbove is set, it can
// safely use t.GetMatchAbove() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MatchAbove == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Logging_Console_Subsystem_Priority) GetMatchAbove() E_SrlNokiaLogging_PriorityType {
	if t == nil || t.MatchAbove == 0 {
		return 0
	}
	return t.MatchAbove
}

// GetMatchExact retrieves the value of the leaf MatchExact from the SrlNokiaSystem_System_Logging_Console_Subsystem_Priority
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MatchExact is set, it can
// safely use t.GetMatchExact() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MatchExact == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Logging_Console_Subsystem_Priority) GetMatchExact() []E_SrlNokiaLogging_PriorityType {
	if t == nil || t.MatchExact == nil {
		return nil
	}
	return t.MatchExact
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Logging_Console_Subsystem_Priority
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Logging_Console_Subsystem_Priority) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_Console_Subsystem_Priority) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Logging_Console_Subsystem_Priority"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_Console_Subsystem_Priority) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Logging_Console_Subsystem_Priority) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Logging_Console_Subsystem_Priority.
func (*SrlNokiaSystem_System_Logging_Console_Subsystem_Priority) ΛBelongingModule() string {
	return "srl_nokia-logging"
}

// SrlNokiaSystem_System_Logging_File represents the /srl_nokia-system/system/logging/file YANG schema element.
type SrlNokiaSystem_System_Logging_File struct {
	Directory *string                                                                               `path:"directory" module:"srl_nokia-logging"`
	Facility  map[E_SrlNokiaLogging_FacilityNameType]*SrlNokiaSystem_System_Logging_File_Facility   `path:"facility" module:"srl_nokia-logging"`
	FileName  *string                                                                               `path:"file-name" module:"srl_nokia-logging"`
	Filter    []string                                                                              `path:"filter" module:"srl_nokia-logging"`
	Format    *string                                                                               `path:"format" module:"srl_nokia-logging"`
	Rotate    *uint16                                                                               `path:"rotate" module:"srl_nokia-logging"`
	Size      *string                                                                               `path:"size" module:"srl_nokia-logging"`
	Subsystem map[E_SrlNokiaLogging_SubsystemNameType]*SrlNokiaSystem_System_Logging_File_Subsystem `path:"subsystem" module:"srl_nokia-logging"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Logging_File implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Logging_File) IsYANGGoStruct() {}

// NewFacility creates a new entry in the Facility list of the
// SrlNokiaSystem_System_Logging_File struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_Logging_File) NewFacility(FacilityName E_SrlNokiaLogging_FacilityNameType) (*SrlNokiaSystem_System_Logging_File_Facility, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Facility == nil {
		t.Facility = make(map[E_SrlNokiaLogging_FacilityNameType]*SrlNokiaSystem_System_Logging_File_Facility)
	}

	key := FacilityName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Facility[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Facility", key)
	}

	t.Facility[key] = &SrlNokiaSystem_System_Logging_File_Facility{
		FacilityName: FacilityName,
	}

	return t.Facility[key], nil
}

// RenameFacility renames an entry in the list Facility within
// the SrlNokiaSystem_System_Logging_File struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaSystem_System_Logging_File) RenameFacility(oldK, newK E_SrlNokiaLogging_FacilityNameType) error {
	if _, ok := t.Facility[newK]; ok {
		return fmt.Errorf("key %v already exists in Facility", newK)
	}

	e, ok := t.Facility[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Facility", oldK)
	}
	e.FacilityName = newK

	t.Facility[newK] = e
	delete(t.Facility, oldK)
	return nil
}

// GetOrCreateFacility retrieves the value with the specified keys from
// the receiver SrlNokiaSystem_System_Logging_File. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaSystem_System_Logging_File) GetOrCreateFacility(
	FacilityName E_SrlNokiaLogging_FacilityNameType,
) *SrlNokiaSystem_System_Logging_File_Facility {
	key := FacilityName

	if v, ok := t.Facility[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewFacility(FacilityName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateFacility got unexpected error: %v", err))
	}
	return v
}

// GetFacility retrieves the value with the specified key from
// the Facility map field of SrlNokiaSystem_System_Logging_File. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaSystem_System_Logging_File) GetFacility(FacilityName E_SrlNokiaLogging_FacilityNameType) *SrlNokiaSystem_System_Logging_File_Facility {
	if t == nil {
		return nil
	}

	key := FacilityName

	if lm, ok := t.Facility[key]; ok {
		return lm
	}
	return nil
}

// DeleteFacility deletes the value with the specified keys from
// the receiver SrlNokiaSystem_System_Logging_File. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaSystem_System_Logging_File) DeleteFacility(FacilityName E_SrlNokiaLogging_FacilityNameType) {
	key := FacilityName

	delete(t.Facility, key)
}

// AppendFacility appends the supplied SrlNokiaSystem_System_Logging_File_Facility struct to the
// list Facility of SrlNokiaSystem_System_Logging_File. If the key value(s) specified in
// the supplied SrlNokiaSystem_System_Logging_File_Facility already exist in the list, an error is
// returned.
func (t *SrlNokiaSystem_System_Logging_File) AppendFacility(v *SrlNokiaSystem_System_Logging_File_Facility) error {
	key := v.FacilityName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Facility == nil {
		t.Facility = make(map[E_SrlNokiaLogging_FacilityNameType]*SrlNokiaSystem_System_Logging_File_Facility)
	}

	if _, ok := t.Facility[key]; ok {
		return fmt.Errorf("duplicate key for list Facility %v", key)
	}

	t.Facility[key] = v
	return nil
}

// NewSubsystem creates a new entry in the Subsystem list of the
// SrlNokiaSystem_System_Logging_File struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_Logging_File) NewSubsystem(SubsystemName E_SrlNokiaLogging_SubsystemNameType) (*SrlNokiaSystem_System_Logging_File_Subsystem, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Subsystem == nil {
		t.Subsystem = make(map[E_SrlNokiaLogging_SubsystemNameType]*SrlNokiaSystem_System_Logging_File_Subsystem)
	}

	key := SubsystemName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Subsystem[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Subsystem", key)
	}

	t.Subsystem[key] = &SrlNokiaSystem_System_Logging_File_Subsystem{
		SubsystemName: SubsystemName,
	}

	return t.Subsystem[key], nil
}

// RenameSubsystem renames an entry in the list Subsystem within
// the SrlNokiaSystem_System_Logging_File struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaSystem_System_Logging_File) RenameSubsystem(oldK, newK E_SrlNokiaLogging_SubsystemNameType) error {
	if _, ok := t.Subsystem[newK]; ok {
		return fmt.Errorf("key %v already exists in Subsystem", newK)
	}

	e, ok := t.Subsystem[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Subsystem", oldK)
	}
	e.SubsystemName = newK

	t.Subsystem[newK] = e
	delete(t.Subsystem, oldK)
	return nil
}

// GetOrCreateSubsystem retrieves the value with the specified keys from
// the receiver SrlNokiaSystem_System_Logging_File. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaSystem_System_Logging_File) GetOrCreateSubsystem(
	SubsystemName E_SrlNokiaLogging_SubsystemNameType,
) *SrlNokiaSystem_System_Logging_File_Subsystem {
	key := SubsystemName

	if v, ok := t.Subsystem[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewSubsystem(SubsystemName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateSubsystem got unexpected error: %v", err))
	}
	return v
}

// GetSubsystem retrieves the value with the specified key from
// the Subsystem map field of SrlNokiaSystem_System_Logging_File. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaSystem_System_Logging_File) GetSubsystem(SubsystemName E_SrlNokiaLogging_SubsystemNameType) *SrlNokiaSystem_System_Logging_File_Subsystem {
	if t == nil {
		return nil
	}

	key := SubsystemName

	if lm, ok := t.Subsystem[key]; ok {
		return lm
	}
	return nil
}

// DeleteSubsystem deletes the value with the specified keys from
// the receiver SrlNokiaSystem_System_Logging_File. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaSystem_System_Logging_File) DeleteSubsystem(SubsystemName E_SrlNokiaLogging_SubsystemNameType) {
	key := SubsystemName

	delete(t.Subsystem, key)
}

// AppendSubsystem appends the supplied SrlNokiaSystem_System_Logging_File_Subsystem struct to the
// list Subsystem of SrlNokiaSystem_System_Logging_File. If the key value(s) specified in
// the supplied SrlNokiaSystem_System_Logging_File_Subsystem already exist in the list, an error is
// returned.
func (t *SrlNokiaSystem_System_Logging_File) AppendSubsystem(v *SrlNokiaSystem_System_Logging_File_Subsystem) error {
	key := v.SubsystemName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Subsystem == nil {
		t.Subsystem = make(map[E_SrlNokiaLogging_SubsystemNameType]*SrlNokiaSystem_System_Logging_File_Subsystem)
	}

	if _, ok := t.Subsystem[key]; ok {
		return fmt.Errorf("duplicate key for list Subsystem %v", key)
	}

	t.Subsystem[key] = v
	return nil
}

// GetDirectory retrieves the value of the leaf Directory from the SrlNokiaSystem_System_Logging_File
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Directory is set, it can
// safely use t.GetDirectory() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Directory == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Logging_File) GetDirectory() string {
	if t == nil || t.Directory == nil {
		return "/var/log/srlinux/file"
	}
	return *t.Directory
}

// GetFileName retrieves the value of the leaf FileName from the SrlNokiaSystem_System_Logging_File
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FileName is set, it can
// safely use t.GetFileName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FileName == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Logging_File) GetFileName() string {
	if t == nil || t.FileName == nil {
		return ""
	}
	return *t.FileName
}

// GetFilter retrieves the value of the leaf Filter from the SrlNokiaSystem_System_Logging_File
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Filter is set, it can
// safely use t.GetFilter() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Filter == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Logging_File) GetFilter() []string {
	if t == nil || t.Filter == nil {
		return nil
	}
	return t.Filter
}

// GetFormat retrieves the value of the leaf Format from the SrlNokiaSystem_System_Logging_File
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Format is set, it can
// safely use t.GetFormat() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Format == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Logging_File) GetFormat() string {
	if t == nil || t.Format == nil {
		return "%TIMEGENERATED:::date-rfc3339% %HOSTNAME% %SYSLOGTAG%%MSG:::sp-if-no-1st-sp%%MSG:::drop-last-lf%\\n"
	}
	return *t.Format
}

// GetRotate retrieves the value of the leaf Rotate from the SrlNokiaSystem_System_Logging_File
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Rotate is set, it can
// safely use t.GetRotate() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Rotate == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Logging_File) GetRotate() uint16 {
	if t == nil || t.Rotate == nil {
		return 4
	}
	return *t.Rotate
}

// GetSize retrieves the value of the leaf Size from the SrlNokiaSystem_System_Logging_File
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Size is set, it can
// safely use t.GetSize() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Size == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Logging_File) GetSize() string {
	if t == nil || t.Size == nil {
		return "10M"
	}
	return *t.Size
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Logging_File
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Logging_File) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Directory == nil {
		var v string = "/var/log/srlinux/file"
		t.Directory = &v
	}
	if t.Format == nil {
		var v string = "%TIMEGENERATED:::date-rfc3339% %HOSTNAME% %SYSLOGTAG%%MSG:::sp-if-no-1st-sp%%MSG:::drop-last-lf%\\n"
		t.Format = &v
	}
	if t.Rotate == nil {
		var v uint16 = 4
		t.Rotate = &v
	}
	if t.Size == nil {
		var v string = "10M"
		t.Size = &v
	}
	for _, e := range t.Facility {
		e.PopulateDefaults()
	}
	for _, e := range t.Subsystem {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_Logging_File struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_Logging_File) ΛListKeyMap() (map[string]interface{}, error) {
	if t.FileName == nil {
		return nil, fmt.Errorf("nil value for key FileName")
	}

	return map[string]interface{}{
		"file-name": *t.FileName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_File) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Logging_File"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_File) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Logging_File) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Logging_File.
func (*SrlNokiaSystem_System_Logging_File) ΛBelongingModule() string {
	return "srl_nokia-logging"
}

// SrlNokiaSystem_System_Logging_File_Facility represents the /srl_nokia-system/system/logging/file/facility YANG schema element.
type SrlNokiaSystem_System_Logging_File_Facility struct {
	FacilityName E_SrlNokiaLogging_FacilityNameType                    `path:"facility-name" module:"srl_nokia-logging"`
	Priority     *SrlNokiaSystem_System_Logging_File_Facility_Priority `path:"priority" module:"srl_nokia-logging"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Logging_File_Facility implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Logging_File_Facility) IsYANGGoStruct() {}

// GetOrCreatePriority retrieves the value of the Priority field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_Logging_File_Facility) GetOrCreatePriority() *SrlNokiaSystem_System_Logging_File_Facility_Priority {
	if t.Priority != nil {
		return t.Priority
	}
	t.Priority = &SrlNokiaSystem_System_Logging_File_Facility_Priority{}
	return t.Priority
}

// GetPriority returns the value of the Priority struct pointer
// from SrlNokiaSystem_System_Logging_File_Facility. If the receiver or the field Priority is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_Logging_File_Facility) GetPriority() *SrlNokiaSystem_System_Logging_File_Facility_Priority {
	if t != nil && t.Priority != nil {
		return t.Priority
	}
	return nil
}

// GetFacilityName retrieves the value of the leaf FacilityName from the SrlNokiaSystem_System_Logging_File_Facility
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FacilityName is set, it can
// safely use t.GetFacilityName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FacilityName == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Logging_File_Facility) GetFacilityName() E_SrlNokiaLogging_FacilityNameType {
	if t == nil || t.FacilityName == 0 {
		return 0
	}
	return t.FacilityName
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Logging_File_Facility
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Logging_File_Facility) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Priority.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_Logging_File_Facility struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_Logging_File_Facility) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"facility-name": t.FacilityName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_File_Facility) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Logging_File_Facility"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_File_Facility) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Logging_File_Facility) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Logging_File_Facility.
func (*SrlNokiaSystem_System_Logging_File_Facility) ΛBelongingModule() string {
	return "srl_nokia-logging"
}

// SrlNokiaSystem_System_Logging_File_Facility_Priority represents the /srl_nokia-system/system/logging/file/facility/priority YANG schema element.
type SrlNokiaSystem_System_Logging_File_Facility_Priority struct {
	MatchAbove E_SrlNokiaLogging_PriorityType   `path:"match-above" module:"srl_nokia-logging"`
	MatchExact []E_SrlNokiaLogging_PriorityType `path:"match-exact" module:"srl_nokia-logging"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Logging_File_Facility_Priority implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Logging_File_Facility_Priority) IsYANGGoStruct() {}

// GetMatchAbove retrieves the value of the leaf MatchAbove from the SrlNokiaSystem_System_Logging_File_Facility_Priority
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MatchAbove is set, it can
// safely use t.GetMatchAbove() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MatchAbove == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Logging_File_Facility_Priority) GetMatchAbove() E_SrlNokiaLogging_PriorityType {
	if t == nil || t.MatchAbove == 0 {
		return 0
	}
	return t.MatchAbove
}

// GetMatchExact retrieves the value of the leaf MatchExact from the SrlNokiaSystem_System_Logging_File_Facility_Priority
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MatchExact is set, it can
// safely use t.GetMatchExact() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MatchExact == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Logging_File_Facility_Priority) GetMatchExact() []E_SrlNokiaLogging_PriorityType {
	if t == nil || t.MatchExact == nil {
		return nil
	}
	return t.MatchExact
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Logging_File_Facility_Priority
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Logging_File_Facility_Priority) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_File_Facility_Priority) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Logging_File_Facility_Priority"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_File_Facility_Priority) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Logging_File_Facility_Priority) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Logging_File_Facility_Priority.
func (*SrlNokiaSystem_System_Logging_File_Facility_Priority) ΛBelongingModule() string {
	return "srl_nokia-logging"
}

// SrlNokiaSystem_System_Logging_File_Subsystem represents the /srl_nokia-system/system/logging/file/subsystem YANG schema element.
type SrlNokiaSystem_System_Logging_File_Subsystem struct {
	Priority      *SrlNokiaSystem_System_Logging_File_Subsystem_Priority `path:"priority" module:"srl_nokia-logging"`
	SubsystemName E_SrlNokiaLogging_SubsystemNameType                    `path:"subsystem-name" module:"srl_nokia-logging"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Logging_File_Subsystem implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Logging_File_Subsystem) IsYANGGoStruct() {}

// GetOrCreatePriority retrieves the value of the Priority field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_Logging_File_Subsystem) GetOrCreatePriority() *SrlNokiaSystem_System_Logging_File_Subsystem_Priority {
	if t.Priority != nil {
		return t.Priority
	}
	t.Priority = &SrlNokiaSystem_System_Logging_File_Subsystem_Priority{}
	return t.Priority
}

// GetPriority returns the value of the Priority struct pointer
// from SrlNokiaSystem_System_Logging_File_Subsystem. If the receiver or the field Priority is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_Logging_File_Subsystem) GetPriority() *SrlNokiaSystem_System_Logging_File_Subsystem_Priority {
	if t != nil && t.Priority != nil {
		return t.Priority
	}
	return nil
}

// GetSubsystemName retrieves the value of the leaf SubsystemName from the SrlNokiaSystem_System_Logging_File_Subsystem
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SubsystemName is set, it can
// safely use t.GetSubsystemName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SubsystemName == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Logging_File_Subsystem) GetSubsystemName() E_SrlNokiaLogging_SubsystemNameType {
	if t == nil || t.SubsystemName == 0 {
		return 0
	}
	return t.SubsystemName
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Logging_File_Subsystem
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Logging_File_Subsystem) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Priority.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_Logging_File_Subsystem struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_Logging_File_Subsystem) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"subsystem-name": t.SubsystemName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_File_Subsystem) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Logging_File_Subsystem"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_File_Subsystem) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Logging_File_Subsystem) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Logging_File_Subsystem.
func (*SrlNokiaSystem_System_Logging_File_Subsystem) ΛBelongingModule() string {
	return "srl_nokia-logging"
}

// SrlNokiaSystem_System_Logging_File_Subsystem_Priority represents the /srl_nokia-system/system/logging/file/subsystem/priority YANG schema element.
type SrlNokiaSystem_System_Logging_File_Subsystem_Priority struct {
	MatchAbove E_SrlNokiaLogging_PriorityType   `path:"match-above" module:"srl_nokia-logging"`
	MatchExact []E_SrlNokiaLogging_PriorityType `path:"match-exact" module:"srl_nokia-logging"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Logging_File_Subsystem_Priority implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Logging_File_Subsystem_Priority) IsYANGGoStruct() {}

// GetMatchAbove retrieves the value of the leaf MatchAbove from the SrlNokiaSystem_System_Logging_File_Subsystem_Priority
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MatchAbove is set, it can
// safely use t.GetMatchAbove() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MatchAbove == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Logging_File_Subsystem_Priority) GetMatchAbove() E_SrlNokiaLogging_PriorityType {
	if t == nil || t.MatchAbove == 0 {
		return 0
	}
	return t.MatchAbove
}

// GetMatchExact retrieves the value of the leaf MatchExact from the SrlNokiaSystem_System_Logging_File_Subsystem_Priority
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MatchExact is set, it can
// safely use t.GetMatchExact() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MatchExact == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Logging_File_Subsystem_Priority) GetMatchExact() []E_SrlNokiaLogging_PriorityType {
	if t == nil || t.MatchExact == nil {
		return nil
	}
	return t.MatchExact
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Logging_File_Subsystem_Priority
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Logging_File_Subsystem_Priority) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_File_Subsystem_Priority) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Logging_File_Subsystem_Priority"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_File_Subsystem_Priority) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Logging_File_Subsystem_Priority) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Logging_File_Subsystem_Priority.
func (*SrlNokiaSystem_System_Logging_File_Subsystem_Priority) ΛBelongingModule() string {
	return "srl_nokia-logging"
}

// SrlNokiaSystem_System_Logging_Filter represents the /srl_nokia-system/system/logging/filter YANG schema element.
type SrlNokiaSystem_System_Logging_Filter struct {
	Contains   *string                                                                               `path:"contains" module:"srl_nokia-logging"`
	Facility   map[E_SrlNokiaLogging_FacilityNameType]*SrlNokiaSystem_System_Logging_Filter_Facility `path:"facility" module:"srl_nokia-logging"`
	FilterName *string                                                                               `path:"filter-name" module:"srl_nokia-logging"`
	Prefix     *string                                                                               `path:"prefix" module:"srl_nokia-logging"`
	Regex      *string                                                                               `path:"regex" module:"srl_nokia-logging"`
	Tag        *string                                                                               `path:"tag" module:"srl_nokia-logging"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Logging_Filter implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Logging_Filter) IsYANGGoStruct() {}

// NewFacility creates a new entry in the Facility list of the
// SrlNokiaSystem_System_Logging_Filter struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_Logging_Filter) NewFacility(FacilityName E_SrlNokiaLogging_FacilityNameType) (*SrlNokiaSystem_System_Logging_Filter_Facility, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Facility == nil {
		t.Facility = make(map[E_SrlNokiaLogging_FacilityNameType]*SrlNokiaSystem_System_Logging_Filter_Facility)
	}

	key := FacilityName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Facility[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Facility", key)
	}

	t.Facility[key] = &SrlNokiaSystem_System_Logging_Filter_Facility{
		FacilityName: FacilityName,
	}

	return t.Facility[key], nil
}

// RenameFacility renames an entry in the list Facility within
// the SrlNokiaSystem_System_Logging_Filter struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaSystem_System_Logging_Filter) RenameFacility(oldK, newK E_SrlNokiaLogging_FacilityNameType) error {
	if _, ok := t.Facility[newK]; ok {
		return fmt.Errorf("key %v already exists in Facility", newK)
	}

	e, ok := t.Facility[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Facility", oldK)
	}
	e.FacilityName = newK

	t.Facility[newK] = e
	delete(t.Facility, oldK)
	return nil
}

// GetOrCreateFacility retrieves the value with the specified keys from
// the receiver SrlNokiaSystem_System_Logging_Filter. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaSystem_System_Logging_Filter) GetOrCreateFacility(
	FacilityName E_SrlNokiaLogging_FacilityNameType,
) *SrlNokiaSystem_System_Logging_Filter_Facility {
	key := FacilityName

	if v, ok := t.Facility[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewFacility(FacilityName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateFacility got unexpected error: %v", err))
	}
	return v
}

// GetFacility retrieves the value with the specified key from
// the Facility map field of SrlNokiaSystem_System_Logging_Filter. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaSystem_System_Logging_Filter) GetFacility(FacilityName E_SrlNokiaLogging_FacilityNameType) *SrlNokiaSystem_System_Logging_Filter_Facility {
	if t == nil {
		return nil
	}

	key := FacilityName

	if lm, ok := t.Facility[key]; ok {
		return lm
	}
	return nil
}

// DeleteFacility deletes the value with the specified keys from
// the receiver SrlNokiaSystem_System_Logging_Filter. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaSystem_System_Logging_Filter) DeleteFacility(FacilityName E_SrlNokiaLogging_FacilityNameType) {
	key := FacilityName

	delete(t.Facility, key)
}

// AppendFacility appends the supplied SrlNokiaSystem_System_Logging_Filter_Facility struct to the
// list Facility of SrlNokiaSystem_System_Logging_Filter. If the key value(s) specified in
// the supplied SrlNokiaSystem_System_Logging_Filter_Facility already exist in the list, an error is
// returned.
func (t *SrlNokiaSystem_System_Logging_Filter) AppendFacility(v *SrlNokiaSystem_System_Logging_Filter_Facility) error {
	key := v.FacilityName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Facility == nil {
		t.Facility = make(map[E_SrlNokiaLogging_FacilityNameType]*SrlNokiaSystem_System_Logging_Filter_Facility)
	}

	if _, ok := t.Facility[key]; ok {
		return fmt.Errorf("duplicate key for list Facility %v", key)
	}

	t.Facility[key] = v
	return nil
}

// GetContains retrieves the value of the leaf Contains from the SrlNokiaSystem_System_Logging_Filter
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Contains is set, it can
// safely use t.GetContains() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Contains == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Logging_Filter) GetContains() string {
	if t == nil || t.Contains == nil {
		return ""
	}
	return *t.Contains
}

// GetFilterName retrieves the value of the leaf FilterName from the SrlNokiaSystem_System_Logging_Filter
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FilterName is set, it can
// safely use t.GetFilterName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FilterName == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Logging_Filter) GetFilterName() string {
	if t == nil || t.FilterName == nil {
		return ""
	}
	return *t.FilterName
}

// GetPrefix retrieves the value of the leaf Prefix from the SrlNokiaSystem_System_Logging_Filter
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Prefix is set, it can
// safely use t.GetPrefix() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Prefix == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Logging_Filter) GetPrefix() string {
	if t == nil || t.Prefix == nil {
		return ""
	}
	return *t.Prefix
}

// GetRegex retrieves the value of the leaf Regex from the SrlNokiaSystem_System_Logging_Filter
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Regex is set, it can
// safely use t.GetRegex() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Regex == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Logging_Filter) GetRegex() string {
	if t == nil || t.Regex == nil {
		return ""
	}
	return *t.Regex
}

// GetTag retrieves the value of the leaf Tag from the SrlNokiaSystem_System_Logging_Filter
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Tag is set, it can
// safely use t.GetTag() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Tag == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Logging_Filter) GetTag() string {
	if t == nil || t.Tag == nil {
		return ""
	}
	return *t.Tag
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Logging_Filter
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Logging_Filter) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Facility {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_Logging_Filter struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_Logging_Filter) ΛListKeyMap() (map[string]interface{}, error) {
	if t.FilterName == nil {
		return nil, fmt.Errorf("nil value for key FilterName")
	}

	return map[string]interface{}{
		"filter-name": *t.FilterName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_Filter) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Logging_Filter"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_Filter) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Logging_Filter) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Logging_Filter.
func (*SrlNokiaSystem_System_Logging_Filter) ΛBelongingModule() string {
	return "srl_nokia-logging"
}

// SrlNokiaSystem_System_Logging_Filter_Facility represents the /srl_nokia-system/system/logging/filter/facility YANG schema element.
type SrlNokiaSystem_System_Logging_Filter_Facility struct {
	FacilityName E_SrlNokiaLogging_FacilityNameType                      `path:"facility-name" module:"srl_nokia-logging"`
	Priority     *SrlNokiaSystem_System_Logging_Filter_Facility_Priority `path:"priority" module:"srl_nokia-logging"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Logging_Filter_Facility implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Logging_Filter_Facility) IsYANGGoStruct() {}

// GetOrCreatePriority retrieves the value of the Priority field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_Logging_Filter_Facility) GetOrCreatePriority() *SrlNokiaSystem_System_Logging_Filter_Facility_Priority {
	if t.Priority != nil {
		return t.Priority
	}
	t.Priority = &SrlNokiaSystem_System_Logging_Filter_Facility_Priority{}
	return t.Priority
}

// GetPriority returns the value of the Priority struct pointer
// from SrlNokiaSystem_System_Logging_Filter_Facility. If the receiver or the field Priority is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_Logging_Filter_Facility) GetPriority() *SrlNokiaSystem_System_Logging_Filter_Facility_Priority {
	if t != nil && t.Priority != nil {
		return t.Priority
	}
	return nil
}

// GetFacilityName retrieves the value of the leaf FacilityName from the SrlNokiaSystem_System_Logging_Filter_Facility
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FacilityName is set, it can
// safely use t.GetFacilityName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FacilityName == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Logging_Filter_Facility) GetFacilityName() E_SrlNokiaLogging_FacilityNameType {
	if t == nil || t.FacilityName == 0 {
		return 0
	}
	return t.FacilityName
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Logging_Filter_Facility
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Logging_Filter_Facility) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Priority.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_Logging_Filter_Facility struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_Logging_Filter_Facility) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"facility-name": t.FacilityName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_Filter_Facility) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Logging_Filter_Facility"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_Filter_Facility) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Logging_Filter_Facility) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Logging_Filter_Facility.
func (*SrlNokiaSystem_System_Logging_Filter_Facility) ΛBelongingModule() string {
	return "srl_nokia-logging"
}

// SrlNokiaSystem_System_Logging_Filter_Facility_Priority represents the /srl_nokia-system/system/logging/filter/facility/priority YANG schema element.
type SrlNokiaSystem_System_Logging_Filter_Facility_Priority struct {
	MatchAbove E_SrlNokiaLogging_PriorityType   `path:"match-above" module:"srl_nokia-logging"`
	MatchExact []E_SrlNokiaLogging_PriorityType `path:"match-exact" module:"srl_nokia-logging"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Logging_Filter_Facility_Priority implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Logging_Filter_Facility_Priority) IsYANGGoStruct() {}

// GetMatchAbove retrieves the value of the leaf MatchAbove from the SrlNokiaSystem_System_Logging_Filter_Facility_Priority
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MatchAbove is set, it can
// safely use t.GetMatchAbove() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MatchAbove == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Logging_Filter_Facility_Priority) GetMatchAbove() E_SrlNokiaLogging_PriorityType {
	if t == nil || t.MatchAbove == 0 {
		return 0
	}
	return t.MatchAbove
}

// GetMatchExact retrieves the value of the leaf MatchExact from the SrlNokiaSystem_System_Logging_Filter_Facility_Priority
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MatchExact is set, it can
// safely use t.GetMatchExact() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MatchExact == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Logging_Filter_Facility_Priority) GetMatchExact() []E_SrlNokiaLogging_PriorityType {
	if t == nil || t.MatchExact == nil {
		return nil
	}
	return t.MatchExact
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Logging_Filter_Facility_Priority
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Logging_Filter_Facility_Priority) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_Filter_Facility_Priority) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Logging_Filter_Facility_Priority"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_Filter_Facility_Priority) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Logging_Filter_Facility_Priority) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Logging_Filter_Facility_Priority.
func (*SrlNokiaSystem_System_Logging_Filter_Facility_Priority) ΛBelongingModule() string {
	return "srl_nokia-logging"
}

// SrlNokiaSystem_System_Logging_RemoteServer represents the /srl_nokia-system/system/logging/remote-server YANG schema element.
type SrlNokiaSystem_System_Logging_RemoteServer struct {
	Facility      map[E_SrlNokiaLogging_FacilityNameType]*SrlNokiaSystem_System_Logging_RemoteServer_Facility   `path:"facility" module:"srl_nokia-logging"`
	Filter        []string                                                                                      `path:"filter" module:"srl_nokia-logging"`
	Host          *string                                                                                       `path:"host" module:"srl_nokia-logging"`
	RemotePort    *uint32                                                                                       `path:"remote-port" module:"srl_nokia-logging"`
	SourceAddress *string                                                                                       `path:"source-address" module:"srl_nokia-logging"`
	Subsystem     map[E_SrlNokiaLogging_SubsystemNameType]*SrlNokiaSystem_System_Logging_RemoteServer_Subsystem `path:"subsystem" module:"srl_nokia-logging"`
	Transport     E_SrlNokiaLogging_TransportType                                                               `path:"transport" module:"srl_nokia-logging"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Logging_RemoteServer implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Logging_RemoteServer) IsYANGGoStruct() {}

// NewFacility creates a new entry in the Facility list of the
// SrlNokiaSystem_System_Logging_RemoteServer struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_Logging_RemoteServer) NewFacility(
	FacilityName E_SrlNokiaLogging_FacilityNameType,
) (*SrlNokiaSystem_System_Logging_RemoteServer_Facility, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Facility == nil {
		t.Facility = make(map[E_SrlNokiaLogging_FacilityNameType]*SrlNokiaSystem_System_Logging_RemoteServer_Facility)
	}

	key := FacilityName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Facility[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Facility", key)
	}

	t.Facility[key] = &SrlNokiaSystem_System_Logging_RemoteServer_Facility{
		FacilityName: FacilityName,
	}

	return t.Facility[key], nil
}

// RenameFacility renames an entry in the list Facility within
// the SrlNokiaSystem_System_Logging_RemoteServer struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaSystem_System_Logging_RemoteServer) RenameFacility(oldK, newK E_SrlNokiaLogging_FacilityNameType) error {
	if _, ok := t.Facility[newK]; ok {
		return fmt.Errorf("key %v already exists in Facility", newK)
	}

	e, ok := t.Facility[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Facility", oldK)
	}
	e.FacilityName = newK

	t.Facility[newK] = e
	delete(t.Facility, oldK)
	return nil
}

// GetOrCreateFacility retrieves the value with the specified keys from
// the receiver SrlNokiaSystem_System_Logging_RemoteServer. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaSystem_System_Logging_RemoteServer) GetOrCreateFacility(
	FacilityName E_SrlNokiaLogging_FacilityNameType,
) *SrlNokiaSystem_System_Logging_RemoteServer_Facility {
	key := FacilityName

	if v, ok := t.Facility[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewFacility(FacilityName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateFacility got unexpected error: %v", err))
	}
	return v
}

// GetFacility retrieves the value with the specified key from
// the Facility map field of SrlNokiaSystem_System_Logging_RemoteServer. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaSystem_System_Logging_RemoteServer) GetFacility(
	FacilityName E_SrlNokiaLogging_FacilityNameType,
) *SrlNokiaSystem_System_Logging_RemoteServer_Facility {
	if t == nil {
		return nil
	}

	key := FacilityName

	if lm, ok := t.Facility[key]; ok {
		return lm
	}
	return nil
}

// DeleteFacility deletes the value with the specified keys from
// the receiver SrlNokiaSystem_System_Logging_RemoteServer. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaSystem_System_Logging_RemoteServer) DeleteFacility(FacilityName E_SrlNokiaLogging_FacilityNameType) {
	key := FacilityName

	delete(t.Facility, key)
}

// AppendFacility appends the supplied SrlNokiaSystem_System_Logging_RemoteServer_Facility struct to the
// list Facility of SrlNokiaSystem_System_Logging_RemoteServer. If the key value(s) specified in
// the supplied SrlNokiaSystem_System_Logging_RemoteServer_Facility already exist in the list, an error is
// returned.
func (t *SrlNokiaSystem_System_Logging_RemoteServer) AppendFacility(
	v *SrlNokiaSystem_System_Logging_RemoteServer_Facility,
) error {
	key := v.FacilityName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Facility == nil {
		t.Facility = make(map[E_SrlNokiaLogging_FacilityNameType]*SrlNokiaSystem_System_Logging_RemoteServer_Facility)
	}

	if _, ok := t.Facility[key]; ok {
		return fmt.Errorf("duplicate key for list Facility %v", key)
	}

	t.Facility[key] = v
	return nil
}

// NewSubsystem creates a new entry in the Subsystem list of the
// SrlNokiaSystem_System_Logging_RemoteServer struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_Logging_RemoteServer) NewSubsystem(
	SubsystemName E_SrlNokiaLogging_SubsystemNameType,
) (*SrlNokiaSystem_System_Logging_RemoteServer_Subsystem, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Subsystem == nil {
		t.Subsystem = make(map[E_SrlNokiaLogging_SubsystemNameType]*SrlNokiaSystem_System_Logging_RemoteServer_Subsystem)
	}

	key := SubsystemName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Subsystem[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Subsystem", key)
	}

	t.Subsystem[key] = &SrlNokiaSystem_System_Logging_RemoteServer_Subsystem{
		SubsystemName: SubsystemName,
	}

	return t.Subsystem[key], nil
}

// RenameSubsystem renames an entry in the list Subsystem within
// the SrlNokiaSystem_System_Logging_RemoteServer struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaSystem_System_Logging_RemoteServer) RenameSubsystem(oldK, newK E_SrlNokiaLogging_SubsystemNameType) error {
	if _, ok := t.Subsystem[newK]; ok {
		return fmt.Errorf("key %v already exists in Subsystem", newK)
	}

	e, ok := t.Subsystem[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Subsystem", oldK)
	}
	e.SubsystemName = newK

	t.Subsystem[newK] = e
	delete(t.Subsystem, oldK)
	return nil
}

// GetOrCreateSubsystem retrieves the value with the specified keys from
// the receiver SrlNokiaSystem_System_Logging_RemoteServer. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaSystem_System_Logging_RemoteServer) GetOrCreateSubsystem(
	SubsystemName E_SrlNokiaLogging_SubsystemNameType,
) *SrlNokiaSystem_System_Logging_RemoteServer_Subsystem {
	key := SubsystemName

	if v, ok := t.Subsystem[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewSubsystem(SubsystemName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateSubsystem got unexpected error: %v", err))
	}
	return v
}

// GetSubsystem retrieves the value with the specified key from
// the Subsystem map field of SrlNokiaSystem_System_Logging_RemoteServer. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaSystem_System_Logging_RemoteServer) GetSubsystem(
	SubsystemName E_SrlNokiaLogging_SubsystemNameType,
) *SrlNokiaSystem_System_Logging_RemoteServer_Subsystem {
	if t == nil {
		return nil
	}

	key := SubsystemName

	if lm, ok := t.Subsystem[key]; ok {
		return lm
	}
	return nil
}

// DeleteSubsystem deletes the value with the specified keys from
// the receiver SrlNokiaSystem_System_Logging_RemoteServer. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaSystem_System_Logging_RemoteServer) DeleteSubsystem(SubsystemName E_SrlNokiaLogging_SubsystemNameType) {
	key := SubsystemName

	delete(t.Subsystem, key)
}

// AppendSubsystem appends the supplied SrlNokiaSystem_System_Logging_RemoteServer_Subsystem struct to the
// list Subsystem of SrlNokiaSystem_System_Logging_RemoteServer. If the key value(s) specified in
// the supplied SrlNokiaSystem_System_Logging_RemoteServer_Subsystem already exist in the list, an error is
// returned.
func (t *SrlNokiaSystem_System_Logging_RemoteServer) AppendSubsystem(
	v *SrlNokiaSystem_System_Logging_RemoteServer_Subsystem,
) error {
	key := v.SubsystemName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Subsystem == nil {
		t.Subsystem = make(map[E_SrlNokiaLogging_SubsystemNameType]*SrlNokiaSystem_System_Logging_RemoteServer_Subsystem)
	}

	if _, ok := t.Subsystem[key]; ok {
		return fmt.Errorf("duplicate key for list Subsystem %v", key)
	}

	t.Subsystem[key] = v
	return nil
}

// GetFilter retrieves the value of the leaf Filter from the SrlNokiaSystem_System_Logging_RemoteServer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Filter is set, it can
// safely use t.GetFilter() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Filter == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Logging_RemoteServer) GetFilter() []string {
	if t == nil || t.Filter == nil {
		return nil
	}
	return t.Filter
}

// GetHost retrieves the value of the leaf Host from the SrlNokiaSystem_System_Logging_RemoteServer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Host is set, it can
// safely use t.GetHost() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Host == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Logging_RemoteServer) GetHost() string {
	if t == nil || t.Host == nil {
		return ""
	}
	return *t.Host
}

// GetRemotePort retrieves the value of the leaf RemotePort from the SrlNokiaSystem_System_Logging_RemoteServer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RemotePort is set, it can
// safely use t.GetRemotePort() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RemotePort == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Logging_RemoteServer) GetRemotePort() uint32 {
	if t == nil || t.RemotePort == nil {
		return 514
	}
	return *t.RemotePort
}

// GetSourceAddress retrieves the value of the leaf SourceAddress from the SrlNokiaSystem_System_Logging_RemoteServer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SourceAddress is set, it can
// safely use t.GetSourceAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SourceAddress == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Logging_RemoteServer) GetSourceAddress() string {
	if t == nil || t.SourceAddress == nil {
		return ""
	}
	return *t.SourceAddress
}

// GetTransport retrieves the value of the leaf Transport from the SrlNokiaSystem_System_Logging_RemoteServer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Transport is set, it can
// safely use t.GetTransport() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Transport == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Logging_RemoteServer) GetTransport() E_SrlNokiaLogging_TransportType {
	if t == nil || t.Transport == 0 {
		return SrlNokiaLogging_TransportType_udp
	}
	return t.Transport
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Logging_RemoteServer
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Logging_RemoteServer) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.RemotePort == nil {
		var v uint32 = 514
		t.RemotePort = &v
	}
	if t.Transport == 0 {
		t.Transport = SrlNokiaLogging_TransportType_udp
	}
	for _, e := range t.Facility {
		e.PopulateDefaults()
	}
	for _, e := range t.Subsystem {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_Logging_RemoteServer struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_Logging_RemoteServer) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Host == nil {
		return nil, fmt.Errorf("nil value for key Host")
	}

	return map[string]interface{}{
		"host": *t.Host,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_RemoteServer) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Logging_RemoteServer"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_RemoteServer) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Logging_RemoteServer) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Logging_RemoteServer.
func (*SrlNokiaSystem_System_Logging_RemoteServer) ΛBelongingModule() string {
	return "srl_nokia-logging"
}

// SrlNokiaSystem_System_Logging_RemoteServer_Facility represents the /srl_nokia-system/system/logging/remote-server/facility YANG schema element.
type SrlNokiaSystem_System_Logging_RemoteServer_Facility struct {
	FacilityName E_SrlNokiaLogging_FacilityNameType                            `path:"facility-name" module:"srl_nokia-logging"`
	Priority     *SrlNokiaSystem_System_Logging_RemoteServer_Facility_Priority `path:"priority" module:"srl_nokia-logging"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Logging_RemoteServer_Facility implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Logging_RemoteServer_Facility) IsYANGGoStruct() {}

// GetOrCreatePriority retrieves the value of the Priority field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_Logging_RemoteServer_Facility) GetOrCreatePriority() *SrlNokiaSystem_System_Logging_RemoteServer_Facility_Priority {
	if t.Priority != nil {
		return t.Priority
	}
	t.Priority = &SrlNokiaSystem_System_Logging_RemoteServer_Facility_Priority{}
	return t.Priority
}

// GetPriority returns the value of the Priority struct pointer
// from SrlNokiaSystem_System_Logging_RemoteServer_Facility. If the receiver or the field Priority is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_Logging_RemoteServer_Facility) GetPriority() *SrlNokiaSystem_System_Logging_RemoteServer_Facility_Priority {
	if t != nil && t.Priority != nil {
		return t.Priority
	}
	return nil
}

// GetFacilityName retrieves the value of the leaf FacilityName from the SrlNokiaSystem_System_Logging_RemoteServer_Facility
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FacilityName is set, it can
// safely use t.GetFacilityName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FacilityName == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Logging_RemoteServer_Facility) GetFacilityName() E_SrlNokiaLogging_FacilityNameType {
	if t == nil || t.FacilityName == 0 {
		return 0
	}
	return t.FacilityName
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Logging_RemoteServer_Facility
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Logging_RemoteServer_Facility) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Priority.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_Logging_RemoteServer_Facility struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_Logging_RemoteServer_Facility) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"facility-name": t.FacilityName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_RemoteServer_Facility) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Logging_RemoteServer_Facility"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_RemoteServer_Facility) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Logging_RemoteServer_Facility) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Logging_RemoteServer_Facility.
func (*SrlNokiaSystem_System_Logging_RemoteServer_Facility) ΛBelongingModule() string {
	return "srl_nokia-logging"
}

// SrlNokiaSystem_System_Logging_RemoteServer_Facility_Priority represents the /srl_nokia-system/system/logging/remote-server/facility/priority YANG schema element.
type SrlNokiaSystem_System_Logging_RemoteServer_Facility_Priority struct {
	MatchAbove E_SrlNokiaLogging_PriorityType   `path:"match-above" module:"srl_nokia-logging"`
	MatchExact []E_SrlNokiaLogging_PriorityType `path:"match-exact" module:"srl_nokia-logging"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Logging_RemoteServer_Facility_Priority implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Logging_RemoteServer_Facility_Priority) IsYANGGoStruct() {}

// GetMatchAbove retrieves the value of the leaf MatchAbove from the SrlNokiaSystem_System_Logging_RemoteServer_Facility_Priority
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MatchAbove is set, it can
// safely use t.GetMatchAbove() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MatchAbove == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Logging_RemoteServer_Facility_Priority) GetMatchAbove() E_SrlNokiaLogging_PriorityType {
	if t == nil || t.MatchAbove == 0 {
		return 0
	}
	return t.MatchAbove
}

// GetMatchExact retrieves the value of the leaf MatchExact from the SrlNokiaSystem_System_Logging_RemoteServer_Facility_Priority
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MatchExact is set, it can
// safely use t.GetMatchExact() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MatchExact == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Logging_RemoteServer_Facility_Priority) GetMatchExact() []E_SrlNokiaLogging_PriorityType {
	if t == nil || t.MatchExact == nil {
		return nil
	}
	return t.MatchExact
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Logging_RemoteServer_Facility_Priority
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Logging_RemoteServer_Facility_Priority) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_RemoteServer_Facility_Priority) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Logging_RemoteServer_Facility_Priority"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_RemoteServer_Facility_Priority) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Logging_RemoteServer_Facility_Priority) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Logging_RemoteServer_Facility_Priority.
func (*SrlNokiaSystem_System_Logging_RemoteServer_Facility_Priority) ΛBelongingModule() string {
	return "srl_nokia-logging"
}

// SrlNokiaSystem_System_Logging_RemoteServer_Subsystem represents the /srl_nokia-system/system/logging/remote-server/subsystem YANG schema element.
type SrlNokiaSystem_System_Logging_RemoteServer_Subsystem struct {
	Priority      *SrlNokiaSystem_System_Logging_RemoteServer_Subsystem_Priority `path:"priority" module:"srl_nokia-logging"`
	SubsystemName E_SrlNokiaLogging_SubsystemNameType                            `path:"subsystem-name" module:"srl_nokia-logging"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Logging_RemoteServer_Subsystem implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Logging_RemoteServer_Subsystem) IsYANGGoStruct() {}

// GetOrCreatePriority retrieves the value of the Priority field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_Logging_RemoteServer_Subsystem) GetOrCreatePriority() *SrlNokiaSystem_System_Logging_RemoteServer_Subsystem_Priority {
	if t.Priority != nil {
		return t.Priority
	}
	t.Priority = &SrlNokiaSystem_System_Logging_RemoteServer_Subsystem_Priority{}
	return t.Priority
}

// GetPriority returns the value of the Priority struct pointer
// from SrlNokiaSystem_System_Logging_RemoteServer_Subsystem. If the receiver or the field Priority is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_Logging_RemoteServer_Subsystem) GetPriority() *SrlNokiaSystem_System_Logging_RemoteServer_Subsystem_Priority {
	if t != nil && t.Priority != nil {
		return t.Priority
	}
	return nil
}

// GetSubsystemName retrieves the value of the leaf SubsystemName from the SrlNokiaSystem_System_Logging_RemoteServer_Subsystem
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SubsystemName is set, it can
// safely use t.GetSubsystemName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SubsystemName == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Logging_RemoteServer_Subsystem) GetSubsystemName() E_SrlNokiaLogging_SubsystemNameType {
	if t == nil || t.SubsystemName == 0 {
		return 0
	}
	return t.SubsystemName
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Logging_RemoteServer_Subsystem
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Logging_RemoteServer_Subsystem) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Priority.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_Logging_RemoteServer_Subsystem struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_Logging_RemoteServer_Subsystem) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"subsystem-name": t.SubsystemName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_RemoteServer_Subsystem) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Logging_RemoteServer_Subsystem"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_RemoteServer_Subsystem) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Logging_RemoteServer_Subsystem) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Logging_RemoteServer_Subsystem.
func (*SrlNokiaSystem_System_Logging_RemoteServer_Subsystem) ΛBelongingModule() string {
	return "srl_nokia-logging"
}

// SrlNokiaSystem_System_Logging_RemoteServer_Subsystem_Priority represents the /srl_nokia-system/system/logging/remote-server/subsystem/priority YANG schema element.
type SrlNokiaSystem_System_Logging_RemoteServer_Subsystem_Priority struct {
	MatchAbove E_SrlNokiaLogging_PriorityType   `path:"match-above" module:"srl_nokia-logging"`
	MatchExact []E_SrlNokiaLogging_PriorityType `path:"match-exact" module:"srl_nokia-logging"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Logging_RemoteServer_Subsystem_Priority implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Logging_RemoteServer_Subsystem_Priority) IsYANGGoStruct() {}

// GetMatchAbove retrieves the value of the leaf MatchAbove from the SrlNokiaSystem_System_Logging_RemoteServer_Subsystem_Priority
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MatchAbove is set, it can
// safely use t.GetMatchAbove() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MatchAbove == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Logging_RemoteServer_Subsystem_Priority) GetMatchAbove() E_SrlNokiaLogging_PriorityType {
	if t == nil || t.MatchAbove == 0 {
		return 0
	}
	return t.MatchAbove
}

// GetMatchExact retrieves the value of the leaf MatchExact from the SrlNokiaSystem_System_Logging_RemoteServer_Subsystem_Priority
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MatchExact is set, it can
// safely use t.GetMatchExact() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MatchExact == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Logging_RemoteServer_Subsystem_Priority) GetMatchExact() []E_SrlNokiaLogging_PriorityType {
	if t == nil || t.MatchExact == nil {
		return nil
	}
	return t.MatchExact
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Logging_RemoteServer_Subsystem_Priority
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Logging_RemoteServer_Subsystem_Priority) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_RemoteServer_Subsystem_Priority) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Logging_RemoteServer_Subsystem_Priority"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_RemoteServer_Subsystem_Priority) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Logging_RemoteServer_Subsystem_Priority) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Logging_RemoteServer_Subsystem_Priority.
func (*SrlNokiaSystem_System_Logging_RemoteServer_Subsystem_Priority) ΛBelongingModule() string {
	return "srl_nokia-logging"
}

// SrlNokiaSystem_System_Maintenance represents the /srl_nokia-system/system/maintenance YANG schema element.
type SrlNokiaSystem_System_Maintenance struct {
	Group   map[string]*SrlNokiaSystem_System_Maintenance_Group   `path:"group" module:"srl_nokia-maintenance-mode"`
	Profile map[string]*SrlNokiaSystem_System_Maintenance_Profile `path:"profile" module:"srl_nokia-maintenance-mode"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Maintenance implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Maintenance) IsYANGGoStruct() {}

// NewGroup creates a new entry in the Group list of the
// SrlNokiaSystem_System_Maintenance struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_Maintenance) NewGroup(Name string) (*SrlNokiaSystem_System_Maintenance_Group, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Group == nil {
		t.Group = make(map[string]*SrlNokiaSystem_System_Maintenance_Group)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Group[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Group", key)
	}

	t.Group[key] = &SrlNokiaSystem_System_Maintenance_Group{
		Name: &Name,
	}

	return t.Group[key], nil
}

// RenameGroup renames an entry in the list Group within
// the SrlNokiaSystem_System_Maintenance struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaSystem_System_Maintenance) RenameGroup(oldK, newK string) error {
	if _, ok := t.Group[newK]; ok {
		return fmt.Errorf("key %v already exists in Group", newK)
	}

	e, ok := t.Group[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Group", oldK)
	}
	e.Name = &newK

	t.Group[newK] = e
	delete(t.Group, oldK)
	return nil
}

// GetOrCreateGroup retrieves the value with the specified keys from
// the receiver SrlNokiaSystem_System_Maintenance. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaSystem_System_Maintenance) GetOrCreateGroup(Name string) *SrlNokiaSystem_System_Maintenance_Group {
	key := Name

	if v, ok := t.Group[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewGroup(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateGroup got unexpected error: %v", err))
	}
	return v
}

// GetGroup retrieves the value with the specified key from
// the Group map field of SrlNokiaSystem_System_Maintenance. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaSystem_System_Maintenance) GetGroup(Name string) *SrlNokiaSystem_System_Maintenance_Group {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Group[key]; ok {
		return lm
	}
	return nil
}

// DeleteGroup deletes the value with the specified keys from
// the receiver SrlNokiaSystem_System_Maintenance. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaSystem_System_Maintenance) DeleteGroup(Name string) {
	key := Name

	delete(t.Group, key)
}

// AppendGroup appends the supplied SrlNokiaSystem_System_Maintenance_Group struct to the
// list Group of SrlNokiaSystem_System_Maintenance. If the key value(s) specified in
// the supplied SrlNokiaSystem_System_Maintenance_Group already exist in the list, an error is
// returned.
func (t *SrlNokiaSystem_System_Maintenance) AppendGroup(v *SrlNokiaSystem_System_Maintenance_Group) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Group == nil {
		t.Group = make(map[string]*SrlNokiaSystem_System_Maintenance_Group)
	}

	if _, ok := t.Group[key]; ok {
		return fmt.Errorf("duplicate key for list Group %v", key)
	}

	t.Group[key] = v
	return nil
}

// NewProfile creates a new entry in the Profile list of the
// SrlNokiaSystem_System_Maintenance struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_Maintenance) NewProfile(Name string) (*SrlNokiaSystem_System_Maintenance_Profile, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Profile == nil {
		t.Profile = make(map[string]*SrlNokiaSystem_System_Maintenance_Profile)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Profile[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Profile", key)
	}

	t.Profile[key] = &SrlNokiaSystem_System_Maintenance_Profile{
		Name: &Name,
	}

	return t.Profile[key], nil
}

// RenameProfile renames an entry in the list Profile within
// the SrlNokiaSystem_System_Maintenance struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaSystem_System_Maintenance) RenameProfile(oldK, newK string) error {
	if _, ok := t.Profile[newK]; ok {
		return fmt.Errorf("key %v already exists in Profile", newK)
	}

	e, ok := t.Profile[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Profile", oldK)
	}
	e.Name = &newK

	t.Profile[newK] = e
	delete(t.Profile, oldK)
	return nil
}

// GetOrCreateProfile retrieves the value with the specified keys from
// the receiver SrlNokiaSystem_System_Maintenance. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaSystem_System_Maintenance) GetOrCreateProfile(Name string) *SrlNokiaSystem_System_Maintenance_Profile {
	key := Name

	if v, ok := t.Profile[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewProfile(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateProfile got unexpected error: %v", err))
	}
	return v
}

// GetProfile retrieves the value with the specified key from
// the Profile map field of SrlNokiaSystem_System_Maintenance. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaSystem_System_Maintenance) GetProfile(Name string) *SrlNokiaSystem_System_Maintenance_Profile {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Profile[key]; ok {
		return lm
	}
	return nil
}

// DeleteProfile deletes the value with the specified keys from
// the receiver SrlNokiaSystem_System_Maintenance. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaSystem_System_Maintenance) DeleteProfile(Name string) {
	key := Name

	delete(t.Profile, key)
}

// AppendProfile appends the supplied SrlNokiaSystem_System_Maintenance_Profile struct to the
// list Profile of SrlNokiaSystem_System_Maintenance. If the key value(s) specified in
// the supplied SrlNokiaSystem_System_Maintenance_Profile already exist in the list, an error is
// returned.
func (t *SrlNokiaSystem_System_Maintenance) AppendProfile(v *SrlNokiaSystem_System_Maintenance_Profile) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Profile == nil {
		t.Profile = make(map[string]*SrlNokiaSystem_System_Maintenance_Profile)
	}

	if _, ok := t.Profile[key]; ok {
		return fmt.Errorf("duplicate key for list Profile %v", key)
	}

	t.Profile[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Maintenance
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Maintenance) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Group {
		e.PopulateDefaults()
	}
	for _, e := range t.Profile {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Maintenance) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Maintenance"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Maintenance) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Maintenance) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Maintenance.
func (*SrlNokiaSystem_System_Maintenance) ΛBelongingModule() string {
	return "srl_nokia-maintenance-mode"
}

// SrlNokiaSystem_System_Maintenance_Group represents the /srl_nokia-system/system/maintenance/group YANG schema element.
type SrlNokiaSystem_System_Maintenance_Group struct {
	MaintenanceMode    *SrlNokiaSystem_System_Maintenance_Group_MaintenanceMode `path:"maintenance-mode" module:"srl_nokia-maintenance-mode"`
	MaintenanceProfile *string                                                  `path:"maintenance-profile" module:"srl_nokia-maintenance-mode"`
	Members            *SrlNokiaSystem_System_Maintenance_Group_Members         `path:"members" module:"srl_nokia-maintenance-mode"`
	Name               *string                                                  `path:"name" module:"srl_nokia-maintenance-mode"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Maintenance_Group implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Maintenance_Group) IsYANGGoStruct() {}

// GetOrCreateMaintenanceMode retrieves the value of the MaintenanceMode field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_Maintenance_Group) GetOrCreateMaintenanceMode() *SrlNokiaSystem_System_Maintenance_Group_MaintenanceMode {
	if t.MaintenanceMode != nil {
		return t.MaintenanceMode
	}
	t.MaintenanceMode = &SrlNokiaSystem_System_Maintenance_Group_MaintenanceMode{}
	return t.MaintenanceMode
}

// GetOrCreateMembers retrieves the value of the Members field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_Maintenance_Group) GetOrCreateMembers() *SrlNokiaSystem_System_Maintenance_Group_Members {
	if t.Members != nil {
		return t.Members
	}
	t.Members = &SrlNokiaSystem_System_Maintenance_Group_Members{}
	return t.Members
}

// GetMaintenanceMode returns the value of the MaintenanceMode struct pointer
// from SrlNokiaSystem_System_Maintenance_Group. If the receiver or the field MaintenanceMode is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_Maintenance_Group) GetMaintenanceMode() *SrlNokiaSystem_System_Maintenance_Group_MaintenanceMode {
	if t != nil && t.MaintenanceMode != nil {
		return t.MaintenanceMode
	}
	return nil
}

// GetMembers returns the value of the Members struct pointer
// from SrlNokiaSystem_System_Maintenance_Group. If the receiver or the field Members is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_Maintenance_Group) GetMembers() *SrlNokiaSystem_System_Maintenance_Group_Members {
	if t != nil && t.Members != nil {
		return t.Members
	}
	return nil
}

// GetMaintenanceProfile retrieves the value of the leaf MaintenanceProfile from the SrlNokiaSystem_System_Maintenance_Group
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MaintenanceProfile is set, it can
// safely use t.GetMaintenanceProfile() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MaintenanceProfile == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Maintenance_Group) GetMaintenanceProfile() string {
	if t == nil || t.MaintenanceProfile == nil {
		return ""
	}
	return *t.MaintenanceProfile
}

// GetName retrieves the value of the leaf Name from the SrlNokiaSystem_System_Maintenance_Group
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Maintenance_Group) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Maintenance_Group
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Maintenance_Group) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.MaintenanceMode.PopulateDefaults()
	t.Members.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_Maintenance_Group struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_Maintenance_Group) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Maintenance_Group) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Maintenance_Group"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Maintenance_Group) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Maintenance_Group) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Maintenance_Group.
func (*SrlNokiaSystem_System_Maintenance_Group) ΛBelongingModule() string {
	return "srl_nokia-maintenance-mode"
}

// SrlNokiaSystem_System_Maintenance_Group_MaintenanceMode represents the /srl_nokia-system/system/maintenance/group/maintenance-mode YANG schema element.
type SrlNokiaSystem_System_Maintenance_Group_MaintenanceMode struct {
	AdminState E_SrlNokiaCommon_AdminState `path:"admin-state" module:"srl_nokia-maintenance-mode"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Maintenance_Group_MaintenanceMode implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Maintenance_Group_MaintenanceMode) IsYANGGoStruct() {}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaSystem_System_Maintenance_Group_MaintenanceMode
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Maintenance_Group_MaintenanceMode) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_disable
	}
	return t.AdminState
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Maintenance_Group_MaintenanceMode
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Maintenance_Group_MaintenanceMode) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_disable
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Maintenance_Group_MaintenanceMode) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Maintenance_Group_MaintenanceMode"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Maintenance_Group_MaintenanceMode) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Maintenance_Group_MaintenanceMode) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Maintenance_Group_MaintenanceMode.
func (*SrlNokiaSystem_System_Maintenance_Group_MaintenanceMode) ΛBelongingModule() string {
	return "srl_nokia-maintenance-mode"
}

// SrlNokiaSystem_System_Maintenance_Group_Members represents the /srl_nokia-system/system/maintenance/group/members YANG schema element.
type SrlNokiaSystem_System_Maintenance_Group_Members struct {
	Bgp  *SrlNokiaSystem_System_Maintenance_Group_Members_Bgp  `path:"bgp" module:"srl_nokia-maintenance-mode"`
	Isis *SrlNokiaSystem_System_Maintenance_Group_Members_Isis `path:"isis" module:"srl_nokia-maintenance-mode"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Maintenance_Group_Members implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Maintenance_Group_Members) IsYANGGoStruct() {}

// GetOrCreateBgp retrieves the value of the Bgp field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_Maintenance_Group_Members) GetOrCreateBgp() *SrlNokiaSystem_System_Maintenance_Group_Members_Bgp {
	if t.Bgp != nil {
		return t.Bgp
	}
	t.Bgp = &SrlNokiaSystem_System_Maintenance_Group_Members_Bgp{}
	return t.Bgp
}

// GetOrCreateIsis retrieves the value of the Isis field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_Maintenance_Group_Members) GetOrCreateIsis() *SrlNokiaSystem_System_Maintenance_Group_Members_Isis {
	if t.Isis != nil {
		return t.Isis
	}
	t.Isis = &SrlNokiaSystem_System_Maintenance_Group_Members_Isis{}
	return t.Isis
}

// GetBgp returns the value of the Bgp struct pointer
// from SrlNokiaSystem_System_Maintenance_Group_Members. If the receiver or the field Bgp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_Maintenance_Group_Members) GetBgp() *SrlNokiaSystem_System_Maintenance_Group_Members_Bgp {
	if t != nil && t.Bgp != nil {
		return t.Bgp
	}
	return nil
}

// GetIsis returns the value of the Isis struct pointer
// from SrlNokiaSystem_System_Maintenance_Group_Members. If the receiver or the field Isis is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_Maintenance_Group_Members) GetIsis() *SrlNokiaSystem_System_Maintenance_Group_Members_Isis {
	if t != nil && t.Isis != nil {
		return t.Isis
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Maintenance_Group_Members
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Maintenance_Group_Members) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Bgp.PopulateDefaults()
	t.Isis.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Maintenance_Group_Members) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Maintenance_Group_Members"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Maintenance_Group_Members) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Maintenance_Group_Members) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Maintenance_Group_Members.
func (*SrlNokiaSystem_System_Maintenance_Group_Members) ΛBelongingModule() string {
	return "srl_nokia-maintenance-mode"
}

// SrlNokiaSystem_System_Maintenance_Group_Members_Bgp represents the /srl_nokia-system/system/maintenance/group/members/bgp YANG schema element.
type SrlNokiaSystem_System_Maintenance_Group_Members_Bgp struct {
	NetworkInstance map[string]*SrlNokiaSystem_System_Maintenance_Group_Members_Bgp_NetworkInstance `path:"network-instance" module:"srl_nokia-maintenance-mode"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Maintenance_Group_Members_Bgp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Maintenance_Group_Members_Bgp) IsYANGGoStruct() {}

// NewNetworkInstance creates a new entry in the NetworkInstance list of the
// SrlNokiaSystem_System_Maintenance_Group_Members_Bgp struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_Maintenance_Group_Members_Bgp) NewNetworkInstance(Name string) (*SrlNokiaSystem_System_Maintenance_Group_Members_Bgp_NetworkInstance, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NetworkInstance == nil {
		t.NetworkInstance = make(map[string]*SrlNokiaSystem_System_Maintenance_Group_Members_Bgp_NetworkInstance)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.NetworkInstance[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list NetworkInstance", key)
	}

	t.NetworkInstance[key] = &SrlNokiaSystem_System_Maintenance_Group_Members_Bgp_NetworkInstance{
		Name: &Name,
	}

	return t.NetworkInstance[key], nil
}

// RenameNetworkInstance renames an entry in the list NetworkInstance within
// the SrlNokiaSystem_System_Maintenance_Group_Members_Bgp struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaSystem_System_Maintenance_Group_Members_Bgp) RenameNetworkInstance(oldK, newK string) error {
	if _, ok := t.NetworkInstance[newK]; ok {
		return fmt.Errorf("key %v already exists in NetworkInstance", newK)
	}

	e, ok := t.NetworkInstance[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in NetworkInstance", oldK)
	}
	e.Name = &newK

	t.NetworkInstance[newK] = e
	delete(t.NetworkInstance, oldK)
	return nil
}

// GetOrCreateNetworkInstance retrieves the value with the specified keys from
// the receiver SrlNokiaSystem_System_Maintenance_Group_Members_Bgp. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaSystem_System_Maintenance_Group_Members_Bgp) GetOrCreateNetworkInstance(
	Name string,
) *SrlNokiaSystem_System_Maintenance_Group_Members_Bgp_NetworkInstance {
	key := Name

	if v, ok := t.NetworkInstance[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNetworkInstance(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNetworkInstance got unexpected error: %v", err))
	}
	return v
}

// GetNetworkInstance retrieves the value with the specified key from
// the NetworkInstance map field of SrlNokiaSystem_System_Maintenance_Group_Members_Bgp. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaSystem_System_Maintenance_Group_Members_Bgp) GetNetworkInstance(Name string) *SrlNokiaSystem_System_Maintenance_Group_Members_Bgp_NetworkInstance {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.NetworkInstance[key]; ok {
		return lm
	}
	return nil
}

// DeleteNetworkInstance deletes the value with the specified keys from
// the receiver SrlNokiaSystem_System_Maintenance_Group_Members_Bgp. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaSystem_System_Maintenance_Group_Members_Bgp) DeleteNetworkInstance(Name string) {
	key := Name

	delete(t.NetworkInstance, key)
}

// AppendNetworkInstance appends the supplied SrlNokiaSystem_System_Maintenance_Group_Members_Bgp_NetworkInstance struct to the
// list NetworkInstance of SrlNokiaSystem_System_Maintenance_Group_Members_Bgp. If the key value(s) specified in
// the supplied SrlNokiaSystem_System_Maintenance_Group_Members_Bgp_NetworkInstance already exist in the list, an error is
// returned.
func (t *SrlNokiaSystem_System_Maintenance_Group_Members_Bgp) AppendNetworkInstance(
	v *SrlNokiaSystem_System_Maintenance_Group_Members_Bgp_NetworkInstance,
) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NetworkInstance == nil {
		t.NetworkInstance = make(map[string]*SrlNokiaSystem_System_Maintenance_Group_Members_Bgp_NetworkInstance)
	}

	if _, ok := t.NetworkInstance[key]; ok {
		return fmt.Errorf("duplicate key for list NetworkInstance %v", key)
	}

	t.NetworkInstance[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Maintenance_Group_Members_Bgp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Maintenance_Group_Members_Bgp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.NetworkInstance {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Maintenance_Group_Members_Bgp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Maintenance_Group_Members_Bgp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Maintenance_Group_Members_Bgp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Maintenance_Group_Members_Bgp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Maintenance_Group_Members_Bgp.
func (*SrlNokiaSystem_System_Maintenance_Group_Members_Bgp) ΛBelongingModule() string {
	return "srl_nokia-maintenance-mode"
}

// SrlNokiaSystem_System_Maintenance_Group_Members_Bgp_NetworkInstance represents the /srl_nokia-system/system/maintenance/group/members/bgp/network-instance YANG schema element.
type SrlNokiaSystem_System_Maintenance_Group_Members_Bgp_NetworkInstance struct {
	Name      *string  `path:"name" module:"srl_nokia-maintenance-mode"`
	Neighbor  []string `path:"neighbor" module:"srl_nokia-maintenance-mode"`
	PeerGroup []string `path:"peer-group" module:"srl_nokia-maintenance-mode"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Maintenance_Group_Members_Bgp_NetworkInstance implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Maintenance_Group_Members_Bgp_NetworkInstance) IsYANGGoStruct() {}

// GetName retrieves the value of the leaf Name from the SrlNokiaSystem_System_Maintenance_Group_Members_Bgp_NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Maintenance_Group_Members_Bgp_NetworkInstance) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetNeighbor retrieves the value of the leaf Neighbor from the SrlNokiaSystem_System_Maintenance_Group_Members_Bgp_NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Neighbor is set, it can
// safely use t.GetNeighbor() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Neighbor == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Maintenance_Group_Members_Bgp_NetworkInstance) GetNeighbor() []string {
	if t == nil || t.Neighbor == nil {
		return nil
	}
	return t.Neighbor
}

// GetPeerGroup retrieves the value of the leaf PeerGroup from the SrlNokiaSystem_System_Maintenance_Group_Members_Bgp_NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PeerGroup is set, it can
// safely use t.GetPeerGroup() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PeerGroup == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Maintenance_Group_Members_Bgp_NetworkInstance) GetPeerGroup() []string {
	if t == nil || t.PeerGroup == nil {
		return nil
	}
	return t.PeerGroup
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Maintenance_Group_Members_Bgp_NetworkInstance
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Maintenance_Group_Members_Bgp_NetworkInstance) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_Maintenance_Group_Members_Bgp_NetworkInstance struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_Maintenance_Group_Members_Bgp_NetworkInstance) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Maintenance_Group_Members_Bgp_NetworkInstance) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Maintenance_Group_Members_Bgp_NetworkInstance"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Maintenance_Group_Members_Bgp_NetworkInstance) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Maintenance_Group_Members_Bgp_NetworkInstance) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Maintenance_Group_Members_Bgp_NetworkInstance.
func (*SrlNokiaSystem_System_Maintenance_Group_Members_Bgp_NetworkInstance) ΛBelongingModule() string {
	return "srl_nokia-maintenance-mode"
}

// SrlNokiaSystem_System_Maintenance_Group_Members_Isis represents the /srl_nokia-system/system/maintenance/group/members/isis YANG schema element.
type SrlNokiaSystem_System_Maintenance_Group_Members_Isis struct {
	NetworkInstances []string `path:"network-instances" module:"srl_nokia-maintenance-mode"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Maintenance_Group_Members_Isis implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Maintenance_Group_Members_Isis) IsYANGGoStruct() {}

// GetNetworkInstances retrieves the value of the leaf NetworkInstances from the SrlNokiaSystem_System_Maintenance_Group_Members_Isis
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NetworkInstances is set, it can
// safely use t.GetNetworkInstances() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NetworkInstances == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Maintenance_Group_Members_Isis) GetNetworkInstances() []string {
	if t == nil || t.NetworkInstances == nil {
		return nil
	}
	return t.NetworkInstances
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Maintenance_Group_Members_Isis
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Maintenance_Group_Members_Isis) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Maintenance_Group_Members_Isis) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Maintenance_Group_Members_Isis"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Maintenance_Group_Members_Isis) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Maintenance_Group_Members_Isis) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Maintenance_Group_Members_Isis.
func (*SrlNokiaSystem_System_Maintenance_Group_Members_Isis) ΛBelongingModule() string {
	return "srl_nokia-maintenance-mode"
}
