/*
Package ygotsrl is a generated package which contains definitions
of structs which represent a YANG schema. The generated schema can be
compressed by a series of transformations (compression was false
in this case).

This package was generated by /home/hans/go/pkg/mod/github.com/openconfig/ygot@v0.29.17/genutil/names.go
using the following YANG input files:
	- work/srlinux-yang-models/srl_nokia/models/acl/srl_nokia-acl-policers.yang
	- work/srlinux-yang-models/srl_nokia/models/acl/srl_nokia-acl-qos.yang
	- work/srlinux-yang-models/srl_nokia/models/acl/srl_nokia-acl.yang
	- work/srlinux-yang-models/srl_nokia/models/acl/srl_nokia-packet-match-types.yang
	- work/srlinux-yang-models/srl_nokia/models/bfd/srl_nokia-bfd.yang
	- work/srlinux-yang-models/srl_nokia/models/bfd/srl_nokia-micro-bfd.yang
	- work/srlinux-yang-models/srl_nokia/models/common/srl_nokia-common.yang
	- work/srlinux-yang-models/srl_nokia/models/common/srl_nokia-extensions.yang
	- work/srlinux-yang-models/srl_nokia/models/common/srl_nokia-features.yang
	- work/srlinux-yang-models/srl_nokia/models/ethcfm/srl_nokia-ethcfm-types.yang
	- work/srlinux-yang-models/srl_nokia/models/ethcfm/srl_nokia-ethcfm.yang
	- work/srlinux-yang-models/srl_nokia/models/ethcfm/srl_nokia-oam-pm-ethcfm.yang
	- work/srlinux-yang-models/srl_nokia/models/grpc/srl_nokia-gnsi-authz.yang
	- work/srlinux-yang-models/srl_nokia/models/grpc/srl_nokia-gnsi-certz.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-if-ip.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-if-mpls.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-bridge-table-mac-duplication-entries.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-bridge-table-mac-learning-entries.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-bridge-table-mac-table.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-bridge-table-statistics.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-bridge-table.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-ethernet-segment-association.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-ip-dhcp-relay.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-ip-dhcp-server.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-ip-dhcp.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-ip-vrrp.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-l2cp.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-lag.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-local-mirror-destination.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-nbr-evpn.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-nbr-virtual-ip-discovery.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-nbr.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-p4rt.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-router-adv.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-vlans.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-vxdp.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-lacp.yang
	- work/srlinux-yang-models/srl_nokia/models/ipamps/srl_nokia-ippm-source-udp-pool.yang
	- work/srlinux-yang-models/srl_nokia/models/ipamps/srl_nokia-link-measurement.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-aggregate-routes.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bgp-evpn-bgp-instance-mpls-bridge-table-multicast-destinations.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bgp-evpn-bgp-instance-mpls-bridge-table-statistics.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bgp-evpn-bgp-instance-mpls-bridge-table-unicast-destinations.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bgp-evpn-bgp-instance-mpls-vpws-destinations.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bgp-evpn.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bgp-ipvpn.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bgp-vpn.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bgp.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table-mac-duplication-entries.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table-mac-duplication.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table-mac-learning-entries.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table-mac-learning.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table-mac-limit.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table-mac-table.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table-proxy-arp-nd.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table-reserved-macs.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table-shg.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table-static-mac.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-connection-point.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-icmp.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-igmp-snooping.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-igmp-types.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-igmp.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-ip-route-tables.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-isis-lsdb-types.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-isis-lsdb.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-isis.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-ldp.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-linux.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-maintenance-policies.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-mld-snooping.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-mld.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-mpls-route-tables.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-mpls.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-multicast-mfib-tables.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-mvpn-l3.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-network-instance-mtu.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-network-instance.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-next-hop-groups.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-ospf-lsdb.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-ospf-types.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-ospf.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-ospfv3-lsas.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-pcep.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-pim.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-policy-forwarding.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-rib-bgp.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-segment-routing.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-static-routes.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-tcp-udp.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-te-policies.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-traffic-engineering.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-tunnel-tables.yang
	- work/srlinux-yang-models/srl_nokia/models/oam/srl_nokia-lsp-ping-trace.yang
	- work/srlinux-yang-models/srl_nokia/models/oam/srl_nokia-oam-pm-ip.yang
	- work/srlinux-yang-models/srl_nokia/models/oam/srl_nokia-oam-pm-types.yang
	- work/srlinux-yang-models/srl_nokia/models/oam/srl_nokia-oam-pm.yang
	- work/srlinux-yang-models/srl_nokia/models/oam/srl_nokia-oam.yang
	- work/srlinux-yang-models/srl_nokia/models/oam/srl_nokia-stamp.yang
	- work/srlinux-yang-models/srl_nokia/models/oam/srl_nokia-twamp.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-acl.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-cgroup.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-chassis.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-control.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-cpu.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-datapath-resources.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-disk.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-fabric.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-fan.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-healthz.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-lc.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-linecard-fib.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-memory.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-mtu.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-p4rt.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-pipeline-counters.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-psu.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-qos.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-redundancy.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-resource-mgmt.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-resource-monitoring.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-secure-boot.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-tcam.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-tpm.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-vxdp.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform.yang
	- work/srlinux-yang-models/srl_nokia/models/qos/srl_nokia-qos-policers.yang
	- work/srlinux-yang-models/srl_nokia/models/qos/srl_nokia-qos.yang
	- work/srlinux-yang-models/srl_nokia/models/routing-policy/srl_nokia-policy-types.yang
	- work/srlinux-yang-models/srl_nokia/models/routing-policy/srl_nokia-routing-policy.yang
	- work/srlinux-yang-models/srl_nokia/models/sync/srl_nokia-sync-freq.yang
	- work/srlinux-yang-models/srl_nokia/models/sync/srl_nokia-sync-interfaces.yang
	- work/srlinux-yang-models/srl_nokia/models/sync/srl_nokia-sync-ptp.yang
	- work/srlinux-yang-models/srl_nokia/models/sync/srl_nokia-sync-types.yang
	- work/srlinux-yang-models/srl_nokia/models/sync/srl_nokia-sync.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-aaa-password.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-aaa-radius.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-aaa-tacacs.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-aaa-types.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-aaa.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-app-mgmt.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-boot.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-configuration-role.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-configuration.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-dhcp-server.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-dns.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-event-handler.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-ftp.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-gnmi-server.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-gribi-server.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-json-rpc.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-keychains.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-license.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-lldp-types.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-lldp.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-load-balancing.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-logging.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-maintenance-mode.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-mirroring.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-mpls-label-management.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-mpls-services-evpn-label-management.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-mpls-services-network-instance-label-management.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-mtu.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-ntp.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-openconfig.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-p4rt-server.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-packet-link-qual.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-ra_guard.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-sflow.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-snmp-trace.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-snmp.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-ssh.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system-banner.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system-bridge-table-proxy-arp.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system-bridge-table.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system-info.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system-multicast-mfib-table.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system-multicast.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system-name.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system-network-instance-bgp-evpn-ethernet-segments.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system-network-instance-bgp-vpn.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system-network-instance.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system-protocols.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-timezone.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-tls.yang
	- work/srlinux-yang-models/srl_nokia/models/transport-security/srl_nokia-macsec.yang
	- work/srlinux-yang-models/srl_nokia/models/transport-security/srl_nokia-transport-security.yang
	- work/srlinux-yang-models/srl_nokia/models/tunnel/srl_nokia-tunnel-interfaces-vxlan-interface-bridge-table-multicast-destinations.yang
	- work/srlinux-yang-models/srl_nokia/models/tunnel/srl_nokia-tunnel-interfaces-vxlan-interface-bridge-table-unicast-destinations.yang
	- work/srlinux-yang-models/srl_nokia/models/tunnel/srl_nokia-tunnel-interfaces-vxlan-interface-bridge-table-unicast-es-destination-vteps.yang
	- work/srlinux-yang-models/srl_nokia/models/tunnel/srl_nokia-tunnel-interfaces-vxlan-interface-bridge-table.yang
	- work/srlinux-yang-models/srl_nokia/models/tunnel/srl_nokia-tunnel-interfaces.yang
	- work/srlinux-yang-models/srl_nokia/models/tunnel/srl_nokia-tunnel.yang
	- work/srlinux-yang-models/srl_nokia/models/tunnel/srl_nokia-vxlan-tunnel-vtep.yang
Imported modules were sourced from:
	- work/srlinux-yang-models/...
*/
package ygotsrl

import (
	"fmt"
	"reflect"

	"github.com/openconfig/ygot/ygot"
	"github.com/openconfig/ygot/ytypes"
)

// SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ExceedAction represents the /srl_nokia-qos/qos/policer-templates/policer-template/policer/exceed-action YANG schema element.
type SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ExceedAction struct {
	DropProbability E_SrlNokiaAclPolicers_DropProbabilityLevel `path:"drop-probability" module:"srl_nokia-acl-policers"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ExceedAction implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ExceedAction) IsYANGGoStruct() {}

// GetDropProbability retrieves the value of the leaf DropProbability from the SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ExceedAction
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DropProbability is set, it can
// safely use t.GetDropProbability() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DropProbability == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ExceedAction) GetDropProbability() E_SrlNokiaAclPolicers_DropProbabilityLevel {
	if t == nil || t.DropProbability == 0 {
		return SrlNokiaAclPolicers_DropProbabilityLevel_medium
	}
	return t.DropProbability
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ExceedAction
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ExceedAction) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.DropProbability == 0 {
		t.DropProbability = SrlNokiaAclPolicers_DropProbabilityLevel_medium
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ExceedAction) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ExceedAction"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ExceedAction) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ExceedAction) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ExceedAction.
func (*SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ExceedAction) ΛBelongingModule() string {
	return "srl_nokia-acl-policers"
}

// SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ForwardingClass represents the /srl_nokia-qos/qos/policer-templates/policer-template/policer/forwarding-class YANG schema element.
type SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ForwardingClass struct {
	Fc             SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ForwardingClass_Fc_Union `path:"fc" module:"srl_nokia-acl-policers"`
	ForwardingType []E_SrlNokiaAclPolicers_ForwardingType                                            `path:"forwarding-type" module:"srl_nokia-acl-policers"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ForwardingClass implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ForwardingClass) IsYANGGoStruct() {}

// GetFc retrieves the value of the leaf Fc from the SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ForwardingClass
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Fc is set, it can
// safely use t.GetFc() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Fc == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ForwardingClass) GetFc() SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ForwardingClass_Fc_Union {
	if t == nil || t.Fc == nil {
		return nil
	}
	return t.Fc
}

// GetForwardingType retrieves the value of the leaf ForwardingType from the SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ForwardingClass
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ForwardingType is set, it can
// safely use t.GetForwardingType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ForwardingType == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ForwardingClass) GetForwardingType() []E_SrlNokiaAclPolicers_ForwardingType {
	if t == nil || t.ForwardingType == nil {
		return nil
	}
	return t.ForwardingType
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ForwardingClass
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ForwardingClass) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ForwardingClass struct, which is a YANG list entry.
func (t *SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ForwardingClass) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"fc": t.Fc,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ForwardingClass) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ForwardingClass"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ForwardingClass) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ForwardingClass) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ForwardingClass.
func (*SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ForwardingClass) ΛBelongingModule() string {
	return "srl_nokia-acl-policers"
}

// SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ViolateAction represents the /srl_nokia-qos/qos/policer-templates/policer-template/policer/violate-action YANG schema element.
type SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ViolateAction struct {
	Drop            YANGEmpty                                  `path:"drop" module:"srl_nokia-acl-policers"`
	DropProbability E_SrlNokiaAclPolicers_DropProbabilityLevel `path:"drop-probability" module:"srl_nokia-acl-policers"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ViolateAction implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ViolateAction) IsYANGGoStruct() {}

// GetDrop retrieves the value of the leaf Drop from the SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ViolateAction
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Drop is set, it can
// safely use t.GetDrop() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Drop == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ViolateAction) GetDrop() YANGEmpty {
	if t == nil || t.Drop == false {
		return false
	}
	return t.Drop
}

// GetDropProbability retrieves the value of the leaf DropProbability from the SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ViolateAction
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DropProbability is set, it can
// safely use t.GetDropProbability() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DropProbability == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ViolateAction) GetDropProbability() E_SrlNokiaAclPolicers_DropProbabilityLevel {
	if t == nil || t.DropProbability == 0 {
		return SrlNokiaAclPolicers_DropProbabilityLevel_high
	}
	return t.DropProbability
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ViolateAction
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ViolateAction) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.DropProbability == 0 {
		t.DropProbability = SrlNokiaAclPolicers_DropProbabilityLevel_high
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ViolateAction) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ViolateAction"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ViolateAction) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ViolateAction) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ViolateAction.
func (*SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ViolateAction) ΛBelongingModule() string {
	return "srl_nokia-acl-policers"
}

// SrlNokiaQos_Qos_QueueTemplates represents the /srl_nokia-qos/qos/queue-templates YANG schema element.
type SrlNokiaQos_Qos_QueueTemplates struct {
	QueueTemplate map[string]*SrlNokiaQos_Qos_QueueTemplates_QueueTemplate `path:"queue-template" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_QueueTemplates implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_QueueTemplates) IsYANGGoStruct() {}

// NewQueueTemplate creates a new entry in the QueueTemplate list of the
// SrlNokiaQos_Qos_QueueTemplates struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaQos_Qos_QueueTemplates) NewQueueTemplate(Name string) (*SrlNokiaQos_Qos_QueueTemplates_QueueTemplate, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.QueueTemplate == nil {
		t.QueueTemplate = make(map[string]*SrlNokiaQos_Qos_QueueTemplates_QueueTemplate)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.QueueTemplate[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list QueueTemplate", key)
	}

	t.QueueTemplate[key] = &SrlNokiaQos_Qos_QueueTemplates_QueueTemplate{
		Name: &Name,
	}

	return t.QueueTemplate[key], nil
}

// RenameQueueTemplate renames an entry in the list QueueTemplate within
// the SrlNokiaQos_Qos_QueueTemplates struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaQos_Qos_QueueTemplates) RenameQueueTemplate(oldK, newK string) error {
	if _, ok := t.QueueTemplate[newK]; ok {
		return fmt.Errorf("key %v already exists in QueueTemplate", newK)
	}

	e, ok := t.QueueTemplate[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in QueueTemplate", oldK)
	}
	e.Name = &newK

	t.QueueTemplate[newK] = e
	delete(t.QueueTemplate, oldK)
	return nil
}

// GetOrCreateQueueTemplate retrieves the value with the specified keys from
// the receiver SrlNokiaQos_Qos_QueueTemplates. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaQos_Qos_QueueTemplates) GetOrCreateQueueTemplate(Name string) *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate {
	key := Name

	if v, ok := t.QueueTemplate[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewQueueTemplate(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateQueueTemplate got unexpected error: %v", err))
	}
	return v
}

// GetQueueTemplate retrieves the value with the specified key from
// the QueueTemplate map field of SrlNokiaQos_Qos_QueueTemplates. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaQos_Qos_QueueTemplates) GetQueueTemplate(Name string) *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.QueueTemplate[key]; ok {
		return lm
	}
	return nil
}

// DeleteQueueTemplate deletes the value with the specified keys from
// the receiver SrlNokiaQos_Qos_QueueTemplates. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaQos_Qos_QueueTemplates) DeleteQueueTemplate(Name string) {
	key := Name

	delete(t.QueueTemplate, key)
}

// AppendQueueTemplate appends the supplied SrlNokiaQos_Qos_QueueTemplates_QueueTemplate struct to the
// list QueueTemplate of SrlNokiaQos_Qos_QueueTemplates. If the key value(s) specified in
// the supplied SrlNokiaQos_Qos_QueueTemplates_QueueTemplate already exist in the list, an error is
// returned.
func (t *SrlNokiaQos_Qos_QueueTemplates) AppendQueueTemplate(v *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.QueueTemplate == nil {
		t.QueueTemplate = make(map[string]*SrlNokiaQos_Qos_QueueTemplates_QueueTemplate)
	}

	if _, ok := t.QueueTemplate[key]; ok {
		return fmt.Errorf("duplicate key for list QueueTemplate %v", key)
	}

	t.QueueTemplate[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_QueueTemplates
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_QueueTemplates) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.QueueTemplate {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_QueueTemplates) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_QueueTemplates"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_QueueTemplates) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_QueueTemplates) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_QueueTemplates.
func (*SrlNokiaQos_Qos_QueueTemplates) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_QueueTemplates_QueueTemplate represents the /srl_nokia-qos/qos/queue-templates/queue-template YANG schema element.
type SrlNokiaQos_Qos_QueueTemplates_QueueTemplate struct {
	ActiveQueueManagement *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement `path:"active-queue-management" module:"srl_nokia-qos" yangPresence:"true"`
	Name                  *string                                                             `path:"name" module:"srl_nokia-qos"`
	QueueDepth            *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_QueueDepth            `path:"queue-depth" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_QueueTemplates_QueueTemplate implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_QueueTemplates_QueueTemplate) IsYANGGoStruct() {}

// GetOrCreateActiveQueueManagement retrieves the value of the ActiveQueueManagement field
// or returns the existing field if it already exists.
func (t *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate) GetOrCreateActiveQueueManagement() *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement {
	if t.ActiveQueueManagement != nil {
		return t.ActiveQueueManagement
	}
	t.ActiveQueueManagement = &SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement{}
	return t.ActiveQueueManagement
}

// GetOrCreateQueueDepth retrieves the value of the QueueDepth field
// or returns the existing field if it already exists.
func (t *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate) GetOrCreateQueueDepth() *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_QueueDepth {
	if t.QueueDepth != nil {
		return t.QueueDepth
	}
	t.QueueDepth = &SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_QueueDepth{}
	return t.QueueDepth
}

// GetActiveQueueManagement returns the value of the ActiveQueueManagement struct pointer
// from SrlNokiaQos_Qos_QueueTemplates_QueueTemplate. If the receiver or the field ActiveQueueManagement is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate) GetActiveQueueManagement() *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement {
	if t != nil && t.ActiveQueueManagement != nil {
		return t.ActiveQueueManagement
	}
	return nil
}

// GetQueueDepth returns the value of the QueueDepth struct pointer
// from SrlNokiaQos_Qos_QueueTemplates_QueueTemplate. If the receiver or the field QueueDepth is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate) GetQueueDepth() *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_QueueDepth {
	if t != nil && t.QueueDepth != nil {
		return t.QueueDepth
	}
	return nil
}

// GetName retrieves the value of the leaf Name from the SrlNokiaQos_Qos_QueueTemplates_QueueTemplate
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_QueueTemplates_QueueTemplate
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.ActiveQueueManagement.PopulateDefaults()
	t.QueueDepth.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the SrlNokiaQos_Qos_QueueTemplates_QueueTemplate struct, which is a YANG list entry.
func (t *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_QueueTemplates_QueueTemplate"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_QueueTemplates_QueueTemplate.
func (*SrlNokiaQos_Qos_QueueTemplates_QueueTemplate) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement represents the /srl_nokia-qos/qos/queue-templates/queue-template/active-queue-management YANG schema element.
type SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement struct {
	EcnSlope     map[E_SrlNokiaQos_EcnDropProbability]*SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_EcnSlope                                                  `path:"ecn-slope" module:"srl_nokia-qos"`
	WeightFactor *uint8                                                                                                                                                             `path:"weight-factor" module:"srl_nokia-qos"`
	WredSlope    map[SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope_Key]*SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope `path:"wred-slope" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement) IsYANGGoStruct() {}

// SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope_Key represents the key for list WredSlope of element /srl_nokia-qos/qos/queue-templates/queue-template/active-queue-management.
type SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope_Key struct {
	TrafficType     E_SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope_TrafficType `path:"traffic-type"`
	DropProbability E_SrlNokiaCommon_DropProbability                                                           `path:"drop-probability"`
}

// IsYANGGoKeyStruct ensures that SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope_Key partially implements the
// yang.GoKeyStruct interface. This allows functions that need to
// handle this key struct to identify it as being generated by gogen.
func (SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope_Key) IsYANGGoKeyStruct() {
}

// ΛListKeyMap returns the values of the SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope_Key key struct.
func (t SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope_Key) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"traffic-type":     t.TrafficType,
		"drop-probability": t.DropProbability,
	}, nil
}

// NewEcnSlope creates a new entry in the EcnSlope list of the
// SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement) NewEcnSlope(
	EcnDropProbability E_SrlNokiaQos_EcnDropProbability,
) (*SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_EcnSlope, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.EcnSlope == nil {
		t.EcnSlope = make(map[E_SrlNokiaQos_EcnDropProbability]*SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_EcnSlope)
	}

	key := EcnDropProbability

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.EcnSlope[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list EcnSlope", key)
	}

	t.EcnSlope[key] = &SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_EcnSlope{
		EcnDropProbability: EcnDropProbability,
	}

	return t.EcnSlope[key], nil
}

// RenameEcnSlope renames an entry in the list EcnSlope within
// the SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement) RenameEcnSlope(oldK, newK E_SrlNokiaQos_EcnDropProbability) error {
	if _, ok := t.EcnSlope[newK]; ok {
		return fmt.Errorf("key %v already exists in EcnSlope", newK)
	}

	e, ok := t.EcnSlope[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in EcnSlope", oldK)
	}
	e.EcnDropProbability = newK

	t.EcnSlope[newK] = e
	delete(t.EcnSlope, oldK)
	return nil
}

// GetOrCreateEcnSlope retrieves the value with the specified keys from
// the receiver SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement) GetOrCreateEcnSlope(
	EcnDropProbability E_SrlNokiaQos_EcnDropProbability,
) *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_EcnSlope {
	key := EcnDropProbability

	if v, ok := t.EcnSlope[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEcnSlope(EcnDropProbability)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEcnSlope got unexpected error: %v", err))
	}
	return v
}

// GetEcnSlope retrieves the value with the specified key from
// the EcnSlope map field of SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement) GetEcnSlope(
	EcnDropProbability E_SrlNokiaQos_EcnDropProbability,
) *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_EcnSlope {
	if t == nil {
		return nil
	}

	key := EcnDropProbability

	if lm, ok := t.EcnSlope[key]; ok {
		return lm
	}
	return nil
}

// DeleteEcnSlope deletes the value with the specified keys from
// the receiver SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement) DeleteEcnSlope(EcnDropProbability E_SrlNokiaQos_EcnDropProbability) {
	key := EcnDropProbability

	delete(t.EcnSlope, key)
}

// AppendEcnSlope appends the supplied SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_EcnSlope struct to the
// list EcnSlope of SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement. If the key value(s) specified in
// the supplied SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_EcnSlope already exist in the list, an error is
// returned.
func (t *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement) AppendEcnSlope(
	v *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_EcnSlope,
) error {
	key := v.EcnDropProbability

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.EcnSlope == nil {
		t.EcnSlope = make(map[E_SrlNokiaQos_EcnDropProbability]*SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_EcnSlope)
	}

	if _, ok := t.EcnSlope[key]; ok {
		return fmt.Errorf("duplicate key for list EcnSlope %v", key)
	}

	t.EcnSlope[key] = v
	return nil
}

// NewWredSlope creates a new entry in the WredSlope list of the
// SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement) NewWredSlope(
	TrafficType E_SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope_TrafficType,
	DropProbability E_SrlNokiaCommon_DropProbability,
) (*SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.WredSlope == nil {
		t.WredSlope = make(map[SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope_Key]*SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope)
	}

	key := SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope_Key{
		TrafficType:     TrafficType,
		DropProbability: DropProbability,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.WredSlope[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list WredSlope", key)
	}

	t.WredSlope[key] = &SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope{
		TrafficType:     TrafficType,
		DropProbability: DropProbability,
	}

	return t.WredSlope[key], nil
}

// RenameWredSlope renames an entry in the list WredSlope within
// the SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement) RenameWredSlope(
	oldK, newK SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope_Key,
) error {
	if _, ok := t.WredSlope[newK]; ok {
		return fmt.Errorf("key %v already exists in WredSlope", newK)
	}

	e, ok := t.WredSlope[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in WredSlope", oldK)
	}
	e.TrafficType = newK.TrafficType
	e.DropProbability = newK.DropProbability

	t.WredSlope[newK] = e
	delete(t.WredSlope, oldK)
	return nil
}

// GetOrCreateWredSlope retrieves the value with the specified keys from
// the receiver SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement) GetOrCreateWredSlope(
	TrafficType E_SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope_TrafficType,
	DropProbability E_SrlNokiaCommon_DropProbability,
) *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope {
	key := SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope_Key{
		TrafficType:     TrafficType,
		DropProbability: DropProbability,
	}

	if v, ok := t.WredSlope[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewWredSlope(TrafficType, DropProbability)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateWredSlope got unexpected error: %v", err))
	}
	return v
}

// GetWredSlope retrieves the value with the specified key from
// the WredSlope map field of SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement) GetWredSlope(
	TrafficType E_SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope_TrafficType,
	DropProbability E_SrlNokiaCommon_DropProbability,
) *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope {
	if t == nil {
		return nil
	}

	key := SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope_Key{
		TrafficType:     TrafficType,
		DropProbability: DropProbability,
	}

	if lm, ok := t.WredSlope[key]; ok {
		return lm
	}
	return nil
}

// DeleteWredSlope deletes the value with the specified keys from
// the receiver SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement) DeleteWredSlope(
	TrafficType E_SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope_TrafficType, DropProbability E_SrlNokiaCommon_DropProbability,
) {
	key := SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope_Key{
		TrafficType:     TrafficType,
		DropProbability: DropProbability,
	}

	delete(t.WredSlope, key)
}

// AppendWredSlope appends the supplied SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope struct to the
// list WredSlope of SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement. If the key value(s) specified in
// the supplied SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope already exist in the list, an error is
// returned.
func (t *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement) AppendWredSlope(
	v *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope,
) error {
	key := SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope_Key{
		TrafficType:     v.TrafficType,
		DropProbability: v.DropProbability,
	}

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.WredSlope == nil {
		t.WredSlope = make(map[SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope_Key]*SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope)
	}

	if _, ok := t.WredSlope[key]; ok {
		return fmt.Errorf("duplicate key for list WredSlope %v", key)
	}

	t.WredSlope[key] = v
	return nil
}

// GetWeightFactor retrieves the value of the leaf WeightFactor from the SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if WeightFactor is set, it can
// safely use t.GetWeightFactor() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.WeightFactor == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement) GetWeightFactor() uint8 {
	if t == nil || t.WeightFactor == nil {
		return 0
	}
	return *t.WeightFactor
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.WeightFactor == nil {
		var v uint8 = 0
		t.WeightFactor = &v
	}
	for _, e := range t.EcnSlope {
		e.PopulateDefaults()
	}
	for _, e := range t.WredSlope {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement.
func (*SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_EcnSlope represents the /srl_nokia-qos/qos/queue-templates/queue-template/active-queue-management/ecn-slope YANG schema element.
type SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_EcnSlope struct {
	EcnDropProbability  E_SrlNokiaQos_EcnDropProbability `path:"ecn-drop-probability" module:"srl_nokia-qos"`
	MaxProbability      *uint8                           `path:"max-probability" module:"srl_nokia-qos"`
	MaxThresholdPercent *uint8                           `path:"max-threshold-percent" module:"srl_nokia-qos"`
	MinThresholdPercent *uint8                           `path:"min-threshold-percent" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_EcnSlope implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_EcnSlope) IsYANGGoStruct() {
}

// GetEcnDropProbability retrieves the value of the leaf EcnDropProbability from the SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_EcnSlope
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EcnDropProbability is set, it can
// safely use t.GetEcnDropProbability() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EcnDropProbability == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_EcnSlope) GetEcnDropProbability() E_SrlNokiaQos_EcnDropProbability {
	if t == nil || t.EcnDropProbability == 0 {
		return 0
	}
	return t.EcnDropProbability
}

// GetMaxProbability retrieves the value of the leaf MaxProbability from the SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_EcnSlope
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MaxProbability is set, it can
// safely use t.GetMaxProbability() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MaxProbability == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_EcnSlope) GetMaxProbability() uint8 {
	if t == nil || t.MaxProbability == nil {
		return 0
	}
	return *t.MaxProbability
}

// GetMaxThresholdPercent retrieves the value of the leaf MaxThresholdPercent from the SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_EcnSlope
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MaxThresholdPercent is set, it can
// safely use t.GetMaxThresholdPercent() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MaxThresholdPercent == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_EcnSlope) GetMaxThresholdPercent() uint8 {
	if t == nil || t.MaxThresholdPercent == nil {
		return 100
	}
	return *t.MaxThresholdPercent
}

// GetMinThresholdPercent retrieves the value of the leaf MinThresholdPercent from the SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_EcnSlope
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MinThresholdPercent is set, it can
// safely use t.GetMinThresholdPercent() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MinThresholdPercent == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_EcnSlope) GetMinThresholdPercent() uint8 {
	if t == nil || t.MinThresholdPercent == nil {
		return 100
	}
	return *t.MinThresholdPercent
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_EcnSlope
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_EcnSlope) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.MaxProbability == nil {
		var v uint8 = 0
		t.MaxProbability = &v
	}
	if t.MaxThresholdPercent == nil {
		var v uint8 = 100
		t.MaxThresholdPercent = &v
	}
	if t.MinThresholdPercent == nil {
		var v uint8 = 100
		t.MinThresholdPercent = &v
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_EcnSlope struct, which is a YANG list entry.
func (t *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_EcnSlope) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"ecn-drop-probability": t.EcnDropProbability,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_EcnSlope) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_EcnSlope"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_EcnSlope) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_EcnSlope) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_EcnSlope.
func (*SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_EcnSlope) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope represents the /srl_nokia-qos/qos/queue-templates/queue-template/active-queue-management/wred-slope YANG schema element.
type SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope struct {
	DropProbability     E_SrlNokiaCommon_DropProbability                                                           `path:"drop-probability" module:"srl_nokia-qos"`
	MaxProbability      *uint8                                                                                     `path:"max-probability" module:"srl_nokia-qos"`
	MaxThresholdPercent *uint8                                                                                     `path:"max-threshold-percent" module:"srl_nokia-qos"`
	MinThresholdPercent *uint8                                                                                     `path:"min-threshold-percent" module:"srl_nokia-qos"`
	TrafficType         E_SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope_TrafficType `path:"traffic-type" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope) IsYANGGoStruct() {
}

// GetDropProbability retrieves the value of the leaf DropProbability from the SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DropProbability is set, it can
// safely use t.GetDropProbability() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DropProbability == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope) GetDropProbability() E_SrlNokiaCommon_DropProbability {
	if t == nil || t.DropProbability == 0 {
		return 0
	}
	return t.DropProbability
}

// GetMaxProbability retrieves the value of the leaf MaxProbability from the SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MaxProbability is set, it can
// safely use t.GetMaxProbability() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MaxProbability == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope) GetMaxProbability() uint8 {
	if t == nil || t.MaxProbability == nil {
		return 0
	}
	return *t.MaxProbability
}

// GetMaxThresholdPercent retrieves the value of the leaf MaxThresholdPercent from the SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MaxThresholdPercent is set, it can
// safely use t.GetMaxThresholdPercent() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MaxThresholdPercent == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope) GetMaxThresholdPercent() uint8 {
	if t == nil || t.MaxThresholdPercent == nil {
		return 100
	}
	return *t.MaxThresholdPercent
}

// GetMinThresholdPercent retrieves the value of the leaf MinThresholdPercent from the SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MinThresholdPercent is set, it can
// safely use t.GetMinThresholdPercent() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MinThresholdPercent == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope) GetMinThresholdPercent() uint8 {
	if t == nil || t.MinThresholdPercent == nil {
		return 100
	}
	return *t.MinThresholdPercent
}

// GetTrafficType retrieves the value of the leaf TrafficType from the SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TrafficType is set, it can
// safely use t.GetTrafficType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TrafficType == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope) GetTrafficType() E_SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope_TrafficType {
	if t == nil || t.TrafficType == 0 {
		return 0
	}
	return t.TrafficType
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.MaxProbability == nil {
		var v uint8 = 0
		t.MaxProbability = &v
	}
	if t.MaxThresholdPercent == nil {
		var v uint8 = 100
		t.MaxThresholdPercent = &v
	}
	if t.MinThresholdPercent == nil {
		var v uint8 = 100
		t.MinThresholdPercent = &v
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope struct, which is a YANG list entry.
func (t *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"drop-probability": t.DropProbability,
		"traffic-type":     t.TrafficType,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope.
func (*SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_QueueDepth represents the /srl_nokia-qos/qos/queue-templates/queue-template/queue-depth YANG schema element.
type SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_QueueDepth struct {
	HighThresholdBytes *uint32 `path:"high-threshold-bytes" module:"srl_nokia-qos"`
	MaximumBurstSize   *uint32 `path:"maximum-burst-size" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_QueueDepth implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_QueueDepth) IsYANGGoStruct() {}

// GetHighThresholdBytes retrieves the value of the leaf HighThresholdBytes from the SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_QueueDepth
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if HighThresholdBytes is set, it can
// safely use t.GetHighThresholdBytes() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.HighThresholdBytes == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_QueueDepth) GetHighThresholdBytes() uint32 {
	if t == nil || t.HighThresholdBytes == nil {
		return 0
	}
	return *t.HighThresholdBytes
}

// GetMaximumBurstSize retrieves the value of the leaf MaximumBurstSize from the SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_QueueDepth
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MaximumBurstSize is set, it can
// safely use t.GetMaximumBurstSize() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MaximumBurstSize == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_QueueDepth) GetMaximumBurstSize() uint32 {
	if t == nil || t.MaximumBurstSize == nil {
		return 0
	}
	return *t.MaximumBurstSize
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_QueueDepth
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_QueueDepth) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.HighThresholdBytes == nil {
		var v uint32 = 0
		t.HighThresholdBytes = &v
	}
	if t.MaximumBurstSize == nil {
		var v uint32 = 0
		t.MaximumBurstSize = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_QueueDepth) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_QueueDepth"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_QueueDepth) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_QueueDepth) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_QueueDepth.
func (*SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_QueueDepth) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_Queues represents the /srl_nokia-qos/qos/queues YANG schema element.
type SrlNokiaQos_Qos_Queues struct {
	Queue map[string]*SrlNokiaQos_Qos_Queues_Queue `path:"queue" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_Queues implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_Queues) IsYANGGoStruct() {}

// NewQueue creates a new entry in the Queue list of the
// SrlNokiaQos_Qos_Queues struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaQos_Qos_Queues) NewQueue(Name string) (*SrlNokiaQos_Qos_Queues_Queue, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Queue == nil {
		t.Queue = make(map[string]*SrlNokiaQos_Qos_Queues_Queue)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Queue[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Queue", key)
	}

	t.Queue[key] = &SrlNokiaQos_Qos_Queues_Queue{
		Name: &Name,
	}

	return t.Queue[key], nil
}

// RenameQueue renames an entry in the list Queue within
// the SrlNokiaQos_Qos_Queues struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaQos_Qos_Queues) RenameQueue(oldK, newK string) error {
	if _, ok := t.Queue[newK]; ok {
		return fmt.Errorf("key %v already exists in Queue", newK)
	}

	e, ok := t.Queue[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Queue", oldK)
	}
	e.Name = &newK

	t.Queue[newK] = e
	delete(t.Queue, oldK)
	return nil
}

// GetOrCreateQueue retrieves the value with the specified keys from
// the receiver SrlNokiaQos_Qos_Queues. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaQos_Qos_Queues) GetOrCreateQueue(Name string) *SrlNokiaQos_Qos_Queues_Queue {
	key := Name

	if v, ok := t.Queue[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewQueue(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateQueue got unexpected error: %v", err))
	}
	return v
}

// GetQueue retrieves the value with the specified key from
// the Queue map field of SrlNokiaQos_Qos_Queues. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaQos_Qos_Queues) GetQueue(Name string) *SrlNokiaQos_Qos_Queues_Queue {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Queue[key]; ok {
		return lm
	}
	return nil
}

// DeleteQueue deletes the value with the specified keys from
// the receiver SrlNokiaQos_Qos_Queues. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaQos_Qos_Queues) DeleteQueue(Name string) {
	key := Name

	delete(t.Queue, key)
}

// AppendQueue appends the supplied SrlNokiaQos_Qos_Queues_Queue struct to the
// list Queue of SrlNokiaQos_Qos_Queues. If the key value(s) specified in
// the supplied SrlNokiaQos_Qos_Queues_Queue already exist in the list, an error is
// returned.
func (t *SrlNokiaQos_Qos_Queues) AppendQueue(v *SrlNokiaQos_Qos_Queues_Queue) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Queue == nil {
		t.Queue = make(map[string]*SrlNokiaQos_Qos_Queues_Queue)
	}

	if _, ok := t.Queue[key]; ok {
		return fmt.Errorf("duplicate key for list Queue %v", key)
	}

	t.Queue[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_Queues
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_Queues) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Queue {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_Queues) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_Queues"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_Queues) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_Queues) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_Queues.
func (*SrlNokiaQos_Qos_Queues) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_Queues_Queue represents the /srl_nokia-qos/qos/queues/queue YANG schema element.
type SrlNokiaQos_Qos_Queues_Queue struct {
	InterfacePool *uint8  `path:"interface-pool" module:"srl_nokia-qos"`
	Name          *string `path:"name" module:"srl_nokia-qos"`
	QueueIndex    *uint16 `path:"queue-index" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_Queues_Queue implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_Queues_Queue) IsYANGGoStruct() {}

// GetInterfacePool retrieves the value of the leaf InterfacePool from the SrlNokiaQos_Qos_Queues_Queue
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InterfacePool is set, it can
// safely use t.GetInterfacePool() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InterfacePool == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_Queues_Queue) GetInterfacePool() uint8 {
	if t == nil || t.InterfacePool == nil {
		return 0
	}
	return *t.InterfacePool
}

// GetName retrieves the value of the leaf Name from the SrlNokiaQos_Qos_Queues_Queue
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_Queues_Queue) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetQueueIndex retrieves the value of the leaf QueueIndex from the SrlNokiaQos_Qos_Queues_Queue
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if QueueIndex is set, it can
// safely use t.GetQueueIndex() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.QueueIndex == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_Queues_Queue) GetQueueIndex() uint16 {
	if t == nil || t.QueueIndex == nil {
		return 0
	}
	return *t.QueueIndex
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_Queues_Queue
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_Queues_Queue) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the SrlNokiaQos_Qos_Queues_Queue struct, which is a YANG list entry.
func (t *SrlNokiaQos_Qos_Queues_Queue) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_Queues_Queue) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_Queues_Queue"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_Queues_Queue) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_Queues_Queue) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_Queues_Queue.
func (*SrlNokiaQos_Qos_Queues_Queue) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_ResourceManagement represents the /srl_nokia-qos/qos/resource-management YANG schema element.
type SrlNokiaQos_Qos_ResourceManagement struct {
	DropZones                       *SrlNokiaQos_Qos_ResourceManagement_DropZones                       `path:"drop-zones" module:"srl_nokia-qos"`
	ForwardingClassResourcePriority *SrlNokiaQos_Qos_ResourceManagement_ForwardingClassResourcePriority `path:"forwarding-class-resource-priority" module:"srl_nokia-qos"`
	ResourceUtilizationThresholds   *SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds   `path:"resource-utilization-thresholds" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_ResourceManagement implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_ResourceManagement) IsYANGGoStruct() {}

// GetOrCreateDropZones retrieves the value of the DropZones field
// or returns the existing field if it already exists.
func (t *SrlNokiaQos_Qos_ResourceManagement) GetOrCreateDropZones() *SrlNokiaQos_Qos_ResourceManagement_DropZones {
	if t.DropZones != nil {
		return t.DropZones
	}
	t.DropZones = &SrlNokiaQos_Qos_ResourceManagement_DropZones{}
	return t.DropZones
}

// GetOrCreateForwardingClassResourcePriority retrieves the value of the ForwardingClassResourcePriority field
// or returns the existing field if it already exists.
func (t *SrlNokiaQos_Qos_ResourceManagement) GetOrCreateForwardingClassResourcePriority() *SrlNokiaQos_Qos_ResourceManagement_ForwardingClassResourcePriority {
	if t.ForwardingClassResourcePriority != nil {
		return t.ForwardingClassResourcePriority
	}
	t.ForwardingClassResourcePriority = &SrlNokiaQos_Qos_ResourceManagement_ForwardingClassResourcePriority{}
	return t.ForwardingClassResourcePriority
}

// GetOrCreateResourceUtilizationThresholds retrieves the value of the ResourceUtilizationThresholds field
// or returns the existing field if it already exists.
func (t *SrlNokiaQos_Qos_ResourceManagement) GetOrCreateResourceUtilizationThresholds() *SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds {
	if t.ResourceUtilizationThresholds != nil {
		return t.ResourceUtilizationThresholds
	}
	t.ResourceUtilizationThresholds = &SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds{}
	return t.ResourceUtilizationThresholds
}

// GetDropZones returns the value of the DropZones struct pointer
// from SrlNokiaQos_Qos_ResourceManagement. If the receiver or the field DropZones is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaQos_Qos_ResourceManagement) GetDropZones() *SrlNokiaQos_Qos_ResourceManagement_DropZones {
	if t != nil && t.DropZones != nil {
		return t.DropZones
	}
	return nil
}

// GetForwardingClassResourcePriority returns the value of the ForwardingClassResourcePriority struct pointer
// from SrlNokiaQos_Qos_ResourceManagement. If the receiver or the field ForwardingClassResourcePriority is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaQos_Qos_ResourceManagement) GetForwardingClassResourcePriority() *SrlNokiaQos_Qos_ResourceManagement_ForwardingClassResourcePriority {
	if t != nil && t.ForwardingClassResourcePriority != nil {
		return t.ForwardingClassResourcePriority
	}
	return nil
}

// GetResourceUtilizationThresholds returns the value of the ResourceUtilizationThresholds struct pointer
// from SrlNokiaQos_Qos_ResourceManagement. If the receiver or the field ResourceUtilizationThresholds is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaQos_Qos_ResourceManagement) GetResourceUtilizationThresholds() *SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds {
	if t != nil && t.ResourceUtilizationThresholds != nil {
		return t.ResourceUtilizationThresholds
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_ResourceManagement
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_ResourceManagement) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.DropZones.PopulateDefaults()
	t.ForwardingClassResourcePriority.PopulateDefaults()
	t.ResourceUtilizationThresholds.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_ResourceManagement) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_ResourceManagement"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_ResourceManagement) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_ResourceManagement) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_ResourceManagement.
func (*SrlNokiaQos_Qos_ResourceManagement) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_ResourceManagement_DropZones represents the /srl_nokia-qos/qos/resource-management/drop-zones YANG schema element.
type SrlNokiaQos_Qos_ResourceManagement_DropZones struct {
	MulticastDropZone map[uint8]*SrlNokiaQos_Qos_ResourceManagement_DropZones_MulticastDropZone `path:"multicast-drop-zone" module:"srl_nokia-qos"`
	UnicastDropZone   map[uint8]*SrlNokiaQos_Qos_ResourceManagement_DropZones_UnicastDropZone   `path:"unicast-drop-zone" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_ResourceManagement_DropZones implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_ResourceManagement_DropZones) IsYANGGoStruct() {}

// NewMulticastDropZone creates a new entry in the MulticastDropZone list of the
// SrlNokiaQos_Qos_ResourceManagement_DropZones struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaQos_Qos_ResourceManagement_DropZones) NewMulticastDropZone(Zone uint8) (*SrlNokiaQos_Qos_ResourceManagement_DropZones_MulticastDropZone, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.MulticastDropZone == nil {
		t.MulticastDropZone = make(map[uint8]*SrlNokiaQos_Qos_ResourceManagement_DropZones_MulticastDropZone)
	}

	key := Zone

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.MulticastDropZone[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list MulticastDropZone", key)
	}

	t.MulticastDropZone[key] = &SrlNokiaQos_Qos_ResourceManagement_DropZones_MulticastDropZone{
		Zone: &Zone,
	}

	return t.MulticastDropZone[key], nil
}

// RenameMulticastDropZone renames an entry in the list MulticastDropZone within
// the SrlNokiaQos_Qos_ResourceManagement_DropZones struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaQos_Qos_ResourceManagement_DropZones) RenameMulticastDropZone(oldK, newK uint8) error {
	if _, ok := t.MulticastDropZone[newK]; ok {
		return fmt.Errorf("key %v already exists in MulticastDropZone", newK)
	}

	e, ok := t.MulticastDropZone[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in MulticastDropZone", oldK)
	}
	e.Zone = &newK

	t.MulticastDropZone[newK] = e
	delete(t.MulticastDropZone, oldK)
	return nil
}

// GetOrCreateMulticastDropZone retrieves the value with the specified keys from
// the receiver SrlNokiaQos_Qos_ResourceManagement_DropZones. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaQos_Qos_ResourceManagement_DropZones) GetOrCreateMulticastDropZone(Zone uint8) *SrlNokiaQos_Qos_ResourceManagement_DropZones_MulticastDropZone {
	key := Zone

	if v, ok := t.MulticastDropZone[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewMulticastDropZone(Zone)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateMulticastDropZone got unexpected error: %v", err))
	}
	return v
}

// GetMulticastDropZone retrieves the value with the specified key from
// the MulticastDropZone map field of SrlNokiaQos_Qos_ResourceManagement_DropZones. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaQos_Qos_ResourceManagement_DropZones) GetMulticastDropZone(Zone uint8) *SrlNokiaQos_Qos_ResourceManagement_DropZones_MulticastDropZone {
	if t == nil {
		return nil
	}

	key := Zone

	if lm, ok := t.MulticastDropZone[key]; ok {
		return lm
	}
	return nil
}

// DeleteMulticastDropZone deletes the value with the specified keys from
// the receiver SrlNokiaQos_Qos_ResourceManagement_DropZones. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaQos_Qos_ResourceManagement_DropZones) DeleteMulticastDropZone(Zone uint8) {
	key := Zone

	delete(t.MulticastDropZone, key)
}

// AppendMulticastDropZone appends the supplied SrlNokiaQos_Qos_ResourceManagement_DropZones_MulticastDropZone struct to the
// list MulticastDropZone of SrlNokiaQos_Qos_ResourceManagement_DropZones. If the key value(s) specified in
// the supplied SrlNokiaQos_Qos_ResourceManagement_DropZones_MulticastDropZone already exist in the list, an error is
// returned.
func (t *SrlNokiaQos_Qos_ResourceManagement_DropZones) AppendMulticastDropZone(
	v *SrlNokiaQos_Qos_ResourceManagement_DropZones_MulticastDropZone,
) error {
	if v.Zone == nil {
		return fmt.Errorf("invalid nil key received for Zone")
	}

	key := *v.Zone

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.MulticastDropZone == nil {
		t.MulticastDropZone = make(map[uint8]*SrlNokiaQos_Qos_ResourceManagement_DropZones_MulticastDropZone)
	}

	if _, ok := t.MulticastDropZone[key]; ok {
		return fmt.Errorf("duplicate key for list MulticastDropZone %v", key)
	}

	t.MulticastDropZone[key] = v
	return nil
}

// NewUnicastDropZone creates a new entry in the UnicastDropZone list of the
// SrlNokiaQos_Qos_ResourceManagement_DropZones struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaQos_Qos_ResourceManagement_DropZones) NewUnicastDropZone(Zone uint8) (*SrlNokiaQos_Qos_ResourceManagement_DropZones_UnicastDropZone, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.UnicastDropZone == nil {
		t.UnicastDropZone = make(map[uint8]*SrlNokiaQos_Qos_ResourceManagement_DropZones_UnicastDropZone)
	}

	key := Zone

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.UnicastDropZone[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list UnicastDropZone", key)
	}

	t.UnicastDropZone[key] = &SrlNokiaQos_Qos_ResourceManagement_DropZones_UnicastDropZone{
		Zone: &Zone,
	}

	return t.UnicastDropZone[key], nil
}

// RenameUnicastDropZone renames an entry in the list UnicastDropZone within
// the SrlNokiaQos_Qos_ResourceManagement_DropZones struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaQos_Qos_ResourceManagement_DropZones) RenameUnicastDropZone(oldK, newK uint8) error {
	if _, ok := t.UnicastDropZone[newK]; ok {
		return fmt.Errorf("key %v already exists in UnicastDropZone", newK)
	}

	e, ok := t.UnicastDropZone[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in UnicastDropZone", oldK)
	}
	e.Zone = &newK

	t.UnicastDropZone[newK] = e
	delete(t.UnicastDropZone, oldK)
	return nil
}

// GetOrCreateUnicastDropZone retrieves the value with the specified keys from
// the receiver SrlNokiaQos_Qos_ResourceManagement_DropZones. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaQos_Qos_ResourceManagement_DropZones) GetOrCreateUnicastDropZone(Zone uint8) *SrlNokiaQos_Qos_ResourceManagement_DropZones_UnicastDropZone {
	key := Zone

	if v, ok := t.UnicastDropZone[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewUnicastDropZone(Zone)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateUnicastDropZone got unexpected error: %v", err))
	}
	return v
}

// GetUnicastDropZone retrieves the value with the specified key from
// the UnicastDropZone map field of SrlNokiaQos_Qos_ResourceManagement_DropZones. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaQos_Qos_ResourceManagement_DropZones) GetUnicastDropZone(Zone uint8) *SrlNokiaQos_Qos_ResourceManagement_DropZones_UnicastDropZone {
	if t == nil {
		return nil
	}

	key := Zone

	if lm, ok := t.UnicastDropZone[key]; ok {
		return lm
	}
	return nil
}

// DeleteUnicastDropZone deletes the value with the specified keys from
// the receiver SrlNokiaQos_Qos_ResourceManagement_DropZones. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaQos_Qos_ResourceManagement_DropZones) DeleteUnicastDropZone(Zone uint8) {
	key := Zone

	delete(t.UnicastDropZone, key)
}

// AppendUnicastDropZone appends the supplied SrlNokiaQos_Qos_ResourceManagement_DropZones_UnicastDropZone struct to the
// list UnicastDropZone of SrlNokiaQos_Qos_ResourceManagement_DropZones. If the key value(s) specified in
// the supplied SrlNokiaQos_Qos_ResourceManagement_DropZones_UnicastDropZone already exist in the list, an error is
// returned.
func (t *SrlNokiaQos_Qos_ResourceManagement_DropZones) AppendUnicastDropZone(
	v *SrlNokiaQos_Qos_ResourceManagement_DropZones_UnicastDropZone,
) error {
	if v.Zone == nil {
		return fmt.Errorf("invalid nil key received for Zone")
	}

	key := *v.Zone

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.UnicastDropZone == nil {
		t.UnicastDropZone = make(map[uint8]*SrlNokiaQos_Qos_ResourceManagement_DropZones_UnicastDropZone)
	}

	if _, ok := t.UnicastDropZone[key]; ok {
		return fmt.Errorf("duplicate key for list UnicastDropZone %v", key)
	}

	t.UnicastDropZone[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_ResourceManagement_DropZones
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_ResourceManagement_DropZones) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.MulticastDropZone {
		e.PopulateDefaults()
	}
	for _, e := range t.UnicastDropZone {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_ResourceManagement_DropZones) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_ResourceManagement_DropZones"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_ResourceManagement_DropZones) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_ResourceManagement_DropZones) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_ResourceManagement_DropZones.
func (*SrlNokiaQos_Qos_ResourceManagement_DropZones) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_ResourceManagement_DropZones_MulticastDropZone represents the /srl_nokia-qos/qos/resource-management/drop-zones/multicast-drop-zone YANG schema element.
type SrlNokiaQos_Qos_ResourceManagement_DropZones_MulticastDropZone struct {
	BufferSegmentDropZone *uint8 `path:"buffer-segment-drop-zone" module:"srl_nokia-qos"`
	HeaderBufferDropZone  *uint8 `path:"header-buffer-drop-zone" module:"srl_nokia-qos"`
	PacketIdDropZone      *uint8 `path:"packet-id-drop-zone" module:"srl_nokia-qos"`
	Zone                  *uint8 `path:"zone" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_ResourceManagement_DropZones_MulticastDropZone implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_ResourceManagement_DropZones_MulticastDropZone) IsYANGGoStruct() {}

// GetBufferSegmentDropZone retrieves the value of the leaf BufferSegmentDropZone from the SrlNokiaQos_Qos_ResourceManagement_DropZones_MulticastDropZone
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if BufferSegmentDropZone is set, it can
// safely use t.GetBufferSegmentDropZone() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.BufferSegmentDropZone == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_ResourceManagement_DropZones_MulticastDropZone) GetBufferSegmentDropZone() uint8 {
	if t == nil || t.BufferSegmentDropZone == nil {
		return 0
	}
	return *t.BufferSegmentDropZone
}

// GetHeaderBufferDropZone retrieves the value of the leaf HeaderBufferDropZone from the SrlNokiaQos_Qos_ResourceManagement_DropZones_MulticastDropZone
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if HeaderBufferDropZone is set, it can
// safely use t.GetHeaderBufferDropZone() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.HeaderBufferDropZone == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_ResourceManagement_DropZones_MulticastDropZone) GetHeaderBufferDropZone() uint8 {
	if t == nil || t.HeaderBufferDropZone == nil {
		return 0
	}
	return *t.HeaderBufferDropZone
}

// GetPacketIdDropZone retrieves the value of the leaf PacketIdDropZone from the SrlNokiaQos_Qos_ResourceManagement_DropZones_MulticastDropZone
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PacketIdDropZone is set, it can
// safely use t.GetPacketIdDropZone() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PacketIdDropZone == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_ResourceManagement_DropZones_MulticastDropZone) GetPacketIdDropZone() uint8 {
	if t == nil || t.PacketIdDropZone == nil {
		return 0
	}
	return *t.PacketIdDropZone
}

// GetZone retrieves the value of the leaf Zone from the SrlNokiaQos_Qos_ResourceManagement_DropZones_MulticastDropZone
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Zone is set, it can
// safely use t.GetZone() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Zone == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_ResourceManagement_DropZones_MulticastDropZone) GetZone() uint8 {
	if t == nil || t.Zone == nil {
		return 0
	}
	return *t.Zone
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_ResourceManagement_DropZones_MulticastDropZone
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_ResourceManagement_DropZones_MulticastDropZone) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the SrlNokiaQos_Qos_ResourceManagement_DropZones_MulticastDropZone struct, which is a YANG list entry.
func (t *SrlNokiaQos_Qos_ResourceManagement_DropZones_MulticastDropZone) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Zone == nil {
		return nil, fmt.Errorf("nil value for key Zone")
	}

	return map[string]interface{}{
		"zone": *t.Zone,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_ResourceManagement_DropZones_MulticastDropZone) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_ResourceManagement_DropZones_MulticastDropZone"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_ResourceManagement_DropZones_MulticastDropZone) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_ResourceManagement_DropZones_MulticastDropZone) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_ResourceManagement_DropZones_MulticastDropZone.
func (*SrlNokiaQos_Qos_ResourceManagement_DropZones_MulticastDropZone) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_ResourceManagement_DropZones_UnicastDropZone represents the /srl_nokia-qos/qos/resource-management/drop-zones/unicast-drop-zone YANG schema element.
type SrlNokiaQos_Qos_ResourceManagement_DropZones_UnicastDropZone struct {
	BufferSegmentDropZone *uint8 `path:"buffer-segment-drop-zone" module:"srl_nokia-qos"`
	HeaderBufferDropZone  *uint8 `path:"header-buffer-drop-zone" module:"srl_nokia-qos"`
	PacketIdDropZone      *uint8 `path:"packet-id-drop-zone" module:"srl_nokia-qos"`
	Zone                  *uint8 `path:"zone" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_ResourceManagement_DropZones_UnicastDropZone implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_ResourceManagement_DropZones_UnicastDropZone) IsYANGGoStruct() {}

// GetBufferSegmentDropZone retrieves the value of the leaf BufferSegmentDropZone from the SrlNokiaQos_Qos_ResourceManagement_DropZones_UnicastDropZone
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if BufferSegmentDropZone is set, it can
// safely use t.GetBufferSegmentDropZone() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.BufferSegmentDropZone == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_ResourceManagement_DropZones_UnicastDropZone) GetBufferSegmentDropZone() uint8 {
	if t == nil || t.BufferSegmentDropZone == nil {
		return 0
	}
	return *t.BufferSegmentDropZone
}

// GetHeaderBufferDropZone retrieves the value of the leaf HeaderBufferDropZone from the SrlNokiaQos_Qos_ResourceManagement_DropZones_UnicastDropZone
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if HeaderBufferDropZone is set, it can
// safely use t.GetHeaderBufferDropZone() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.HeaderBufferDropZone == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_ResourceManagement_DropZones_UnicastDropZone) GetHeaderBufferDropZone() uint8 {
	if t == nil || t.HeaderBufferDropZone == nil {
		return 0
	}
	return *t.HeaderBufferDropZone
}

// GetPacketIdDropZone retrieves the value of the leaf PacketIdDropZone from the SrlNokiaQos_Qos_ResourceManagement_DropZones_UnicastDropZone
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PacketIdDropZone is set, it can
// safely use t.GetPacketIdDropZone() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PacketIdDropZone == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_ResourceManagement_DropZones_UnicastDropZone) GetPacketIdDropZone() uint8 {
	if t == nil || t.PacketIdDropZone == nil {
		return 0
	}
	return *t.PacketIdDropZone
}

// GetZone retrieves the value of the leaf Zone from the SrlNokiaQos_Qos_ResourceManagement_DropZones_UnicastDropZone
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Zone is set, it can
// safely use t.GetZone() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Zone == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_ResourceManagement_DropZones_UnicastDropZone) GetZone() uint8 {
	if t == nil || t.Zone == nil {
		return 0
	}
	return *t.Zone
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_ResourceManagement_DropZones_UnicastDropZone
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_ResourceManagement_DropZones_UnicastDropZone) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the SrlNokiaQos_Qos_ResourceManagement_DropZones_UnicastDropZone struct, which is a YANG list entry.
func (t *SrlNokiaQos_Qos_ResourceManagement_DropZones_UnicastDropZone) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Zone == nil {
		return nil, fmt.Errorf("nil value for key Zone")
	}

	return map[string]interface{}{
		"zone": *t.Zone,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_ResourceManagement_DropZones_UnicastDropZone) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_ResourceManagement_DropZones_UnicastDropZone"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_ResourceManagement_DropZones_UnicastDropZone) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_ResourceManagement_DropZones_UnicastDropZone) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_ResourceManagement_DropZones_UnicastDropZone.
func (*SrlNokiaQos_Qos_ResourceManagement_DropZones_UnicastDropZone) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_ResourceManagement_ForwardingClassResourcePriority represents the /srl_nokia-qos/qos/resource-management/forwarding-class-resource-priority YANG schema element.
type SrlNokiaQos_Qos_ResourceManagement_ForwardingClassResourcePriority struct {
	ForwardingClass map[SrlNokiaQos_Qos_ResourceManagement_ForwardingClassResourcePriority_ForwardingClass_Name_Union]*SrlNokiaQos_Qos_ResourceManagement_ForwardingClassResourcePriority_ForwardingClass `path:"forwarding-class" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_ResourceManagement_ForwardingClassResourcePriority implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_ResourceManagement_ForwardingClassResourcePriority) IsYANGGoStruct() {}

// NewForwardingClass creates a new entry in the ForwardingClass list of the
// SrlNokiaQos_Qos_ResourceManagement_ForwardingClassResourcePriority struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaQos_Qos_ResourceManagement_ForwardingClassResourcePriority) NewForwardingClass(
	Name SrlNokiaQos_Qos_ResourceManagement_ForwardingClassResourcePriority_ForwardingClass_Name_Union,
) (*SrlNokiaQos_Qos_ResourceManagement_ForwardingClassResourcePriority_ForwardingClass, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ForwardingClass == nil {
		t.ForwardingClass = make(map[SrlNokiaQos_Qos_ResourceManagement_ForwardingClassResourcePriority_ForwardingClass_Name_Union]*SrlNokiaQos_Qos_ResourceManagement_ForwardingClassResourcePriority_ForwardingClass)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.ForwardingClass[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list ForwardingClass", key)
	}

	t.ForwardingClass[key] = &SrlNokiaQos_Qos_ResourceManagement_ForwardingClassResourcePriority_ForwardingClass{
		Name: Name,
	}

	return t.ForwardingClass[key], nil
}

// RenameForwardingClass renames an entry in the list ForwardingClass within
// the SrlNokiaQos_Qos_ResourceManagement_ForwardingClassResourcePriority struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaQos_Qos_ResourceManagement_ForwardingClassResourcePriority) RenameForwardingClass(
	oldK, newK SrlNokiaQos_Qos_ResourceManagement_ForwardingClassResourcePriority_ForwardingClass_Name_Union,
) error {
	if _, ok := t.ForwardingClass[newK]; ok {
		return fmt.Errorf("key %v already exists in ForwardingClass", newK)
	}

	e, ok := t.ForwardingClass[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in ForwardingClass", oldK)
	}
	e.Name = newK

	t.ForwardingClass[newK] = e
	delete(t.ForwardingClass, oldK)
	return nil
}

// GetOrCreateForwardingClass retrieves the value with the specified keys from
// the receiver SrlNokiaQos_Qos_ResourceManagement_ForwardingClassResourcePriority. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaQos_Qos_ResourceManagement_ForwardingClassResourcePriority) GetOrCreateForwardingClass(
	Name SrlNokiaQos_Qos_ResourceManagement_ForwardingClassResourcePriority_ForwardingClass_Name_Union,
) *SrlNokiaQos_Qos_ResourceManagement_ForwardingClassResourcePriority_ForwardingClass {
	key := Name

	if v, ok := t.ForwardingClass[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewForwardingClass(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateForwardingClass got unexpected error: %v", err))
	}
	return v
}

// GetForwardingClass retrieves the value with the specified key from
// the ForwardingClass map field of SrlNokiaQos_Qos_ResourceManagement_ForwardingClassResourcePriority. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaQos_Qos_ResourceManagement_ForwardingClassResourcePriority) GetForwardingClass(
	Name SrlNokiaQos_Qos_ResourceManagement_ForwardingClassResourcePriority_ForwardingClass_Name_Union,
) *SrlNokiaQos_Qos_ResourceManagement_ForwardingClassResourcePriority_ForwardingClass {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.ForwardingClass[key]; ok {
		return lm
	}
	return nil
}

// DeleteForwardingClass deletes the value with the specified keys from
// the receiver SrlNokiaQos_Qos_ResourceManagement_ForwardingClassResourcePriority. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaQos_Qos_ResourceManagement_ForwardingClassResourcePriority) DeleteForwardingClass(
	Name SrlNokiaQos_Qos_ResourceManagement_ForwardingClassResourcePriority_ForwardingClass_Name_Union,
) {
	key := Name

	delete(t.ForwardingClass, key)
}

// AppendForwardingClass appends the supplied SrlNokiaQos_Qos_ResourceManagement_ForwardingClassResourcePriority_ForwardingClass struct to the
// list ForwardingClass of SrlNokiaQos_Qos_ResourceManagement_ForwardingClassResourcePriority. If the key value(s) specified in
// the supplied SrlNokiaQos_Qos_ResourceManagement_ForwardingClassResourcePriority_ForwardingClass already exist in the list, an error is
// returned.
func (t *SrlNokiaQos_Qos_ResourceManagement_ForwardingClassResourcePriority) AppendForwardingClass(
	v *SrlNokiaQos_Qos_ResourceManagement_ForwardingClassResourcePriority_ForwardingClass,
) error {
	key := v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ForwardingClass == nil {
		t.ForwardingClass = make(map[SrlNokiaQos_Qos_ResourceManagement_ForwardingClassResourcePriority_ForwardingClass_Name_Union]*SrlNokiaQos_Qos_ResourceManagement_ForwardingClassResourcePriority_ForwardingClass)
	}

	if _, ok := t.ForwardingClass[key]; ok {
		return fmt.Errorf("duplicate key for list ForwardingClass %v", key)
	}

	t.ForwardingClass[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_ResourceManagement_ForwardingClassResourcePriority
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_ResourceManagement_ForwardingClassResourcePriority) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.ForwardingClass {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_ResourceManagement_ForwardingClassResourcePriority) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_ResourceManagement_ForwardingClassResourcePriority"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_ResourceManagement_ForwardingClassResourcePriority) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_ResourceManagement_ForwardingClassResourcePriority) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_ResourceManagement_ForwardingClassResourcePriority.
func (*SrlNokiaQos_Qos_ResourceManagement_ForwardingClassResourcePriority) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_ResourceManagement_ForwardingClassResourcePriority_ForwardingClass represents the /srl_nokia-qos/qos/resource-management/forwarding-class-resource-priority/forwarding-class YANG schema element.
type SrlNokiaQos_Qos_ResourceManagement_ForwardingClassResourcePriority_ForwardingClass struct {
	Name    SrlNokiaQos_Qos_ResourceManagement_ForwardingClassResourcePriority_ForwardingClass_Name_Union                                    `path:"name" module:"srl_nokia-qos"`
	Profile map[E_SrlNokiaCommon_ClassifyProfile]*SrlNokiaQos_Qos_ResourceManagement_ForwardingClassResourcePriority_ForwardingClass_Profile `path:"profile" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_ResourceManagement_ForwardingClassResourcePriority_ForwardingClass implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_ResourceManagement_ForwardingClassResourcePriority_ForwardingClass) IsYANGGoStruct() {
}

// NewProfile creates a new entry in the Profile list of the
// SrlNokiaQos_Qos_ResourceManagement_ForwardingClassResourcePriority_ForwardingClass struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaQos_Qos_ResourceManagement_ForwardingClassResourcePriority_ForwardingClass) NewProfile(
	ProfileName E_SrlNokiaCommon_ClassifyProfile,
) (*SrlNokiaQos_Qos_ResourceManagement_ForwardingClassResourcePriority_ForwardingClass_Profile, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Profile == nil {
		t.Profile = make(map[E_SrlNokiaCommon_ClassifyProfile]*SrlNokiaQos_Qos_ResourceManagement_ForwardingClassResourcePriority_ForwardingClass_Profile)
	}

	key := ProfileName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Profile[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Profile", key)
	}

	t.Profile[key] = &SrlNokiaQos_Qos_ResourceManagement_ForwardingClassResourcePriority_ForwardingClass_Profile{
		ProfileName: ProfileName,
	}

	return t.Profile[key], nil
}

// RenameProfile renames an entry in the list Profile within
// the SrlNokiaQos_Qos_ResourceManagement_ForwardingClassResourcePriority_ForwardingClass struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaQos_Qos_ResourceManagement_ForwardingClassResourcePriority_ForwardingClass) RenameProfile(oldK, newK E_SrlNokiaCommon_ClassifyProfile) error {
	if _, ok := t.Profile[newK]; ok {
		return fmt.Errorf("key %v already exists in Profile", newK)
	}

	e, ok := t.Profile[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Profile", oldK)
	}
	e.ProfileName = newK

	t.Profile[newK] = e
	delete(t.Profile, oldK)
	return nil
}

// GetOrCreateProfile retrieves the value with the specified keys from
// the receiver SrlNokiaQos_Qos_ResourceManagement_ForwardingClassResourcePriority_ForwardingClass. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaQos_Qos_ResourceManagement_ForwardingClassResourcePriority_ForwardingClass) GetOrCreateProfile(
	ProfileName E_SrlNokiaCommon_ClassifyProfile,
) *SrlNokiaQos_Qos_ResourceManagement_ForwardingClassResourcePriority_ForwardingClass_Profile {
	key := ProfileName

	if v, ok := t.Profile[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewProfile(ProfileName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateProfile got unexpected error: %v", err))
	}
	return v
}

// GetProfile retrieves the value with the specified key from
// the Profile map field of SrlNokiaQos_Qos_ResourceManagement_ForwardingClassResourcePriority_ForwardingClass. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaQos_Qos_ResourceManagement_ForwardingClassResourcePriority_ForwardingClass) GetProfile(
	ProfileName E_SrlNokiaCommon_ClassifyProfile,
) *SrlNokiaQos_Qos_ResourceManagement_ForwardingClassResourcePriority_ForwardingClass_Profile {
	if t == nil {
		return nil
	}

	key := ProfileName

	if lm, ok := t.Profile[key]; ok {
		return lm
	}
	return nil
}

// DeleteProfile deletes the value with the specified keys from
// the receiver SrlNokiaQos_Qos_ResourceManagement_ForwardingClassResourcePriority_ForwardingClass. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaQos_Qos_ResourceManagement_ForwardingClassResourcePriority_ForwardingClass) DeleteProfile(ProfileName E_SrlNokiaCommon_ClassifyProfile) {
	key := ProfileName

	delete(t.Profile, key)
}

// AppendProfile appends the supplied SrlNokiaQos_Qos_ResourceManagement_ForwardingClassResourcePriority_ForwardingClass_Profile struct to the
// list Profile of SrlNokiaQos_Qos_ResourceManagement_ForwardingClassResourcePriority_ForwardingClass. If the key value(s) specified in
// the supplied SrlNokiaQos_Qos_ResourceManagement_ForwardingClassResourcePriority_ForwardingClass_Profile already exist in the list, an error is
// returned.
func (t *SrlNokiaQos_Qos_ResourceManagement_ForwardingClassResourcePriority_ForwardingClass) AppendProfile(
	v *SrlNokiaQos_Qos_ResourceManagement_ForwardingClassResourcePriority_ForwardingClass_Profile,
) error {
	key := v.ProfileName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Profile == nil {
		t.Profile = make(map[E_SrlNokiaCommon_ClassifyProfile]*SrlNokiaQos_Qos_ResourceManagement_ForwardingClassResourcePriority_ForwardingClass_Profile)
	}

	if _, ok := t.Profile[key]; ok {
		return fmt.Errorf("duplicate key for list Profile %v", key)
	}

	t.Profile[key] = v
	return nil
}

// GetName retrieves the value of the leaf Name from the SrlNokiaQos_Qos_ResourceManagement_ForwardingClassResourcePriority_ForwardingClass
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_ResourceManagement_ForwardingClassResourcePriority_ForwardingClass) GetName() SrlNokiaQos_Qos_ResourceManagement_ForwardingClassResourcePriority_ForwardingClass_Name_Union {
	if t == nil || t.Name == nil {
		return nil
	}
	return t.Name
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_ResourceManagement_ForwardingClassResourcePriority_ForwardingClass
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_ResourceManagement_ForwardingClassResourcePriority_ForwardingClass) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Profile {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaQos_Qos_ResourceManagement_ForwardingClassResourcePriority_ForwardingClass struct, which is a YANG list entry.
func (t *SrlNokiaQos_Qos_ResourceManagement_ForwardingClassResourcePriority_ForwardingClass) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"name": t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_ResourceManagement_ForwardingClassResourcePriority_ForwardingClass) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_ResourceManagement_ForwardingClassResourcePriority_ForwardingClass"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_ResourceManagement_ForwardingClassResourcePriority_ForwardingClass) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_ResourceManagement_ForwardingClassResourcePriority_ForwardingClass) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_ResourceManagement_ForwardingClassResourcePriority_ForwardingClass.
func (*SrlNokiaQos_Qos_ResourceManagement_ForwardingClassResourcePriority_ForwardingClass) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_ResourceManagement_ForwardingClassResourcePriority_ForwardingClass_Profile represents the /srl_nokia-qos/qos/resource-management/forwarding-class-resource-priority/forwarding-class/profile YANG schema element.
type SrlNokiaQos_Qos_ResourceManagement_ForwardingClassResourcePriority_ForwardingClass_Profile struct {
	MulticastResourcePriority *uint8                           `path:"multicast-resource-priority" module:"srl_nokia-qos"`
	ProfileName               E_SrlNokiaCommon_ClassifyProfile `path:"profile-name" module:"srl_nokia-qos"`
	UnicastResourcePriority   *uint8                           `path:"unicast-resource-priority" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_ResourceManagement_ForwardingClassResourcePriority_ForwardingClass_Profile implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_ResourceManagement_ForwardingClassResourcePriority_ForwardingClass_Profile) IsYANGGoStruct() {
}

// GetMulticastResourcePriority retrieves the value of the leaf MulticastResourcePriority from the SrlNokiaQos_Qos_ResourceManagement_ForwardingClassResourcePriority_ForwardingClass_Profile
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MulticastResourcePriority is set, it can
// safely use t.GetMulticastResourcePriority() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MulticastResourcePriority == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_ResourceManagement_ForwardingClassResourcePriority_ForwardingClass_Profile) GetMulticastResourcePriority() uint8 {
	if t == nil || t.MulticastResourcePriority == nil {
		return 0
	}
	return *t.MulticastResourcePriority
}

// GetProfileName retrieves the value of the leaf ProfileName from the SrlNokiaQos_Qos_ResourceManagement_ForwardingClassResourcePriority_ForwardingClass_Profile
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ProfileName is set, it can
// safely use t.GetProfileName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ProfileName == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_ResourceManagement_ForwardingClassResourcePriority_ForwardingClass_Profile) GetProfileName() E_SrlNokiaCommon_ClassifyProfile {
	if t == nil || t.ProfileName == 0 {
		return 0
	}
	return t.ProfileName
}

// GetUnicastResourcePriority retrieves the value of the leaf UnicastResourcePriority from the SrlNokiaQos_Qos_ResourceManagement_ForwardingClassResourcePriority_ForwardingClass_Profile
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if UnicastResourcePriority is set, it can
// safely use t.GetUnicastResourcePriority() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.UnicastResourcePriority == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_ResourceManagement_ForwardingClassResourcePriority_ForwardingClass_Profile) GetUnicastResourcePriority() uint8 {
	if t == nil || t.UnicastResourcePriority == nil {
		return 0
	}
	return *t.UnicastResourcePriority
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_ResourceManagement_ForwardingClassResourcePriority_ForwardingClass_Profile
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_ResourceManagement_ForwardingClassResourcePriority_ForwardingClass_Profile) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the SrlNokiaQos_Qos_ResourceManagement_ForwardingClassResourcePriority_ForwardingClass_Profile struct, which is a YANG list entry.
func (t *SrlNokiaQos_Qos_ResourceManagement_ForwardingClassResourcePriority_ForwardingClass_Profile) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"profile-name": t.ProfileName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_ResourceManagement_ForwardingClassResourcePriority_ForwardingClass_Profile) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_ResourceManagement_ForwardingClassResourcePriority_ForwardingClass_Profile"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_ResourceManagement_ForwardingClassResourcePriority_ForwardingClass_Profile) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_ResourceManagement_ForwardingClassResourcePriority_ForwardingClass_Profile) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_ResourceManagement_ForwardingClassResourcePriority_ForwardingClass_Profile.
func (*SrlNokiaQos_Qos_ResourceManagement_ForwardingClassResourcePriority_ForwardingClass_Profile) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds represents the /srl_nokia-qos/qos/resource-management/resource-utilization-thresholds YANG schema element.
type SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds struct {
	BufferSegment *SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_BufferSegment `path:"buffer-segment" module:"srl_nokia-qos"`
	HeaderBuffer  *SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_HeaderBuffer  `path:"header-buffer" module:"srl_nokia-qos"`
	PacketId      *SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_PacketId      `path:"packet-id" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds) IsYANGGoStruct() {}

// GetOrCreateBufferSegment retrieves the value of the BufferSegment field
// or returns the existing field if it already exists.
func (t *SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds) GetOrCreateBufferSegment() *SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_BufferSegment {
	if t.BufferSegment != nil {
		return t.BufferSegment
	}
	t.BufferSegment = &SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_BufferSegment{}
	return t.BufferSegment
}

// GetOrCreateHeaderBuffer retrieves the value of the HeaderBuffer field
// or returns the existing field if it already exists.
func (t *SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds) GetOrCreateHeaderBuffer() *SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_HeaderBuffer {
	if t.HeaderBuffer != nil {
		return t.HeaderBuffer
	}
	t.HeaderBuffer = &SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_HeaderBuffer{}
	return t.HeaderBuffer
}

// GetOrCreatePacketId retrieves the value of the PacketId field
// or returns the existing field if it already exists.
func (t *SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds) GetOrCreatePacketId() *SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_PacketId {
	if t.PacketId != nil {
		return t.PacketId
	}
	t.PacketId = &SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_PacketId{}
	return t.PacketId
}

// GetBufferSegment returns the value of the BufferSegment struct pointer
// from SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds. If the receiver or the field BufferSegment is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds) GetBufferSegment() *SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_BufferSegment {
	if t != nil && t.BufferSegment != nil {
		return t.BufferSegment
	}
	return nil
}

// GetHeaderBuffer returns the value of the HeaderBuffer struct pointer
// from SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds. If the receiver or the field HeaderBuffer is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds) GetHeaderBuffer() *SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_HeaderBuffer {
	if t != nil && t.HeaderBuffer != nil {
		return t.HeaderBuffer
	}
	return nil
}

// GetPacketId returns the value of the PacketId struct pointer
// from SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds. If the receiver or the field PacketId is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds) GetPacketId() *SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_PacketId {
	if t != nil && t.PacketId != nil {
		return t.PacketId
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.BufferSegment.PopulateDefaults()
	t.HeaderBuffer.PopulateDefaults()
	t.PacketId.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds.
func (*SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_BufferSegment represents the /srl_nokia-qos/qos/resource-management/resource-utilization-thresholds/buffer-segment YANG schema element.
type SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_BufferSegment struct {
	Threshold map[uint8]*SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_BufferSegment_Threshold `path:"threshold" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_BufferSegment implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_BufferSegment) IsYANGGoStruct() {
}

// NewThreshold creates a new entry in the Threshold list of the
// SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_BufferSegment struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_BufferSegment) NewThreshold(
	Index uint8,
) (*SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_BufferSegment_Threshold, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Threshold == nil {
		t.Threshold = make(map[uint8]*SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_BufferSegment_Threshold)
	}

	key := Index

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Threshold[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Threshold", key)
	}

	t.Threshold[key] = &SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_BufferSegment_Threshold{
		Index: &Index,
	}

	return t.Threshold[key], nil
}

// RenameThreshold renames an entry in the list Threshold within
// the SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_BufferSegment struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_BufferSegment) RenameThreshold(oldK, newK uint8) error {
	if _, ok := t.Threshold[newK]; ok {
		return fmt.Errorf("key %v already exists in Threshold", newK)
	}

	e, ok := t.Threshold[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Threshold", oldK)
	}
	e.Index = &newK

	t.Threshold[newK] = e
	delete(t.Threshold, oldK)
	return nil
}

// GetOrCreateThreshold retrieves the value with the specified keys from
// the receiver SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_BufferSegment. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_BufferSegment) GetOrCreateThreshold(
	Index uint8,
) *SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_BufferSegment_Threshold {
	key := Index

	if v, ok := t.Threshold[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewThreshold(Index)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateThreshold got unexpected error: %v", err))
	}
	return v
}

// GetThreshold retrieves the value with the specified key from
// the Threshold map field of SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_BufferSegment. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_BufferSegment) GetThreshold(
	Index uint8,
) *SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_BufferSegment_Threshold {
	if t == nil {
		return nil
	}

	key := Index

	if lm, ok := t.Threshold[key]; ok {
		return lm
	}
	return nil
}

// DeleteThreshold deletes the value with the specified keys from
// the receiver SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_BufferSegment. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_BufferSegment) DeleteThreshold(Index uint8) {
	key := Index

	delete(t.Threshold, key)
}

// AppendThreshold appends the supplied SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_BufferSegment_Threshold struct to the
// list Threshold of SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_BufferSegment. If the key value(s) specified in
// the supplied SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_BufferSegment_Threshold already exist in the list, an error is
// returned.
func (t *SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_BufferSegment) AppendThreshold(
	v *SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_BufferSegment_Threshold,
) error {
	if v.Index == nil {
		return fmt.Errorf("invalid nil key received for Index")
	}

	key := *v.Index

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Threshold == nil {
		t.Threshold = make(map[uint8]*SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_BufferSegment_Threshold)
	}

	if _, ok := t.Threshold[key]; ok {
		return fmt.Errorf("duplicate key for list Threshold %v", key)
	}

	t.Threshold[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_BufferSegment
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_BufferSegment) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Threshold {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_BufferSegment) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_BufferSegment"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_BufferSegment) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_BufferSegment) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_BufferSegment.
func (*SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_BufferSegment) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_BufferSegment_Threshold represents the /srl_nokia-qos/qos/resource-management/resource-utilization-thresholds/buffer-segment/threshold YANG schema element.
type SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_BufferSegment_Threshold struct {
	FallingThresholdValue *float64 `path:"falling-threshold-value" module:"srl_nokia-qos"`
	Index                 *uint8   `path:"index" module:"srl_nokia-qos"`
	RisingThresholdValue  *float64 `path:"rising-threshold-value" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_BufferSegment_Threshold implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_BufferSegment_Threshold) IsYANGGoStruct() {
}

// GetFallingThresholdValue retrieves the value of the leaf FallingThresholdValue from the SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_BufferSegment_Threshold
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FallingThresholdValue is set, it can
// safely use t.GetFallingThresholdValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FallingThresholdValue == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_BufferSegment_Threshold) GetFallingThresholdValue() float64 {
	if t == nil || t.FallingThresholdValue == nil {
		return 0.0
	}
	return *t.FallingThresholdValue
}

// GetIndex retrieves the value of the leaf Index from the SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_BufferSegment_Threshold
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Index is set, it can
// safely use t.GetIndex() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Index == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_BufferSegment_Threshold) GetIndex() uint8 {
	if t == nil || t.Index == nil {
		return 0
	}
	return *t.Index
}

// GetRisingThresholdValue retrieves the value of the leaf RisingThresholdValue from the SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_BufferSegment_Threshold
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RisingThresholdValue is set, it can
// safely use t.GetRisingThresholdValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RisingThresholdValue == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_BufferSegment_Threshold) GetRisingThresholdValue() float64 {
	if t == nil || t.RisingThresholdValue == nil {
		return 0.0
	}
	return *t.RisingThresholdValue
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_BufferSegment_Threshold
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_BufferSegment_Threshold) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_BufferSegment_Threshold struct, which is a YANG list entry.
func (t *SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_BufferSegment_Threshold) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Index == nil {
		return nil, fmt.Errorf("nil value for key Index")
	}

	return map[string]interface{}{
		"index": *t.Index,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_BufferSegment_Threshold) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_BufferSegment_Threshold"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_BufferSegment_Threshold) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_BufferSegment_Threshold) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_BufferSegment_Threshold.
func (*SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_BufferSegment_Threshold) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_HeaderBuffer represents the /srl_nokia-qos/qos/resource-management/resource-utilization-thresholds/header-buffer YANG schema element.
type SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_HeaderBuffer struct {
	Threshold map[uint8]*SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_HeaderBuffer_Threshold `path:"threshold" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_HeaderBuffer implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_HeaderBuffer) IsYANGGoStruct() {
}

// NewThreshold creates a new entry in the Threshold list of the
// SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_HeaderBuffer struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_HeaderBuffer) NewThreshold(
	Index uint8,
) (*SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_HeaderBuffer_Threshold, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Threshold == nil {
		t.Threshold = make(map[uint8]*SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_HeaderBuffer_Threshold)
	}

	key := Index

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Threshold[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Threshold", key)
	}

	t.Threshold[key] = &SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_HeaderBuffer_Threshold{
		Index: &Index,
	}

	return t.Threshold[key], nil
}

// RenameThreshold renames an entry in the list Threshold within
// the SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_HeaderBuffer struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_HeaderBuffer) RenameThreshold(oldK, newK uint8) error {
	if _, ok := t.Threshold[newK]; ok {
		return fmt.Errorf("key %v already exists in Threshold", newK)
	}

	e, ok := t.Threshold[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Threshold", oldK)
	}
	e.Index = &newK

	t.Threshold[newK] = e
	delete(t.Threshold, oldK)
	return nil
}

// GetOrCreateThreshold retrieves the value with the specified keys from
// the receiver SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_HeaderBuffer. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_HeaderBuffer) GetOrCreateThreshold(
	Index uint8,
) *SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_HeaderBuffer_Threshold {
	key := Index

	if v, ok := t.Threshold[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewThreshold(Index)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateThreshold got unexpected error: %v", err))
	}
	return v
}

// GetThreshold retrieves the value with the specified key from
// the Threshold map field of SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_HeaderBuffer. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_HeaderBuffer) GetThreshold(
	Index uint8,
) *SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_HeaderBuffer_Threshold {
	if t == nil {
		return nil
	}

	key := Index

	if lm, ok := t.Threshold[key]; ok {
		return lm
	}
	return nil
}

// DeleteThreshold deletes the value with the specified keys from
// the receiver SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_HeaderBuffer. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_HeaderBuffer) DeleteThreshold(Index uint8) {
	key := Index

	delete(t.Threshold, key)
}

// AppendThreshold appends the supplied SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_HeaderBuffer_Threshold struct to the
// list Threshold of SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_HeaderBuffer. If the key value(s) specified in
// the supplied SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_HeaderBuffer_Threshold already exist in the list, an error is
// returned.
func (t *SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_HeaderBuffer) AppendThreshold(
	v *SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_HeaderBuffer_Threshold,
) error {
	if v.Index == nil {
		return fmt.Errorf("invalid nil key received for Index")
	}

	key := *v.Index

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Threshold == nil {
		t.Threshold = make(map[uint8]*SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_HeaderBuffer_Threshold)
	}

	if _, ok := t.Threshold[key]; ok {
		return fmt.Errorf("duplicate key for list Threshold %v", key)
	}

	t.Threshold[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_HeaderBuffer
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_HeaderBuffer) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Threshold {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_HeaderBuffer) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_HeaderBuffer"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_HeaderBuffer) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_HeaderBuffer) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_HeaderBuffer.
func (*SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_HeaderBuffer) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_HeaderBuffer_Threshold represents the /srl_nokia-qos/qos/resource-management/resource-utilization-thresholds/header-buffer/threshold YANG schema element.
type SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_HeaderBuffer_Threshold struct {
	FallingThresholdValue *float64 `path:"falling-threshold-value" module:"srl_nokia-qos"`
	Index                 *uint8   `path:"index" module:"srl_nokia-qos"`
	RisingThresholdValue  *float64 `path:"rising-threshold-value" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_HeaderBuffer_Threshold implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_HeaderBuffer_Threshold) IsYANGGoStruct() {
}

// GetFallingThresholdValue retrieves the value of the leaf FallingThresholdValue from the SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_HeaderBuffer_Threshold
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FallingThresholdValue is set, it can
// safely use t.GetFallingThresholdValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FallingThresholdValue == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_HeaderBuffer_Threshold) GetFallingThresholdValue() float64 {
	if t == nil || t.FallingThresholdValue == nil {
		return 0.0
	}
	return *t.FallingThresholdValue
}

// GetIndex retrieves the value of the leaf Index from the SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_HeaderBuffer_Threshold
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Index is set, it can
// safely use t.GetIndex() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Index == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_HeaderBuffer_Threshold) GetIndex() uint8 {
	if t == nil || t.Index == nil {
		return 0
	}
	return *t.Index
}

// GetRisingThresholdValue retrieves the value of the leaf RisingThresholdValue from the SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_HeaderBuffer_Threshold
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RisingThresholdValue is set, it can
// safely use t.GetRisingThresholdValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RisingThresholdValue == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_HeaderBuffer_Threshold) GetRisingThresholdValue() float64 {
	if t == nil || t.RisingThresholdValue == nil {
		return 0.0
	}
	return *t.RisingThresholdValue
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_HeaderBuffer_Threshold
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_HeaderBuffer_Threshold) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_HeaderBuffer_Threshold struct, which is a YANG list entry.
func (t *SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_HeaderBuffer_Threshold) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Index == nil {
		return nil, fmt.Errorf("nil value for key Index")
	}

	return map[string]interface{}{
		"index": *t.Index,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_HeaderBuffer_Threshold) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_HeaderBuffer_Threshold"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_HeaderBuffer_Threshold) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_HeaderBuffer_Threshold) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_HeaderBuffer_Threshold.
func (*SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_HeaderBuffer_Threshold) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_PacketId represents the /srl_nokia-qos/qos/resource-management/resource-utilization-thresholds/packet-id YANG schema element.
type SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_PacketId struct {
	Threshold map[uint8]*SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_PacketId_Threshold `path:"threshold" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_PacketId implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_PacketId) IsYANGGoStruct() {}

// NewThreshold creates a new entry in the Threshold list of the
// SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_PacketId struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_PacketId) NewThreshold(
	Index uint8,
) (*SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_PacketId_Threshold, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Threshold == nil {
		t.Threshold = make(map[uint8]*SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_PacketId_Threshold)
	}

	key := Index

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Threshold[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Threshold", key)
	}

	t.Threshold[key] = &SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_PacketId_Threshold{
		Index: &Index,
	}

	return t.Threshold[key], nil
}

// RenameThreshold renames an entry in the list Threshold within
// the SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_PacketId struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_PacketId) RenameThreshold(oldK, newK uint8) error {
	if _, ok := t.Threshold[newK]; ok {
		return fmt.Errorf("key %v already exists in Threshold", newK)
	}

	e, ok := t.Threshold[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Threshold", oldK)
	}
	e.Index = &newK

	t.Threshold[newK] = e
	delete(t.Threshold, oldK)
	return nil
}

// GetOrCreateThreshold retrieves the value with the specified keys from
// the receiver SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_PacketId. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_PacketId) GetOrCreateThreshold(
	Index uint8,
) *SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_PacketId_Threshold {
	key := Index

	if v, ok := t.Threshold[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewThreshold(Index)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateThreshold got unexpected error: %v", err))
	}
	return v
}

// GetThreshold retrieves the value with the specified key from
// the Threshold map field of SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_PacketId. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_PacketId) GetThreshold(
	Index uint8,
) *SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_PacketId_Threshold {
	if t == nil {
		return nil
	}

	key := Index

	if lm, ok := t.Threshold[key]; ok {
		return lm
	}
	return nil
}

// DeleteThreshold deletes the value with the specified keys from
// the receiver SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_PacketId. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_PacketId) DeleteThreshold(Index uint8) {
	key := Index

	delete(t.Threshold, key)
}

// AppendThreshold appends the supplied SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_PacketId_Threshold struct to the
// list Threshold of SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_PacketId. If the key value(s) specified in
// the supplied SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_PacketId_Threshold already exist in the list, an error is
// returned.
func (t *SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_PacketId) AppendThreshold(
	v *SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_PacketId_Threshold,
) error {
	if v.Index == nil {
		return fmt.Errorf("invalid nil key received for Index")
	}

	key := *v.Index

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Threshold == nil {
		t.Threshold = make(map[uint8]*SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_PacketId_Threshold)
	}

	if _, ok := t.Threshold[key]; ok {
		return fmt.Errorf("duplicate key for list Threshold %v", key)
	}

	t.Threshold[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_PacketId
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_PacketId) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Threshold {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_PacketId) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_PacketId"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_PacketId) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_PacketId) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_PacketId.
func (*SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_PacketId) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_PacketId_Threshold represents the /srl_nokia-qos/qos/resource-management/resource-utilization-thresholds/packet-id/threshold YANG schema element.
type SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_PacketId_Threshold struct {
	FallingThresholdValue *float64 `path:"falling-threshold-value" module:"srl_nokia-qos"`
	Index                 *uint8   `path:"index" module:"srl_nokia-qos"`
	RisingThresholdValue  *float64 `path:"rising-threshold-value" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_PacketId_Threshold implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_PacketId_Threshold) IsYANGGoStruct() {
}

// GetFallingThresholdValue retrieves the value of the leaf FallingThresholdValue from the SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_PacketId_Threshold
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FallingThresholdValue is set, it can
// safely use t.GetFallingThresholdValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FallingThresholdValue == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_PacketId_Threshold) GetFallingThresholdValue() float64 {
	if t == nil || t.FallingThresholdValue == nil {
		return 0.0
	}
	return *t.FallingThresholdValue
}

// GetIndex retrieves the value of the leaf Index from the SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_PacketId_Threshold
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Index is set, it can
// safely use t.GetIndex() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Index == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_PacketId_Threshold) GetIndex() uint8 {
	if t == nil || t.Index == nil {
		return 0
	}
	return *t.Index
}

// GetRisingThresholdValue retrieves the value of the leaf RisingThresholdValue from the SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_PacketId_Threshold
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RisingThresholdValue is set, it can
// safely use t.GetRisingThresholdValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RisingThresholdValue == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_PacketId_Threshold) GetRisingThresholdValue() float64 {
	if t == nil || t.RisingThresholdValue == nil {
		return 0.0
	}
	return *t.RisingThresholdValue
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_PacketId_Threshold
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_PacketId_Threshold) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_PacketId_Threshold struct, which is a YANG list entry.
func (t *SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_PacketId_Threshold) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Index == nil {
		return nil, fmt.Errorf("nil value for key Index")
	}

	return map[string]interface{}{
		"index": *t.Index,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_PacketId_Threshold) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_PacketId_Threshold"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_PacketId_Threshold) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_PacketId_Threshold) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_PacketId_Threshold.
func (*SrlNokiaQos_Qos_ResourceManagement_ResourceUtilizationThresholds_PacketId_Threshold) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_RewriteRules represents the /srl_nokia-qos/qos/rewrite-rules YANG schema element.
type SrlNokiaQos_Qos_RewriteRules struct {
	Dot1PPolicy                map[string]*SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy            `path:"dot1p-policy" module:"srl_nokia-qos"`
	DscpPolicy                 map[string]*SrlNokiaQos_Qos_RewriteRules_DscpPolicy             `path:"dscp-policy" module:"srl_nokia-qos"`
	IpRewritePolicy            map[string]*SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy        `path:"ip-rewrite-policy" module:"srl_nokia-qos"`
	MplsTrafficClassPolicy     map[string]*SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy `path:"mpls-traffic-class-policy" module:"srl_nokia-qos"`
	VxlanOuterHeaderDscpPolicy *string                                                         `path:"vxlan-outer-header-dscp-policy" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_RewriteRules implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_RewriteRules) IsYANGGoStruct() {}

// NewDot1PPolicy creates a new entry in the Dot1PPolicy list of the
// SrlNokiaQos_Qos_RewriteRules struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaQos_Qos_RewriteRules) NewDot1PPolicy(Name string) (*SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Dot1PPolicy == nil {
		t.Dot1PPolicy = make(map[string]*SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Dot1PPolicy[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Dot1PPolicy", key)
	}

	t.Dot1PPolicy[key] = &SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy{
		Name: &Name,
	}

	return t.Dot1PPolicy[key], nil
}

// RenameDot1PPolicy renames an entry in the list Dot1PPolicy within
// the SrlNokiaQos_Qos_RewriteRules struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaQos_Qos_RewriteRules) RenameDot1PPolicy(oldK, newK string) error {
	if _, ok := t.Dot1PPolicy[newK]; ok {
		return fmt.Errorf("key %v already exists in Dot1PPolicy", newK)
	}

	e, ok := t.Dot1PPolicy[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Dot1PPolicy", oldK)
	}
	e.Name = &newK

	t.Dot1PPolicy[newK] = e
	delete(t.Dot1PPolicy, oldK)
	return nil
}

// GetOrCreateDot1PPolicy retrieves the value with the specified keys from
// the receiver SrlNokiaQos_Qos_RewriteRules. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaQos_Qos_RewriteRules) GetOrCreateDot1PPolicy(Name string) *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy {
	key := Name

	if v, ok := t.Dot1PPolicy[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewDot1PPolicy(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateDot1PPolicy got unexpected error: %v", err))
	}
	return v
}

// GetDot1PPolicy retrieves the value with the specified key from
// the Dot1PPolicy map field of SrlNokiaQos_Qos_RewriteRules. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaQos_Qos_RewriteRules) GetDot1PPolicy(Name string) *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Dot1PPolicy[key]; ok {
		return lm
	}
	return nil
}

// DeleteDot1PPolicy deletes the value with the specified keys from
// the receiver SrlNokiaQos_Qos_RewriteRules. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaQos_Qos_RewriteRules) DeleteDot1PPolicy(Name string) {
	key := Name

	delete(t.Dot1PPolicy, key)
}

// AppendDot1PPolicy appends the supplied SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy struct to the
// list Dot1PPolicy of SrlNokiaQos_Qos_RewriteRules. If the key value(s) specified in
// the supplied SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy already exist in the list, an error is
// returned.
func (t *SrlNokiaQos_Qos_RewriteRules) AppendDot1PPolicy(v *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Dot1PPolicy == nil {
		t.Dot1PPolicy = make(map[string]*SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy)
	}

	if _, ok := t.Dot1PPolicy[key]; ok {
		return fmt.Errorf("duplicate key for list Dot1PPolicy %v", key)
	}

	t.Dot1PPolicy[key] = v
	return nil
}

// NewDscpPolicy creates a new entry in the DscpPolicy list of the
// SrlNokiaQos_Qos_RewriteRules struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaQos_Qos_RewriteRules) NewDscpPolicy(Name string) (*SrlNokiaQos_Qos_RewriteRules_DscpPolicy, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.DscpPolicy == nil {
		t.DscpPolicy = make(map[string]*SrlNokiaQos_Qos_RewriteRules_DscpPolicy)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.DscpPolicy[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list DscpPolicy", key)
	}

	t.DscpPolicy[key] = &SrlNokiaQos_Qos_RewriteRules_DscpPolicy{
		Name: &Name,
	}

	return t.DscpPolicy[key], nil
}

// RenameDscpPolicy renames an entry in the list DscpPolicy within
// the SrlNokiaQos_Qos_RewriteRules struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaQos_Qos_RewriteRules) RenameDscpPolicy(oldK, newK string) error {
	if _, ok := t.DscpPolicy[newK]; ok {
		return fmt.Errorf("key %v already exists in DscpPolicy", newK)
	}

	e, ok := t.DscpPolicy[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in DscpPolicy", oldK)
	}
	e.Name = &newK

	t.DscpPolicy[newK] = e
	delete(t.DscpPolicy, oldK)
	return nil
}

// GetOrCreateDscpPolicy retrieves the value with the specified keys from
// the receiver SrlNokiaQos_Qos_RewriteRules. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaQos_Qos_RewriteRules) GetOrCreateDscpPolicy(Name string) *SrlNokiaQos_Qos_RewriteRules_DscpPolicy {
	key := Name

	if v, ok := t.DscpPolicy[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewDscpPolicy(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateDscpPolicy got unexpected error: %v", err))
	}
	return v
}

// GetDscpPolicy retrieves the value with the specified key from
// the DscpPolicy map field of SrlNokiaQos_Qos_RewriteRules. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaQos_Qos_RewriteRules) GetDscpPolicy(Name string) *SrlNokiaQos_Qos_RewriteRules_DscpPolicy {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.DscpPolicy[key]; ok {
		return lm
	}
	return nil
}

// DeleteDscpPolicy deletes the value with the specified keys from
// the receiver SrlNokiaQos_Qos_RewriteRules. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaQos_Qos_RewriteRules) DeleteDscpPolicy(Name string) {
	key := Name

	delete(t.DscpPolicy, key)
}

// AppendDscpPolicy appends the supplied SrlNokiaQos_Qos_RewriteRules_DscpPolicy struct to the
// list DscpPolicy of SrlNokiaQos_Qos_RewriteRules. If the key value(s) specified in
// the supplied SrlNokiaQos_Qos_RewriteRules_DscpPolicy already exist in the list, an error is
// returned.
func (t *SrlNokiaQos_Qos_RewriteRules) AppendDscpPolicy(v *SrlNokiaQos_Qos_RewriteRules_DscpPolicy) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.DscpPolicy == nil {
		t.DscpPolicy = make(map[string]*SrlNokiaQos_Qos_RewriteRules_DscpPolicy)
	}

	if _, ok := t.DscpPolicy[key]; ok {
		return fmt.Errorf("duplicate key for list DscpPolicy %v", key)
	}

	t.DscpPolicy[key] = v
	return nil
}

// NewIpRewritePolicy creates a new entry in the IpRewritePolicy list of the
// SrlNokiaQos_Qos_RewriteRules struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaQos_Qos_RewriteRules) NewIpRewritePolicy(Name string) (*SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.IpRewritePolicy == nil {
		t.IpRewritePolicy = make(map[string]*SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.IpRewritePolicy[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list IpRewritePolicy", key)
	}

	t.IpRewritePolicy[key] = &SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy{
		Name: &Name,
	}

	return t.IpRewritePolicy[key], nil
}

// RenameIpRewritePolicy renames an entry in the list IpRewritePolicy within
// the SrlNokiaQos_Qos_RewriteRules struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaQos_Qos_RewriteRules) RenameIpRewritePolicy(oldK, newK string) error {
	if _, ok := t.IpRewritePolicy[newK]; ok {
		return fmt.Errorf("key %v already exists in IpRewritePolicy", newK)
	}

	e, ok := t.IpRewritePolicy[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in IpRewritePolicy", oldK)
	}
	e.Name = &newK

	t.IpRewritePolicy[newK] = e
	delete(t.IpRewritePolicy, oldK)
	return nil
}

// GetOrCreateIpRewritePolicy retrieves the value with the specified keys from
// the receiver SrlNokiaQos_Qos_RewriteRules. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaQos_Qos_RewriteRules) GetOrCreateIpRewritePolicy(Name string) *SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy {
	key := Name

	if v, ok := t.IpRewritePolicy[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewIpRewritePolicy(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateIpRewritePolicy got unexpected error: %v", err))
	}
	return v
}

// GetIpRewritePolicy retrieves the value with the specified key from
// the IpRewritePolicy map field of SrlNokiaQos_Qos_RewriteRules. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaQos_Qos_RewriteRules) GetIpRewritePolicy(Name string) *SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.IpRewritePolicy[key]; ok {
		return lm
	}
	return nil
}

// DeleteIpRewritePolicy deletes the value with the specified keys from
// the receiver SrlNokiaQos_Qos_RewriteRules. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaQos_Qos_RewriteRules) DeleteIpRewritePolicy(Name string) {
	key := Name

	delete(t.IpRewritePolicy, key)
}

// AppendIpRewritePolicy appends the supplied SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy struct to the
// list IpRewritePolicy of SrlNokiaQos_Qos_RewriteRules. If the key value(s) specified in
// the supplied SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy already exist in the list, an error is
// returned.
func (t *SrlNokiaQos_Qos_RewriteRules) AppendIpRewritePolicy(v *SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.IpRewritePolicy == nil {
		t.IpRewritePolicy = make(map[string]*SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy)
	}

	if _, ok := t.IpRewritePolicy[key]; ok {
		return fmt.Errorf("duplicate key for list IpRewritePolicy %v", key)
	}

	t.IpRewritePolicy[key] = v
	return nil
}

// NewMplsTrafficClassPolicy creates a new entry in the MplsTrafficClassPolicy list of the
// SrlNokiaQos_Qos_RewriteRules struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaQos_Qos_RewriteRules) NewMplsTrafficClassPolicy(Name string) (*SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.MplsTrafficClassPolicy == nil {
		t.MplsTrafficClassPolicy = make(map[string]*SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.MplsTrafficClassPolicy[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list MplsTrafficClassPolicy", key)
	}

	t.MplsTrafficClassPolicy[key] = &SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy{
		Name: &Name,
	}

	return t.MplsTrafficClassPolicy[key], nil
}

// RenameMplsTrafficClassPolicy renames an entry in the list MplsTrafficClassPolicy within
// the SrlNokiaQos_Qos_RewriteRules struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaQos_Qos_RewriteRules) RenameMplsTrafficClassPolicy(oldK, newK string) error {
	if _, ok := t.MplsTrafficClassPolicy[newK]; ok {
		return fmt.Errorf("key %v already exists in MplsTrafficClassPolicy", newK)
	}

	e, ok := t.MplsTrafficClassPolicy[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in MplsTrafficClassPolicy", oldK)
	}
	e.Name = &newK

	t.MplsTrafficClassPolicy[newK] = e
	delete(t.MplsTrafficClassPolicy, oldK)
	return nil
}

// GetOrCreateMplsTrafficClassPolicy retrieves the value with the specified keys from
// the receiver SrlNokiaQos_Qos_RewriteRules. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaQos_Qos_RewriteRules) GetOrCreateMplsTrafficClassPolicy(Name string) *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy {
	key := Name

	if v, ok := t.MplsTrafficClassPolicy[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewMplsTrafficClassPolicy(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateMplsTrafficClassPolicy got unexpected error: %v", err))
	}
	return v
}

// GetMplsTrafficClassPolicy retrieves the value with the specified key from
// the MplsTrafficClassPolicy map field of SrlNokiaQos_Qos_RewriteRules. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaQos_Qos_RewriteRules) GetMplsTrafficClassPolicy(Name string) *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.MplsTrafficClassPolicy[key]; ok {
		return lm
	}
	return nil
}

// DeleteMplsTrafficClassPolicy deletes the value with the specified keys from
// the receiver SrlNokiaQos_Qos_RewriteRules. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaQos_Qos_RewriteRules) DeleteMplsTrafficClassPolicy(Name string) {
	key := Name

	delete(t.MplsTrafficClassPolicy, key)
}

// AppendMplsTrafficClassPolicy appends the supplied SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy struct to the
// list MplsTrafficClassPolicy of SrlNokiaQos_Qos_RewriteRules. If the key value(s) specified in
// the supplied SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy already exist in the list, an error is
// returned.
func (t *SrlNokiaQos_Qos_RewriteRules) AppendMplsTrafficClassPolicy(
	v *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy,
) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.MplsTrafficClassPolicy == nil {
		t.MplsTrafficClassPolicy = make(map[string]*SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy)
	}

	if _, ok := t.MplsTrafficClassPolicy[key]; ok {
		return fmt.Errorf("duplicate key for list MplsTrafficClassPolicy %v", key)
	}

	t.MplsTrafficClassPolicy[key] = v
	return nil
}

// GetVxlanOuterHeaderDscpPolicy retrieves the value of the leaf VxlanOuterHeaderDscpPolicy from the SrlNokiaQos_Qos_RewriteRules
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VxlanOuterHeaderDscpPolicy is set, it can
// safely use t.GetVxlanOuterHeaderDscpPolicy() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VxlanOuterHeaderDscpPolicy == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_RewriteRules) GetVxlanOuterHeaderDscpPolicy() string {
	if t == nil || t.VxlanOuterHeaderDscpPolicy == nil {
		return ""
	}
	return *t.VxlanOuterHeaderDscpPolicy
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_RewriteRules
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_RewriteRules) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Dot1PPolicy {
		e.PopulateDefaults()
	}
	for _, e := range t.DscpPolicy {
		e.PopulateDefaults()
	}
	for _, e := range t.IpRewritePolicy {
		e.PopulateDefaults()
	}
	for _, e := range t.MplsTrafficClassPolicy {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_RewriteRules) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_RewriteRules"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_RewriteRules) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_RewriteRules) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_RewriteRules.
func (*SrlNokiaQos_Qos_RewriteRules) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy represents the /srl_nokia-qos/qos/rewrite-rules/dot1p-policy YANG schema element.
type SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy struct {
	Map  map[SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_ForwardingClass_Union]*SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map `path:"map" module:"srl_nokia-qos"`
	Name *string                                                                                                              `path:"name" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy) IsYANGGoStruct() {}

// NewMap creates a new entry in the Map list of the
// SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy) NewMap(ForwardingClass SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_ForwardingClass_Union) (*SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Map == nil {
		t.Map = make(map[SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_ForwardingClass_Union]*SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map)
	}

	key := ForwardingClass

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Map[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Map", key)
	}

	t.Map[key] = &SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map{
		ForwardingClass: ForwardingClass,
	}

	return t.Map[key], nil
}

// RenameMap renames an entry in the list Map within
// the SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy) RenameMap(
	oldK, newK SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_ForwardingClass_Union,
) error {
	if _, ok := t.Map[newK]; ok {
		return fmt.Errorf("key %v already exists in Map", newK)
	}

	e, ok := t.Map[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Map", oldK)
	}
	e.ForwardingClass = newK

	t.Map[newK] = e
	delete(t.Map, oldK)
	return nil
}

// GetOrCreateMap retrieves the value with the specified keys from
// the receiver SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy) GetOrCreateMap(
	ForwardingClass SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_ForwardingClass_Union,
) *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map {
	key := ForwardingClass

	if v, ok := t.Map[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewMap(ForwardingClass)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateMap got unexpected error: %v", err))
	}
	return v
}

// GetMap retrieves the value with the specified key from
// the Map map field of SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy) GetMap(ForwardingClass SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_ForwardingClass_Union) *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map {
	if t == nil {
		return nil
	}

	key := ForwardingClass

	if lm, ok := t.Map[key]; ok {
		return lm
	}
	return nil
}

// DeleteMap deletes the value with the specified keys from
// the receiver SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy) DeleteMap(
	ForwardingClass SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_ForwardingClass_Union,
) {
	key := ForwardingClass

	delete(t.Map, key)
}

// AppendMap appends the supplied SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map struct to the
// list Map of SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy. If the key value(s) specified in
// the supplied SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map already exist in the list, an error is
// returned.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy) AppendMap(v *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map) error {
	key := v.ForwardingClass

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Map == nil {
		t.Map = make(map[SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_ForwardingClass_Union]*SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map)
	}

	if _, ok := t.Map[key]; ok {
		return fmt.Errorf("duplicate key for list Map %v", key)
	}

	t.Map[key] = v
	return nil
}

// GetName retrieves the value of the leaf Name from the SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Map {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy struct, which is a YANG list entry.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy.
func (*SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map represents the /srl_nokia-qos/qos/rewrite-rules/dot1p-policy/map YANG schema element.
type SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map struct {
	Dot1P           *uint8                                                                                             `path:"dot1p" module:"srl_nokia-qos"`
	DropProbability map[E_SrlNokiaCommon_DropProbability]*SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_DropProbability `path:"drop-probability" module:"srl_nokia-qos"`
	ForwardingClass SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_ForwardingClass_Union                                 `path:"forwarding-class" module:"srl_nokia-qos"`
	InnerDe         *bool                                                                                              `path:"inner-de" module:"srl_nokia-qos"`
	InnerDot1P      *uint8                                                                                             `path:"inner-dot1p" module:"srl_nokia-qos"`
	OuterDe         *bool                                                                                              `path:"outer-de" module:"srl_nokia-qos"`
	OuterDot1P      *uint8                                                                                             `path:"outer-dot1p" module:"srl_nokia-qos"`
	Profile         map[E_SrlNokiaCommon_RewriteProfile]*SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_Profile          `path:"profile" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map) IsYANGGoStruct() {}

// NewDropProbability creates a new entry in the DropProbability list of the
// SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map) NewDropProbability(
	DropProbability E_SrlNokiaCommon_DropProbability,
) (*SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_DropProbability, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.DropProbability == nil {
		t.DropProbability = make(map[E_SrlNokiaCommon_DropProbability]*SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_DropProbability)
	}

	key := DropProbability

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.DropProbability[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list DropProbability", key)
	}

	t.DropProbability[key] = &SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_DropProbability{
		DropProbability: DropProbability,
	}

	return t.DropProbability[key], nil
}

// RenameDropProbability renames an entry in the list DropProbability within
// the SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map) RenameDropProbability(oldK, newK E_SrlNokiaCommon_DropProbability) error {
	if _, ok := t.DropProbability[newK]; ok {
		return fmt.Errorf("key %v already exists in DropProbability", newK)
	}

	e, ok := t.DropProbability[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in DropProbability", oldK)
	}
	e.DropProbability = newK

	t.DropProbability[newK] = e
	delete(t.DropProbability, oldK)
	return nil
}

// GetOrCreateDropProbability retrieves the value with the specified keys from
// the receiver SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map) GetOrCreateDropProbability(
	DropProbability E_SrlNokiaCommon_DropProbability,
) *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_DropProbability {
	key := DropProbability

	if v, ok := t.DropProbability[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewDropProbability(DropProbability)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateDropProbability got unexpected error: %v", err))
	}
	return v
}

// GetDropProbability retrieves the value with the specified key from
// the DropProbability map field of SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map) GetDropProbability(
	DropProbability E_SrlNokiaCommon_DropProbability,
) *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_DropProbability {
	if t == nil {
		return nil
	}

	key := DropProbability

	if lm, ok := t.DropProbability[key]; ok {
		return lm
	}
	return nil
}

// DeleteDropProbability deletes the value with the specified keys from
// the receiver SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map) DeleteDropProbability(DropProbability E_SrlNokiaCommon_DropProbability) {
	key := DropProbability

	delete(t.DropProbability, key)
}

// AppendDropProbability appends the supplied SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_DropProbability struct to the
// list DropProbability of SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map. If the key value(s) specified in
// the supplied SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_DropProbability already exist in the list, an error is
// returned.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map) AppendDropProbability(
	v *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_DropProbability,
) error {
	key := v.DropProbability

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.DropProbability == nil {
		t.DropProbability = make(map[E_SrlNokiaCommon_DropProbability]*SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_DropProbability)
	}

	if _, ok := t.DropProbability[key]; ok {
		return fmt.Errorf("duplicate key for list DropProbability %v", key)
	}

	t.DropProbability[key] = v
	return nil
}

// NewProfile creates a new entry in the Profile list of the
// SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map) NewProfile(
	Profile E_SrlNokiaCommon_RewriteProfile,
) (*SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_Profile, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Profile == nil {
		t.Profile = make(map[E_SrlNokiaCommon_RewriteProfile]*SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_Profile)
	}

	key := Profile

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Profile[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Profile", key)
	}

	t.Profile[key] = &SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_Profile{
		Profile: Profile,
	}

	return t.Profile[key], nil
}

// RenameProfile renames an entry in the list Profile within
// the SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map) RenameProfile(oldK, newK E_SrlNokiaCommon_RewriteProfile) error {
	if _, ok := t.Profile[newK]; ok {
		return fmt.Errorf("key %v already exists in Profile", newK)
	}

	e, ok := t.Profile[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Profile", oldK)
	}
	e.Profile = newK

	t.Profile[newK] = e
	delete(t.Profile, oldK)
	return nil
}

// GetOrCreateProfile retrieves the value with the specified keys from
// the receiver SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map) GetOrCreateProfile(
	Profile E_SrlNokiaCommon_RewriteProfile,
) *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_Profile {
	key := Profile

	if v, ok := t.Profile[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewProfile(Profile)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateProfile got unexpected error: %v", err))
	}
	return v
}

// GetProfile retrieves the value with the specified key from
// the Profile map field of SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map) GetProfile(
	Profile E_SrlNokiaCommon_RewriteProfile,
) *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_Profile {
	if t == nil {
		return nil
	}

	key := Profile

	if lm, ok := t.Profile[key]; ok {
		return lm
	}
	return nil
}

// DeleteProfile deletes the value with the specified keys from
// the receiver SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map) DeleteProfile(Profile E_SrlNokiaCommon_RewriteProfile) {
	key := Profile

	delete(t.Profile, key)
}

// AppendProfile appends the supplied SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_Profile struct to the
// list Profile of SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map. If the key value(s) specified in
// the supplied SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_Profile already exist in the list, an error is
// returned.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map) AppendProfile(
	v *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_Profile,
) error {
	key := v.Profile

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Profile == nil {
		t.Profile = make(map[E_SrlNokiaCommon_RewriteProfile]*SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_Profile)
	}

	if _, ok := t.Profile[key]; ok {
		return fmt.Errorf("duplicate key for list Profile %v", key)
	}

	t.Profile[key] = v
	return nil
}

// GetDot1P retrieves the value of the leaf Dot1P from the SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Dot1P is set, it can
// safely use t.GetDot1P() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Dot1P == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map) GetDot1P() uint8 {
	if t == nil || t.Dot1P == nil {
		return 0
	}
	return *t.Dot1P
}

// GetForwardingClass retrieves the value of the leaf ForwardingClass from the SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ForwardingClass is set, it can
// safely use t.GetForwardingClass() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ForwardingClass == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map) GetForwardingClass() SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_ForwardingClass_Union {
	if t == nil || t.ForwardingClass == nil {
		return nil
	}
	return t.ForwardingClass
}

// GetInnerDe retrieves the value of the leaf InnerDe from the SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InnerDe is set, it can
// safely use t.GetInnerDe() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InnerDe == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map) GetInnerDe() bool {
	if t == nil || t.InnerDe == nil {
		return false
	}
	return *t.InnerDe
}

// GetInnerDot1P retrieves the value of the leaf InnerDot1P from the SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InnerDot1P is set, it can
// safely use t.GetInnerDot1P() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InnerDot1P == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map) GetInnerDot1P() uint8 {
	if t == nil || t.InnerDot1P == nil {
		return 0
	}
	return *t.InnerDot1P
}

// GetOuterDe retrieves the value of the leaf OuterDe from the SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OuterDe is set, it can
// safely use t.GetOuterDe() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OuterDe == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map) GetOuterDe() bool {
	if t == nil || t.OuterDe == nil {
		return false
	}
	return *t.OuterDe
}

// GetOuterDot1P retrieves the value of the leaf OuterDot1P from the SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OuterDot1P is set, it can
// safely use t.GetOuterDot1P() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OuterDot1P == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map) GetOuterDot1P() uint8 {
	if t == nil || t.OuterDot1P == nil {
		return 0
	}
	return *t.OuterDot1P
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.InnerDe == nil {
		var v bool = false
		t.InnerDe = &v
	}
	if t.OuterDe == nil {
		var v bool = false
		t.OuterDe = &v
	}
	for _, e := range t.DropProbability {
		e.PopulateDefaults()
	}
	for _, e := range t.Profile {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map struct, which is a YANG list entry.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"forwarding-class": t.ForwardingClass,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map.
func (*SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_DropProbability represents the /srl_nokia-qos/qos/rewrite-rules/dot1p-policy/map/drop-probability YANG schema element.
type SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_DropProbability struct {
	Dot1P           *uint8                           `path:"dot1p" module:"srl_nokia-qos"`
	DropProbability E_SrlNokiaCommon_DropProbability `path:"drop-probability" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_DropProbability implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_DropProbability) IsYANGGoStruct() {}

// GetDot1P retrieves the value of the leaf Dot1P from the SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_DropProbability
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Dot1P is set, it can
// safely use t.GetDot1P() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Dot1P == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_DropProbability) GetDot1P() uint8 {
	if t == nil || t.Dot1P == nil {
		return 0
	}
	return *t.Dot1P
}

// GetDropProbability retrieves the value of the leaf DropProbability from the SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_DropProbability
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DropProbability is set, it can
// safely use t.GetDropProbability() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DropProbability == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_DropProbability) GetDropProbability() E_SrlNokiaCommon_DropProbability {
	if t == nil || t.DropProbability == 0 {
		return 0
	}
	return t.DropProbability
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_DropProbability
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_DropProbability) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_DropProbability struct, which is a YANG list entry.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_DropProbability) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"drop-probability": t.DropProbability,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_DropProbability) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_DropProbability"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_DropProbability) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_DropProbability) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_DropProbability.
func (*SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_DropProbability) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_Profile represents the /srl_nokia-qos/qos/rewrite-rules/dot1p-policy/map/profile YANG schema element.
type SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_Profile struct {
	InnerDe    *bool                           `path:"inner-de" module:"srl_nokia-qos"`
	InnerDot1P *uint8                          `path:"inner-dot1p" module:"srl_nokia-qos"`
	OuterDe    *bool                           `path:"outer-de" module:"srl_nokia-qos"`
	OuterDot1P *uint8                          `path:"outer-dot1p" module:"srl_nokia-qos"`
	Profile    E_SrlNokiaCommon_RewriteProfile `path:"profile" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_Profile implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_Profile) IsYANGGoStruct() {}

// GetInnerDe retrieves the value of the leaf InnerDe from the SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_Profile
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InnerDe is set, it can
// safely use t.GetInnerDe() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InnerDe == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_Profile) GetInnerDe() bool {
	if t == nil || t.InnerDe == nil {
		return false
	}
	return *t.InnerDe
}

// GetInnerDot1P retrieves the value of the leaf InnerDot1P from the SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_Profile
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InnerDot1P is set, it can
// safely use t.GetInnerDot1P() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InnerDot1P == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_Profile) GetInnerDot1P() uint8 {
	if t == nil || t.InnerDot1P == nil {
		return 0
	}
	return *t.InnerDot1P
}

// GetOuterDe retrieves the value of the leaf OuterDe from the SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_Profile
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OuterDe is set, it can
// safely use t.GetOuterDe() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OuterDe == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_Profile) GetOuterDe() bool {
	if t == nil || t.OuterDe == nil {
		return false
	}
	return *t.OuterDe
}

// GetOuterDot1P retrieves the value of the leaf OuterDot1P from the SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_Profile
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OuterDot1P is set, it can
// safely use t.GetOuterDot1P() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OuterDot1P == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_Profile) GetOuterDot1P() uint8 {
	if t == nil || t.OuterDot1P == nil {
		return 0
	}
	return *t.OuterDot1P
}

// GetProfile retrieves the value of the leaf Profile from the SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_Profile
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Profile is set, it can
// safely use t.GetProfile() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Profile == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_Profile) GetProfile() E_SrlNokiaCommon_RewriteProfile {
	if t == nil || t.Profile == 0 {
		return 0
	}
	return t.Profile
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_Profile
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_Profile) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.InnerDe == nil {
		var v bool = false
		t.InnerDe = &v
	}
	if t.OuterDe == nil {
		var v bool = false
		t.OuterDe = &v
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_Profile struct, which is a YANG list entry.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_Profile) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"profile": t.Profile,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_Profile) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_Profile"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_Profile) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_Profile) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_Profile.
func (*SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_Profile) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_RewriteRules_DscpPolicy represents the /srl_nokia-qos/qos/rewrite-rules/dscp-policy YANG schema element.
type SrlNokiaQos_Qos_RewriteRules_DscpPolicy struct {
	Map  map[SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_ForwardingClass_Union]*SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map `path:"map" module:"srl_nokia-qos"`
	Name *string                                                                                                            `path:"name" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_RewriteRules_DscpPolicy implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_RewriteRules_DscpPolicy) IsYANGGoStruct() {}

// NewMap creates a new entry in the Map list of the
// SrlNokiaQos_Qos_RewriteRules_DscpPolicy struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaQos_Qos_RewriteRules_DscpPolicy) NewMap(ForwardingClass SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_ForwardingClass_Union) (*SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Map == nil {
		t.Map = make(map[SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_ForwardingClass_Union]*SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map)
	}

	key := ForwardingClass

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Map[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Map", key)
	}

	t.Map[key] = &SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map{
		ForwardingClass: ForwardingClass,
	}

	return t.Map[key], nil
}

// RenameMap renames an entry in the list Map within
// the SrlNokiaQos_Qos_RewriteRules_DscpPolicy struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaQos_Qos_RewriteRules_DscpPolicy) RenameMap(
	oldK, newK SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_ForwardingClass_Union,
) error {
	if _, ok := t.Map[newK]; ok {
		return fmt.Errorf("key %v already exists in Map", newK)
	}

	e, ok := t.Map[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Map", oldK)
	}
	e.ForwardingClass = newK

	t.Map[newK] = e
	delete(t.Map, oldK)
	return nil
}

// GetOrCreateMap retrieves the value with the specified keys from
// the receiver SrlNokiaQos_Qos_RewriteRules_DscpPolicy. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaQos_Qos_RewriteRules_DscpPolicy) GetOrCreateMap(
	ForwardingClass SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_ForwardingClass_Union,
) *SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map {
	key := ForwardingClass

	if v, ok := t.Map[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewMap(ForwardingClass)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateMap got unexpected error: %v", err))
	}
	return v
}

// GetMap retrieves the value with the specified key from
// the Map map field of SrlNokiaQos_Qos_RewriteRules_DscpPolicy. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaQos_Qos_RewriteRules_DscpPolicy) GetMap(ForwardingClass SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_ForwardingClass_Union) *SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map {
	if t == nil {
		return nil
	}

	key := ForwardingClass

	if lm, ok := t.Map[key]; ok {
		return lm
	}
	return nil
}

// DeleteMap deletes the value with the specified keys from
// the receiver SrlNokiaQos_Qos_RewriteRules_DscpPolicy. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaQos_Qos_RewriteRules_DscpPolicy) DeleteMap(
	ForwardingClass SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_ForwardingClass_Union,
) {
	key := ForwardingClass

	delete(t.Map, key)
}

// AppendMap appends the supplied SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map struct to the
// list Map of SrlNokiaQos_Qos_RewriteRules_DscpPolicy. If the key value(s) specified in
// the supplied SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map already exist in the list, an error is
// returned.
func (t *SrlNokiaQos_Qos_RewriteRules_DscpPolicy) AppendMap(v *SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map) error {
	key := v.ForwardingClass

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Map == nil {
		t.Map = make(map[SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_ForwardingClass_Union]*SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map)
	}

	if _, ok := t.Map[key]; ok {
		return fmt.Errorf("duplicate key for list Map %v", key)
	}

	t.Map[key] = v
	return nil
}

// GetName retrieves the value of the leaf Name from the SrlNokiaQos_Qos_RewriteRules_DscpPolicy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_RewriteRules_DscpPolicy) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_RewriteRules_DscpPolicy
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_RewriteRules_DscpPolicy) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Map {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaQos_Qos_RewriteRules_DscpPolicy struct, which is a YANG list entry.
func (t *SrlNokiaQos_Qos_RewriteRules_DscpPolicy) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_RewriteRules_DscpPolicy) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_RewriteRules_DscpPolicy"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_RewriteRules_DscpPolicy) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_RewriteRules_DscpPolicy) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_RewriteRules_DscpPolicy.
func (*SrlNokiaQos_Qos_RewriteRules_DscpPolicy) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map represents the /srl_nokia-qos/qos/rewrite-rules/dscp-policy/map YANG schema element.
type SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map struct {
	DropProbability map[E_SrlNokiaCommon_DropProbability]*SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_DropProbability `path:"drop-probability" module:"srl_nokia-qos"`
	Dscp            SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_Dscp_Union                                            `path:"dscp" module:"srl_nokia-qos"`
	ForwardingClass SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_ForwardingClass_Union                                 `path:"forwarding-class" module:"srl_nokia-qos"`
	Profile         map[E_SrlNokiaCommon_RewriteProfile]*SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_Profile          `path:"profile" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map) IsYANGGoStruct() {}

// NewDropProbability creates a new entry in the DropProbability list of the
// SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map) NewDropProbability(
	DropProbability E_SrlNokiaCommon_DropProbability,
) (*SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_DropProbability, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.DropProbability == nil {
		t.DropProbability = make(map[E_SrlNokiaCommon_DropProbability]*SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_DropProbability)
	}

	key := DropProbability

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.DropProbability[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list DropProbability", key)
	}

	t.DropProbability[key] = &SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_DropProbability{
		DropProbability: DropProbability,
	}

	return t.DropProbability[key], nil
}

// RenameDropProbability renames an entry in the list DropProbability within
// the SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map) RenameDropProbability(oldK, newK E_SrlNokiaCommon_DropProbability) error {
	if _, ok := t.DropProbability[newK]; ok {
		return fmt.Errorf("key %v already exists in DropProbability", newK)
	}

	e, ok := t.DropProbability[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in DropProbability", oldK)
	}
	e.DropProbability = newK

	t.DropProbability[newK] = e
	delete(t.DropProbability, oldK)
	return nil
}

// GetOrCreateDropProbability retrieves the value with the specified keys from
// the receiver SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map) GetOrCreateDropProbability(
	DropProbability E_SrlNokiaCommon_DropProbability,
) *SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_DropProbability {
	key := DropProbability

	if v, ok := t.DropProbability[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewDropProbability(DropProbability)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateDropProbability got unexpected error: %v", err))
	}
	return v
}

// GetDropProbability retrieves the value with the specified key from
// the DropProbability map field of SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map) GetDropProbability(
	DropProbability E_SrlNokiaCommon_DropProbability,
) *SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_DropProbability {
	if t == nil {
		return nil
	}

	key := DropProbability

	if lm, ok := t.DropProbability[key]; ok {
		return lm
	}
	return nil
}

// DeleteDropProbability deletes the value with the specified keys from
// the receiver SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map) DeleteDropProbability(DropProbability E_SrlNokiaCommon_DropProbability) {
	key := DropProbability

	delete(t.DropProbability, key)
}

// AppendDropProbability appends the supplied SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_DropProbability struct to the
// list DropProbability of SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map. If the key value(s) specified in
// the supplied SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_DropProbability already exist in the list, an error is
// returned.
func (t *SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map) AppendDropProbability(
	v *SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_DropProbability,
) error {
	key := v.DropProbability

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.DropProbability == nil {
		t.DropProbability = make(map[E_SrlNokiaCommon_DropProbability]*SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_DropProbability)
	}

	if _, ok := t.DropProbability[key]; ok {
		return fmt.Errorf("duplicate key for list DropProbability %v", key)
	}

	t.DropProbability[key] = v
	return nil
}

// NewProfile creates a new entry in the Profile list of the
// SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map) NewProfile(
	Profile E_SrlNokiaCommon_RewriteProfile,
) (*SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_Profile, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Profile == nil {
		t.Profile = make(map[E_SrlNokiaCommon_RewriteProfile]*SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_Profile)
	}

	key := Profile

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Profile[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Profile", key)
	}

	t.Profile[key] = &SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_Profile{
		Profile: Profile,
	}

	return t.Profile[key], nil
}

// RenameProfile renames an entry in the list Profile within
// the SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map) RenameProfile(oldK, newK E_SrlNokiaCommon_RewriteProfile) error {
	if _, ok := t.Profile[newK]; ok {
		return fmt.Errorf("key %v already exists in Profile", newK)
	}

	e, ok := t.Profile[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Profile", oldK)
	}
	e.Profile = newK

	t.Profile[newK] = e
	delete(t.Profile, oldK)
	return nil
}

// GetOrCreateProfile retrieves the value with the specified keys from
// the receiver SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map) GetOrCreateProfile(
	Profile E_SrlNokiaCommon_RewriteProfile,
) *SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_Profile {
	key := Profile

	if v, ok := t.Profile[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewProfile(Profile)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateProfile got unexpected error: %v", err))
	}
	return v
}

// GetProfile retrieves the value with the specified key from
// the Profile map field of SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map) GetProfile(
	Profile E_SrlNokiaCommon_RewriteProfile,
) *SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_Profile {
	if t == nil {
		return nil
	}

	key := Profile

	if lm, ok := t.Profile[key]; ok {
		return lm
	}
	return nil
}

// DeleteProfile deletes the value with the specified keys from
// the receiver SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map) DeleteProfile(Profile E_SrlNokiaCommon_RewriteProfile) {
	key := Profile

	delete(t.Profile, key)
}

// AppendProfile appends the supplied SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_Profile struct to the
// list Profile of SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map. If the key value(s) specified in
// the supplied SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_Profile already exist in the list, an error is
// returned.
func (t *SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map) AppendProfile(
	v *SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_Profile,
) error {
	key := v.Profile

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Profile == nil {
		t.Profile = make(map[E_SrlNokiaCommon_RewriteProfile]*SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_Profile)
	}

	if _, ok := t.Profile[key]; ok {
		return fmt.Errorf("duplicate key for list Profile %v", key)
	}

	t.Profile[key] = v
	return nil
}

// GetDscp retrieves the value of the leaf Dscp from the SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Dscp is set, it can
// safely use t.GetDscp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Dscp == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map) GetDscp() SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_Dscp_Union {
	if t == nil || t.Dscp == nil {
		return nil
	}
	return t.Dscp
}

// GetForwardingClass retrieves the value of the leaf ForwardingClass from the SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ForwardingClass is set, it can
// safely use t.GetForwardingClass() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ForwardingClass == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map) GetForwardingClass() SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_ForwardingClass_Union {
	if t == nil || t.ForwardingClass == nil {
		return nil
	}
	return t.ForwardingClass
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.DropProbability {
		e.PopulateDefaults()
	}
	for _, e := range t.Profile {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map struct, which is a YANG list entry.
func (t *SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"forwarding-class": t.ForwardingClass,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map.
func (*SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_DropProbability represents the /srl_nokia-qos/qos/rewrite-rules/dscp-policy/map/drop-probability YANG schema element.
type SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_DropProbability struct {
	DropProbability E_SrlNokiaCommon_DropProbability                                       `path:"drop-probability" module:"srl_nokia-qos"`
	Dscp            SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_DropProbability_Dscp_Union `path:"dscp" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_DropProbability implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_DropProbability) IsYANGGoStruct() {}

// GetDropProbability retrieves the value of the leaf DropProbability from the SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_DropProbability
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DropProbability is set, it can
// safely use t.GetDropProbability() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DropProbability == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_DropProbability) GetDropProbability() E_SrlNokiaCommon_DropProbability {
	if t == nil || t.DropProbability == 0 {
		return 0
	}
	return t.DropProbability
}

// GetDscp retrieves the value of the leaf Dscp from the SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_DropProbability
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Dscp is set, it can
// safely use t.GetDscp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Dscp == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_DropProbability) GetDscp() SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_DropProbability_Dscp_Union {
	if t == nil || t.Dscp == nil {
		return nil
	}
	return t.Dscp
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_DropProbability
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_DropProbability) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_DropProbability struct, which is a YANG list entry.
func (t *SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_DropProbability) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"drop-probability": t.DropProbability,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_DropProbability) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_DropProbability"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_DropProbability) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_DropProbability) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_DropProbability.
func (*SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_DropProbability) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_Profile represents the /srl_nokia-qos/qos/rewrite-rules/dscp-policy/map/profile YANG schema element.
type SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_Profile struct {
	Dscp    SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_Profile_Dscp_Union `path:"dscp" module:"srl_nokia-qos"`
	Profile E_SrlNokiaCommon_RewriteProfile                                `path:"profile" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_Profile implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_Profile) IsYANGGoStruct() {}

// GetDscp retrieves the value of the leaf Dscp from the SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_Profile
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Dscp is set, it can
// safely use t.GetDscp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Dscp == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_Profile) GetDscp() SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_Profile_Dscp_Union {
	if t == nil || t.Dscp == nil {
		return nil
	}
	return t.Dscp
}

// GetProfile retrieves the value of the leaf Profile from the SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_Profile
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Profile is set, it can
// safely use t.GetProfile() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Profile == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_Profile) GetProfile() E_SrlNokiaCommon_RewriteProfile {
	if t == nil || t.Profile == 0 {
		return 0
	}
	return t.Profile
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_Profile
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_Profile) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_Profile struct, which is a YANG list entry.
func (t *SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_Profile) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"profile": t.Profile,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_Profile) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_Profile"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_Profile) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_Profile) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_Profile.
func (*SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_Profile) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy represents the /srl_nokia-qos/qos/rewrite-rules/ip-rewrite-policy YANG schema element.
type SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy struct {
	Exceed *SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy_Exceed `path:"exceed" module:"srl_nokia-qos"`
	In     *SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy_In     `path:"in" module:"srl_nokia-qos"`
	InPlus *SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy_InPlus `path:"in-plus" module:"srl_nokia-qos"`
	Name   *string                                              `path:"name" module:"srl_nokia-qos"`
	Out    *SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy_Out    `path:"out" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy) IsYANGGoStruct() {}

// GetOrCreateExceed retrieves the value of the Exceed field
// or returns the existing field if it already exists.
func (t *SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy) GetOrCreateExceed() *SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy_Exceed {
	if t.Exceed != nil {
		return t.Exceed
	}
	t.Exceed = &SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy_Exceed{}
	return t.Exceed
}

// GetOrCreateIn retrieves the value of the In field
// or returns the existing field if it already exists.
func (t *SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy) GetOrCreateIn() *SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy_In {
	if t.In != nil {
		return t.In
	}
	t.In = &SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy_In{}
	return t.In
}

// GetOrCreateInPlus retrieves the value of the InPlus field
// or returns the existing field if it already exists.
func (t *SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy) GetOrCreateInPlus() *SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy_InPlus {
	if t.InPlus != nil {
		return t.InPlus
	}
	t.InPlus = &SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy_InPlus{}
	return t.InPlus
}

// GetOrCreateOut retrieves the value of the Out field
// or returns the existing field if it already exists.
func (t *SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy) GetOrCreateOut() *SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy_Out {
	if t.Out != nil {
		return t.Out
	}
	t.Out = &SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy_Out{}
	return t.Out
}

// GetExceed returns the value of the Exceed struct pointer
// from SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy. If the receiver or the field Exceed is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy) GetExceed() *SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy_Exceed {
	if t != nil && t.Exceed != nil {
		return t.Exceed
	}
	return nil
}

// GetIn returns the value of the In struct pointer
// from SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy. If the receiver or the field In is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy) GetIn() *SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy_In {
	if t != nil && t.In != nil {
		return t.In
	}
	return nil
}

// GetInPlus returns the value of the InPlus struct pointer
// from SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy. If the receiver or the field InPlus is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy) GetInPlus() *SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy_InPlus {
	if t != nil && t.InPlus != nil {
		return t.InPlus
	}
	return nil
}

// GetOut returns the value of the Out struct pointer
// from SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy. If the receiver or the field Out is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy) GetOut() *SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy_Out {
	if t != nil && t.Out != nil {
		return t.Out
	}
	return nil
}

// GetName retrieves the value of the leaf Name from the SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Exceed.PopulateDefaults()
	t.In.PopulateDefaults()
	t.InPlus.PopulateDefaults()
	t.Out.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy struct, which is a YANG list entry.
func (t *SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy.
func (*SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy_Exceed represents the /srl_nokia-qos/qos/rewrite-rules/ip-rewrite-policy/exceed YANG schema element.
type SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy_Exceed struct {
	Dscp       SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy_Exceed_Dscp_Union `path:"dscp" module:"srl_nokia-qos"`
	Precedence *uint8                                                         `path:"precedence" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy_Exceed implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy_Exceed) IsYANGGoStruct() {}

// GetDscp retrieves the value of the leaf Dscp from the SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy_Exceed
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Dscp is set, it can
// safely use t.GetDscp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Dscp == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy_Exceed) GetDscp() SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy_Exceed_Dscp_Union {
	if t == nil || t.Dscp == nil {
		return nil
	}
	return t.Dscp
}

// GetPrecedence retrieves the value of the leaf Precedence from the SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy_Exceed
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Precedence is set, it can
// safely use t.GetPrecedence() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Precedence == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy_Exceed) GetPrecedence() uint8 {
	if t == nil || t.Precedence == nil {
		return 0
	}
	return *t.Precedence
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy_Exceed
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy_Exceed) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy_Exceed) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy_Exceed"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy_Exceed) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy_Exceed) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy_Exceed.
func (*SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy_Exceed) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy_In represents the /srl_nokia-qos/qos/rewrite-rules/ip-rewrite-policy/in YANG schema element.
type SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy_In struct {
	Dscp       SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy_In_Dscp_Union `path:"dscp" module:"srl_nokia-qos"`
	Precedence *uint8                                                     `path:"precedence" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy_In implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy_In) IsYANGGoStruct() {}

// GetDscp retrieves the value of the leaf Dscp from the SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy_In
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Dscp is set, it can
// safely use t.GetDscp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Dscp == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy_In) GetDscp() SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy_In_Dscp_Union {
	if t == nil || t.Dscp == nil {
		return nil
	}
	return t.Dscp
}

// GetPrecedence retrieves the value of the leaf Precedence from the SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy_In
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Precedence is set, it can
// safely use t.GetPrecedence() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Precedence == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy_In) GetPrecedence() uint8 {
	if t == nil || t.Precedence == nil {
		return 0
	}
	return *t.Precedence
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy_In
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy_In) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy_In) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy_In"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy_In) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy_In) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy_In.
func (*SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy_In) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy_InPlus represents the /srl_nokia-qos/qos/rewrite-rules/ip-rewrite-policy/in-plus YANG schema element.
type SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy_InPlus struct {
	Dscp       SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy_InPlus_Dscp_Union `path:"dscp" module:"srl_nokia-qos"`
	Precedence *uint8                                                         `path:"precedence" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy_InPlus implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy_InPlus) IsYANGGoStruct() {}

// GetDscp retrieves the value of the leaf Dscp from the SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy_InPlus
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Dscp is set, it can
// safely use t.GetDscp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Dscp == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy_InPlus) GetDscp() SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy_InPlus_Dscp_Union {
	if t == nil || t.Dscp == nil {
		return nil
	}
	return t.Dscp
}

// GetPrecedence retrieves the value of the leaf Precedence from the SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy_InPlus
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Precedence is set, it can
// safely use t.GetPrecedence() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Precedence == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy_InPlus) GetPrecedence() uint8 {
	if t == nil || t.Precedence == nil {
		return 0
	}
	return *t.Precedence
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy_InPlus
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy_InPlus) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy_InPlus) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy_InPlus"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy_InPlus) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy_InPlus) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy_InPlus.
func (*SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy_InPlus) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy_Out represents the /srl_nokia-qos/qos/rewrite-rules/ip-rewrite-policy/out YANG schema element.
type SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy_Out struct {
	Dscp       SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy_Out_Dscp_Union `path:"dscp" module:"srl_nokia-qos"`
	Precedence *uint8                                                      `path:"precedence" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy_Out implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy_Out) IsYANGGoStruct() {}

// GetDscp retrieves the value of the leaf Dscp from the SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy_Out
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Dscp is set, it can
// safely use t.GetDscp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Dscp == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy_Out) GetDscp() SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy_Out_Dscp_Union {
	if t == nil || t.Dscp == nil {
		return nil
	}
	return t.Dscp
}

// GetPrecedence retrieves the value of the leaf Precedence from the SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy_Out
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Precedence is set, it can
// safely use t.GetPrecedence() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Precedence == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy_Out) GetPrecedence() uint8 {
	if t == nil || t.Precedence == nil {
		return 0
	}
	return *t.Precedence
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy_Out
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy_Out) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy_Out) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy_Out"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy_Out) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy_Out) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy_Out.
func (*SrlNokiaQos_Qos_RewriteRules_IpRewritePolicy_Out) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy represents the /srl_nokia-qos/qos/rewrite-rules/mpls-traffic-class-policy YANG schema element.
type SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy struct {
	Map  map[SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_ForwardingClass_Union]*SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map `path:"map" module:"srl_nokia-qos"`
	Name *string                                                                                                                                    `path:"name" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy) IsYANGGoStruct() {}

// NewMap creates a new entry in the Map list of the
// SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy) NewMap(
	ForwardingClass SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_ForwardingClass_Union,
) (*SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Map == nil {
		t.Map = make(map[SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_ForwardingClass_Union]*SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map)
	}

	key := ForwardingClass

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Map[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Map", key)
	}

	t.Map[key] = &SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map{
		ForwardingClass: ForwardingClass,
	}

	return t.Map[key], nil
}

// RenameMap renames an entry in the list Map within
// the SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy) RenameMap(
	oldK, newK SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_ForwardingClass_Union,
) error {
	if _, ok := t.Map[newK]; ok {
		return fmt.Errorf("key %v already exists in Map", newK)
	}

	e, ok := t.Map[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Map", oldK)
	}
	e.ForwardingClass = newK

	t.Map[newK] = e
	delete(t.Map, oldK)
	return nil
}

// GetOrCreateMap retrieves the value with the specified keys from
// the receiver SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy) GetOrCreateMap(
	ForwardingClass SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_ForwardingClass_Union,
) *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map {
	key := ForwardingClass

	if v, ok := t.Map[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewMap(ForwardingClass)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateMap got unexpected error: %v", err))
	}
	return v
}

// GetMap retrieves the value with the specified key from
// the Map map field of SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy) GetMap(
	ForwardingClass SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_ForwardingClass_Union,
) *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map {
	if t == nil {
		return nil
	}

	key := ForwardingClass

	if lm, ok := t.Map[key]; ok {
		return lm
	}
	return nil
}

// DeleteMap deletes the value with the specified keys from
// the receiver SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy) DeleteMap(
	ForwardingClass SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_ForwardingClass_Union,
) {
	key := ForwardingClass

	delete(t.Map, key)
}

// AppendMap appends the supplied SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map struct to the
// list Map of SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy. If the key value(s) specified in
// the supplied SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map already exist in the list, an error is
// returned.
func (t *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy) AppendMap(
	v *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map,
) error {
	key := v.ForwardingClass

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Map == nil {
		t.Map = make(map[SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_ForwardingClass_Union]*SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map)
	}

	if _, ok := t.Map[key]; ok {
		return fmt.Errorf("duplicate key for list Map %v", key)
	}

	t.Map[key] = v
	return nil
}

// GetName retrieves the value of the leaf Name from the SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Map {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy struct, which is a YANG list entry.
func (t *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy.
func (*SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map represents the /srl_nokia-qos/qos/rewrite-rules/mpls-traffic-class-policy/map YANG schema element.
type SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map struct {
	DropProbability map[E_SrlNokiaCommon_DropProbability]*SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_DropProbability `path:"drop-probability" module:"srl_nokia-qos"`
	ForwardingClass SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_ForwardingClass_Union                                 `path:"forwarding-class" module:"srl_nokia-qos"`
	Profile         map[E_SrlNokiaCommon_RewriteProfile]*SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_Profile          `path:"profile" module:"srl_nokia-qos"`
	TrafficClass    *uint8                                                                                                        `path:"traffic-class" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map) IsYANGGoStruct() {}

// NewDropProbability creates a new entry in the DropProbability list of the
// SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map) NewDropProbability(
	DropProbability E_SrlNokiaCommon_DropProbability,
) (*SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_DropProbability, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.DropProbability == nil {
		t.DropProbability = make(map[E_SrlNokiaCommon_DropProbability]*SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_DropProbability)
	}

	key := DropProbability

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.DropProbability[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list DropProbability", key)
	}

	t.DropProbability[key] = &SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_DropProbability{
		DropProbability: DropProbability,
	}

	return t.DropProbability[key], nil
}

// RenameDropProbability renames an entry in the list DropProbability within
// the SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map) RenameDropProbability(oldK, newK E_SrlNokiaCommon_DropProbability) error {
	if _, ok := t.DropProbability[newK]; ok {
		return fmt.Errorf("key %v already exists in DropProbability", newK)
	}

	e, ok := t.DropProbability[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in DropProbability", oldK)
	}
	e.DropProbability = newK

	t.DropProbability[newK] = e
	delete(t.DropProbability, oldK)
	return nil
}

// GetOrCreateDropProbability retrieves the value with the specified keys from
// the receiver SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map) GetOrCreateDropProbability(
	DropProbability E_SrlNokiaCommon_DropProbability,
) *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_DropProbability {
	key := DropProbability

	if v, ok := t.DropProbability[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewDropProbability(DropProbability)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateDropProbability got unexpected error: %v", err))
	}
	return v
}

// GetDropProbability retrieves the value with the specified key from
// the DropProbability map field of SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map) GetDropProbability(
	DropProbability E_SrlNokiaCommon_DropProbability,
) *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_DropProbability {
	if t == nil {
		return nil
	}

	key := DropProbability

	if lm, ok := t.DropProbability[key]; ok {
		return lm
	}
	return nil
}

// DeleteDropProbability deletes the value with the specified keys from
// the receiver SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map) DeleteDropProbability(DropProbability E_SrlNokiaCommon_DropProbability) {
	key := DropProbability

	delete(t.DropProbability, key)
}

// AppendDropProbability appends the supplied SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_DropProbability struct to the
// list DropProbability of SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map. If the key value(s) specified in
// the supplied SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_DropProbability already exist in the list, an error is
// returned.
func (t *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map) AppendDropProbability(
	v *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_DropProbability,
) error {
	key := v.DropProbability

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.DropProbability == nil {
		t.DropProbability = make(map[E_SrlNokiaCommon_DropProbability]*SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_DropProbability)
	}

	if _, ok := t.DropProbability[key]; ok {
		return fmt.Errorf("duplicate key for list DropProbability %v", key)
	}

	t.DropProbability[key] = v
	return nil
}

// NewProfile creates a new entry in the Profile list of the
// SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map) NewProfile(
	Profile E_SrlNokiaCommon_RewriteProfile,
) (*SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_Profile, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Profile == nil {
		t.Profile = make(map[E_SrlNokiaCommon_RewriteProfile]*SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_Profile)
	}

	key := Profile

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Profile[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Profile", key)
	}

	t.Profile[key] = &SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_Profile{
		Profile: Profile,
	}

	return t.Profile[key], nil
}

// RenameProfile renames an entry in the list Profile within
// the SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map) RenameProfile(oldK, newK E_SrlNokiaCommon_RewriteProfile) error {
	if _, ok := t.Profile[newK]; ok {
		return fmt.Errorf("key %v already exists in Profile", newK)
	}

	e, ok := t.Profile[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Profile", oldK)
	}
	e.Profile = newK

	t.Profile[newK] = e
	delete(t.Profile, oldK)
	return nil
}

// GetOrCreateProfile retrieves the value with the specified keys from
// the receiver SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map) GetOrCreateProfile(
	Profile E_SrlNokiaCommon_RewriteProfile,
) *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_Profile {
	key := Profile

	if v, ok := t.Profile[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewProfile(Profile)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateProfile got unexpected error: %v", err))
	}
	return v
}

// GetProfile retrieves the value with the specified key from
// the Profile map field of SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map) GetProfile(
	Profile E_SrlNokiaCommon_RewriteProfile,
) *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_Profile {
	if t == nil {
		return nil
	}

	key := Profile

	if lm, ok := t.Profile[key]; ok {
		return lm
	}
	return nil
}

// DeleteProfile deletes the value with the specified keys from
// the receiver SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map) DeleteProfile(Profile E_SrlNokiaCommon_RewriteProfile) {
	key := Profile

	delete(t.Profile, key)
}

// AppendProfile appends the supplied SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_Profile struct to the
// list Profile of SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map. If the key value(s) specified in
// the supplied SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_Profile already exist in the list, an error is
// returned.
func (t *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map) AppendProfile(
	v *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_Profile,
) error {
	key := v.Profile

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Profile == nil {
		t.Profile = make(map[E_SrlNokiaCommon_RewriteProfile]*SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_Profile)
	}

	if _, ok := t.Profile[key]; ok {
		return fmt.Errorf("duplicate key for list Profile %v", key)
	}

	t.Profile[key] = v
	return nil
}

// GetForwardingClass retrieves the value of the leaf ForwardingClass from the SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ForwardingClass is set, it can
// safely use t.GetForwardingClass() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ForwardingClass == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map) GetForwardingClass() SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_ForwardingClass_Union {
	if t == nil || t.ForwardingClass == nil {
		return nil
	}
	return t.ForwardingClass
}

// GetTrafficClass retrieves the value of the leaf TrafficClass from the SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TrafficClass is set, it can
// safely use t.GetTrafficClass() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TrafficClass == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map) GetTrafficClass() uint8 {
	if t == nil || t.TrafficClass == nil {
		return 0
	}
	return *t.TrafficClass
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.DropProbability {
		e.PopulateDefaults()
	}
	for _, e := range t.Profile {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map struct, which is a YANG list entry.
func (t *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"forwarding-class": t.ForwardingClass,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map.
func (*SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_DropProbability represents the /srl_nokia-qos/qos/rewrite-rules/mpls-traffic-class-policy/map/drop-probability YANG schema element.
type SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_DropProbability struct {
	DropProbability E_SrlNokiaCommon_DropProbability `path:"drop-probability" module:"srl_nokia-qos"`
	TrafficClass    *uint8                           `path:"traffic-class" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_DropProbability implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_DropProbability) IsYANGGoStruct() {}

// GetDropProbability retrieves the value of the leaf DropProbability from the SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_DropProbability
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DropProbability is set, it can
// safely use t.GetDropProbability() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DropProbability == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_DropProbability) GetDropProbability() E_SrlNokiaCommon_DropProbability {
	if t == nil || t.DropProbability == 0 {
		return 0
	}
	return t.DropProbability
}

// GetTrafficClass retrieves the value of the leaf TrafficClass from the SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_DropProbability
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TrafficClass is set, it can
// safely use t.GetTrafficClass() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TrafficClass == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_DropProbability) GetTrafficClass() uint8 {
	if t == nil || t.TrafficClass == nil {
		return 0
	}
	return *t.TrafficClass
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_DropProbability
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_DropProbability) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_DropProbability struct, which is a YANG list entry.
func (t *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_DropProbability) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"drop-probability": t.DropProbability,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_DropProbability) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_DropProbability"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_DropProbability) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_DropProbability) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_DropProbability.
func (*SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_DropProbability) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_Profile represents the /srl_nokia-qos/qos/rewrite-rules/mpls-traffic-class-policy/map/profile YANG schema element.
type SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_Profile struct {
	Profile      E_SrlNokiaCommon_RewriteProfile `path:"profile" module:"srl_nokia-qos"`
	TrafficClass *uint8                          `path:"traffic-class" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_Profile implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_Profile) IsYANGGoStruct() {}

// GetProfile retrieves the value of the leaf Profile from the SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_Profile
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Profile is set, it can
// safely use t.GetProfile() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Profile == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_Profile) GetProfile() E_SrlNokiaCommon_RewriteProfile {
	if t == nil || t.Profile == 0 {
		return 0
	}
	return t.Profile
}

// GetTrafficClass retrieves the value of the leaf TrafficClass from the SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_Profile
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TrafficClass is set, it can
// safely use t.GetTrafficClass() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TrafficClass == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_Profile) GetTrafficClass() uint8 {
	if t == nil || t.TrafficClass == nil {
		return 0
	}
	return *t.TrafficClass
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_Profile
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_Profile) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_Profile struct, which is a YANG list entry.
func (t *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_Profile) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"profile": t.Profile,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_Profile) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_Profile"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_Profile) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_Profile) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_Profile.
func (*SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_Profile) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_SchedulerPolicies represents the /srl_nokia-qos/qos/scheduler-policies YANG schema element.
type SrlNokiaQos_Qos_SchedulerPolicies struct {
	QueueSchedulingPolicy          map[string]*SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy      `path:"queue-scheduling-policy" module:"srl_nokia-qos"`
	SchedClassSchedulingPolicy     map[string]*SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy `path:"sched-class-scheduling-policy" module:"srl_nokia-qos"`
	SchedulerPolicy                map[string]*SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy            `path:"scheduler-policy" module:"srl_nokia-qos"`
	SchedulingPriorityMappingTable *SrlNokiaQos_Qos_SchedulerPolicies_SchedulingPriorityMappingTable        `path:"scheduling-priority-mapping-table" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_SchedulerPolicies implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_SchedulerPolicies) IsYANGGoStruct() {}

// NewQueueSchedulingPolicy creates a new entry in the QueueSchedulingPolicy list of the
// SrlNokiaQos_Qos_SchedulerPolicies struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaQos_Qos_SchedulerPolicies) NewQueueSchedulingPolicy(Name string) (*SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.QueueSchedulingPolicy == nil {
		t.QueueSchedulingPolicy = make(map[string]*SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.QueueSchedulingPolicy[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list QueueSchedulingPolicy", key)
	}

	t.QueueSchedulingPolicy[key] = &SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy{
		Name: &Name,
	}

	return t.QueueSchedulingPolicy[key], nil
}

// RenameQueueSchedulingPolicy renames an entry in the list QueueSchedulingPolicy within
// the SrlNokiaQos_Qos_SchedulerPolicies struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaQos_Qos_SchedulerPolicies) RenameQueueSchedulingPolicy(oldK, newK string) error {
	if _, ok := t.QueueSchedulingPolicy[newK]; ok {
		return fmt.Errorf("key %v already exists in QueueSchedulingPolicy", newK)
	}

	e, ok := t.QueueSchedulingPolicy[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in QueueSchedulingPolicy", oldK)
	}
	e.Name = &newK

	t.QueueSchedulingPolicy[newK] = e
	delete(t.QueueSchedulingPolicy, oldK)
	return nil
}

// GetOrCreateQueueSchedulingPolicy retrieves the value with the specified keys from
// the receiver SrlNokiaQos_Qos_SchedulerPolicies. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaQos_Qos_SchedulerPolicies) GetOrCreateQueueSchedulingPolicy(Name string) *SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy {
	key := Name

	if v, ok := t.QueueSchedulingPolicy[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewQueueSchedulingPolicy(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateQueueSchedulingPolicy got unexpected error: %v", err))
	}
	return v
}

// GetQueueSchedulingPolicy retrieves the value with the specified key from
// the QueueSchedulingPolicy map field of SrlNokiaQos_Qos_SchedulerPolicies. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaQos_Qos_SchedulerPolicies) GetQueueSchedulingPolicy(Name string) *SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.QueueSchedulingPolicy[key]; ok {
		return lm
	}
	return nil
}

// DeleteQueueSchedulingPolicy deletes the value with the specified keys from
// the receiver SrlNokiaQos_Qos_SchedulerPolicies. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaQos_Qos_SchedulerPolicies) DeleteQueueSchedulingPolicy(Name string) {
	key := Name

	delete(t.QueueSchedulingPolicy, key)
}

// AppendQueueSchedulingPolicy appends the supplied SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy struct to the
// list QueueSchedulingPolicy of SrlNokiaQos_Qos_SchedulerPolicies. If the key value(s) specified in
// the supplied SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy already exist in the list, an error is
// returned.
func (t *SrlNokiaQos_Qos_SchedulerPolicies) AppendQueueSchedulingPolicy(
	v *SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy,
) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.QueueSchedulingPolicy == nil {
		t.QueueSchedulingPolicy = make(map[string]*SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy)
	}

	if _, ok := t.QueueSchedulingPolicy[key]; ok {
		return fmt.Errorf("duplicate key for list QueueSchedulingPolicy %v", key)
	}

	t.QueueSchedulingPolicy[key] = v
	return nil
}

// NewSchedClassSchedulingPolicy creates a new entry in the SchedClassSchedulingPolicy list of the
// SrlNokiaQos_Qos_SchedulerPolicies struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaQos_Qos_SchedulerPolicies) NewSchedClassSchedulingPolicy(Name string) (*SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.SchedClassSchedulingPolicy == nil {
		t.SchedClassSchedulingPolicy = make(map[string]*SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.SchedClassSchedulingPolicy[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list SchedClassSchedulingPolicy", key)
	}

	t.SchedClassSchedulingPolicy[key] = &SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy{
		Name: &Name,
	}

	return t.SchedClassSchedulingPolicy[key], nil
}

// RenameSchedClassSchedulingPolicy renames an entry in the list SchedClassSchedulingPolicy within
// the SrlNokiaQos_Qos_SchedulerPolicies struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaQos_Qos_SchedulerPolicies) RenameSchedClassSchedulingPolicy(oldK, newK string) error {
	if _, ok := t.SchedClassSchedulingPolicy[newK]; ok {
		return fmt.Errorf("key %v already exists in SchedClassSchedulingPolicy", newK)
	}

	e, ok := t.SchedClassSchedulingPolicy[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in SchedClassSchedulingPolicy", oldK)
	}
	e.Name = &newK

	t.SchedClassSchedulingPolicy[newK] = e
	delete(t.SchedClassSchedulingPolicy, oldK)
	return nil
}

// GetOrCreateSchedClassSchedulingPolicy retrieves the value with the specified keys from
// the receiver SrlNokiaQos_Qos_SchedulerPolicies. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaQos_Qos_SchedulerPolicies) GetOrCreateSchedClassSchedulingPolicy(Name string) *SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy {
	key := Name

	if v, ok := t.SchedClassSchedulingPolicy[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewSchedClassSchedulingPolicy(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateSchedClassSchedulingPolicy got unexpected error: %v", err))
	}
	return v
}

// GetSchedClassSchedulingPolicy retrieves the value with the specified key from
// the SchedClassSchedulingPolicy map field of SrlNokiaQos_Qos_SchedulerPolicies. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaQos_Qos_SchedulerPolicies) GetSchedClassSchedulingPolicy(Name string) *SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.SchedClassSchedulingPolicy[key]; ok {
		return lm
	}
	return nil
}

// DeleteSchedClassSchedulingPolicy deletes the value with the specified keys from
// the receiver SrlNokiaQos_Qos_SchedulerPolicies. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaQos_Qos_SchedulerPolicies) DeleteSchedClassSchedulingPolicy(Name string) {
	key := Name

	delete(t.SchedClassSchedulingPolicy, key)
}

// AppendSchedClassSchedulingPolicy appends the supplied SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy struct to the
// list SchedClassSchedulingPolicy of SrlNokiaQos_Qos_SchedulerPolicies. If the key value(s) specified in
// the supplied SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy already exist in the list, an error is
// returned.
func (t *SrlNokiaQos_Qos_SchedulerPolicies) AppendSchedClassSchedulingPolicy(
	v *SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy,
) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.SchedClassSchedulingPolicy == nil {
		t.SchedClassSchedulingPolicy = make(map[string]*SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy)
	}

	if _, ok := t.SchedClassSchedulingPolicy[key]; ok {
		return fmt.Errorf("duplicate key for list SchedClassSchedulingPolicy %v", key)
	}

	t.SchedClassSchedulingPolicy[key] = v
	return nil
}

// NewSchedulerPolicy creates a new entry in the SchedulerPolicy list of the
// SrlNokiaQos_Qos_SchedulerPolicies struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaQos_Qos_SchedulerPolicies) NewSchedulerPolicy(Name string) (*SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.SchedulerPolicy == nil {
		t.SchedulerPolicy = make(map[string]*SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.SchedulerPolicy[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list SchedulerPolicy", key)
	}

	t.SchedulerPolicy[key] = &SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy{
		Name: &Name,
	}

	return t.SchedulerPolicy[key], nil
}

// RenameSchedulerPolicy renames an entry in the list SchedulerPolicy within
// the SrlNokiaQos_Qos_SchedulerPolicies struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaQos_Qos_SchedulerPolicies) RenameSchedulerPolicy(oldK, newK string) error {
	if _, ok := t.SchedulerPolicy[newK]; ok {
		return fmt.Errorf("key %v already exists in SchedulerPolicy", newK)
	}

	e, ok := t.SchedulerPolicy[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in SchedulerPolicy", oldK)
	}
	e.Name = &newK

	t.SchedulerPolicy[newK] = e
	delete(t.SchedulerPolicy, oldK)
	return nil
}

// GetOrCreateSchedulerPolicy retrieves the value with the specified keys from
// the receiver SrlNokiaQos_Qos_SchedulerPolicies. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaQos_Qos_SchedulerPolicies) GetOrCreateSchedulerPolicy(Name string) *SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy {
	key := Name

	if v, ok := t.SchedulerPolicy[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewSchedulerPolicy(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateSchedulerPolicy got unexpected error: %v", err))
	}
	return v
}

// GetSchedulerPolicy retrieves the value with the specified key from
// the SchedulerPolicy map field of SrlNokiaQos_Qos_SchedulerPolicies. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaQos_Qos_SchedulerPolicies) GetSchedulerPolicy(Name string) *SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.SchedulerPolicy[key]; ok {
		return lm
	}
	return nil
}

// DeleteSchedulerPolicy deletes the value with the specified keys from
// the receiver SrlNokiaQos_Qos_SchedulerPolicies. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaQos_Qos_SchedulerPolicies) DeleteSchedulerPolicy(Name string) {
	key := Name

	delete(t.SchedulerPolicy, key)
}

// AppendSchedulerPolicy appends the supplied SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy struct to the
// list SchedulerPolicy of SrlNokiaQos_Qos_SchedulerPolicies. If the key value(s) specified in
// the supplied SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy already exist in the list, an error is
// returned.
func (t *SrlNokiaQos_Qos_SchedulerPolicies) AppendSchedulerPolicy(
	v *SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy,
) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.SchedulerPolicy == nil {
		t.SchedulerPolicy = make(map[string]*SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy)
	}

	if _, ok := t.SchedulerPolicy[key]; ok {
		return fmt.Errorf("duplicate key for list SchedulerPolicy %v", key)
	}

	t.SchedulerPolicy[key] = v
	return nil
}

// GetOrCreateSchedulingPriorityMappingTable retrieves the value of the SchedulingPriorityMappingTable field
// or returns the existing field if it already exists.
func (t *SrlNokiaQos_Qos_SchedulerPolicies) GetOrCreateSchedulingPriorityMappingTable() *SrlNokiaQos_Qos_SchedulerPolicies_SchedulingPriorityMappingTable {
	if t.SchedulingPriorityMappingTable != nil {
		return t.SchedulingPriorityMappingTable
	}
	t.SchedulingPriorityMappingTable = &SrlNokiaQos_Qos_SchedulerPolicies_SchedulingPriorityMappingTable{}
	return t.SchedulingPriorityMappingTable
}

// GetSchedulingPriorityMappingTable returns the value of the SchedulingPriorityMappingTable struct pointer
// from SrlNokiaQos_Qos_SchedulerPolicies. If the receiver or the field SchedulingPriorityMappingTable is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaQos_Qos_SchedulerPolicies) GetSchedulingPriorityMappingTable() *SrlNokiaQos_Qos_SchedulerPolicies_SchedulingPriorityMappingTable {
	if t != nil && t.SchedulingPriorityMappingTable != nil {
		return t.SchedulingPriorityMappingTable
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_SchedulerPolicies
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_SchedulerPolicies) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.SchedulingPriorityMappingTable.PopulateDefaults()
	for _, e := range t.QueueSchedulingPolicy {
		e.PopulateDefaults()
	}
	for _, e := range t.SchedClassSchedulingPolicy {
		e.PopulateDefaults()
	}
	for _, e := range t.SchedulerPolicy {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_SchedulerPolicies) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_SchedulerPolicies"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_SchedulerPolicies) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_SchedulerPolicies) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_SchedulerPolicies.
func (*SrlNokiaQos_Qos_SchedulerPolicies) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy represents the /srl_nokia-qos/qos/scheduler-policies/queue-scheduling-policy YANG schema element.
type SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy struct {
	Name      *string                                                                                                                                          `path:"name" module:"srl_nokia-qos"`
	Queue     map[SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue_QueueName_Union]*SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue `path:"queue" module:"srl_nokia-qos"`
	Scheduler map[uint8]*SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Scheduler                                                                     `path:"scheduler" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy) IsYANGGoStruct() {}

// NewQueue creates a new entry in the Queue list of the
// SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy) NewQueue(
	QueueName SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue_QueueName_Union,
) (*SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Queue == nil {
		t.Queue = make(map[SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue_QueueName_Union]*SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue)
	}

	key := QueueName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Queue[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Queue", key)
	}

	t.Queue[key] = &SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue{
		QueueName: QueueName,
	}

	return t.Queue[key], nil
}

// RenameQueue renames an entry in the list Queue within
// the SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy) RenameQueue(
	oldK, newK SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue_QueueName_Union,
) error {
	if _, ok := t.Queue[newK]; ok {
		return fmt.Errorf("key %v already exists in Queue", newK)
	}

	e, ok := t.Queue[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Queue", oldK)
	}
	e.QueueName = newK

	t.Queue[newK] = e
	delete(t.Queue, oldK)
	return nil
}

// GetOrCreateQueue retrieves the value with the specified keys from
// the receiver SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy) GetOrCreateQueue(
	QueueName SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue_QueueName_Union,
) *SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue {
	key := QueueName

	if v, ok := t.Queue[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewQueue(QueueName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateQueue got unexpected error: %v", err))
	}
	return v
}

// GetQueue retrieves the value with the specified key from
// the Queue map field of SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy) GetQueue(
	QueueName SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue_QueueName_Union,
) *SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue {
	if t == nil {
		return nil
	}

	key := QueueName

	if lm, ok := t.Queue[key]; ok {
		return lm
	}
	return nil
}

// DeleteQueue deletes the value with the specified keys from
// the receiver SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy) DeleteQueue(
	QueueName SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue_QueueName_Union,
) {
	key := QueueName

	delete(t.Queue, key)
}

// AppendQueue appends the supplied SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue struct to the
// list Queue of SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy. If the key value(s) specified in
// the supplied SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue already exist in the list, an error is
// returned.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy) AppendQueue(
	v *SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue,
) error {
	key := v.QueueName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Queue == nil {
		t.Queue = make(map[SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue_QueueName_Union]*SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue)
	}

	if _, ok := t.Queue[key]; ok {
		return fmt.Errorf("duplicate key for list Queue %v", key)
	}

	t.Queue[key] = v
	return nil
}

// NewScheduler creates a new entry in the Scheduler list of the
// SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy) NewScheduler(SequenceId uint8) (*SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Scheduler, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Scheduler == nil {
		t.Scheduler = make(map[uint8]*SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Scheduler)
	}

	key := SequenceId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Scheduler[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Scheduler", key)
	}

	t.Scheduler[key] = &SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Scheduler{
		SequenceId: &SequenceId,
	}

	return t.Scheduler[key], nil
}

// RenameScheduler renames an entry in the list Scheduler within
// the SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy) RenameScheduler(oldK, newK uint8) error {
	if _, ok := t.Scheduler[newK]; ok {
		return fmt.Errorf("key %v already exists in Scheduler", newK)
	}

	e, ok := t.Scheduler[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Scheduler", oldK)
	}
	e.SequenceId = &newK

	t.Scheduler[newK] = e
	delete(t.Scheduler, oldK)
	return nil
}

// GetOrCreateScheduler retrieves the value with the specified keys from
// the receiver SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy) GetOrCreateScheduler(
	SequenceId uint8,
) *SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Scheduler {
	key := SequenceId

	if v, ok := t.Scheduler[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewScheduler(SequenceId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateScheduler got unexpected error: %v", err))
	}
	return v
}

// GetScheduler retrieves the value with the specified key from
// the Scheduler map field of SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy) GetScheduler(SequenceId uint8) *SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Scheduler {
	if t == nil {
		return nil
	}

	key := SequenceId

	if lm, ok := t.Scheduler[key]; ok {
		return lm
	}
	return nil
}

// DeleteScheduler deletes the value with the specified keys from
// the receiver SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy) DeleteScheduler(SequenceId uint8) {
	key := SequenceId

	delete(t.Scheduler, key)
}

// AppendScheduler appends the supplied SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Scheduler struct to the
// list Scheduler of SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy. If the key value(s) specified in
// the supplied SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Scheduler already exist in the list, an error is
// returned.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy) AppendScheduler(
	v *SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Scheduler,
) error {
	if v.SequenceId == nil {
		return fmt.Errorf("invalid nil key received for SequenceId")
	}

	key := *v.SequenceId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Scheduler == nil {
		t.Scheduler = make(map[uint8]*SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Scheduler)
	}

	if _, ok := t.Scheduler[key]; ok {
		return fmt.Errorf("duplicate key for list Scheduler %v", key)
	}

	t.Scheduler[key] = v
	return nil
}

// GetName retrieves the value of the leaf Name from the SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Queue {
		e.PopulateDefaults()
	}
	for _, e := range t.Scheduler {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy struct, which is a YANG list entry.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy.
func (*SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue represents the /srl_nokia-qos/qos/scheduler-policies/queue-scheduling-policy/queue YANG schema element.
type SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue struct {
	QueueDepth *SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue_QueueDepth     `path:"queue-depth" module:"srl_nokia-qos"`
	QueueName  SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue_QueueName_Union `path:"queue-name" module:"srl_nokia-qos"`
	Scheduling *SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue_Scheduling     `path:"scheduling" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue) IsYANGGoStruct() {}

// GetOrCreateQueueDepth retrieves the value of the QueueDepth field
// or returns the existing field if it already exists.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue) GetOrCreateQueueDepth() *SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue_QueueDepth {
	if t.QueueDepth != nil {
		return t.QueueDepth
	}
	t.QueueDepth = &SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue_QueueDepth{}
	return t.QueueDepth
}

// GetOrCreateScheduling retrieves the value of the Scheduling field
// or returns the existing field if it already exists.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue) GetOrCreateScheduling() *SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue_Scheduling {
	if t.Scheduling != nil {
		return t.Scheduling
	}
	t.Scheduling = &SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue_Scheduling{}
	return t.Scheduling
}

// GetQueueDepth returns the value of the QueueDepth struct pointer
// from SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue. If the receiver or the field QueueDepth is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue) GetQueueDepth() *SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue_QueueDepth {
	if t != nil && t.QueueDepth != nil {
		return t.QueueDepth
	}
	return nil
}

// GetScheduling returns the value of the Scheduling struct pointer
// from SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue. If the receiver or the field Scheduling is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue) GetScheduling() *SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue_Scheduling {
	if t != nil && t.Scheduling != nil {
		return t.Scheduling
	}
	return nil
}

// GetQueueName retrieves the value of the leaf QueueName from the SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if QueueName is set, it can
// safely use t.GetQueueName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.QueueName == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue) GetQueueName() SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue_QueueName_Union {
	if t == nil || t.QueueName == nil {
		return nil
	}
	return t.QueueName
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.QueueDepth.PopulateDefaults()
	t.Scheduling.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue struct, which is a YANG list entry.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"queue-name": t.QueueName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue.
func (*SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue_QueueDepth represents the /srl_nokia-qos/qos/scheduler-policies/queue-scheduling-policy/queue/queue-depth YANG schema element.
type SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue_QueueDepth struct {
	CommittedBurstSize E_SrlNokiaQos_FutureCbsSize                                                                     `path:"committed-burst-size" module:"srl_nokia-qos"`
	MaximumBurstSize   SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue_QueueDepth_MaximumBurstSize_Union `path:"maximum-burst-size" module:"srl_nokia-qos"`
	MbsAdaptationRule  E_SrlNokiaCommon_AdaptationRule                                                                 `path:"mbs-adaptation-rule" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue_QueueDepth implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue_QueueDepth) IsYANGGoStruct() {}

// GetCommittedBurstSize retrieves the value of the leaf CommittedBurstSize from the SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue_QueueDepth
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if CommittedBurstSize is set, it can
// safely use t.GetCommittedBurstSize() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.CommittedBurstSize == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue_QueueDepth) GetCommittedBurstSize() E_SrlNokiaQos_FutureCbsSize {
	if t == nil || t.CommittedBurstSize == 0 {
		return SrlNokiaQos_FutureCbsSize_default
	}
	return t.CommittedBurstSize
}

// GetMaximumBurstSize retrieves the value of the leaf MaximumBurstSize from the SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue_QueueDepth
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MaximumBurstSize is set, it can
// safely use t.GetMaximumBurstSize() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MaximumBurstSize == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue_QueueDepth) GetMaximumBurstSize() SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue_QueueDepth_MaximumBurstSize_Union {
	if t == nil || t.MaximumBurstSize == nil {
		return nil
	}
	return t.MaximumBurstSize
}

// GetMbsAdaptationRule retrieves the value of the leaf MbsAdaptationRule from the SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue_QueueDepth
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MbsAdaptationRule is set, it can
// safely use t.GetMbsAdaptationRule() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MbsAdaptationRule == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue_QueueDepth) GetMbsAdaptationRule() E_SrlNokiaCommon_AdaptationRule {
	if t == nil || t.MbsAdaptationRule == 0 {
		return SrlNokiaCommon_AdaptationRule_closest
	}
	return t.MbsAdaptationRule
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue_QueueDepth
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue_QueueDepth) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.CommittedBurstSize == 0 {
		t.CommittedBurstSize = SrlNokiaQos_FutureCbsSize_default
	}
	if t.MbsAdaptationRule == 0 {
		t.MbsAdaptationRule = SrlNokiaCommon_AdaptationRule_closest
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue_QueueDepth) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue_QueueDepth"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue_QueueDepth) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue_QueueDepth) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue_QueueDepth.
func (*SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue_QueueDepth) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue_Scheduling represents the /srl_nokia-qos/qos/scheduler-policies/queue-scheduling-policy/queue/scheduling YANG schema element.
type SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue_Scheduling struct {
	PacketLengthAdjustment *SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue_Scheduling_PacketLengthAdjustment `path:"packet-length-adjustment" module:"srl_nokia-qos"`
	SchedulingClass        *uint8                                                                                           `path:"scheduling-class" module:"srl_nokia-qos"`
	Weight                 *uint8                                                                                           `path:"weight" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue_Scheduling implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue_Scheduling) IsYANGGoStruct() {}

// GetOrCreatePacketLengthAdjustment retrieves the value of the PacketLengthAdjustment field
// or returns the existing field if it already exists.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue_Scheduling) GetOrCreatePacketLengthAdjustment() *SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue_Scheduling_PacketLengthAdjustment {
	if t.PacketLengthAdjustment != nil {
		return t.PacketLengthAdjustment
	}
	t.PacketLengthAdjustment = &SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue_Scheduling_PacketLengthAdjustment{}
	return t.PacketLengthAdjustment
}

// GetPacketLengthAdjustment returns the value of the PacketLengthAdjustment struct pointer
// from SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue_Scheduling. If the receiver or the field PacketLengthAdjustment is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue_Scheduling) GetPacketLengthAdjustment() *SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue_Scheduling_PacketLengthAdjustment {
	if t != nil && t.PacketLengthAdjustment != nil {
		return t.PacketLengthAdjustment
	}
	return nil
}

// GetSchedulingClass retrieves the value of the leaf SchedulingClass from the SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue_Scheduling
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SchedulingClass is set, it can
// safely use t.GetSchedulingClass() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SchedulingClass == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue_Scheduling) GetSchedulingClass() uint8 {
	if t == nil || t.SchedulingClass == nil {
		return 0
	}
	return *t.SchedulingClass
}

// GetWeight retrieves the value of the leaf Weight from the SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue_Scheduling
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Weight is set, it can
// safely use t.GetWeight() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Weight == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue_Scheduling) GetWeight() uint8 {
	if t == nil || t.Weight == nil {
		return 1
	}
	return *t.Weight
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue_Scheduling
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue_Scheduling) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.SchedulingClass == nil {
		var v uint8 = 0
		t.SchedulingClass = &v
	}
	if t.Weight == nil {
		var v uint8 = 1
		t.Weight = &v
	}
	t.PacketLengthAdjustment.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue_Scheduling) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue_Scheduling"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue_Scheduling) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue_Scheduling) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue_Scheduling.
func (*SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue_Scheduling) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue_Scheduling_PacketLengthAdjustment represents the /srl_nokia-qos/qos/scheduler-policies/queue-scheduling-policy/queue/scheduling/packet-length-adjustment YANG schema element.
type SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue_Scheduling_PacketLengthAdjustment struct {
	Add      *uint32 `path:"add" module:"srl_nokia-qos"`
	Subtract *uint32 `path:"subtract" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue_Scheduling_PacketLengthAdjustment implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue_Scheduling_PacketLengthAdjustment) IsYANGGoStruct() {
}

// GetAdd retrieves the value of the leaf Add from the SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue_Scheduling_PacketLengthAdjustment
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Add is set, it can
// safely use t.GetAdd() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Add == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue_Scheduling_PacketLengthAdjustment) GetAdd() uint32 {
	if t == nil || t.Add == nil {
		return 0
	}
	return *t.Add
}

// GetSubtract retrieves the value of the leaf Subtract from the SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue_Scheduling_PacketLengthAdjustment
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Subtract is set, it can
// safely use t.GetSubtract() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Subtract == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue_Scheduling_PacketLengthAdjustment) GetSubtract() uint32 {
	if t == nil || t.Subtract == nil {
		return 0
	}
	return *t.Subtract
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue_Scheduling_PacketLengthAdjustment
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue_Scheduling_PacketLengthAdjustment) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Add == nil {
		var v uint32 = 0
		t.Add = &v
	}
	if t.Subtract == nil {
		var v uint32 = 0
		t.Subtract = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue_Scheduling_PacketLengthAdjustment) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue_Scheduling_PacketLengthAdjustment"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue_Scheduling_PacketLengthAdjustment) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue_Scheduling_PacketLengthAdjustment) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue_Scheduling_PacketLengthAdjustment.
func (*SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Queue_Scheduling_PacketLengthAdjustment) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Scheduler represents the /srl_nokia-qos/qos/scheduler-policies/queue-scheduling-policy/scheduler YANG schema element.
type SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Scheduler struct {
	BurstAllowance      *uint64                                                                                     `path:"burst-allowance" module:"srl_nokia-qos"`
	Inputs              *SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Scheduler_Inputs                   `path:"inputs" module:"srl_nokia-qos"`
	OutputWeight        *uint8                                                                                      `path:"output-weight" module:"srl_nokia-qos"`
	Rate                *SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Scheduler_Rate                     `path:"rate" module:"srl_nokia-qos"`
	SequenceId          *uint8                                                                                      `path:"sequence-id" module:"srl_nokia-qos"`
	ThresholdSeparation SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Scheduler_ThresholdSeparation_Union `path:"threshold-separation" module:"srl_nokia-qos"`
	Tier                *uint8                                                                                      `path:"tier" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Scheduler implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Scheduler) IsYANGGoStruct() {}

// GetOrCreateInputs retrieves the value of the Inputs field
// or returns the existing field if it already exists.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Scheduler) GetOrCreateInputs() *SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Scheduler_Inputs {
	if t.Inputs != nil {
		return t.Inputs
	}
	t.Inputs = &SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Scheduler_Inputs{}
	return t.Inputs
}

// GetOrCreateRate retrieves the value of the Rate field
// or returns the existing field if it already exists.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Scheduler) GetOrCreateRate() *SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Scheduler_Rate {
	if t.Rate != nil {
		return t.Rate
	}
	t.Rate = &SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Scheduler_Rate{}
	return t.Rate
}

// GetInputs returns the value of the Inputs struct pointer
// from SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Scheduler. If the receiver or the field Inputs is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Scheduler) GetInputs() *SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Scheduler_Inputs {
	if t != nil && t.Inputs != nil {
		return t.Inputs
	}
	return nil
}

// GetRate returns the value of the Rate struct pointer
// from SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Scheduler. If the receiver or the field Rate is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Scheduler) GetRate() *SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Scheduler_Rate {
	if t != nil && t.Rate != nil {
		return t.Rate
	}
	return nil
}

// GetBurstAllowance retrieves the value of the leaf BurstAllowance from the SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Scheduler
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if BurstAllowance is set, it can
// safely use t.GetBurstAllowance() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.BurstAllowance == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Scheduler) GetBurstAllowance() uint64 {
	if t == nil || t.BurstAllowance == nil {
		return 9000
	}
	return *t.BurstAllowance
}

// GetOutputWeight retrieves the value of the leaf OutputWeight from the SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Scheduler
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutputWeight is set, it can
// safely use t.GetOutputWeight() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutputWeight == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Scheduler) GetOutputWeight() uint8 {
	if t == nil || t.OutputWeight == nil {
		return 1
	}
	return *t.OutputWeight
}

// GetSequenceId retrieves the value of the leaf SequenceId from the SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Scheduler
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SequenceId is set, it can
// safely use t.GetSequenceId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SequenceId == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Scheduler) GetSequenceId() uint8 {
	if t == nil || t.SequenceId == nil {
		return 0
	}
	return *t.SequenceId
}

// GetThresholdSeparation retrieves the value of the leaf ThresholdSeparation from the SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Scheduler
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ThresholdSeparation is set, it can
// safely use t.GetThresholdSeparation() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ThresholdSeparation == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Scheduler) GetThresholdSeparation() SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Scheduler_ThresholdSeparation_Union {
	if t == nil || t.ThresholdSeparation == nil {
		return SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Scheduler_ThresholdSeparation_Enum_default
	}
	return t.ThresholdSeparation
}

// GetTier retrieves the value of the leaf Tier from the SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Scheduler
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Tier is set, it can
// safely use t.GetTier() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Tier == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Scheduler) GetTier() uint8 {
	if t == nil || t.Tier == nil {
		return 0
	}
	return *t.Tier
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Scheduler
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Scheduler) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.BurstAllowance == nil {
		var v uint64 = 9000
		t.BurstAllowance = &v
	}
	if t.OutputWeight == nil {
		var v uint8 = 1
		t.OutputWeight = &v
	}
	if t.ThresholdSeparation == nil {
		t.ThresholdSeparation = SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Scheduler_ThresholdSeparation_Enum_default
	}
	if t.Tier == nil {
		var v uint8 = 0
		t.Tier = &v
	}
	t.Inputs.PopulateDefaults()
	t.Rate.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Scheduler struct, which is a YANG list entry.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Scheduler) ΛListKeyMap() (map[string]interface{}, error) {
	if t.SequenceId == nil {
		return nil, fmt.Errorf("nil value for key SequenceId")
	}

	return map[string]interface{}{
		"sequence-id": *t.SequenceId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Scheduler) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Scheduler"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Scheduler) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Scheduler) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Scheduler.
func (*SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Scheduler) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Scheduler_Inputs represents the /srl_nokia-qos/qos/scheduler-policies/queue-scheduling-policy/scheduler/inputs YANG schema element.
type SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Scheduler_Inputs struct {
	Inputs E_SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Scheduler_Inputs_Inputs      `path:"inputs" module:"srl_nokia-qos"`
	Queue  []SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Scheduler_Inputs_Queue_Union `path:"queue" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Scheduler_Inputs implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Scheduler_Inputs) IsYANGGoStruct() {}

// GetInputs retrieves the value of the leaf Inputs from the SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Scheduler_Inputs
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Inputs is set, it can
// safely use t.GetInputs() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Inputs == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Scheduler_Inputs) GetInputs() E_SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Scheduler_Inputs_Inputs {
	if t == nil || t.Inputs == 0 {
		return 0
	}
	return t.Inputs
}

// GetQueue retrieves the value of the leaf Queue from the SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Scheduler_Inputs
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Queue is set, it can
// safely use t.GetQueue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Queue == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Scheduler_Inputs) GetQueue() []SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Scheduler_Inputs_Queue_Union {
	if t == nil || t.Queue == nil {
		return nil
	}
	return t.Queue
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Scheduler_Inputs
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Scheduler_Inputs) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Scheduler_Inputs) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Scheduler_Inputs"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Scheduler_Inputs) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Scheduler_Inputs) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Scheduler_Inputs.
func (*SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Scheduler_Inputs) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Scheduler_Rate represents the /srl_nokia-qos/qos/scheduler-policies/queue-scheduling-policy/scheduler/rate YANG schema element.
type SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Scheduler_Rate struct {
	PeakRateKbps       *uint64                         `path:"peak-rate-kbps" module:"srl_nokia-qos"`
	PeakRatePercentage *uint8                          `path:"peak-rate-percentage" module:"srl_nokia-qos"`
	PirAdaptationRule  E_SrlNokiaCommon_AdaptationRule `path:"pir-adaptation-rule" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Scheduler_Rate implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Scheduler_Rate) IsYANGGoStruct() {}

// GetPeakRateKbps retrieves the value of the leaf PeakRateKbps from the SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Scheduler_Rate
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PeakRateKbps is set, it can
// safely use t.GetPeakRateKbps() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PeakRateKbps == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Scheduler_Rate) GetPeakRateKbps() uint64 {
	if t == nil || t.PeakRateKbps == nil {
		return 0
	}
	return *t.PeakRateKbps
}

// GetPeakRatePercentage retrieves the value of the leaf PeakRatePercentage from the SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Scheduler_Rate
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PeakRatePercentage is set, it can
// safely use t.GetPeakRatePercentage() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PeakRatePercentage == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Scheduler_Rate) GetPeakRatePercentage() uint8 {
	if t == nil || t.PeakRatePercentage == nil {
		return 100
	}
	return *t.PeakRatePercentage
}

// GetPirAdaptationRule retrieves the value of the leaf PirAdaptationRule from the SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Scheduler_Rate
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PirAdaptationRule is set, it can
// safely use t.GetPirAdaptationRule() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PirAdaptationRule == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Scheduler_Rate) GetPirAdaptationRule() E_SrlNokiaCommon_AdaptationRule {
	if t == nil || t.PirAdaptationRule == 0 {
		return SrlNokiaCommon_AdaptationRule_closest
	}
	return t.PirAdaptationRule
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Scheduler_Rate
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Scheduler_Rate) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.PeakRatePercentage == nil {
		var v uint8 = 100
		t.PeakRatePercentage = &v
	}
	if t.PirAdaptationRule == 0 {
		t.PirAdaptationRule = SrlNokiaCommon_AdaptationRule_closest
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Scheduler_Rate) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Scheduler_Rate"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Scheduler_Rate) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Scheduler_Rate) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Scheduler_Rate.
func (*SrlNokiaQos_Qos_SchedulerPolicies_QueueSchedulingPolicy_Scheduler_Rate) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy represents the /srl_nokia-qos/qos/scheduler-policies/sched-class-scheduling-policy YANG schema element.
type SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy struct {
	Name      *string                                                                           `path:"name" module:"srl_nokia-qos"`
	Scheduler map[uint8]*SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy_Scheduler `path:"scheduler" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy) IsYANGGoStruct() {}

// NewScheduler creates a new entry in the Scheduler list of the
// SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy) NewScheduler(
	SequenceId uint8,
) (*SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy_Scheduler, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Scheduler == nil {
		t.Scheduler = make(map[uint8]*SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy_Scheduler)
	}

	key := SequenceId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Scheduler[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Scheduler", key)
	}

	t.Scheduler[key] = &SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy_Scheduler{
		SequenceId: &SequenceId,
	}

	return t.Scheduler[key], nil
}

// RenameScheduler renames an entry in the list Scheduler within
// the SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy) RenameScheduler(oldK, newK uint8) error {
	if _, ok := t.Scheduler[newK]; ok {
		return fmt.Errorf("key %v already exists in Scheduler", newK)
	}

	e, ok := t.Scheduler[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Scheduler", oldK)
	}
	e.SequenceId = &newK

	t.Scheduler[newK] = e
	delete(t.Scheduler, oldK)
	return nil
}

// GetOrCreateScheduler retrieves the value with the specified keys from
// the receiver SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy) GetOrCreateScheduler(
	SequenceId uint8,
) *SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy_Scheduler {
	key := SequenceId

	if v, ok := t.Scheduler[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewScheduler(SequenceId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateScheduler got unexpected error: %v", err))
	}
	return v
}

// GetScheduler retrieves the value with the specified key from
// the Scheduler map field of SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy) GetScheduler(
	SequenceId uint8,
) *SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy_Scheduler {
	if t == nil {
		return nil
	}

	key := SequenceId

	if lm, ok := t.Scheduler[key]; ok {
		return lm
	}
	return nil
}

// DeleteScheduler deletes the value with the specified keys from
// the receiver SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy) DeleteScheduler(SequenceId uint8) {
	key := SequenceId

	delete(t.Scheduler, key)
}

// AppendScheduler appends the supplied SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy_Scheduler struct to the
// list Scheduler of SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy. If the key value(s) specified in
// the supplied SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy_Scheduler already exist in the list, an error is
// returned.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy) AppendScheduler(
	v *SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy_Scheduler,
) error {
	if v.SequenceId == nil {
		return fmt.Errorf("invalid nil key received for SequenceId")
	}

	key := *v.SequenceId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Scheduler == nil {
		t.Scheduler = make(map[uint8]*SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy_Scheduler)
	}

	if _, ok := t.Scheduler[key]; ok {
		return fmt.Errorf("duplicate key for list Scheduler %v", key)
	}

	t.Scheduler[key] = v
	return nil
}

// GetName retrieves the value of the leaf Name from the SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Scheduler {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy struct, which is a YANG list entry.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy.
func (*SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy_Scheduler represents the /srl_nokia-qos/qos/scheduler-policies/sched-class-scheduling-policy/scheduler YANG schema element.
type SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy_Scheduler struct {
	BurstAllowance      *uint64                                                                                          `path:"burst-allowance" module:"srl_nokia-qos"`
	Inputs              *SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy_Scheduler_Inputs                   `path:"inputs" module:"srl_nokia-qos"`
	Rate                *SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy_Scheduler_Rate                     `path:"rate" module:"srl_nokia-qos"`
	SequenceId          *uint8                                                                                           `path:"sequence-id" module:"srl_nokia-qos"`
	ThresholdSeparation SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy_Scheduler_ThresholdSeparation_Union `path:"threshold-separation" module:"srl_nokia-qos"`
	Tier                *uint8                                                                                           `path:"tier" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy_Scheduler implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy_Scheduler) IsYANGGoStruct() {}

// GetOrCreateInputs retrieves the value of the Inputs field
// or returns the existing field if it already exists.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy_Scheduler) GetOrCreateInputs() *SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy_Scheduler_Inputs {
	if t.Inputs != nil {
		return t.Inputs
	}
	t.Inputs = &SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy_Scheduler_Inputs{}
	return t.Inputs
}

// GetOrCreateRate retrieves the value of the Rate field
// or returns the existing field if it already exists.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy_Scheduler) GetOrCreateRate() *SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy_Scheduler_Rate {
	if t.Rate != nil {
		return t.Rate
	}
	t.Rate = &SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy_Scheduler_Rate{}
	return t.Rate
}

// GetInputs returns the value of the Inputs struct pointer
// from SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy_Scheduler. If the receiver or the field Inputs is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy_Scheduler) GetInputs() *SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy_Scheduler_Inputs {
	if t != nil && t.Inputs != nil {
		return t.Inputs
	}
	return nil
}

// GetRate returns the value of the Rate struct pointer
// from SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy_Scheduler. If the receiver or the field Rate is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy_Scheduler) GetRate() *SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy_Scheduler_Rate {
	if t != nil && t.Rate != nil {
		return t.Rate
	}
	return nil
}

// GetBurstAllowance retrieves the value of the leaf BurstAllowance from the SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy_Scheduler
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if BurstAllowance is set, it can
// safely use t.GetBurstAllowance() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.BurstAllowance == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy_Scheduler) GetBurstAllowance() uint64 {
	if t == nil || t.BurstAllowance == nil {
		return 9000
	}
	return *t.BurstAllowance
}

// GetSequenceId retrieves the value of the leaf SequenceId from the SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy_Scheduler
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SequenceId is set, it can
// safely use t.GetSequenceId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SequenceId == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy_Scheduler) GetSequenceId() uint8 {
	if t == nil || t.SequenceId == nil {
		return 0
	}
	return *t.SequenceId
}

// GetThresholdSeparation retrieves the value of the leaf ThresholdSeparation from the SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy_Scheduler
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ThresholdSeparation is set, it can
// safely use t.GetThresholdSeparation() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ThresholdSeparation == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy_Scheduler) GetThresholdSeparation() SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy_Scheduler_ThresholdSeparation_Union {
	if t == nil || t.ThresholdSeparation == nil {
		return SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy_Scheduler_ThresholdSeparation_Enum_default
	}
	return t.ThresholdSeparation
}

// GetTier retrieves the value of the leaf Tier from the SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy_Scheduler
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Tier is set, it can
// safely use t.GetTier() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Tier == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy_Scheduler) GetTier() uint8 {
	if t == nil || t.Tier == nil {
		return 0
	}
	return *t.Tier
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy_Scheduler
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy_Scheduler) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.BurstAllowance == nil {
		var v uint64 = 9000
		t.BurstAllowance = &v
	}
	if t.ThresholdSeparation == nil {
		t.ThresholdSeparation = SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy_Scheduler_ThresholdSeparation_Enum_default
	}
	if t.Tier == nil {
		var v uint8 = 0
		t.Tier = &v
	}
	t.Inputs.PopulateDefaults()
	t.Rate.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy_Scheduler struct, which is a YANG list entry.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy_Scheduler) ΛListKeyMap() (map[string]interface{}, error) {
	if t.SequenceId == nil {
		return nil, fmt.Errorf("nil value for key SequenceId")
	}

	return map[string]interface{}{
		"sequence-id": *t.SequenceId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy_Scheduler) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy_Scheduler"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy_Scheduler) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy_Scheduler) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy_Scheduler.
func (*SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy_Scheduler) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy_Scheduler_Inputs represents the /srl_nokia-qos/qos/scheduler-policies/sched-class-scheduling-policy/scheduler/inputs YANG schema element.
type SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy_Scheduler_Inputs struct {
	Inputs          E_SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy_Scheduler_Inputs_Inputs `path:"inputs" module:"srl_nokia-qos"`
	SchedulingClass []uint8                                                                                `path:"scheduling-class" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy_Scheduler_Inputs implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy_Scheduler_Inputs) IsYANGGoStruct() {
}

// GetInputs retrieves the value of the leaf Inputs from the SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy_Scheduler_Inputs
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Inputs is set, it can
// safely use t.GetInputs() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Inputs == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy_Scheduler_Inputs) GetInputs() E_SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy_Scheduler_Inputs_Inputs {
	if t == nil || t.Inputs == 0 {
		return 0
	}
	return t.Inputs
}

// GetSchedulingClass retrieves the value of the leaf SchedulingClass from the SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy_Scheduler_Inputs
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SchedulingClass is set, it can
// safely use t.GetSchedulingClass() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SchedulingClass == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy_Scheduler_Inputs) GetSchedulingClass() []uint8 {
	if t == nil || t.SchedulingClass == nil {
		return nil
	}
	return t.SchedulingClass
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy_Scheduler_Inputs
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy_Scheduler_Inputs) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy_Scheduler_Inputs) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy_Scheduler_Inputs"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy_Scheduler_Inputs) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy_Scheduler_Inputs) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy_Scheduler_Inputs.
func (*SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy_Scheduler_Inputs) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy_Scheduler_Rate represents the /srl_nokia-qos/qos/scheduler-policies/sched-class-scheduling-policy/scheduler/rate YANG schema element.
type SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy_Scheduler_Rate struct {
	PeakRateKbps       *uint64                         `path:"peak-rate-kbps" module:"srl_nokia-qos"`
	PeakRatePercentage *uint8                          `path:"peak-rate-percentage" module:"srl_nokia-qos"`
	PirAdaptationRule  E_SrlNokiaCommon_AdaptationRule `path:"pir-adaptation-rule" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy_Scheduler_Rate implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy_Scheduler_Rate) IsYANGGoStruct() {
}

// GetPeakRateKbps retrieves the value of the leaf PeakRateKbps from the SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy_Scheduler_Rate
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PeakRateKbps is set, it can
// safely use t.GetPeakRateKbps() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PeakRateKbps == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy_Scheduler_Rate) GetPeakRateKbps() uint64 {
	if t == nil || t.PeakRateKbps == nil {
		return 0
	}
	return *t.PeakRateKbps
}

// GetPeakRatePercentage retrieves the value of the leaf PeakRatePercentage from the SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy_Scheduler_Rate
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PeakRatePercentage is set, it can
// safely use t.GetPeakRatePercentage() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PeakRatePercentage == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy_Scheduler_Rate) GetPeakRatePercentage() uint8 {
	if t == nil || t.PeakRatePercentage == nil {
		return 100
	}
	return *t.PeakRatePercentage
}

// GetPirAdaptationRule retrieves the value of the leaf PirAdaptationRule from the SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy_Scheduler_Rate
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PirAdaptationRule is set, it can
// safely use t.GetPirAdaptationRule() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PirAdaptationRule == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy_Scheduler_Rate) GetPirAdaptationRule() E_SrlNokiaCommon_AdaptationRule {
	if t == nil || t.PirAdaptationRule == 0 {
		return SrlNokiaCommon_AdaptationRule_closest
	}
	return t.PirAdaptationRule
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy_Scheduler_Rate
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy_Scheduler_Rate) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.PeakRatePercentage == nil {
		var v uint8 = 100
		t.PeakRatePercentage = &v
	}
	if t.PirAdaptationRule == 0 {
		t.PirAdaptationRule = SrlNokiaCommon_AdaptationRule_closest
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy_Scheduler_Rate) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy_Scheduler_Rate"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy_Scheduler_Rate) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy_Scheduler_Rate) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy_Scheduler_Rate.
func (*SrlNokiaQos_Qos_SchedulerPolicies_SchedClassSchedulingPolicy_Scheduler_Rate) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy represents the /srl_nokia-qos/qos/scheduler-policies/scheduler-policy YANG schema element.
type SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy struct {
	Name      *string                                                                 `path:"name" module:"srl_nokia-qos"`
	Scheduler map[uint32]*SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler `path:"scheduler" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy) IsYANGGoStruct() {}

// NewScheduler creates a new entry in the Scheduler list of the
// SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy) NewScheduler(Sequence uint32) (*SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Scheduler == nil {
		t.Scheduler = make(map[uint32]*SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler)
	}

	key := Sequence

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Scheduler[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Scheduler", key)
	}

	t.Scheduler[key] = &SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler{
		Sequence: &Sequence,
	}

	return t.Scheduler[key], nil
}

// RenameScheduler renames an entry in the list Scheduler within
// the SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy) RenameScheduler(oldK, newK uint32) error {
	if _, ok := t.Scheduler[newK]; ok {
		return fmt.Errorf("key %v already exists in Scheduler", newK)
	}

	e, ok := t.Scheduler[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Scheduler", oldK)
	}
	e.Sequence = &newK

	t.Scheduler[newK] = e
	delete(t.Scheduler, oldK)
	return nil
}

// GetOrCreateScheduler retrieves the value with the specified keys from
// the receiver SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy) GetOrCreateScheduler(Sequence uint32) *SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler {
	key := Sequence

	if v, ok := t.Scheduler[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewScheduler(Sequence)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateScheduler got unexpected error: %v", err))
	}
	return v
}

// GetScheduler retrieves the value with the specified key from
// the Scheduler map field of SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy) GetScheduler(Sequence uint32) *SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler {
	if t == nil {
		return nil
	}

	key := Sequence

	if lm, ok := t.Scheduler[key]; ok {
		return lm
	}
	return nil
}

// DeleteScheduler deletes the value with the specified keys from
// the receiver SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy) DeleteScheduler(Sequence uint32) {
	key := Sequence

	delete(t.Scheduler, key)
}

// AppendScheduler appends the supplied SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler struct to the
// list Scheduler of SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy. If the key value(s) specified in
// the supplied SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler already exist in the list, an error is
// returned.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy) AppendScheduler(
	v *SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler,
) error {
	if v.Sequence == nil {
		return fmt.Errorf("invalid nil key received for Sequence")
	}

	key := *v.Sequence

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Scheduler == nil {
		t.Scheduler = make(map[uint32]*SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler)
	}

	if _, ok := t.Scheduler[key]; ok {
		return fmt.Errorf("duplicate key for list Scheduler %v", key)
	}

	t.Scheduler[key] = v
	return nil
}

// GetName retrieves the value of the leaf Name from the SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Scheduler {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy struct, which is a YANG list entry.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy.
func (*SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler represents the /srl_nokia-qos/qos/scheduler-policies/scheduler-policy/scheduler YANG schema element.
type SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler struct {
	Input    map[string]*SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler_Input `path:"input" module:"srl_nokia-qos"`
	Priority E_SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler_Priority        `path:"priority" module:"srl_nokia-qos"`
	Sequence *uint32                                                                       `path:"sequence" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler) IsYANGGoStruct() {}

// NewInput creates a new entry in the Input list of the
// SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler) NewInput(Id string) (*SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler_Input, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Input == nil {
		t.Input = make(map[string]*SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler_Input)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Input[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Input", key)
	}

	t.Input[key] = &SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler_Input{
		Id: &Id,
	}

	return t.Input[key], nil
}

// RenameInput renames an entry in the list Input within
// the SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler) RenameInput(oldK, newK string) error {
	if _, ok := t.Input[newK]; ok {
		return fmt.Errorf("key %v already exists in Input", newK)
	}

	e, ok := t.Input[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Input", oldK)
	}
	e.Id = &newK

	t.Input[newK] = e
	delete(t.Input, oldK)
	return nil
}

// GetOrCreateInput retrieves the value with the specified keys from
// the receiver SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler) GetOrCreateInput(Id string) *SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler_Input {
	key := Id

	if v, ok := t.Input[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInput(Id)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInput got unexpected error: %v", err))
	}
	return v
}

// GetInput retrieves the value with the specified key from
// the Input map field of SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler) GetInput(Id string) *SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler_Input {
	if t == nil {
		return nil
	}

	key := Id

	if lm, ok := t.Input[key]; ok {
		return lm
	}
	return nil
}

// DeleteInput deletes the value with the specified keys from
// the receiver SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler) DeleteInput(Id string) {
	key := Id

	delete(t.Input, key)
}

// AppendInput appends the supplied SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler_Input struct to the
// list Input of SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler. If the key value(s) specified in
// the supplied SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler_Input already exist in the list, an error is
// returned.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler) AppendInput(
	v *SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler_Input,
) error {
	if v.Id == nil {
		return fmt.Errorf("invalid nil key received for Id")
	}

	key := *v.Id

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Input == nil {
		t.Input = make(map[string]*SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler_Input)
	}

	if _, ok := t.Input[key]; ok {
		return fmt.Errorf("duplicate key for list Input %v", key)
	}

	t.Input[key] = v
	return nil
}

// GetPriority retrieves the value of the leaf Priority from the SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Priority is set, it can
// safely use t.GetPriority() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Priority == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler) GetPriority() E_SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler_Priority {
	if t == nil || t.Priority == 0 {
		return 0
	}
	return t.Priority
}

// GetSequence retrieves the value of the leaf Sequence from the SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Sequence is set, it can
// safely use t.GetSequence() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Sequence == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler) GetSequence() uint32 {
	if t == nil || t.Sequence == nil {
		return 0
	}
	return *t.Sequence
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Input {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler struct, which is a YANG list entry.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Sequence == nil {
		return nil, fmt.Errorf("nil value for key Sequence")
	}

	return map[string]interface{}{
		"sequence": *t.Sequence,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler.
func (*SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler_Input represents the /srl_nokia-qos/qos/scheduler-policies/scheduler-policy/scheduler/input YANG schema element.
type SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler_Input struct {
	Id              *string                                                                           `path:"id" module:"srl_nokia-qos"`
	InputType       E_SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler_Input_InputType     `path:"input-type" module:"srl_nokia-qos"`
	PeakRatePercent *uint8                                                                            `path:"peak-rate-percent" module:"srl_nokia-qos"`
	QueueName       SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler_Input_QueueName_Union `path:"queue-name" module:"srl_nokia-qos"`
	Weight          *uint8                                                                            `path:"weight" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler_Input implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler_Input) IsYANGGoStruct() {}

// GetId retrieves the value of the leaf Id from the SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler_Input
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Id is set, it can
// safely use t.GetId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Id == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler_Input) GetId() string {
	if t == nil || t.Id == nil {
		return ""
	}
	return *t.Id
}

// GetInputType retrieves the value of the leaf InputType from the SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler_Input
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InputType is set, it can
// safely use t.GetInputType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InputType == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler_Input) GetInputType() E_SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler_Input_InputType {
	if t == nil || t.InputType == 0 {
		return SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler_Input_InputType_queue
	}
	return t.InputType
}

// GetPeakRatePercent retrieves the value of the leaf PeakRatePercent from the SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler_Input
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PeakRatePercent is set, it can
// safely use t.GetPeakRatePercent() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PeakRatePercent == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler_Input) GetPeakRatePercent() uint8 {
	if t == nil || t.PeakRatePercent == nil {
		return 100
	}
	return *t.PeakRatePercent
}

// GetQueueName retrieves the value of the leaf QueueName from the SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler_Input
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if QueueName is set, it can
// safely use t.GetQueueName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.QueueName == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler_Input) GetQueueName() SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler_Input_QueueName_Union {
	if t == nil || t.QueueName == nil {
		return nil
	}
	return t.QueueName
}

// GetWeight retrieves the value of the leaf Weight from the SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler_Input
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Weight is set, it can
// safely use t.GetWeight() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Weight == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler_Input) GetWeight() uint8 {
	if t == nil || t.Weight == nil {
		return 0
	}
	return *t.Weight
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler_Input
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler_Input) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.InputType == 0 {
		t.InputType = SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler_Input_InputType_queue
	}
	if t.PeakRatePercent == nil {
		var v uint8 = 100
		t.PeakRatePercent = &v
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler_Input struct, which is a YANG list entry.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler_Input) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Id == nil {
		return nil, fmt.Errorf("nil value for key Id")
	}

	return map[string]interface{}{
		"id": *t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler_Input) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler_Input"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler_Input) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler_Input) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler_Input.
func (*SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler_Input) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_SchedulerPolicies_SchedulingPriorityMappingTable represents the /srl_nokia-qos/qos/scheduler-policies/scheduling-priority-mapping-table YANG schema element.
type SrlNokiaQos_Qos_SchedulerPolicies_SchedulingPriorityMappingTable struct {
	SchedulingClass map[uint8]*SrlNokiaQos_Qos_SchedulerPolicies_SchedulingPriorityMappingTable_SchedulingClass `path:"scheduling-class" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_SchedulerPolicies_SchedulingPriorityMappingTable implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_SchedulerPolicies_SchedulingPriorityMappingTable) IsYANGGoStruct() {}

// NewSchedulingClass creates a new entry in the SchedulingClass list of the
// SrlNokiaQos_Qos_SchedulerPolicies_SchedulingPriorityMappingTable struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedulingPriorityMappingTable) NewSchedulingClass(
	Index uint8,
) (*SrlNokiaQos_Qos_SchedulerPolicies_SchedulingPriorityMappingTable_SchedulingClass, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.SchedulingClass == nil {
		t.SchedulingClass = make(map[uint8]*SrlNokiaQos_Qos_SchedulerPolicies_SchedulingPriorityMappingTable_SchedulingClass)
	}

	key := Index

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.SchedulingClass[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list SchedulingClass", key)
	}

	t.SchedulingClass[key] = &SrlNokiaQos_Qos_SchedulerPolicies_SchedulingPriorityMappingTable_SchedulingClass{
		Index: &Index,
	}

	return t.SchedulingClass[key], nil
}

// RenameSchedulingClass renames an entry in the list SchedulingClass within
// the SrlNokiaQos_Qos_SchedulerPolicies_SchedulingPriorityMappingTable struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedulingPriorityMappingTable) RenameSchedulingClass(oldK, newK uint8) error {
	if _, ok := t.SchedulingClass[newK]; ok {
		return fmt.Errorf("key %v already exists in SchedulingClass", newK)
	}

	e, ok := t.SchedulingClass[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in SchedulingClass", oldK)
	}
	e.Index = &newK

	t.SchedulingClass[newK] = e
	delete(t.SchedulingClass, oldK)
	return nil
}

// GetOrCreateSchedulingClass retrieves the value with the specified keys from
// the receiver SrlNokiaQos_Qos_SchedulerPolicies_SchedulingPriorityMappingTable. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedulingPriorityMappingTable) GetOrCreateSchedulingClass(
	Index uint8,
) *SrlNokiaQos_Qos_SchedulerPolicies_SchedulingPriorityMappingTable_SchedulingClass {
	key := Index

	if v, ok := t.SchedulingClass[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewSchedulingClass(Index)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateSchedulingClass got unexpected error: %v", err))
	}
	return v
}

// GetSchedulingClass retrieves the value with the specified key from
// the SchedulingClass map field of SrlNokiaQos_Qos_SchedulerPolicies_SchedulingPriorityMappingTable. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedulingPriorityMappingTable) GetSchedulingClass(
	Index uint8,
) *SrlNokiaQos_Qos_SchedulerPolicies_SchedulingPriorityMappingTable_SchedulingClass {
	if t == nil {
		return nil
	}

	key := Index

	if lm, ok := t.SchedulingClass[key]; ok {
		return lm
	}
	return nil
}

// DeleteSchedulingClass deletes the value with the specified keys from
// the receiver SrlNokiaQos_Qos_SchedulerPolicies_SchedulingPriorityMappingTable. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedulingPriorityMappingTable) DeleteSchedulingClass(Index uint8) {
	key := Index

	delete(t.SchedulingClass, key)
}

// AppendSchedulingClass appends the supplied SrlNokiaQos_Qos_SchedulerPolicies_SchedulingPriorityMappingTable_SchedulingClass struct to the
// list SchedulingClass of SrlNokiaQos_Qos_SchedulerPolicies_SchedulingPriorityMappingTable. If the key value(s) specified in
// the supplied SrlNokiaQos_Qos_SchedulerPolicies_SchedulingPriorityMappingTable_SchedulingClass already exist in the list, an error is
// returned.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedulingPriorityMappingTable) AppendSchedulingClass(
	v *SrlNokiaQos_Qos_SchedulerPolicies_SchedulingPriorityMappingTable_SchedulingClass,
) error {
	if v.Index == nil {
		return fmt.Errorf("invalid nil key received for Index")
	}

	key := *v.Index

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.SchedulingClass == nil {
		t.SchedulingClass = make(map[uint8]*SrlNokiaQos_Qos_SchedulerPolicies_SchedulingPriorityMappingTable_SchedulingClass)
	}

	if _, ok := t.SchedulingClass[key]; ok {
		return fmt.Errorf("duplicate key for list SchedulingClass %v", key)
	}

	t.SchedulingClass[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_SchedulerPolicies_SchedulingPriorityMappingTable
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedulingPriorityMappingTable) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.SchedulingClass {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedulingPriorityMappingTable) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_SchedulerPolicies_SchedulingPriorityMappingTable"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedulingPriorityMappingTable) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedulingPriorityMappingTable) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_SchedulerPolicies_SchedulingPriorityMappingTable.
func (*SrlNokiaQos_Qos_SchedulerPolicies_SchedulingPriorityMappingTable) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_SchedulerPolicies_SchedulingPriorityMappingTable_SchedulingClass represents the /srl_nokia-qos/qos/scheduler-policies/scheduling-priority-mapping-table/scheduling-class YANG schema element.
type SrlNokiaQos_Qos_SchedulerPolicies_SchedulingPriorityMappingTable_SchedulingClass struct {
	Index              *uint8 `path:"index" module:"srl_nokia-qos"`
	SchedulingPriority *uint8 `path:"scheduling-priority" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_SchedulerPolicies_SchedulingPriorityMappingTable_SchedulingClass implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_SchedulerPolicies_SchedulingPriorityMappingTable_SchedulingClass) IsYANGGoStruct() {
}

// GetIndex retrieves the value of the leaf Index from the SrlNokiaQos_Qos_SchedulerPolicies_SchedulingPriorityMappingTable_SchedulingClass
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Index is set, it can
// safely use t.GetIndex() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Index == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedulingPriorityMappingTable_SchedulingClass) GetIndex() uint8 {
	if t == nil || t.Index == nil {
		return 0
	}
	return *t.Index
}

// GetSchedulingPriority retrieves the value of the leaf SchedulingPriority from the SrlNokiaQos_Qos_SchedulerPolicies_SchedulingPriorityMappingTable_SchedulingClass
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SchedulingPriority is set, it can
// safely use t.GetSchedulingPriority() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SchedulingPriority == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedulingPriorityMappingTable_SchedulingClass) GetSchedulingPriority() uint8 {
	if t == nil || t.SchedulingPriority == nil {
		return 0
	}
	return *t.SchedulingPriority
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_SchedulerPolicies_SchedulingPriorityMappingTable_SchedulingClass
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedulingPriorityMappingTable_SchedulingClass) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the SrlNokiaQos_Qos_SchedulerPolicies_SchedulingPriorityMappingTable_SchedulingClass struct, which is a YANG list entry.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedulingPriorityMappingTable_SchedulingClass) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Index == nil {
		return nil, fmt.Errorf("nil value for key Index")
	}

	return map[string]interface{}{
		"index": *t.Index,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedulingPriorityMappingTable_SchedulingClass) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_SchedulerPolicies_SchedulingPriorityMappingTable_SchedulingClass"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedulingPriorityMappingTable_SchedulingClass) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedulingPriorityMappingTable_SchedulingClass) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_SchedulerPolicies_SchedulingPriorityMappingTable_SchedulingClass.
func (*SrlNokiaQos_Qos_SchedulerPolicies_SchedulingPriorityMappingTable_SchedulingClass) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaRoutingPolicy_RoutingPolicy represents the /srl_nokia-routing-policy/routing-policy YANG schema element.
type SrlNokiaRoutingPolicy_RoutingPolicy struct {
	AsPathSet    map[string]*SrlNokiaRoutingPolicy_RoutingPolicy_AsPathSet    `path:"as-path-set" module:"srl_nokia-routing-policy"`
	CommunitySet map[string]*SrlNokiaRoutingPolicy_RoutingPolicy_CommunitySet `path:"community-set" module:"srl_nokia-routing-policy"`
	Policy       map[string]*SrlNokiaRoutingPolicy_RoutingPolicy_Policy       `path:"policy" module:"srl_nokia-routing-policy"`
	PrefixSet    map[string]*SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet    `path:"prefix-set" module:"srl_nokia-routing-policy"`
	TagSet       map[string]*SrlNokiaRoutingPolicy_RoutingPolicy_TagSet       `path:"tag-set" module:"srl_nokia-routing-policy"`
}

// IsYANGGoStruct ensures that SrlNokiaRoutingPolicy_RoutingPolicy implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaRoutingPolicy_RoutingPolicy) IsYANGGoStruct() {}

// NewAsPathSet creates a new entry in the AsPathSet list of the
// SrlNokiaRoutingPolicy_RoutingPolicy struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy) NewAsPathSet(Name string) (*SrlNokiaRoutingPolicy_RoutingPolicy_AsPathSet, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AsPathSet == nil {
		t.AsPathSet = make(map[string]*SrlNokiaRoutingPolicy_RoutingPolicy_AsPathSet)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.AsPathSet[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list AsPathSet", key)
	}

	t.AsPathSet[key] = &SrlNokiaRoutingPolicy_RoutingPolicy_AsPathSet{
		Name: &Name,
	}

	return t.AsPathSet[key], nil
}

// RenameAsPathSet renames an entry in the list AsPathSet within
// the SrlNokiaRoutingPolicy_RoutingPolicy struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy) RenameAsPathSet(oldK, newK string) error {
	if _, ok := t.AsPathSet[newK]; ok {
		return fmt.Errorf("key %v already exists in AsPathSet", newK)
	}

	e, ok := t.AsPathSet[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in AsPathSet", oldK)
	}
	e.Name = &newK

	t.AsPathSet[newK] = e
	delete(t.AsPathSet, oldK)
	return nil
}

// GetOrCreateAsPathSet retrieves the value with the specified keys from
// the receiver SrlNokiaRoutingPolicy_RoutingPolicy. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy) GetOrCreateAsPathSet(Name string) *SrlNokiaRoutingPolicy_RoutingPolicy_AsPathSet {
	key := Name

	if v, ok := t.AsPathSet[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAsPathSet(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAsPathSet got unexpected error: %v", err))
	}
	return v
}

// GetAsPathSet retrieves the value with the specified key from
// the AsPathSet map field of SrlNokiaRoutingPolicy_RoutingPolicy. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy) GetAsPathSet(Name string) *SrlNokiaRoutingPolicy_RoutingPolicy_AsPathSet {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.AsPathSet[key]; ok {
		return lm
	}
	return nil
}

// DeleteAsPathSet deletes the value with the specified keys from
// the receiver SrlNokiaRoutingPolicy_RoutingPolicy. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy) DeleteAsPathSet(Name string) {
	key := Name

	delete(t.AsPathSet, key)
}

// AppendAsPathSet appends the supplied SrlNokiaRoutingPolicy_RoutingPolicy_AsPathSet struct to the
// list AsPathSet of SrlNokiaRoutingPolicy_RoutingPolicy. If the key value(s) specified in
// the supplied SrlNokiaRoutingPolicy_RoutingPolicy_AsPathSet already exist in the list, an error is
// returned.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy) AppendAsPathSet(v *SrlNokiaRoutingPolicy_RoutingPolicy_AsPathSet) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AsPathSet == nil {
		t.AsPathSet = make(map[string]*SrlNokiaRoutingPolicy_RoutingPolicy_AsPathSet)
	}

	if _, ok := t.AsPathSet[key]; ok {
		return fmt.Errorf("duplicate key for list AsPathSet %v", key)
	}

	t.AsPathSet[key] = v
	return nil
}

// NewCommunitySet creates a new entry in the CommunitySet list of the
// SrlNokiaRoutingPolicy_RoutingPolicy struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy) NewCommunitySet(Name string) (*SrlNokiaRoutingPolicy_RoutingPolicy_CommunitySet, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.CommunitySet == nil {
		t.CommunitySet = make(map[string]*SrlNokiaRoutingPolicy_RoutingPolicy_CommunitySet)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.CommunitySet[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list CommunitySet", key)
	}

	t.CommunitySet[key] = &SrlNokiaRoutingPolicy_RoutingPolicy_CommunitySet{
		Name: &Name,
	}

	return t.CommunitySet[key], nil
}

// RenameCommunitySet renames an entry in the list CommunitySet within
// the SrlNokiaRoutingPolicy_RoutingPolicy struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy) RenameCommunitySet(oldK, newK string) error {
	if _, ok := t.CommunitySet[newK]; ok {
		return fmt.Errorf("key %v already exists in CommunitySet", newK)
	}

	e, ok := t.CommunitySet[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in CommunitySet", oldK)
	}
	e.Name = &newK

	t.CommunitySet[newK] = e
	delete(t.CommunitySet, oldK)
	return nil
}

// GetOrCreateCommunitySet retrieves the value with the specified keys from
// the receiver SrlNokiaRoutingPolicy_RoutingPolicy. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy) GetOrCreateCommunitySet(Name string) *SrlNokiaRoutingPolicy_RoutingPolicy_CommunitySet {
	key := Name

	if v, ok := t.CommunitySet[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewCommunitySet(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateCommunitySet got unexpected error: %v", err))
	}
	return v
}

// GetCommunitySet retrieves the value with the specified key from
// the CommunitySet map field of SrlNokiaRoutingPolicy_RoutingPolicy. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy) GetCommunitySet(Name string) *SrlNokiaRoutingPolicy_RoutingPolicy_CommunitySet {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.CommunitySet[key]; ok {
		return lm
	}
	return nil
}

// DeleteCommunitySet deletes the value with the specified keys from
// the receiver SrlNokiaRoutingPolicy_RoutingPolicy. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy) DeleteCommunitySet(Name string) {
	key := Name

	delete(t.CommunitySet, key)
}

// AppendCommunitySet appends the supplied SrlNokiaRoutingPolicy_RoutingPolicy_CommunitySet struct to the
// list CommunitySet of SrlNokiaRoutingPolicy_RoutingPolicy. If the key value(s) specified in
// the supplied SrlNokiaRoutingPolicy_RoutingPolicy_CommunitySet already exist in the list, an error is
// returned.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy) AppendCommunitySet(
	v *SrlNokiaRoutingPolicy_RoutingPolicy_CommunitySet,
) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.CommunitySet == nil {
		t.CommunitySet = make(map[string]*SrlNokiaRoutingPolicy_RoutingPolicy_CommunitySet)
	}

	if _, ok := t.CommunitySet[key]; ok {
		return fmt.Errorf("duplicate key for list CommunitySet %v", key)
	}

	t.CommunitySet[key] = v
	return nil
}

// NewPolicy creates a new entry in the Policy list of the
// SrlNokiaRoutingPolicy_RoutingPolicy struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy) NewPolicy(Name string) (*SrlNokiaRoutingPolicy_RoutingPolicy_Policy, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Policy == nil {
		t.Policy = make(map[string]*SrlNokiaRoutingPolicy_RoutingPolicy_Policy)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Policy[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Policy", key)
	}

	t.Policy[key] = &SrlNokiaRoutingPolicy_RoutingPolicy_Policy{
		Name: &Name,
	}

	return t.Policy[key], nil
}

// RenamePolicy renames an entry in the list Policy within
// the SrlNokiaRoutingPolicy_RoutingPolicy struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy) RenamePolicy(oldK, newK string) error {
	if _, ok := t.Policy[newK]; ok {
		return fmt.Errorf("key %v already exists in Policy", newK)
	}

	e, ok := t.Policy[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Policy", oldK)
	}
	e.Name = &newK

	t.Policy[newK] = e
	delete(t.Policy, oldK)
	return nil
}

// GetOrCreatePolicy retrieves the value with the specified keys from
// the receiver SrlNokiaRoutingPolicy_RoutingPolicy. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy) GetOrCreatePolicy(Name string) *SrlNokiaRoutingPolicy_RoutingPolicy_Policy {
	key := Name

	if v, ok := t.Policy[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPolicy(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePolicy got unexpected error: %v", err))
	}
	return v
}

// GetPolicy retrieves the value with the specified key from
// the Policy map field of SrlNokiaRoutingPolicy_RoutingPolicy. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy) GetPolicy(Name string) *SrlNokiaRoutingPolicy_RoutingPolicy_Policy {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Policy[key]; ok {
		return lm
	}
	return nil
}

// DeletePolicy deletes the value with the specified keys from
// the receiver SrlNokiaRoutingPolicy_RoutingPolicy. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy) DeletePolicy(Name string) {
	key := Name

	delete(t.Policy, key)
}

// AppendPolicy appends the supplied SrlNokiaRoutingPolicy_RoutingPolicy_Policy struct to the
// list Policy of SrlNokiaRoutingPolicy_RoutingPolicy. If the key value(s) specified in
// the supplied SrlNokiaRoutingPolicy_RoutingPolicy_Policy already exist in the list, an error is
// returned.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy) AppendPolicy(v *SrlNokiaRoutingPolicy_RoutingPolicy_Policy) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Policy == nil {
		t.Policy = make(map[string]*SrlNokiaRoutingPolicy_RoutingPolicy_Policy)
	}

	if _, ok := t.Policy[key]; ok {
		return fmt.Errorf("duplicate key for list Policy %v", key)
	}

	t.Policy[key] = v
	return nil
}

// NewPrefixSet creates a new entry in the PrefixSet list of the
// SrlNokiaRoutingPolicy_RoutingPolicy struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy) NewPrefixSet(Name string) (*SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PrefixSet == nil {
		t.PrefixSet = make(map[string]*SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.PrefixSet[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list PrefixSet", key)
	}

	t.PrefixSet[key] = &SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet{
		Name: &Name,
	}

	return t.PrefixSet[key], nil
}

// RenamePrefixSet renames an entry in the list PrefixSet within
// the SrlNokiaRoutingPolicy_RoutingPolicy struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy) RenamePrefixSet(oldK, newK string) error {
	if _, ok := t.PrefixSet[newK]; ok {
		return fmt.Errorf("key %v already exists in PrefixSet", newK)
	}

	e, ok := t.PrefixSet[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in PrefixSet", oldK)
	}
	e.Name = &newK

	t.PrefixSet[newK] = e
	delete(t.PrefixSet, oldK)
	return nil
}

// GetOrCreatePrefixSet retrieves the value with the specified keys from
// the receiver SrlNokiaRoutingPolicy_RoutingPolicy. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy) GetOrCreatePrefixSet(Name string) *SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet {
	key := Name

	if v, ok := t.PrefixSet[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPrefixSet(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePrefixSet got unexpected error: %v", err))
	}
	return v
}

// GetPrefixSet retrieves the value with the specified key from
// the PrefixSet map field of SrlNokiaRoutingPolicy_RoutingPolicy. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy) GetPrefixSet(Name string) *SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.PrefixSet[key]; ok {
		return lm
	}
	return nil
}

// DeletePrefixSet deletes the value with the specified keys from
// the receiver SrlNokiaRoutingPolicy_RoutingPolicy. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy) DeletePrefixSet(Name string) {
	key := Name

	delete(t.PrefixSet, key)
}

// AppendPrefixSet appends the supplied SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet struct to the
// list PrefixSet of SrlNokiaRoutingPolicy_RoutingPolicy. If the key value(s) specified in
// the supplied SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet already exist in the list, an error is
// returned.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy) AppendPrefixSet(v *SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PrefixSet == nil {
		t.PrefixSet = make(map[string]*SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet)
	}

	if _, ok := t.PrefixSet[key]; ok {
		return fmt.Errorf("duplicate key for list PrefixSet %v", key)
	}

	t.PrefixSet[key] = v
	return nil
}

// NewTagSet creates a new entry in the TagSet list of the
// SrlNokiaRoutingPolicy_RoutingPolicy struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy) NewTagSet(Name string) (*SrlNokiaRoutingPolicy_RoutingPolicy_TagSet, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.TagSet == nil {
		t.TagSet = make(map[string]*SrlNokiaRoutingPolicy_RoutingPolicy_TagSet)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.TagSet[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list TagSet", key)
	}

	t.TagSet[key] = &SrlNokiaRoutingPolicy_RoutingPolicy_TagSet{
		Name: &Name,
	}

	return t.TagSet[key], nil
}

// RenameTagSet renames an entry in the list TagSet within
// the SrlNokiaRoutingPolicy_RoutingPolicy struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy) RenameTagSet(oldK, newK string) error {
	if _, ok := t.TagSet[newK]; ok {
		return fmt.Errorf("key %v already exists in TagSet", newK)
	}

	e, ok := t.TagSet[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in TagSet", oldK)
	}
	e.Name = &newK

	t.TagSet[newK] = e
	delete(t.TagSet, oldK)
	return nil
}

// GetOrCreateTagSet retrieves the value with the specified keys from
// the receiver SrlNokiaRoutingPolicy_RoutingPolicy. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy) GetOrCreateTagSet(Name string) *SrlNokiaRoutingPolicy_RoutingPolicy_TagSet {
	key := Name

	if v, ok := t.TagSet[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewTagSet(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateTagSet got unexpected error: %v", err))
	}
	return v
}

// GetTagSet retrieves the value with the specified key from
// the TagSet map field of SrlNokiaRoutingPolicy_RoutingPolicy. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy) GetTagSet(Name string) *SrlNokiaRoutingPolicy_RoutingPolicy_TagSet {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.TagSet[key]; ok {
		return lm
	}
	return nil
}

// DeleteTagSet deletes the value with the specified keys from
// the receiver SrlNokiaRoutingPolicy_RoutingPolicy. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy) DeleteTagSet(Name string) {
	key := Name

	delete(t.TagSet, key)
}

// AppendTagSet appends the supplied SrlNokiaRoutingPolicy_RoutingPolicy_TagSet struct to the
// list TagSet of SrlNokiaRoutingPolicy_RoutingPolicy. If the key value(s) specified in
// the supplied SrlNokiaRoutingPolicy_RoutingPolicy_TagSet already exist in the list, an error is
// returned.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy) AppendTagSet(v *SrlNokiaRoutingPolicy_RoutingPolicy_TagSet) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.TagSet == nil {
		t.TagSet = make(map[string]*SrlNokiaRoutingPolicy_RoutingPolicy_TagSet)
	}

	if _, ok := t.TagSet[key]; ok {
		return fmt.Errorf("duplicate key for list TagSet %v", key)
	}

	t.TagSet[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaRoutingPolicy_RoutingPolicy
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.AsPathSet {
		e.PopulateDefaults()
	}
	for _, e := range t.CommunitySet {
		e.PopulateDefaults()
	}
	for _, e := range t.Policy {
		e.PopulateDefaults()
	}
	for _, e := range t.PrefixSet {
		e.PopulateDefaults()
	}
	for _, e := range t.TagSet {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaRoutingPolicy_RoutingPolicy"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaRoutingPolicy_RoutingPolicy.
func (*SrlNokiaRoutingPolicy_RoutingPolicy) ΛBelongingModule() string {
	return "srl_nokia-routing-policy"
}

// SrlNokiaRoutingPolicy_RoutingPolicy_AsPathSet represents the /srl_nokia-routing-policy/routing-policy/as-path-set YANG schema element.
type SrlNokiaRoutingPolicy_RoutingPolicy_AsPathSet struct {
	Expression *string `path:"expression" module:"srl_nokia-routing-policy"`
	Name       *string `path:"name" module:"srl_nokia-routing-policy"`
}

// IsYANGGoStruct ensures that SrlNokiaRoutingPolicy_RoutingPolicy_AsPathSet implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaRoutingPolicy_RoutingPolicy_AsPathSet) IsYANGGoStruct() {}

// GetExpression retrieves the value of the leaf Expression from the SrlNokiaRoutingPolicy_RoutingPolicy_AsPathSet
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Expression is set, it can
// safely use t.GetExpression() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Expression == nil' before retrieving the leaf's value.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_AsPathSet) GetExpression() string {
	if t == nil || t.Expression == nil {
		return ""
	}
	return *t.Expression
}

// GetName retrieves the value of the leaf Name from the SrlNokiaRoutingPolicy_RoutingPolicy_AsPathSet
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_AsPathSet) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaRoutingPolicy_RoutingPolicy_AsPathSet
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_AsPathSet) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the SrlNokiaRoutingPolicy_RoutingPolicy_AsPathSet struct, which is a YANG list entry.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_AsPathSet) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_AsPathSet) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaRoutingPolicy_RoutingPolicy_AsPathSet"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_AsPathSet) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_AsPathSet) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaRoutingPolicy_RoutingPolicy_AsPathSet.
func (*SrlNokiaRoutingPolicy_RoutingPolicy_AsPathSet) ΛBelongingModule() string {
	return "srl_nokia-routing-policy"
}

// SrlNokiaRoutingPolicy_RoutingPolicy_CommunitySet represents the /srl_nokia-routing-policy/routing-policy/community-set YANG schema element.
type SrlNokiaRoutingPolicy_RoutingPolicy_CommunitySet struct {
	Member []SrlNokiaRoutingPolicy_RoutingPolicy_CommunitySet_Member_Union `path:"member" module:"srl_nokia-routing-policy"`
	Name   *string                                                         `path:"name" module:"srl_nokia-routing-policy"`
}

// IsYANGGoStruct ensures that SrlNokiaRoutingPolicy_RoutingPolicy_CommunitySet implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaRoutingPolicy_RoutingPolicy_CommunitySet) IsYANGGoStruct() {}

// GetMember retrieves the value of the leaf Member from the SrlNokiaRoutingPolicy_RoutingPolicy_CommunitySet
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Member is set, it can
// safely use t.GetMember() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Member == nil' before retrieving the leaf's value.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_CommunitySet) GetMember() []SrlNokiaRoutingPolicy_RoutingPolicy_CommunitySet_Member_Union {
	if t == nil || t.Member == nil {
		return nil
	}
	return t.Member
}

// GetName retrieves the value of the leaf Name from the SrlNokiaRoutingPolicy_RoutingPolicy_CommunitySet
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_CommunitySet) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaRoutingPolicy_RoutingPolicy_CommunitySet
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_CommunitySet) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the SrlNokiaRoutingPolicy_RoutingPolicy_CommunitySet struct, which is a YANG list entry.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_CommunitySet) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_CommunitySet) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaRoutingPolicy_RoutingPolicy_CommunitySet"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_CommunitySet) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_CommunitySet) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaRoutingPolicy_RoutingPolicy_CommunitySet.
func (*SrlNokiaRoutingPolicy_RoutingPolicy_CommunitySet) ΛBelongingModule() string {
	return "srl_nokia-routing-policy"
}

// SrlNokiaRoutingPolicy_RoutingPolicy_Policy represents the /srl_nokia-routing-policy/routing-policy/policy YANG schema element.
type SrlNokiaRoutingPolicy_RoutingPolicy_Policy struct {
	DefaultAction *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction        `path:"default-action" module:"srl_nokia-routing-policy"`
	Name          *string                                                          `path:"name" module:"srl_nokia-routing-policy"`
	Statement     *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_OrderedMap `path:"statement" module:"srl_nokia-routing-policy"`
}

// IsYANGGoStruct ensures that SrlNokiaRoutingPolicy_RoutingPolicy_Policy implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaRoutingPolicy_RoutingPolicy_Policy) IsYANGGoStruct() {}

// GetOrCreateDefaultAction retrieves the value of the DefaultAction field
// or returns the existing field if it already exists.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy) GetOrCreateDefaultAction() *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction {
	if t.DefaultAction != nil {
		return t.DefaultAction
	}
	t.DefaultAction = &SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction{}
	return t.DefaultAction
}

// GetDefaultAction returns the value of the DefaultAction struct pointer
// from SrlNokiaRoutingPolicy_RoutingPolicy_Policy. If the receiver or the field DefaultAction is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy) GetDefaultAction() *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction {
	if t != nil && t.DefaultAction != nil {
		return t.DefaultAction
	}
	return nil
}

// GetName retrieves the value of the leaf Name from the SrlNokiaRoutingPolicy_RoutingPolicy_Policy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// AppendNewStatement creates a new entry in the Statement
// ordered map of the SrlNokiaRoutingPolicy_RoutingPolicy_Policy struct. The keys of the list are
// populated from the input arguments.
func (s *SrlNokiaRoutingPolicy_RoutingPolicy_Policy) AppendNewStatement(Name string) (*SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement, error) {
	if s.Statement == nil {
		s.Statement = &SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_OrderedMap{}
	}
	return s.Statement.AppendNew(Name)
}

// AppendStatement appends the supplied SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement struct
// to the list Statement of SrlNokiaRoutingPolicy_RoutingPolicy_Policy. If the key value(s)
// specified in the supplied SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement already exist in the list, an
// error is returned.
func (s *SrlNokiaRoutingPolicy_RoutingPolicy_Policy) AppendStatement(
	v *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement,
) error {
	if s.Statement == nil {
		s.Statement = &SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_OrderedMap{}
	}
	return s.Statement.Append(v)
}

// GetStatement retrieves the value with the specified key from the
// Statement map field of SrlNokiaRoutingPolicy_RoutingPolicy_Policy. If the receiver
// is nil, or the specified key is not present in the list, nil is returned
// such that Get* methods may be safely chained.
func (s *SrlNokiaRoutingPolicy_RoutingPolicy_Policy) GetStatement(Name string) *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement {
	if s == nil {
		return nil
	}
	key := Name
	return s.Statement.Get(key)
}

// DeleteStatement deletes the value with the specified keys from
// the receiver SrlNokiaRoutingPolicy_RoutingPolicy_Policy. If there is no such element, the
// function is a no-op.
func (s *SrlNokiaRoutingPolicy_RoutingPolicy_Policy) DeleteStatement(Name string) bool {
	key := Name
	return s.Statement.Delete(key)
}

// SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_OrderedMap is an ordered map that represents the "ordered-by user"
// list elements at /srl_nokia-routing-policy/routing-policy/policy/statement.
type SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_OrderedMap struct {
	keys     []string
	valueMap map[string]*SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement
}

// IsYANGOrderedList ensures that SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_OrderedMap implements the
// ygot.GoOrderedMap interface.
func (*SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_OrderedMap) IsYANGOrderedList() {}

// init initializes any uninitialized values.
func (o *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_OrderedMap) init() {
	if o == nil {
		return
	}
	if o.valueMap == nil {
		o.valueMap = map[string]*SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement{}
	}
}

// Keys returns a copy of the list's keys.
func (o *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_OrderedMap) Keys() []string {
	if o == nil {
		return nil
	}
	return append([]string{}, o.keys...)
}

// Values returns the current set of the list's values in order.
func (o *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_OrderedMap) Values() []*SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement {
	if o == nil {
		return nil
	}
	var values []*SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement
	for _, key := range o.keys {
		values = append(values, o.valueMap[key])
	}
	return values
}

// Len returns a size of SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_OrderedMap.
func (o *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_OrderedMap) Len() int {
	if o == nil {
		return 0
	}
	return len(o.keys)
}

// Get returns the value corresponding to the key. If the key is not found, nil
// is returned.
func (o *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_OrderedMap) Get(key string) *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement {
	if o == nil {
		return nil
	}
	val, _ := o.valueMap[key]
	return val
}

// Delete deletes an element.
func (o *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_OrderedMap) Delete(key string) bool {
	if o == nil {
		return false
	}
	if _, ok := o.valueMap[key]; !ok {
		return false
	}
	for i, k := range o.keys {
		if k == key {
			o.keys = append(o.keys[:i], o.keys[i+1:]...)
			delete(o.valueMap, key)
			return true
		}
	}
	return false
}

// Append appends a SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement, returning an error if the key
// already exists in the ordered list or if the key is unspecified.
func (o *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_OrderedMap) Append(
	v *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement,
) error {
	if o == nil {
		return fmt.Errorf("nil ordered map, cannot append SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement")
	}
	if v == nil {
		return fmt.Errorf("nil SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement")
	}
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	if _, ok := o.valueMap[key]; ok {
		return fmt.Errorf("duplicate key for list Statement %v", key)
	}
	o.keys = append(o.keys, key)
	o.init()
	o.valueMap[key] = v
	return nil
}

// AppendNew creates and appends a new SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement, returning the
// newly-initialized v. It returns an error if the v already exists.
func (o *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_OrderedMap) AppendNew(Name string) (*SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement, error) {
	if o == nil {
		return nil, fmt.Errorf("nil ordered map, cannot append SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement")
	}
	key := Name

	if _, ok := o.valueMap[key]; ok {
		return nil, fmt.Errorf("duplicate key for list Statement %v", key)
	}
	o.keys = append(o.keys, key)
	newElement := &SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement{
		Name: &Name,
	}
	o.init()
	o.valueMap[key] = newElement
	return newElement, nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaRoutingPolicy_RoutingPolicy_Policy
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.DefaultAction.PopulateDefaults()
	for _, e := range t.Statement.Values() {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaRoutingPolicy_RoutingPolicy_Policy struct, which is a YANG list entry.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaRoutingPolicy_RoutingPolicy_Policy"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaRoutingPolicy_RoutingPolicy_Policy.
func (*SrlNokiaRoutingPolicy_RoutingPolicy_Policy) ΛBelongingModule() string {
	return "srl_nokia-routing-policy"
}

// SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction represents the /srl_nokia-routing-policy/routing-policy/policy/default-action YANG schema element.
type SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction struct {
	Bgp             *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp             `path:"bgp" module:"srl_nokia-routing-policy"`
	InternalTags    *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_InternalTags    `path:"internal-tags" module:"srl_nokia-routing-policy"`
	PolicyResult    E_SrlNokiaPolicyTypes_PolicyResultType                                    `path:"policy-result" module:"srl_nokia-routing-policy"`
	RoutePreference *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_RoutePreference `path:"route-preference" module:"srl_nokia-routing-policy"`
}

// IsYANGGoStruct ensures that SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction) IsYANGGoStruct() {}

// GetOrCreateBgp retrieves the value of the Bgp field
// or returns the existing field if it already exists.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction) GetOrCreateBgp() *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp {
	if t.Bgp != nil {
		return t.Bgp
	}
	t.Bgp = &SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp{}
	return t.Bgp
}

// GetOrCreateInternalTags retrieves the value of the InternalTags field
// or returns the existing field if it already exists.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction) GetOrCreateInternalTags() *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_InternalTags {
	if t.InternalTags != nil {
		return t.InternalTags
	}
	t.InternalTags = &SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_InternalTags{}
	return t.InternalTags
}

// GetOrCreateRoutePreference retrieves the value of the RoutePreference field
// or returns the existing field if it already exists.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction) GetOrCreateRoutePreference() *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_RoutePreference {
	if t.RoutePreference != nil {
		return t.RoutePreference
	}
	t.RoutePreference = &SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_RoutePreference{}
	return t.RoutePreference
}

// GetBgp returns the value of the Bgp struct pointer
// from SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction. If the receiver or the field Bgp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction) GetBgp() *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp {
	if t != nil && t.Bgp != nil {
		return t.Bgp
	}
	return nil
}

// GetInternalTags returns the value of the InternalTags struct pointer
// from SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction. If the receiver or the field InternalTags is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction) GetInternalTags() *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_InternalTags {
	if t != nil && t.InternalTags != nil {
		return t.InternalTags
	}
	return nil
}

// GetRoutePreference returns the value of the RoutePreference struct pointer
// from SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction. If the receiver or the field RoutePreference is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction) GetRoutePreference() *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_RoutePreference {
	if t != nil && t.RoutePreference != nil {
		return t.RoutePreference
	}
	return nil
}

// GetPolicyResult retrieves the value of the leaf PolicyResult from the SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PolicyResult is set, it can
// safely use t.GetPolicyResult() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PolicyResult == nil' before retrieving the leaf's value.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction) GetPolicyResult() E_SrlNokiaPolicyTypes_PolicyResultType {
	if t == nil || t.PolicyResult == 0 {
		return 0
	}
	return t.PolicyResult
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Bgp.PopulateDefaults()
	t.InternalTags.PopulateDefaults()
	t.RoutePreference.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction.
func (*SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction) ΛBelongingModule() string {
	return "srl_nokia-routing-policy"
}

// SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp represents the /srl_nokia-routing-policy/routing-policy/policy/default-action/bgp YANG schema element.
type SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp struct {
	AsPath          *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_AsPath          `path:"as-path" module:"srl_nokia-routing-policy"`
	Communities     *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_Communities     `path:"communities" module:"srl_nokia-routing-policy"`
	LocalPreference *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_LocalPreference `path:"local-preference" module:"srl_nokia-routing-policy"`
	Med             *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_Med             `path:"med" module:"srl_nokia-routing-policy"`
	Origin          *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_Origin          `path:"origin" module:"srl_nokia-routing-policy"`
}

// IsYANGGoStruct ensures that SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp) IsYANGGoStruct() {}

// GetOrCreateAsPath retrieves the value of the AsPath field
// or returns the existing field if it already exists.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp) GetOrCreateAsPath() *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_AsPath {
	if t.AsPath != nil {
		return t.AsPath
	}
	t.AsPath = &SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_AsPath{}
	return t.AsPath
}

// GetOrCreateCommunities retrieves the value of the Communities field
// or returns the existing field if it already exists.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp) GetOrCreateCommunities() *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_Communities {
	if t.Communities != nil {
		return t.Communities
	}
	t.Communities = &SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_Communities{}
	return t.Communities
}

// GetOrCreateLocalPreference retrieves the value of the LocalPreference field
// or returns the existing field if it already exists.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp) GetOrCreateLocalPreference() *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_LocalPreference {
	if t.LocalPreference != nil {
		return t.LocalPreference
	}
	t.LocalPreference = &SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_LocalPreference{}
	return t.LocalPreference
}

// GetOrCreateMed retrieves the value of the Med field
// or returns the existing field if it already exists.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp) GetOrCreateMed() *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_Med {
	if t.Med != nil {
		return t.Med
	}
	t.Med = &SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_Med{}
	return t.Med
}

// GetOrCreateOrigin retrieves the value of the Origin field
// or returns the existing field if it already exists.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp) GetOrCreateOrigin() *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_Origin {
	if t.Origin != nil {
		return t.Origin
	}
	t.Origin = &SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_Origin{}
	return t.Origin
}

// GetAsPath returns the value of the AsPath struct pointer
// from SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp. If the receiver or the field AsPath is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp) GetAsPath() *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_AsPath {
	if t != nil && t.AsPath != nil {
		return t.AsPath
	}
	return nil
}

// GetCommunities returns the value of the Communities struct pointer
// from SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp. If the receiver or the field Communities is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp) GetCommunities() *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_Communities {
	if t != nil && t.Communities != nil {
		return t.Communities
	}
	return nil
}

// GetLocalPreference returns the value of the LocalPreference struct pointer
// from SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp. If the receiver or the field LocalPreference is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp) GetLocalPreference() *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_LocalPreference {
	if t != nil && t.LocalPreference != nil {
		return t.LocalPreference
	}
	return nil
}

// GetMed returns the value of the Med struct pointer
// from SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp. If the receiver or the field Med is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp) GetMed() *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_Med {
	if t != nil && t.Med != nil {
		return t.Med
	}
	return nil
}

// GetOrigin returns the value of the Origin struct pointer
// from SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp. If the receiver or the field Origin is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp) GetOrigin() *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_Origin {
	if t != nil && t.Origin != nil {
		return t.Origin
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.AsPath.PopulateDefaults()
	t.Communities.PopulateDefaults()
	t.LocalPreference.PopulateDefaults()
	t.Med.PopulateDefaults()
	t.Origin.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp.
func (*SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp) ΛBelongingModule() string {
	return "srl_nokia-routing-policy"
}

// SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_AsPath represents the /srl_nokia-routing-policy/routing-policy/policy/default-action/bgp/as-path YANG schema element.
type SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_AsPath struct {
	Prepend *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_AsPath_Prepend `path:"prepend" module:"srl_nokia-routing-policy"`
	Remove  *bool                                                                        `path:"remove" module:"srl_nokia-routing-policy"`
	Replace []uint32                                                                     `path:"replace" module:"srl_nokia-routing-policy"`
}

// IsYANGGoStruct ensures that SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_AsPath implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_AsPath) IsYANGGoStruct() {}

// GetOrCreatePrepend retrieves the value of the Prepend field
// or returns the existing field if it already exists.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_AsPath) GetOrCreatePrepend() *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_AsPath_Prepend {
	if t.Prepend != nil {
		return t.Prepend
	}
	t.Prepend = &SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_AsPath_Prepend{}
	return t.Prepend
}

// GetPrepend returns the value of the Prepend struct pointer
// from SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_AsPath. If the receiver or the field Prepend is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_AsPath) GetPrepend() *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_AsPath_Prepend {
	if t != nil && t.Prepend != nil {
		return t.Prepend
	}
	return nil
}

// GetRemove retrieves the value of the leaf Remove from the SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_AsPath
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Remove is set, it can
// safely use t.GetRemove() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Remove == nil' before retrieving the leaf's value.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_AsPath) GetRemove() bool {
	if t == nil || t.Remove == nil {
		return false
	}
	return *t.Remove
}

// GetReplace retrieves the value of the leaf Replace from the SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_AsPath
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Replace is set, it can
// safely use t.GetReplace() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Replace == nil' before retrieving the leaf's value.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_AsPath) GetReplace() []uint32 {
	if t == nil || t.Replace == nil {
		return nil
	}
	return t.Replace
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_AsPath
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_AsPath) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Prepend.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_AsPath) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_AsPath"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_AsPath) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_AsPath) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_AsPath.
func (*SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_AsPath) ΛBelongingModule() string {
	return "srl_nokia-routing-policy"
}
