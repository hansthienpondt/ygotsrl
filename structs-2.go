/*
Package ygotsrl is a generated package which contains definitions
of structs which represent a YANG schema. The generated schema can be
compressed by a series of transformations (compression was false
in this case).

This package was generated by /home/hans/go/pkg/mod/github.com/openconfig/ygot@v0.29.17/genutil/names.go
using the following YANG input files:
	- work/srlinux-yang-models/srl_nokia/models/acl/srl_nokia-acl-policers.yang
	- work/srlinux-yang-models/srl_nokia/models/acl/srl_nokia-acl-qos.yang
	- work/srlinux-yang-models/srl_nokia/models/acl/srl_nokia-acl.yang
	- work/srlinux-yang-models/srl_nokia/models/acl/srl_nokia-packet-match-types.yang
	- work/srlinux-yang-models/srl_nokia/models/bfd/srl_nokia-bfd.yang
	- work/srlinux-yang-models/srl_nokia/models/bfd/srl_nokia-micro-bfd.yang
	- work/srlinux-yang-models/srl_nokia/models/common/srl_nokia-common.yang
	- work/srlinux-yang-models/srl_nokia/models/common/srl_nokia-extensions.yang
	- work/srlinux-yang-models/srl_nokia/models/common/srl_nokia-features.yang
	- work/srlinux-yang-models/srl_nokia/models/ethcfm/srl_nokia-ethcfm-types.yang
	- work/srlinux-yang-models/srl_nokia/models/ethcfm/srl_nokia-ethcfm.yang
	- work/srlinux-yang-models/srl_nokia/models/ethcfm/srl_nokia-oam-pm-ethcfm.yang
	- work/srlinux-yang-models/srl_nokia/models/grpc/srl_nokia-gnsi-authz.yang
	- work/srlinux-yang-models/srl_nokia/models/grpc/srl_nokia-gnsi-certz.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-if-ip.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-if-mpls.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-bridge-table-mac-duplication-entries.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-bridge-table-mac-learning-entries.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-bridge-table-mac-table.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-bridge-table-statistics.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-bridge-table.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-ethernet-segment-association.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-ip-dhcp-relay.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-ip-dhcp-server.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-ip-dhcp.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-ip-vrrp.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-l2cp.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-lag.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-local-mirror-destination.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-nbr-evpn.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-nbr-virtual-ip-discovery.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-nbr.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-p4rt.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-router-adv.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-vlans.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-vxdp.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-lacp.yang
	- work/srlinux-yang-models/srl_nokia/models/ipamps/srl_nokia-ippm-source-udp-pool.yang
	- work/srlinux-yang-models/srl_nokia/models/ipamps/srl_nokia-link-measurement.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-aggregate-routes.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bgp-evpn-bgp-instance-mpls-bridge-table-multicast-destinations.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bgp-evpn-bgp-instance-mpls-bridge-table-statistics.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bgp-evpn-bgp-instance-mpls-bridge-table-unicast-destinations.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bgp-evpn-bgp-instance-mpls-vpws-destinations.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bgp-evpn.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bgp-ipvpn.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bgp-vpn.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bgp.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table-mac-duplication-entries.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table-mac-duplication.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table-mac-learning-entries.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table-mac-learning.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table-mac-limit.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table-mac-table.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table-proxy-arp-nd.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table-reserved-macs.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table-shg.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table-static-mac.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-connection-point.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-icmp.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-igmp-snooping.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-igmp-types.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-igmp.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-ip-route-tables.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-isis-lsdb-types.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-isis-lsdb.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-isis.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-ldp.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-linux.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-maintenance-policies.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-mld-snooping.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-mld.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-mpls-route-tables.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-mpls.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-multicast-mfib-tables.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-mvpn-l3.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-network-instance-mtu.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-network-instance.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-next-hop-groups.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-ospf-lsdb.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-ospf-types.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-ospf.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-ospfv3-lsas.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-pcep.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-pim.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-policy-forwarding.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-rib-bgp.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-segment-routing.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-static-routes.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-tcp-udp.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-te-policies.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-traffic-engineering.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-tunnel-tables.yang
	- work/srlinux-yang-models/srl_nokia/models/oam/srl_nokia-lsp-ping-trace.yang
	- work/srlinux-yang-models/srl_nokia/models/oam/srl_nokia-oam-pm-ip.yang
	- work/srlinux-yang-models/srl_nokia/models/oam/srl_nokia-oam-pm-types.yang
	- work/srlinux-yang-models/srl_nokia/models/oam/srl_nokia-oam-pm.yang
	- work/srlinux-yang-models/srl_nokia/models/oam/srl_nokia-oam.yang
	- work/srlinux-yang-models/srl_nokia/models/oam/srl_nokia-stamp.yang
	- work/srlinux-yang-models/srl_nokia/models/oam/srl_nokia-twamp.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-acl.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-cgroup.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-chassis.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-control.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-cpu.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-datapath-resources.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-disk.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-fabric.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-fan.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-healthz.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-lc.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-linecard-fib.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-memory.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-mtu.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-p4rt.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-pipeline-counters.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-psu.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-qos.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-redundancy.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-resource-mgmt.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-resource-monitoring.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-secure-boot.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-tcam.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-tpm.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-vxdp.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform.yang
	- work/srlinux-yang-models/srl_nokia/models/qos/srl_nokia-qos-policers.yang
	- work/srlinux-yang-models/srl_nokia/models/qos/srl_nokia-qos.yang
	- work/srlinux-yang-models/srl_nokia/models/routing-policy/srl_nokia-policy-types.yang
	- work/srlinux-yang-models/srl_nokia/models/routing-policy/srl_nokia-routing-policy.yang
	- work/srlinux-yang-models/srl_nokia/models/sync/srl_nokia-sync-freq.yang
	- work/srlinux-yang-models/srl_nokia/models/sync/srl_nokia-sync-interfaces.yang
	- work/srlinux-yang-models/srl_nokia/models/sync/srl_nokia-sync-ptp.yang
	- work/srlinux-yang-models/srl_nokia/models/sync/srl_nokia-sync-types.yang
	- work/srlinux-yang-models/srl_nokia/models/sync/srl_nokia-sync.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-aaa-password.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-aaa-radius.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-aaa-tacacs.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-aaa-types.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-aaa.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-app-mgmt.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-boot.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-configuration-role.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-configuration.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-dhcp-server.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-dns.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-event-handler.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-ftp.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-gnmi-server.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-gribi-server.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-json-rpc.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-keychains.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-license.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-lldp-types.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-lldp.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-load-balancing.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-logging.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-maintenance-mode.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-mirroring.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-mpls-label-management.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-mpls-services-evpn-label-management.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-mpls-services-network-instance-label-management.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-mtu.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-ntp.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-openconfig.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-p4rt-server.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-packet-link-qual.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-ra_guard.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-sflow.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-snmp-trace.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-snmp.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-ssh.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system-banner.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system-bridge-table-proxy-arp.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system-bridge-table.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system-info.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system-multicast-mfib-table.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system-multicast.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system-name.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system-network-instance-bgp-evpn-ethernet-segments.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system-network-instance-bgp-vpn.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system-network-instance.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system-protocols.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-timezone.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-tls.yang
	- work/srlinux-yang-models/srl_nokia/models/transport-security/srl_nokia-macsec.yang
	- work/srlinux-yang-models/srl_nokia/models/transport-security/srl_nokia-transport-security.yang
	- work/srlinux-yang-models/srl_nokia/models/tunnel/srl_nokia-tunnel-interfaces-vxlan-interface-bridge-table-multicast-destinations.yang
	- work/srlinux-yang-models/srl_nokia/models/tunnel/srl_nokia-tunnel-interfaces-vxlan-interface-bridge-table-unicast-destinations.yang
	- work/srlinux-yang-models/srl_nokia/models/tunnel/srl_nokia-tunnel-interfaces-vxlan-interface-bridge-table-unicast-es-destination-vteps.yang
	- work/srlinux-yang-models/srl_nokia/models/tunnel/srl_nokia-tunnel-interfaces-vxlan-interface-bridge-table.yang
	- work/srlinux-yang-models/srl_nokia/models/tunnel/srl_nokia-tunnel-interfaces.yang
	- work/srlinux-yang-models/srl_nokia/models/tunnel/srl_nokia-tunnel.yang
	- work/srlinux-yang-models/srl_nokia/models/tunnel/srl_nokia-vxlan-tunnel-vtep.yang
Imported modules were sourced from:
	- work/srlinux-yang-models/...
*/
package ygotsrl

import (
	"fmt"
	"reflect"

	"github.com/openconfig/ygot/ygot"
	"github.com/openconfig/ygot/ytypes"
)

// SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action represents the /srl_nokia-acl/acl/system-filter/ipv6-filter/entry/action YANG schema element.
type SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action struct {
	Accept *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action_Accept `path:"accept" module:"srl_nokia-acl" yangPresence:"true"`
	Drop   *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action_Drop   `path:"drop" module:"srl_nokia-acl" yangPresence:"true"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action) IsYANGGoStruct() {}

// GetOrCreateAccept retrieves the value of the Accept field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action) GetOrCreateAccept() *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action_Accept {
	if t.Accept != nil {
		return t.Accept
	}
	t.Accept = &SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action_Accept{}
	return t.Accept
}

// GetOrCreateDrop retrieves the value of the Drop field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action) GetOrCreateDrop() *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action_Drop {
	if t.Drop != nil {
		return t.Drop
	}
	t.Drop = &SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action_Drop{}
	return t.Drop
}

// GetAccept returns the value of the Accept struct pointer
// from SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action. If the receiver or the field Accept is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action) GetAccept() *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action_Accept {
	if t != nil && t.Accept != nil {
		return t.Accept
	}
	return nil
}

// GetDrop returns the value of the Drop struct pointer
// from SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action. If the receiver or the field Drop is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action) GetDrop() *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action_Drop {
	if t != nil && t.Drop != nil {
		return t.Drop
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Accept.PopulateDefaults()
	t.Drop.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action.
func (*SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action_Accept represents the /srl_nokia-acl/acl/system-filter/ipv6-filter/entry/action/accept YANG schema element.
type SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action_Accept struct{}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action_Accept implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action_Accept) IsYANGGoStruct() {}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action_Accept
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action_Accept) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action_Accept) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action_Accept"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action_Accept) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action_Accept) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action_Accept.
func (*SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action_Accept) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action_Drop represents the /srl_nokia-acl/acl/system-filter/ipv6-filter/entry/action/drop YANG schema element.
type SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action_Drop struct {
	Log *bool `path:"log" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action_Drop implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action_Drop) IsYANGGoStruct() {}

// GetLog retrieves the value of the leaf Log from the SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action_Drop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Log is set, it can
// safely use t.GetLog() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Log == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action_Drop) GetLog() bool {
	if t == nil || t.Log == nil {
		return false
	}
	return *t.Log
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action_Drop
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action_Drop) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Log == nil {
		var v bool = false
		t.Log = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action_Drop) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action_Drop"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action_Drop) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action_Drop) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action_Drop.
func (*SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action_Drop) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match represents the /srl_nokia-acl/acl/system-filter/ipv6-filter/entry/match YANG schema element.
type SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match struct {
	DestinationIp   *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationIp   `path:"destination-ip" module:"srl_nokia-acl"`
	DestinationPort *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationPort `path:"destination-port" module:"srl_nokia-acl"`
	DscpSet         []SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DscpSet_Union  `path:"dscp-set" module:"srl_nokia-acl"`
	Icmp6           *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_Icmp6           `path:"icmp6" module:"srl_nokia-acl"`
	NextHeader      SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_NextHeader_Union `path:"next-header" module:"srl_nokia-acl"`
	SourceIp        *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourceIp        `path:"source-ip" module:"srl_nokia-acl"`
	SourcePort      *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourcePort      `path:"source-port" module:"srl_nokia-acl"`
	TcpFlags        *string                                                              `path:"tcp-flags" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match) IsYANGGoStruct() {}

// GetOrCreateDestinationIp retrieves the value of the DestinationIp field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match) GetOrCreateDestinationIp() *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationIp {
	if t.DestinationIp != nil {
		return t.DestinationIp
	}
	t.DestinationIp = &SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationIp{}
	return t.DestinationIp
}

// GetOrCreateDestinationPort retrieves the value of the DestinationPort field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match) GetOrCreateDestinationPort() *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationPort {
	if t.DestinationPort != nil {
		return t.DestinationPort
	}
	t.DestinationPort = &SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationPort{}
	return t.DestinationPort
}

// GetOrCreateIcmp6 retrieves the value of the Icmp6 field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match) GetOrCreateIcmp6() *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_Icmp6 {
	if t.Icmp6 != nil {
		return t.Icmp6
	}
	t.Icmp6 = &SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_Icmp6{}
	return t.Icmp6
}

// GetOrCreateSourceIp retrieves the value of the SourceIp field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match) GetOrCreateSourceIp() *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourceIp {
	if t.SourceIp != nil {
		return t.SourceIp
	}
	t.SourceIp = &SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourceIp{}
	return t.SourceIp
}

// GetOrCreateSourcePort retrieves the value of the SourcePort field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match) GetOrCreateSourcePort() *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourcePort {
	if t.SourcePort != nil {
		return t.SourcePort
	}
	t.SourcePort = &SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourcePort{}
	return t.SourcePort
}

// GetDestinationIp returns the value of the DestinationIp struct pointer
// from SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match. If the receiver or the field DestinationIp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match) GetDestinationIp() *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationIp {
	if t != nil && t.DestinationIp != nil {
		return t.DestinationIp
	}
	return nil
}

// GetDestinationPort returns the value of the DestinationPort struct pointer
// from SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match. If the receiver or the field DestinationPort is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match) GetDestinationPort() *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationPort {
	if t != nil && t.DestinationPort != nil {
		return t.DestinationPort
	}
	return nil
}

// GetIcmp6 returns the value of the Icmp6 struct pointer
// from SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match. If the receiver or the field Icmp6 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match) GetIcmp6() *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_Icmp6 {
	if t != nil && t.Icmp6 != nil {
		return t.Icmp6
	}
	return nil
}

// GetSourceIp returns the value of the SourceIp struct pointer
// from SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match. If the receiver or the field SourceIp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match) GetSourceIp() *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourceIp {
	if t != nil && t.SourceIp != nil {
		return t.SourceIp
	}
	return nil
}

// GetSourcePort returns the value of the SourcePort struct pointer
// from SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match. If the receiver or the field SourcePort is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match) GetSourcePort() *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourcePort {
	if t != nil && t.SourcePort != nil {
		return t.SourcePort
	}
	return nil
}

// GetDscpSet retrieves the value of the leaf DscpSet from the SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DscpSet is set, it can
// safely use t.GetDscpSet() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DscpSet == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match) GetDscpSet() []SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DscpSet_Union {
	if t == nil || t.DscpSet == nil {
		return nil
	}
	return t.DscpSet
}

// GetNextHeader retrieves the value of the leaf NextHeader from the SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NextHeader is set, it can
// safely use t.GetNextHeader() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NextHeader == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match) GetNextHeader() SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_NextHeader_Union {
	if t == nil || t.NextHeader == nil {
		return nil
	}
	return t.NextHeader
}

// GetTcpFlags retrieves the value of the leaf TcpFlags from the SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TcpFlags is set, it can
// safely use t.GetTcpFlags() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TcpFlags == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match) GetTcpFlags() string {
	if t == nil || t.TcpFlags == nil {
		return ""
	}
	return *t.TcpFlags
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.DestinationIp.PopulateDefaults()
	t.DestinationPort.PopulateDefaults()
	t.Icmp6.PopulateDefaults()
	t.SourceIp.PopulateDefaults()
	t.SourcePort.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match.
func (*SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationIp represents the /srl_nokia-acl/acl/system-filter/ipv6-filter/entry/match/destination-ip YANG schema element.
type SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationIp struct {
	Address *string `path:"address" module:"srl_nokia-acl"`
	Mask    *string `path:"mask" module:"srl_nokia-acl"`
	Prefix  *string `path:"prefix" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationIp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationIp) IsYANGGoStruct() {}

// GetAddress retrieves the value of the leaf Address from the SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Address is set, it can
// safely use t.GetAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Address == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationIp) GetAddress() string {
	if t == nil || t.Address == nil {
		return ""
	}
	return *t.Address
}

// GetMask retrieves the value of the leaf Mask from the SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Mask is set, it can
// safely use t.GetMask() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Mask == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationIp) GetMask() string {
	if t == nil || t.Mask == nil {
		return ""
	}
	return *t.Mask
}

// GetPrefix retrieves the value of the leaf Prefix from the SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Prefix is set, it can
// safely use t.GetPrefix() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Prefix == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationIp) GetPrefix() string {
	if t == nil || t.Prefix == nil {
		return ""
	}
	return *t.Prefix
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationIp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationIp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationIp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationIp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationIp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationIp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationIp.
func (*SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationIp) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationPort represents the /srl_nokia-acl/acl/system-filter/ipv6-filter/entry/match/destination-port YANG schema element.
type SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationPort struct {
	Operator E_SrlNokiaPacketMatchTypes_Operator                                             `path:"operator" module:"srl_nokia-acl"`
	Range    *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationPort_Range      `path:"range" module:"srl_nokia-acl"`
	Value    SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationPort_Value_Union `path:"value" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationPort implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationPort) IsYANGGoStruct() {}

// GetOrCreateRange retrieves the value of the Range field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationPort) GetOrCreateRange() *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationPort_Range {
	if t.Range != nil {
		return t.Range
	}
	t.Range = &SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationPort_Range{}
	return t.Range
}

// GetRange returns the value of the Range struct pointer
// from SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationPort. If the receiver or the field Range is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationPort) GetRange() *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationPort_Range {
	if t != nil && t.Range != nil {
		return t.Range
	}
	return nil
}

// GetOperator retrieves the value of the leaf Operator from the SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationPort
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Operator is set, it can
// safely use t.GetOperator() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Operator == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationPort) GetOperator() E_SrlNokiaPacketMatchTypes_Operator {
	if t == nil || t.Operator == 0 {
		return 0
	}
	return t.Operator
}

// GetValue retrieves the value of the leaf Value from the SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationPort
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Value is set, it can
// safely use t.GetValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Value == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationPort) GetValue() SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationPort_Value_Union {
	if t == nil || t.Value == nil {
		return nil
	}
	return t.Value
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationPort
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationPort) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Range.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationPort) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationPort"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationPort) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationPort) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationPort.
func (*SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationPort) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationPort_Range represents the /srl_nokia-acl/acl/system-filter/ipv6-filter/entry/match/destination-port/range YANG schema element.
type SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationPort_Range struct {
	End   SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationPort_Range_End_Union   `path:"end" module:"srl_nokia-acl"`
	Start SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationPort_Range_Start_Union `path:"start" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationPort_Range implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationPort_Range) IsYANGGoStruct() {}

// GetEnd retrieves the value of the leaf End from the SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationPort_Range
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if End is set, it can
// safely use t.GetEnd() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.End == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationPort_Range) GetEnd() SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationPort_Range_End_Union {
	if t == nil || t.End == nil {
		return nil
	}
	return t.End
}

// GetStart retrieves the value of the leaf Start from the SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationPort_Range
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Start is set, it can
// safely use t.GetStart() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Start == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationPort_Range) GetStart() SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationPort_Range_Start_Union {
	if t == nil || t.Start == nil {
		return nil
	}
	return t.Start
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationPort_Range
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationPort_Range) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationPort_Range) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationPort_Range"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationPort_Range) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationPort_Range) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationPort_Range.
func (*SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationPort_Range) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_Icmp6 represents the /srl_nokia-acl/acl/system-filter/ipv6-filter/entry/match/icmp6 YANG schema element.
type SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_Icmp6 struct {
	Code []uint8                                                              `path:"code" module:"srl_nokia-acl"`
	Type SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_Icmp6_Type_Union `path:"type" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_Icmp6 implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_Icmp6) IsYANGGoStruct() {}

// GetCode retrieves the value of the leaf Code from the SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_Icmp6
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Code is set, it can
// safely use t.GetCode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Code == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_Icmp6) GetCode() []uint8 {
	if t == nil || t.Code == nil {
		return nil
	}
	return t.Code
}

// GetType retrieves the value of the leaf Type from the SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_Icmp6
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Type is set, it can
// safely use t.GetType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Type == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_Icmp6) GetType() SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_Icmp6_Type_Union {
	if t == nil || t.Type == nil {
		return nil
	}
	return t.Type
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_Icmp6
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_Icmp6) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_Icmp6) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_Icmp6"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_Icmp6) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_Icmp6) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_Icmp6.
func (*SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_Icmp6) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourceIp represents the /srl_nokia-acl/acl/system-filter/ipv6-filter/entry/match/source-ip YANG schema element.
type SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourceIp struct {
	Address *string `path:"address" module:"srl_nokia-acl"`
	Mask    *string `path:"mask" module:"srl_nokia-acl"`
	Prefix  *string `path:"prefix" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourceIp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourceIp) IsYANGGoStruct() {}

// GetAddress retrieves the value of the leaf Address from the SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourceIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Address is set, it can
// safely use t.GetAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Address == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourceIp) GetAddress() string {
	if t == nil || t.Address == nil {
		return ""
	}
	return *t.Address
}

// GetMask retrieves the value of the leaf Mask from the SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourceIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Mask is set, it can
// safely use t.GetMask() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Mask == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourceIp) GetMask() string {
	if t == nil || t.Mask == nil {
		return ""
	}
	return *t.Mask
}

// GetPrefix retrieves the value of the leaf Prefix from the SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourceIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Prefix is set, it can
// safely use t.GetPrefix() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Prefix == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourceIp) GetPrefix() string {
	if t == nil || t.Prefix == nil {
		return ""
	}
	return *t.Prefix
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourceIp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourceIp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourceIp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourceIp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourceIp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourceIp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourceIp.
func (*SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourceIp) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourcePort represents the /srl_nokia-acl/acl/system-filter/ipv6-filter/entry/match/source-port YANG schema element.
type SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourcePort struct {
	Operator E_SrlNokiaPacketMatchTypes_Operator                                        `path:"operator" module:"srl_nokia-acl"`
	Range    *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourcePort_Range      `path:"range" module:"srl_nokia-acl"`
	Value    SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourcePort_Value_Union `path:"value" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourcePort implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourcePort) IsYANGGoStruct() {}

// GetOrCreateRange retrieves the value of the Range field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourcePort) GetOrCreateRange() *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourcePort_Range {
	if t.Range != nil {
		return t.Range
	}
	t.Range = &SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourcePort_Range{}
	return t.Range
}

// GetRange returns the value of the Range struct pointer
// from SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourcePort. If the receiver or the field Range is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourcePort) GetRange() *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourcePort_Range {
	if t != nil && t.Range != nil {
		return t.Range
	}
	return nil
}

// GetOperator retrieves the value of the leaf Operator from the SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourcePort
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Operator is set, it can
// safely use t.GetOperator() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Operator == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourcePort) GetOperator() E_SrlNokiaPacketMatchTypes_Operator {
	if t == nil || t.Operator == 0 {
		return 0
	}
	return t.Operator
}

// GetValue retrieves the value of the leaf Value from the SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourcePort
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Value is set, it can
// safely use t.GetValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Value == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourcePort) GetValue() SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourcePort_Value_Union {
	if t == nil || t.Value == nil {
		return nil
	}
	return t.Value
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourcePort
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourcePort) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Range.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourcePort) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourcePort"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourcePort) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourcePort) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourcePort.
func (*SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourcePort) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourcePort_Range represents the /srl_nokia-acl/acl/system-filter/ipv6-filter/entry/match/source-port/range YANG schema element.
type SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourcePort_Range struct {
	End   SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourcePort_Range_End_Union   `path:"end" module:"srl_nokia-acl"`
	Start SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourcePort_Range_Start_Union `path:"start" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourcePort_Range implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourcePort_Range) IsYANGGoStruct() {}

// GetEnd retrieves the value of the leaf End from the SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourcePort_Range
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if End is set, it can
// safely use t.GetEnd() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.End == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourcePort_Range) GetEnd() SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourcePort_Range_End_Union {
	if t == nil || t.End == nil {
		return nil
	}
	return t.End
}

// GetStart retrieves the value of the leaf Start from the SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourcePort_Range
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Start is set, it can
// safely use t.GetStart() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Start == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourcePort_Range) GetStart() SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourcePort_Range_Start_Union {
	if t == nil || t.Start == nil {
		return nil
	}
	return t.Start
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourcePort_Range
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourcePort_Range) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourcePort_Range) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourcePort_Range"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourcePort_Range) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourcePort_Range) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourcePort_Range.
func (*SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourcePort_Range) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaBfd_Bfd represents the /srl_nokia-bfd/bfd YANG schema element.
type SrlNokiaBfd_Bfd struct {
	MicroBfdSessions *SrlNokiaBfd_Bfd_MicroBfdSessions        `path:"micro-bfd-sessions" module:"srl_nokia-micro-bfd"`
	Subinterface     map[string]*SrlNokiaBfd_Bfd_Subinterface `path:"subinterface" module:"srl_nokia-bfd"`
}

// IsYANGGoStruct ensures that SrlNokiaBfd_Bfd implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaBfd_Bfd) IsYANGGoStruct() {}

// NewSubinterface creates a new entry in the Subinterface list of the
// SrlNokiaBfd_Bfd struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaBfd_Bfd) NewSubinterface(Id string) (*SrlNokiaBfd_Bfd_Subinterface, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Subinterface == nil {
		t.Subinterface = make(map[string]*SrlNokiaBfd_Bfd_Subinterface)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Subinterface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Subinterface", key)
	}

	t.Subinterface[key] = &SrlNokiaBfd_Bfd_Subinterface{
		Id: &Id,
	}

	return t.Subinterface[key], nil
}

// RenameSubinterface renames an entry in the list Subinterface within
// the SrlNokiaBfd_Bfd struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaBfd_Bfd) RenameSubinterface(oldK, newK string) error {
	if _, ok := t.Subinterface[newK]; ok {
		return fmt.Errorf("key %v already exists in Subinterface", newK)
	}

	e, ok := t.Subinterface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Subinterface", oldK)
	}
	e.Id = &newK

	t.Subinterface[newK] = e
	delete(t.Subinterface, oldK)
	return nil
}

// GetOrCreateSubinterface retrieves the value with the specified keys from
// the receiver SrlNokiaBfd_Bfd. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaBfd_Bfd) GetOrCreateSubinterface(Id string) *SrlNokiaBfd_Bfd_Subinterface {
	key := Id

	if v, ok := t.Subinterface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewSubinterface(Id)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateSubinterface got unexpected error: %v", err))
	}
	return v
}

// GetSubinterface retrieves the value with the specified key from
// the Subinterface map field of SrlNokiaBfd_Bfd. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaBfd_Bfd) GetSubinterface(Id string) *SrlNokiaBfd_Bfd_Subinterface {
	if t == nil {
		return nil
	}

	key := Id

	if lm, ok := t.Subinterface[key]; ok {
		return lm
	}
	return nil
}

// DeleteSubinterface deletes the value with the specified keys from
// the receiver SrlNokiaBfd_Bfd. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaBfd_Bfd) DeleteSubinterface(Id string) {
	key := Id

	delete(t.Subinterface, key)
}

// AppendSubinterface appends the supplied SrlNokiaBfd_Bfd_Subinterface struct to the
// list Subinterface of SrlNokiaBfd_Bfd. If the key value(s) specified in
// the supplied SrlNokiaBfd_Bfd_Subinterface already exist in the list, an error is
// returned.
func (t *SrlNokiaBfd_Bfd) AppendSubinterface(v *SrlNokiaBfd_Bfd_Subinterface) error {
	if v.Id == nil {
		return fmt.Errorf("invalid nil key received for Id")
	}

	key := *v.Id

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Subinterface == nil {
		t.Subinterface = make(map[string]*SrlNokiaBfd_Bfd_Subinterface)
	}

	if _, ok := t.Subinterface[key]; ok {
		return fmt.Errorf("duplicate key for list Subinterface %v", key)
	}

	t.Subinterface[key] = v
	return nil
}

// GetOrCreateMicroBfdSessions retrieves the value of the MicroBfdSessions field
// or returns the existing field if it already exists.
func (t *SrlNokiaBfd_Bfd) GetOrCreateMicroBfdSessions() *SrlNokiaBfd_Bfd_MicroBfdSessions {
	if t.MicroBfdSessions != nil {
		return t.MicroBfdSessions
	}
	t.MicroBfdSessions = &SrlNokiaBfd_Bfd_MicroBfdSessions{}
	return t.MicroBfdSessions
}

// GetMicroBfdSessions returns the value of the MicroBfdSessions struct pointer
// from SrlNokiaBfd_Bfd. If the receiver or the field MicroBfdSessions is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaBfd_Bfd) GetMicroBfdSessions() *SrlNokiaBfd_Bfd_MicroBfdSessions {
	if t != nil && t.MicroBfdSessions != nil {
		return t.MicroBfdSessions
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaBfd_Bfd
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaBfd_Bfd) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.MicroBfdSessions.PopulateDefaults()
	for _, e := range t.Subinterface {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaBfd_Bfd) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaBfd_Bfd"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaBfd_Bfd) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaBfd_Bfd) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaBfd_Bfd.
func (*SrlNokiaBfd_Bfd) ΛBelongingModule() string {
	return "srl_nokia-bfd"
}

// SrlNokiaBfd_Bfd_MicroBfdSessions represents the /srl_nokia-bfd/bfd/micro-bfd-sessions YANG schema element.
type SrlNokiaBfd_Bfd_MicroBfdSessions struct {
	LagInterface map[string]*SrlNokiaBfd_Bfd_MicroBfdSessions_LagInterface `path:"lag-interface" module:"srl_nokia-micro-bfd"`
}

// IsYANGGoStruct ensures that SrlNokiaBfd_Bfd_MicroBfdSessions implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaBfd_Bfd_MicroBfdSessions) IsYANGGoStruct() {}

// NewLagInterface creates a new entry in the LagInterface list of the
// SrlNokiaBfd_Bfd_MicroBfdSessions struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaBfd_Bfd_MicroBfdSessions) NewLagInterface(Name string) (*SrlNokiaBfd_Bfd_MicroBfdSessions_LagInterface, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.LagInterface == nil {
		t.LagInterface = make(map[string]*SrlNokiaBfd_Bfd_MicroBfdSessions_LagInterface)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.LagInterface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list LagInterface", key)
	}

	t.LagInterface[key] = &SrlNokiaBfd_Bfd_MicroBfdSessions_LagInterface{
		Name: &Name,
	}

	return t.LagInterface[key], nil
}

// RenameLagInterface renames an entry in the list LagInterface within
// the SrlNokiaBfd_Bfd_MicroBfdSessions struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaBfd_Bfd_MicroBfdSessions) RenameLagInterface(oldK, newK string) error {
	if _, ok := t.LagInterface[newK]; ok {
		return fmt.Errorf("key %v already exists in LagInterface", newK)
	}

	e, ok := t.LagInterface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in LagInterface", oldK)
	}
	e.Name = &newK

	t.LagInterface[newK] = e
	delete(t.LagInterface, oldK)
	return nil
}

// GetOrCreateLagInterface retrieves the value with the specified keys from
// the receiver SrlNokiaBfd_Bfd_MicroBfdSessions. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaBfd_Bfd_MicroBfdSessions) GetOrCreateLagInterface(Name string) *SrlNokiaBfd_Bfd_MicroBfdSessions_LagInterface {
	key := Name

	if v, ok := t.LagInterface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewLagInterface(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateLagInterface got unexpected error: %v", err))
	}
	return v
}

// GetLagInterface retrieves the value with the specified key from
// the LagInterface map field of SrlNokiaBfd_Bfd_MicroBfdSessions. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaBfd_Bfd_MicroBfdSessions) GetLagInterface(Name string) *SrlNokiaBfd_Bfd_MicroBfdSessions_LagInterface {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.LagInterface[key]; ok {
		return lm
	}
	return nil
}

// DeleteLagInterface deletes the value with the specified keys from
// the receiver SrlNokiaBfd_Bfd_MicroBfdSessions. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaBfd_Bfd_MicroBfdSessions) DeleteLagInterface(Name string) {
	key := Name

	delete(t.LagInterface, key)
}

// AppendLagInterface appends the supplied SrlNokiaBfd_Bfd_MicroBfdSessions_LagInterface struct to the
// list LagInterface of SrlNokiaBfd_Bfd_MicroBfdSessions. If the key value(s) specified in
// the supplied SrlNokiaBfd_Bfd_MicroBfdSessions_LagInterface already exist in the list, an error is
// returned.
func (t *SrlNokiaBfd_Bfd_MicroBfdSessions) AppendLagInterface(v *SrlNokiaBfd_Bfd_MicroBfdSessions_LagInterface) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.LagInterface == nil {
		t.LagInterface = make(map[string]*SrlNokiaBfd_Bfd_MicroBfdSessions_LagInterface)
	}

	if _, ok := t.LagInterface[key]; ok {
		return fmt.Errorf("duplicate key for list LagInterface %v", key)
	}

	t.LagInterface[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaBfd_Bfd_MicroBfdSessions
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaBfd_Bfd_MicroBfdSessions) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.LagInterface {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaBfd_Bfd_MicroBfdSessions) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaBfd_Bfd_MicroBfdSessions"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaBfd_Bfd_MicroBfdSessions) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaBfd_Bfd_MicroBfdSessions) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaBfd_Bfd_MicroBfdSessions.
func (*SrlNokiaBfd_Bfd_MicroBfdSessions) ΛBelongingModule() string {
	return "srl_nokia-micro-bfd"
}

// SrlNokiaBfd_Bfd_MicroBfdSessions_LagInterface represents the /srl_nokia-bfd/bfd/micro-bfd-sessions/lag-interface YANG schema element.
type SrlNokiaBfd_Bfd_MicroBfdSessions_LagInterface struct {
	AdminState                     E_SrlNokiaCommon_AdminState `path:"admin-state" module:"srl_nokia-micro-bfd"`
	DesiredMinimumTransmitInterval *uint32                     `path:"desired-minimum-transmit-interval" module:"srl_nokia-micro-bfd"`
	DetectionMultiplier            *uint8                      `path:"detection-multiplier" module:"srl_nokia-micro-bfd"`
	LocalAddress                   *string                     `path:"local-address" module:"srl_nokia-micro-bfd"`
	Name                           *string                     `path:"name" module:"srl_nokia-micro-bfd"`
	RemoteAddress                  *string                     `path:"remote-address" module:"srl_nokia-micro-bfd"`
	RequiredMinimumReceive         *uint32                     `path:"required-minimum-receive" module:"srl_nokia-micro-bfd"`
}

// IsYANGGoStruct ensures that SrlNokiaBfd_Bfd_MicroBfdSessions_LagInterface implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaBfd_Bfd_MicroBfdSessions_LagInterface) IsYANGGoStruct() {}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaBfd_Bfd_MicroBfdSessions_LagInterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaBfd_Bfd_MicroBfdSessions_LagInterface) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_disable
	}
	return t.AdminState
}

// GetDesiredMinimumTransmitInterval retrieves the value of the leaf DesiredMinimumTransmitInterval from the SrlNokiaBfd_Bfd_MicroBfdSessions_LagInterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DesiredMinimumTransmitInterval is set, it can
// safely use t.GetDesiredMinimumTransmitInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DesiredMinimumTransmitInterval == nil' before retrieving the leaf's value.
func (t *SrlNokiaBfd_Bfd_MicroBfdSessions_LagInterface) GetDesiredMinimumTransmitInterval() uint32 {
	if t == nil || t.DesiredMinimumTransmitInterval == nil {
		return 1000000
	}
	return *t.DesiredMinimumTransmitInterval
}

// GetDetectionMultiplier retrieves the value of the leaf DetectionMultiplier from the SrlNokiaBfd_Bfd_MicroBfdSessions_LagInterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DetectionMultiplier is set, it can
// safely use t.GetDetectionMultiplier() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DetectionMultiplier == nil' before retrieving the leaf's value.
func (t *SrlNokiaBfd_Bfd_MicroBfdSessions_LagInterface) GetDetectionMultiplier() uint8 {
	if t == nil || t.DetectionMultiplier == nil {
		return 3
	}
	return *t.DetectionMultiplier
}

// GetLocalAddress retrieves the value of the leaf LocalAddress from the SrlNokiaBfd_Bfd_MicroBfdSessions_LagInterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LocalAddress is set, it can
// safely use t.GetLocalAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LocalAddress == nil' before retrieving the leaf's value.
func (t *SrlNokiaBfd_Bfd_MicroBfdSessions_LagInterface) GetLocalAddress() string {
	if t == nil || t.LocalAddress == nil {
		return ""
	}
	return *t.LocalAddress
}

// GetName retrieves the value of the leaf Name from the SrlNokiaBfd_Bfd_MicroBfdSessions_LagInterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaBfd_Bfd_MicroBfdSessions_LagInterface) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetRemoteAddress retrieves the value of the leaf RemoteAddress from the SrlNokiaBfd_Bfd_MicroBfdSessions_LagInterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RemoteAddress is set, it can
// safely use t.GetRemoteAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RemoteAddress == nil' before retrieving the leaf's value.
func (t *SrlNokiaBfd_Bfd_MicroBfdSessions_LagInterface) GetRemoteAddress() string {
	if t == nil || t.RemoteAddress == nil {
		return ""
	}
	return *t.RemoteAddress
}

// GetRequiredMinimumReceive retrieves the value of the leaf RequiredMinimumReceive from the SrlNokiaBfd_Bfd_MicroBfdSessions_LagInterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RequiredMinimumReceive is set, it can
// safely use t.GetRequiredMinimumReceive() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RequiredMinimumReceive == nil' before retrieving the leaf's value.
func (t *SrlNokiaBfd_Bfd_MicroBfdSessions_LagInterface) GetRequiredMinimumReceive() uint32 {
	if t == nil || t.RequiredMinimumReceive == nil {
		return 1000000
	}
	return *t.RequiredMinimumReceive
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaBfd_Bfd_MicroBfdSessions_LagInterface
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaBfd_Bfd_MicroBfdSessions_LagInterface) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_disable
	}
	if t.DesiredMinimumTransmitInterval == nil {
		var v uint32 = 1000000
		t.DesiredMinimumTransmitInterval = &v
	}
	if t.DetectionMultiplier == nil {
		var v uint8 = 3
		t.DetectionMultiplier = &v
	}
	if t.RequiredMinimumReceive == nil {
		var v uint32 = 1000000
		t.RequiredMinimumReceive = &v
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaBfd_Bfd_MicroBfdSessions_LagInterface struct, which is a YANG list entry.
func (t *SrlNokiaBfd_Bfd_MicroBfdSessions_LagInterface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaBfd_Bfd_MicroBfdSessions_LagInterface) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaBfd_Bfd_MicroBfdSessions_LagInterface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaBfd_Bfd_MicroBfdSessions_LagInterface) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaBfd_Bfd_MicroBfdSessions_LagInterface) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaBfd_Bfd_MicroBfdSessions_LagInterface.
func (*SrlNokiaBfd_Bfd_MicroBfdSessions_LagInterface) ΛBelongingModule() string {
	return "srl_nokia-micro-bfd"
}

// SrlNokiaBfd_Bfd_Subinterface represents the /srl_nokia-bfd/bfd/subinterface YANG schema element.
type SrlNokiaBfd_Bfd_Subinterface struct {
	AdminState                     E_SrlNokiaCommon_AdminState `path:"admin-state" module:"srl_nokia-bfd"`
	DesiredMinimumTransmitInterval *uint32                     `path:"desired-minimum-transmit-interval" module:"srl_nokia-bfd"`
	DetectionMultiplier            *uint8                      `path:"detection-multiplier" module:"srl_nokia-bfd"`
	Id                             *string                     `path:"id" module:"srl_nokia-bfd"`
	MaxHopCount                    *uint8                      `path:"max-hop-count" module:"srl_nokia-bfd"`
	MinimumEchoReceiveInterval     *uint32                     `path:"minimum-echo-receive-interval" module:"srl_nokia-bfd"`
	RequiredMinimumReceive         *uint32                     `path:"required-minimum-receive" module:"srl_nokia-bfd"`
}

// IsYANGGoStruct ensures that SrlNokiaBfd_Bfd_Subinterface implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaBfd_Bfd_Subinterface) IsYANGGoStruct() {}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaBfd_Bfd_Subinterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaBfd_Bfd_Subinterface) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_disable
	}
	return t.AdminState
}

// GetDesiredMinimumTransmitInterval retrieves the value of the leaf DesiredMinimumTransmitInterval from the SrlNokiaBfd_Bfd_Subinterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DesiredMinimumTransmitInterval is set, it can
// safely use t.GetDesiredMinimumTransmitInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DesiredMinimumTransmitInterval == nil' before retrieving the leaf's value.
func (t *SrlNokiaBfd_Bfd_Subinterface) GetDesiredMinimumTransmitInterval() uint32 {
	if t == nil || t.DesiredMinimumTransmitInterval == nil {
		return 1000000
	}
	return *t.DesiredMinimumTransmitInterval
}

// GetDetectionMultiplier retrieves the value of the leaf DetectionMultiplier from the SrlNokiaBfd_Bfd_Subinterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DetectionMultiplier is set, it can
// safely use t.GetDetectionMultiplier() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DetectionMultiplier == nil' before retrieving the leaf's value.
func (t *SrlNokiaBfd_Bfd_Subinterface) GetDetectionMultiplier() uint8 {
	if t == nil || t.DetectionMultiplier == nil {
		return 3
	}
	return *t.DetectionMultiplier
}

// GetId retrieves the value of the leaf Id from the SrlNokiaBfd_Bfd_Subinterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Id is set, it can
// safely use t.GetId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Id == nil' before retrieving the leaf's value.
func (t *SrlNokiaBfd_Bfd_Subinterface) GetId() string {
	if t == nil || t.Id == nil {
		return ""
	}
	return *t.Id
}

// GetMaxHopCount retrieves the value of the leaf MaxHopCount from the SrlNokiaBfd_Bfd_Subinterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MaxHopCount is set, it can
// safely use t.GetMaxHopCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MaxHopCount == nil' before retrieving the leaf's value.
func (t *SrlNokiaBfd_Bfd_Subinterface) GetMaxHopCount() uint8 {
	if t == nil || t.MaxHopCount == nil {
		return 255
	}
	return *t.MaxHopCount
}

// GetMinimumEchoReceiveInterval retrieves the value of the leaf MinimumEchoReceiveInterval from the SrlNokiaBfd_Bfd_Subinterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MinimumEchoReceiveInterval is set, it can
// safely use t.GetMinimumEchoReceiveInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MinimumEchoReceiveInterval == nil' before retrieving the leaf's value.
func (t *SrlNokiaBfd_Bfd_Subinterface) GetMinimumEchoReceiveInterval() uint32 {
	if t == nil || t.MinimumEchoReceiveInterval == nil {
		return 0
	}
	return *t.MinimumEchoReceiveInterval
}

// GetRequiredMinimumReceive retrieves the value of the leaf RequiredMinimumReceive from the SrlNokiaBfd_Bfd_Subinterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RequiredMinimumReceive is set, it can
// safely use t.GetRequiredMinimumReceive() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RequiredMinimumReceive == nil' before retrieving the leaf's value.
func (t *SrlNokiaBfd_Bfd_Subinterface) GetRequiredMinimumReceive() uint32 {
	if t == nil || t.RequiredMinimumReceive == nil {
		return 1000000
	}
	return *t.RequiredMinimumReceive
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaBfd_Bfd_Subinterface
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaBfd_Bfd_Subinterface) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_disable
	}
	if t.DesiredMinimumTransmitInterval == nil {
		var v uint32 = 1000000
		t.DesiredMinimumTransmitInterval = &v
	}
	if t.DetectionMultiplier == nil {
		var v uint8 = 3
		t.DetectionMultiplier = &v
	}
	if t.MaxHopCount == nil {
		var v uint8 = 255
		t.MaxHopCount = &v
	}
	if t.MinimumEchoReceiveInterval == nil {
		var v uint32 = 0
		t.MinimumEchoReceiveInterval = &v
	}
	if t.RequiredMinimumReceive == nil {
		var v uint32 = 1000000
		t.RequiredMinimumReceive = &v
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaBfd_Bfd_Subinterface struct, which is a YANG list entry.
func (t *SrlNokiaBfd_Bfd_Subinterface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Id == nil {
		return nil, fmt.Errorf("nil value for key Id")
	}

	return map[string]interface{}{
		"id": *t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaBfd_Bfd_Subinterface) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaBfd_Bfd_Subinterface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaBfd_Bfd_Subinterface) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaBfd_Bfd_Subinterface) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaBfd_Bfd_Subinterface.
func (*SrlNokiaBfd_Bfd_Subinterface) ΛBelongingModule() string {
	return "srl_nokia-bfd"
}

// SrlNokiaInterfaces_Interface represents the /srl_nokia-interfaces/interface YANG schema element.
type SrlNokiaInterfaces_Interface struct {
	AdminState   E_SrlNokiaCommon_AdminState                           `path:"admin-state" module:"srl_nokia-interfaces"`
	BreakoutMode *SrlNokiaInterfaces_Interface_BreakoutMode            `path:"breakout-mode" module:"srl_nokia-interfaces" yangPresence:"true"`
	Description  *string                                               `path:"description" module:"srl_nokia-interfaces"`
	Ethernet     *SrlNokiaInterfaces_Interface_Ethernet                `path:"ethernet" module:"srl_nokia-interfaces"`
	Lag          *SrlNokiaInterfaces_Interface_Lag                     `path:"lag" module:"srl_nokia-interfaces-lag" yangPresence:"true"`
	Linux        *SrlNokiaInterfaces_Interface_Linux                   `path:"linux" module:"srl_nokia-interfaces-vxdp"`
	LoopbackMode E_SrlNokiaInterfaces_LoopbackModeType                 `path:"loopback-mode" module:"srl_nokia-interfaces"`
	Mtu          *uint16                                               `path:"mtu" module:"srl_nokia-interfaces"`
	Name         *string                                               `path:"name" module:"srl_nokia-interfaces"`
	P4Rt         *SrlNokiaInterfaces_Interface_P4Rt                    `path:"p4rt" module:"srl_nokia-interfaces-p4rt" yangPresence:"true"`
	Qos          *SrlNokiaInterfaces_Interface_Qos                     `path:"qos" module:"srl_nokia-qos" yangPresence:"true"`
	Sflow        *SrlNokiaInterfaces_Interface_Sflow                   `path:"sflow" module:"srl_nokia-interfaces"`
	Subinterface map[uint32]*SrlNokiaInterfaces_Interface_Subinterface `path:"subinterface" module:"srl_nokia-interfaces"`
	Tpid         E_SrlNokiaInterfacesVlans_TPID_TYPES                  `path:"tpid" module:"srl_nokia-interfaces-vlans"`
	Transceiver  *SrlNokiaInterfaces_Interface_Transceiver             `path:"transceiver" module:"srl_nokia-interfaces"`
	Uuid         *string                                               `path:"uuid" module:"srl_nokia-interfaces-vxdp"`
	Vhost        *SrlNokiaInterfaces_Interface_Vhost                   `path:"vhost" module:"srl_nokia-interfaces-vxdp" yangPresence:"true"`
	VlanTagging  *bool                                                 `path:"vlan-tagging" module:"srl_nokia-interfaces-vlans"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface) IsYANGGoStruct() {}

// NewSubinterface creates a new entry in the Subinterface list of the
// SrlNokiaInterfaces_Interface struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaInterfaces_Interface) NewSubinterface(Index uint32) (*SrlNokiaInterfaces_Interface_Subinterface, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Subinterface == nil {
		t.Subinterface = make(map[uint32]*SrlNokiaInterfaces_Interface_Subinterface)
	}

	key := Index

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Subinterface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Subinterface", key)
	}

	t.Subinterface[key] = &SrlNokiaInterfaces_Interface_Subinterface{
		Index: &Index,
	}

	return t.Subinterface[key], nil
}

// RenameSubinterface renames an entry in the list Subinterface within
// the SrlNokiaInterfaces_Interface struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaInterfaces_Interface) RenameSubinterface(oldK, newK uint32) error {
	if _, ok := t.Subinterface[newK]; ok {
		return fmt.Errorf("key %v already exists in Subinterface", newK)
	}

	e, ok := t.Subinterface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Subinterface", oldK)
	}
	e.Index = &newK

	t.Subinterface[newK] = e
	delete(t.Subinterface, oldK)
	return nil
}

// GetOrCreateSubinterface retrieves the value with the specified keys from
// the receiver SrlNokiaInterfaces_Interface. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaInterfaces_Interface) GetOrCreateSubinterface(Index uint32) *SrlNokiaInterfaces_Interface_Subinterface {
	key := Index

	if v, ok := t.Subinterface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewSubinterface(Index)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateSubinterface got unexpected error: %v", err))
	}
	return v
}

// GetSubinterface retrieves the value with the specified key from
// the Subinterface map field of SrlNokiaInterfaces_Interface. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaInterfaces_Interface) GetSubinterface(Index uint32) *SrlNokiaInterfaces_Interface_Subinterface {
	if t == nil {
		return nil
	}

	key := Index

	if lm, ok := t.Subinterface[key]; ok {
		return lm
	}
	return nil
}

// DeleteSubinterface deletes the value with the specified keys from
// the receiver SrlNokiaInterfaces_Interface. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaInterfaces_Interface) DeleteSubinterface(Index uint32) {
	key := Index

	delete(t.Subinterface, key)
}

// AppendSubinterface appends the supplied SrlNokiaInterfaces_Interface_Subinterface struct to the
// list Subinterface of SrlNokiaInterfaces_Interface. If the key value(s) specified in
// the supplied SrlNokiaInterfaces_Interface_Subinterface already exist in the list, an error is
// returned.
func (t *SrlNokiaInterfaces_Interface) AppendSubinterface(v *SrlNokiaInterfaces_Interface_Subinterface) error {
	if v.Index == nil {
		return fmt.Errorf("invalid nil key received for Index")
	}

	key := *v.Index

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Subinterface == nil {
		t.Subinterface = make(map[uint32]*SrlNokiaInterfaces_Interface_Subinterface)
	}

	if _, ok := t.Subinterface[key]; ok {
		return fmt.Errorf("duplicate key for list Subinterface %v", key)
	}

	t.Subinterface[key] = v
	return nil
}

// GetOrCreateBreakoutMode retrieves the value of the BreakoutMode field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface) GetOrCreateBreakoutMode() *SrlNokiaInterfaces_Interface_BreakoutMode {
	if t.BreakoutMode != nil {
		return t.BreakoutMode
	}
	t.BreakoutMode = &SrlNokiaInterfaces_Interface_BreakoutMode{}
	return t.BreakoutMode
}

// GetOrCreateEthernet retrieves the value of the Ethernet field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface) GetOrCreateEthernet() *SrlNokiaInterfaces_Interface_Ethernet {
	if t.Ethernet != nil {
		return t.Ethernet
	}
	t.Ethernet = &SrlNokiaInterfaces_Interface_Ethernet{}
	return t.Ethernet
}

// GetOrCreateLag retrieves the value of the Lag field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface) GetOrCreateLag() *SrlNokiaInterfaces_Interface_Lag {
	if t.Lag != nil {
		return t.Lag
	}
	t.Lag = &SrlNokiaInterfaces_Interface_Lag{}
	return t.Lag
}

// GetOrCreateLinux retrieves the value of the Linux field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface) GetOrCreateLinux() *SrlNokiaInterfaces_Interface_Linux {
	if t.Linux != nil {
		return t.Linux
	}
	t.Linux = &SrlNokiaInterfaces_Interface_Linux{}
	return t.Linux
}

// GetOrCreateP4Rt retrieves the value of the P4Rt field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface) GetOrCreateP4Rt() *SrlNokiaInterfaces_Interface_P4Rt {
	if t.P4Rt != nil {
		return t.P4Rt
	}
	t.P4Rt = &SrlNokiaInterfaces_Interface_P4Rt{}
	return t.P4Rt
}

// GetOrCreateQos retrieves the value of the Qos field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface) GetOrCreateQos() *SrlNokiaInterfaces_Interface_Qos {
	if t.Qos != nil {
		return t.Qos
	}
	t.Qos = &SrlNokiaInterfaces_Interface_Qos{}
	return t.Qos
}

// GetOrCreateSflow retrieves the value of the Sflow field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface) GetOrCreateSflow() *SrlNokiaInterfaces_Interface_Sflow {
	if t.Sflow != nil {
		return t.Sflow
	}
	t.Sflow = &SrlNokiaInterfaces_Interface_Sflow{}
	return t.Sflow
}

// GetOrCreateTransceiver retrieves the value of the Transceiver field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface) GetOrCreateTransceiver() *SrlNokiaInterfaces_Interface_Transceiver {
	if t.Transceiver != nil {
		return t.Transceiver
	}
	t.Transceiver = &SrlNokiaInterfaces_Interface_Transceiver{}
	return t.Transceiver
}

// GetOrCreateVhost retrieves the value of the Vhost field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface) GetOrCreateVhost() *SrlNokiaInterfaces_Interface_Vhost {
	if t.Vhost != nil {
		return t.Vhost
	}
	t.Vhost = &SrlNokiaInterfaces_Interface_Vhost{}
	return t.Vhost
}

// GetBreakoutMode returns the value of the BreakoutMode struct pointer
// from SrlNokiaInterfaces_Interface. If the receiver or the field BreakoutMode is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface) GetBreakoutMode() *SrlNokiaInterfaces_Interface_BreakoutMode {
	if t != nil && t.BreakoutMode != nil {
		return t.BreakoutMode
	}
	return nil
}

// GetEthernet returns the value of the Ethernet struct pointer
// from SrlNokiaInterfaces_Interface. If the receiver or the field Ethernet is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface) GetEthernet() *SrlNokiaInterfaces_Interface_Ethernet {
	if t != nil && t.Ethernet != nil {
		return t.Ethernet
	}
	return nil
}

// GetLag returns the value of the Lag struct pointer
// from SrlNokiaInterfaces_Interface. If the receiver or the field Lag is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface) GetLag() *SrlNokiaInterfaces_Interface_Lag {
	if t != nil && t.Lag != nil {
		return t.Lag
	}
	return nil
}

// GetLinux returns the value of the Linux struct pointer
// from SrlNokiaInterfaces_Interface. If the receiver or the field Linux is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface) GetLinux() *SrlNokiaInterfaces_Interface_Linux {
	if t != nil && t.Linux != nil {
		return t.Linux
	}
	return nil
}

// GetP4Rt returns the value of the P4Rt struct pointer
// from SrlNokiaInterfaces_Interface. If the receiver or the field P4Rt is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface) GetP4Rt() *SrlNokiaInterfaces_Interface_P4Rt {
	if t != nil && t.P4Rt != nil {
		return t.P4Rt
	}
	return nil
}

// GetQos returns the value of the Qos struct pointer
// from SrlNokiaInterfaces_Interface. If the receiver or the field Qos is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface) GetQos() *SrlNokiaInterfaces_Interface_Qos {
	if t != nil && t.Qos != nil {
		return t.Qos
	}
	return nil
}

// GetSflow returns the value of the Sflow struct pointer
// from SrlNokiaInterfaces_Interface. If the receiver or the field Sflow is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface) GetSflow() *SrlNokiaInterfaces_Interface_Sflow {
	if t != nil && t.Sflow != nil {
		return t.Sflow
	}
	return nil
}

// GetTransceiver returns the value of the Transceiver struct pointer
// from SrlNokiaInterfaces_Interface. If the receiver or the field Transceiver is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface) GetTransceiver() *SrlNokiaInterfaces_Interface_Transceiver {
	if t != nil && t.Transceiver != nil {
		return t.Transceiver
	}
	return nil
}

// GetVhost returns the value of the Vhost struct pointer
// from SrlNokiaInterfaces_Interface. If the receiver or the field Vhost is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface) GetVhost() *SrlNokiaInterfaces_Interface_Vhost {
	if t != nil && t.Vhost != nil {
		return t.Vhost
	}
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaInterfaces_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_enable
	}
	return t.AdminState
}

// GetDescription retrieves the value of the leaf Description from the SrlNokiaInterfaces_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetLoopbackMode retrieves the value of the leaf LoopbackMode from the SrlNokiaInterfaces_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LoopbackMode is set, it can
// safely use t.GetLoopbackMode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LoopbackMode == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface) GetLoopbackMode() E_SrlNokiaInterfaces_LoopbackModeType {
	if t == nil || t.LoopbackMode == 0 {
		return 0
	}
	return t.LoopbackMode
}

// GetMtu retrieves the value of the leaf Mtu from the SrlNokiaInterfaces_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Mtu is set, it can
// safely use t.GetMtu() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Mtu == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface) GetMtu() uint16 {
	if t == nil || t.Mtu == nil {
		return 0
	}
	return *t.Mtu
}

// GetName retrieves the value of the leaf Name from the SrlNokiaInterfaces_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetTpid retrieves the value of the leaf Tpid from the SrlNokiaInterfaces_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Tpid is set, it can
// safely use t.GetTpid() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Tpid == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface) GetTpid() E_SrlNokiaInterfacesVlans_TPID_TYPES {
	if t == nil || t.Tpid == 0 {
		return 0
	}
	return t.Tpid
}

// GetUuid retrieves the value of the leaf Uuid from the SrlNokiaInterfaces_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Uuid is set, it can
// safely use t.GetUuid() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Uuid == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface) GetUuid() string {
	if t == nil || t.Uuid == nil {
		return ""
	}
	return *t.Uuid
}

// GetVlanTagging retrieves the value of the leaf VlanTagging from the SrlNokiaInterfaces_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VlanTagging is set, it can
// safely use t.GetVlanTagging() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VlanTagging == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface) GetVlanTagging() bool {
	if t == nil || t.VlanTagging == nil {
		return false
	}
	return *t.VlanTagging
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_enable
	}
	t.BreakoutMode.PopulateDefaults()
	t.Ethernet.PopulateDefaults()
	t.Lag.PopulateDefaults()
	t.Linux.PopulateDefaults()
	t.P4Rt.PopulateDefaults()
	t.Qos.PopulateDefaults()
	t.Sflow.PopulateDefaults()
	t.Transceiver.PopulateDefaults()
	t.Vhost.PopulateDefaults()
	for _, e := range t.Subinterface {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaInterfaces_Interface struct, which is a YANG list entry.
func (t *SrlNokiaInterfaces_Interface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface.
func (*SrlNokiaInterfaces_Interface) ΛBelongingModule() string {
	return "srl_nokia-interfaces"
}

// SrlNokiaInterfaces_Interface_BreakoutMode represents the /srl_nokia-interfaces/interface/breakout-mode YANG schema element.
type SrlNokiaInterfaces_Interface_BreakoutMode struct {
	BreakoutPortSpeed E_SrlNokiaInterfaces_Interface_BreakoutMode_BreakoutPortSpeed `path:"breakout-port-speed" module:"srl_nokia-interfaces"`
	NumBreakoutPorts  E_SrlNokiaInterfaces_Interface_BreakoutMode_NumBreakoutPorts  `path:"num-breakout-ports" module:"srl_nokia-interfaces"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_BreakoutMode implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_BreakoutMode) IsYANGGoStruct() {}

// GetBreakoutPortSpeed retrieves the value of the leaf BreakoutPortSpeed from the SrlNokiaInterfaces_Interface_BreakoutMode
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if BreakoutPortSpeed is set, it can
// safely use t.GetBreakoutPortSpeed() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.BreakoutPortSpeed == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_BreakoutMode) GetBreakoutPortSpeed() E_SrlNokiaInterfaces_Interface_BreakoutMode_BreakoutPortSpeed {
	if t == nil || t.BreakoutPortSpeed == 0 {
		return 0
	}
	return t.BreakoutPortSpeed
}

// GetNumBreakoutPorts retrieves the value of the leaf NumBreakoutPorts from the SrlNokiaInterfaces_Interface_BreakoutMode
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NumBreakoutPorts is set, it can
// safely use t.GetNumBreakoutPorts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NumBreakoutPorts == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_BreakoutMode) GetNumBreakoutPorts() E_SrlNokiaInterfaces_Interface_BreakoutMode_NumBreakoutPorts {
	if t == nil || t.NumBreakoutPorts == 0 {
		return 0
	}
	return t.NumBreakoutPorts
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_BreakoutMode
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_BreakoutMode) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_BreakoutMode) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_BreakoutMode"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_BreakoutMode) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_BreakoutMode) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_BreakoutMode.
func (*SrlNokiaInterfaces_Interface_BreakoutMode) ΛBelongingModule() string {
	return "srl_nokia-interfaces"
}

// SrlNokiaInterfaces_Interface_Ethernet represents the /srl_nokia-interfaces/interface/ethernet YANG schema element.
type SrlNokiaInterfaces_Interface_Ethernet struct {
	AggregateId      *string                                                  `path:"aggregate-id" module:"srl_nokia-interfaces"`
	AutoNegotiate    *bool                                                    `path:"auto-negotiate" module:"srl_nokia-interfaces"`
	DacLinkTraining  *bool                                                    `path:"dac-link-training" module:"srl_nokia-interfaces"`
	DuplexMode       E_SrlNokiaInterfaces_Interface_Ethernet_DuplexMode       `path:"duplex-mode" module:"srl_nokia-interfaces"`
	FlowControl      *SrlNokiaInterfaces_Interface_Ethernet_FlowControl       `path:"flow-control" module:"srl_nokia-interfaces"`
	ForwardingViable *bool                                                    `path:"forwarding-viable" module:"srl_nokia-interfaces"`
	HoldTime         *SrlNokiaInterfaces_Interface_Ethernet_HoldTime          `path:"hold-time" module:"srl_nokia-interfaces" yangPresence:"true"`
	L2CpTransparency *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency  `path:"l2cp-transparency" module:"srl_nokia-interfaces-l2cp" yangPresence:"true"`
	LacpPortPriority *uint16                                                  `path:"lacp-port-priority" module:"srl_nokia-interfaces"`
	MacAddress       *string                                                  `path:"mac-address" module:"srl_nokia-interfaces"`
	PortSpeed        E_SrlNokiaInterfaces_Interface_Ethernet_PortSpeed        `path:"port-speed" module:"srl_nokia-interfaces"`
	PtpAsymmetry     *int32                                                   `path:"ptp-asymmetry" module:"srl_nokia-interfaces"`
	ReloadDelay      *uint32                                                  `path:"reload-delay" module:"srl_nokia-interfaces"`
	StandbySignaling E_SrlNokiaInterfaces_Interface_Ethernet_StandbySignaling `path:"standby-signaling" module:"srl_nokia-interfaces"`
	StormControl     *SrlNokiaInterfaces_Interface_Ethernet_StormControl      `path:"storm-control" module:"srl_nokia-interfaces" yangPresence:"true"`
	Synce            *SrlNokiaInterfaces_Interface_Ethernet_Synce             `path:"synce" module:"srl_nokia-interfaces" yangPresence:"true"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Ethernet implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Ethernet) IsYANGGoStruct() {}

// GetOrCreateFlowControl retrieves the value of the FlowControl field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Ethernet) GetOrCreateFlowControl() *SrlNokiaInterfaces_Interface_Ethernet_FlowControl {
	if t.FlowControl != nil {
		return t.FlowControl
	}
	t.FlowControl = &SrlNokiaInterfaces_Interface_Ethernet_FlowControl{}
	return t.FlowControl
}

// GetOrCreateHoldTime retrieves the value of the HoldTime field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Ethernet) GetOrCreateHoldTime() *SrlNokiaInterfaces_Interface_Ethernet_HoldTime {
	if t.HoldTime != nil {
		return t.HoldTime
	}
	t.HoldTime = &SrlNokiaInterfaces_Interface_Ethernet_HoldTime{}
	return t.HoldTime
}

// GetOrCreateL2CpTransparency retrieves the value of the L2CpTransparency field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Ethernet) GetOrCreateL2CpTransparency() *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency {
	if t.L2CpTransparency != nil {
		return t.L2CpTransparency
	}
	t.L2CpTransparency = &SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency{}
	return t.L2CpTransparency
}

// GetOrCreateStormControl retrieves the value of the StormControl field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Ethernet) GetOrCreateStormControl() *SrlNokiaInterfaces_Interface_Ethernet_StormControl {
	if t.StormControl != nil {
		return t.StormControl
	}
	t.StormControl = &SrlNokiaInterfaces_Interface_Ethernet_StormControl{}
	return t.StormControl
}

// GetOrCreateSynce retrieves the value of the Synce field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Ethernet) GetOrCreateSynce() *SrlNokiaInterfaces_Interface_Ethernet_Synce {
	if t.Synce != nil {
		return t.Synce
	}
	t.Synce = &SrlNokiaInterfaces_Interface_Ethernet_Synce{}
	return t.Synce
}

// GetFlowControl returns the value of the FlowControl struct pointer
// from SrlNokiaInterfaces_Interface_Ethernet. If the receiver or the field FlowControl is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Ethernet) GetFlowControl() *SrlNokiaInterfaces_Interface_Ethernet_FlowControl {
	if t != nil && t.FlowControl != nil {
		return t.FlowControl
	}
	return nil
}

// GetHoldTime returns the value of the HoldTime struct pointer
// from SrlNokiaInterfaces_Interface_Ethernet. If the receiver or the field HoldTime is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Ethernet) GetHoldTime() *SrlNokiaInterfaces_Interface_Ethernet_HoldTime {
	if t != nil && t.HoldTime != nil {
		return t.HoldTime
	}
	return nil
}

// GetL2CpTransparency returns the value of the L2CpTransparency struct pointer
// from SrlNokiaInterfaces_Interface_Ethernet. If the receiver or the field L2CpTransparency is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Ethernet) GetL2CpTransparency() *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency {
	if t != nil && t.L2CpTransparency != nil {
		return t.L2CpTransparency
	}
	return nil
}

// GetStormControl returns the value of the StormControl struct pointer
// from SrlNokiaInterfaces_Interface_Ethernet. If the receiver or the field StormControl is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Ethernet) GetStormControl() *SrlNokiaInterfaces_Interface_Ethernet_StormControl {
	if t != nil && t.StormControl != nil {
		return t.StormControl
	}
	return nil
}

// GetSynce returns the value of the Synce struct pointer
// from SrlNokiaInterfaces_Interface_Ethernet. If the receiver or the field Synce is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Ethernet) GetSynce() *SrlNokiaInterfaces_Interface_Ethernet_Synce {
	if t != nil && t.Synce != nil {
		return t.Synce
	}
	return nil
}

// GetAggregateId retrieves the value of the leaf AggregateId from the SrlNokiaInterfaces_Interface_Ethernet
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AggregateId is set, it can
// safely use t.GetAggregateId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AggregateId == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Ethernet) GetAggregateId() string {
	if t == nil || t.AggregateId == nil {
		return ""
	}
	return *t.AggregateId
}

// GetAutoNegotiate retrieves the value of the leaf AutoNegotiate from the SrlNokiaInterfaces_Interface_Ethernet
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AutoNegotiate is set, it can
// safely use t.GetAutoNegotiate() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AutoNegotiate == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Ethernet) GetAutoNegotiate() bool {
	if t == nil || t.AutoNegotiate == nil {
		return false
	}
	return *t.AutoNegotiate
}

// GetDacLinkTraining retrieves the value of the leaf DacLinkTraining from the SrlNokiaInterfaces_Interface_Ethernet
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DacLinkTraining is set, it can
// safely use t.GetDacLinkTraining() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DacLinkTraining == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Ethernet) GetDacLinkTraining() bool {
	if t == nil || t.DacLinkTraining == nil {
		return false
	}
	return *t.DacLinkTraining
}

// GetDuplexMode retrieves the value of the leaf DuplexMode from the SrlNokiaInterfaces_Interface_Ethernet
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DuplexMode is set, it can
// safely use t.GetDuplexMode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DuplexMode == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Ethernet) GetDuplexMode() E_SrlNokiaInterfaces_Interface_Ethernet_DuplexMode {
	if t == nil || t.DuplexMode == 0 {
		return 0
	}
	return t.DuplexMode
}

// GetForwardingViable retrieves the value of the leaf ForwardingViable from the SrlNokiaInterfaces_Interface_Ethernet
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ForwardingViable is set, it can
// safely use t.GetForwardingViable() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ForwardingViable == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Ethernet) GetForwardingViable() bool {
	if t == nil || t.ForwardingViable == nil {
		return false
	}
	return *t.ForwardingViable
}

// GetLacpPortPriority retrieves the value of the leaf LacpPortPriority from the SrlNokiaInterfaces_Interface_Ethernet
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LacpPortPriority is set, it can
// safely use t.GetLacpPortPriority() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LacpPortPriority == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Ethernet) GetLacpPortPriority() uint16 {
	if t == nil || t.LacpPortPriority == nil {
		return 0
	}
	return *t.LacpPortPriority
}

// GetMacAddress retrieves the value of the leaf MacAddress from the SrlNokiaInterfaces_Interface_Ethernet
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MacAddress is set, it can
// safely use t.GetMacAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MacAddress == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Ethernet) GetMacAddress() string {
	if t == nil || t.MacAddress == nil {
		return ""
	}
	return *t.MacAddress
}

// GetPortSpeed retrieves the value of the leaf PortSpeed from the SrlNokiaInterfaces_Interface_Ethernet
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PortSpeed is set, it can
// safely use t.GetPortSpeed() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PortSpeed == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Ethernet) GetPortSpeed() E_SrlNokiaInterfaces_Interface_Ethernet_PortSpeed {
	if t == nil || t.PortSpeed == 0 {
		return 0
	}
	return t.PortSpeed
}

// GetPtpAsymmetry retrieves the value of the leaf PtpAsymmetry from the SrlNokiaInterfaces_Interface_Ethernet
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PtpAsymmetry is set, it can
// safely use t.GetPtpAsymmetry() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PtpAsymmetry == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Ethernet) GetPtpAsymmetry() int32 {
	if t == nil || t.PtpAsymmetry == nil {
		return 0
	}
	return *t.PtpAsymmetry
}

// GetReloadDelay retrieves the value of the leaf ReloadDelay from the SrlNokiaInterfaces_Interface_Ethernet
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ReloadDelay is set, it can
// safely use t.GetReloadDelay() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ReloadDelay == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Ethernet) GetReloadDelay() uint32 {
	if t == nil || t.ReloadDelay == nil {
		return 0
	}
	return *t.ReloadDelay
}

// GetStandbySignaling retrieves the value of the leaf StandbySignaling from the SrlNokiaInterfaces_Interface_Ethernet
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if StandbySignaling is set, it can
// safely use t.GetStandbySignaling() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.StandbySignaling == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Ethernet) GetStandbySignaling() E_SrlNokiaInterfaces_Interface_Ethernet_StandbySignaling {
	if t == nil || t.StandbySignaling == 0 {
		return 0
	}
	return t.StandbySignaling
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Ethernet
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Ethernet) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.PtpAsymmetry == nil {
		var v int32 = 0
		t.PtpAsymmetry = &v
	}
	t.FlowControl.PopulateDefaults()
	t.HoldTime.PopulateDefaults()
	t.L2CpTransparency.PopulateDefaults()
	t.StormControl.PopulateDefaults()
	t.Synce.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Ethernet) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Ethernet"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Ethernet) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Ethernet) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Ethernet.
func (*SrlNokiaInterfaces_Interface_Ethernet) ΛBelongingModule() string {
	return "srl_nokia-interfaces"
}

// SrlNokiaInterfaces_Interface_Ethernet_FlowControl represents the /srl_nokia-interfaces/interface/ethernet/flow-control YANG schema element.
type SrlNokiaInterfaces_Interface_Ethernet_FlowControl struct {
	Receive  *bool `path:"receive" module:"srl_nokia-interfaces"`
	Transmit *bool `path:"transmit" module:"srl_nokia-interfaces"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Ethernet_FlowControl implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Ethernet_FlowControl) IsYANGGoStruct() {}

// GetReceive retrieves the value of the leaf Receive from the SrlNokiaInterfaces_Interface_Ethernet_FlowControl
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Receive is set, it can
// safely use t.GetReceive() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Receive == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Ethernet_FlowControl) GetReceive() bool {
	if t == nil || t.Receive == nil {
		return false
	}
	return *t.Receive
}

// GetTransmit retrieves the value of the leaf Transmit from the SrlNokiaInterfaces_Interface_Ethernet_FlowControl
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Transmit is set, it can
// safely use t.GetTransmit() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Transmit == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Ethernet_FlowControl) GetTransmit() bool {
	if t == nil || t.Transmit == nil {
		return false
	}
	return *t.Transmit
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Ethernet_FlowControl
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Ethernet_FlowControl) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Ethernet_FlowControl) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Ethernet_FlowControl"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Ethernet_FlowControl) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Ethernet_FlowControl) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Ethernet_FlowControl.
func (*SrlNokiaInterfaces_Interface_Ethernet_FlowControl) ΛBelongingModule() string {
	return "srl_nokia-interfaces"
}

// SrlNokiaInterfaces_Interface_Ethernet_HoldTime represents the /srl_nokia-interfaces/interface/ethernet/hold-time YANG schema element.
type SrlNokiaInterfaces_Interface_Ethernet_HoldTime struct {
	Down *uint32 `path:"down" module:"srl_nokia-interfaces"`
	Up   *uint32 `path:"up" module:"srl_nokia-interfaces"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Ethernet_HoldTime implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Ethernet_HoldTime) IsYANGGoStruct() {}

// GetDown retrieves the value of the leaf Down from the SrlNokiaInterfaces_Interface_Ethernet_HoldTime
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Down is set, it can
// safely use t.GetDown() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Down == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Ethernet_HoldTime) GetDown() uint32 {
	if t == nil || t.Down == nil {
		return 0
	}
	return *t.Down
}

// GetUp retrieves the value of the leaf Up from the SrlNokiaInterfaces_Interface_Ethernet_HoldTime
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Up is set, it can
// safely use t.GetUp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Up == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Ethernet_HoldTime) GetUp() uint32 {
	if t == nil || t.Up == nil {
		return 0
	}
	return *t.Up
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Ethernet_HoldTime
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Ethernet_HoldTime) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Ethernet_HoldTime) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Ethernet_HoldTime"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Ethernet_HoldTime) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Ethernet_HoldTime) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Ethernet_HoldTime.
func (*SrlNokiaInterfaces_Interface_Ethernet_HoldTime) ΛBelongingModule() string {
	return "srl_nokia-interfaces"
}

// SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency represents the /srl_nokia-interfaces/interface/ethernet/l2cp-transparency YANG schema element.
type SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency struct {
	Dot1X         *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Dot1X `path:"dot1x" module:"srl_nokia-interfaces-l2cp"`
	Lacp          *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Lacp  `path:"lacp" module:"srl_nokia-interfaces-l2cp"`
	Lldp          *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Lldp  `path:"lldp" module:"srl_nokia-interfaces-l2cp"`
	Ptp           *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Ptp   `path:"ptp" module:"srl_nokia-interfaces-l2cp"`
	TunnelAllL2Cp *bool                                                         `path:"tunnel-all-l2cp" module:"srl_nokia-interfaces-l2cp"`
	Xstp          *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Xstp  `path:"xstp" module:"srl_nokia-interfaces-l2cp"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency) IsYANGGoStruct() {}

// GetOrCreateDot1X retrieves the value of the Dot1X field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency) GetOrCreateDot1X() *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Dot1X {
	if t.Dot1X != nil {
		return t.Dot1X
	}
	t.Dot1X = &SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Dot1X{}
	return t.Dot1X
}

// GetOrCreateLacp retrieves the value of the Lacp field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency) GetOrCreateLacp() *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Lacp {
	if t.Lacp != nil {
		return t.Lacp
	}
	t.Lacp = &SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Lacp{}
	return t.Lacp
}

// GetOrCreateLldp retrieves the value of the Lldp field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency) GetOrCreateLldp() *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Lldp {
	if t.Lldp != nil {
		return t.Lldp
	}
	t.Lldp = &SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Lldp{}
	return t.Lldp
}

// GetOrCreatePtp retrieves the value of the Ptp field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency) GetOrCreatePtp() *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Ptp {
	if t.Ptp != nil {
		return t.Ptp
	}
	t.Ptp = &SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Ptp{}
	return t.Ptp
}

// GetOrCreateXstp retrieves the value of the Xstp field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency) GetOrCreateXstp() *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Xstp {
	if t.Xstp != nil {
		return t.Xstp
	}
	t.Xstp = &SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Xstp{}
	return t.Xstp
}

// GetDot1X returns the value of the Dot1X struct pointer
// from SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency. If the receiver or the field Dot1X is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency) GetDot1X() *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Dot1X {
	if t != nil && t.Dot1X != nil {
		return t.Dot1X
	}
	return nil
}

// GetLacp returns the value of the Lacp struct pointer
// from SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency. If the receiver or the field Lacp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency) GetLacp() *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Lacp {
	if t != nil && t.Lacp != nil {
		return t.Lacp
	}
	return nil
}

// GetLldp returns the value of the Lldp struct pointer
// from SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency. If the receiver or the field Lldp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency) GetLldp() *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Lldp {
	if t != nil && t.Lldp != nil {
		return t.Lldp
	}
	return nil
}

// GetPtp returns the value of the Ptp struct pointer
// from SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency. If the receiver or the field Ptp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency) GetPtp() *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Ptp {
	if t != nil && t.Ptp != nil {
		return t.Ptp
	}
	return nil
}

// GetXstp returns the value of the Xstp struct pointer
// from SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency. If the receiver or the field Xstp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency) GetXstp() *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Xstp {
	if t != nil && t.Xstp != nil {
		return t.Xstp
	}
	return nil
}

// GetTunnelAllL2Cp retrieves the value of the leaf TunnelAllL2Cp from the SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TunnelAllL2Cp is set, it can
// safely use t.GetTunnelAllL2Cp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TunnelAllL2Cp == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency) GetTunnelAllL2Cp() bool {
	if t == nil || t.TunnelAllL2Cp == nil {
		return false
	}
	return *t.TunnelAllL2Cp
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.TunnelAllL2Cp == nil {
		var v bool = false
		t.TunnelAllL2Cp = &v
	}
	t.Dot1X.PopulateDefaults()
	t.Lacp.PopulateDefaults()
	t.Lldp.PopulateDefaults()
	t.Ptp.PopulateDefaults()
	t.Xstp.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency.
func (*SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency) ΛBelongingModule() string {
	return "srl_nokia-interfaces-l2cp"
}

// SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Dot1X represents the /srl_nokia-interfaces/interface/ethernet/l2cp-transparency/dot1x YANG schema element.
type SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Dot1X struct {
	Tunnel *bool `path:"tunnel" module:"srl_nokia-interfaces-l2cp"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Dot1X implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Dot1X) IsYANGGoStruct() {}

// GetTunnel retrieves the value of the leaf Tunnel from the SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Dot1X
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Tunnel is set, it can
// safely use t.GetTunnel() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Tunnel == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Dot1X) GetTunnel() bool {
	if t == nil || t.Tunnel == nil {
		return false
	}
	return *t.Tunnel
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Dot1X
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Dot1X) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Tunnel == nil {
		var v bool = false
		t.Tunnel = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Dot1X) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Dot1X"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Dot1X) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Dot1X) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Dot1X.
func (*SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Dot1X) ΛBelongingModule() string {
	return "srl_nokia-interfaces-l2cp"
}

// SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Lacp represents the /srl_nokia-interfaces/interface/ethernet/l2cp-transparency/lacp YANG schema element.
type SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Lacp struct {
	Tunnel *bool `path:"tunnel" module:"srl_nokia-interfaces-l2cp"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Lacp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Lacp) IsYANGGoStruct() {}

// GetTunnel retrieves the value of the leaf Tunnel from the SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Lacp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Tunnel is set, it can
// safely use t.GetTunnel() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Tunnel == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Lacp) GetTunnel() bool {
	if t == nil || t.Tunnel == nil {
		return false
	}
	return *t.Tunnel
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Lacp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Lacp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Tunnel == nil {
		var v bool = false
		t.Tunnel = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Lacp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Lacp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Lacp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Lacp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Lacp.
func (*SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Lacp) ΛBelongingModule() string {
	return "srl_nokia-interfaces-l2cp"
}

// SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Lldp represents the /srl_nokia-interfaces/interface/ethernet/l2cp-transparency/lldp YANG schema element.
type SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Lldp struct {
	Tunnel *bool `path:"tunnel" module:"srl_nokia-interfaces-l2cp"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Lldp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Lldp) IsYANGGoStruct() {}

// GetTunnel retrieves the value of the leaf Tunnel from the SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Lldp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Tunnel is set, it can
// safely use t.GetTunnel() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Tunnel == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Lldp) GetTunnel() bool {
	if t == nil || t.Tunnel == nil {
		return false
	}
	return *t.Tunnel
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Lldp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Lldp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Tunnel == nil {
		var v bool = false
		t.Tunnel = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Lldp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Lldp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Lldp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Lldp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Lldp.
func (*SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Lldp) ΛBelongingModule() string {
	return "srl_nokia-interfaces-l2cp"
}

// SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Ptp represents the /srl_nokia-interfaces/interface/ethernet/l2cp-transparency/ptp YANG schema element.
type SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Ptp struct {
	Tunnel *bool `path:"tunnel" module:"srl_nokia-interfaces-l2cp"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Ptp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Ptp) IsYANGGoStruct() {}

// GetTunnel retrieves the value of the leaf Tunnel from the SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Ptp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Tunnel is set, it can
// safely use t.GetTunnel() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Tunnel == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Ptp) GetTunnel() bool {
	if t == nil || t.Tunnel == nil {
		return false
	}
	return *t.Tunnel
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Ptp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Ptp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Tunnel == nil {
		var v bool = false
		t.Tunnel = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Ptp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Ptp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Ptp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Ptp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Ptp.
func (*SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Ptp) ΛBelongingModule() string {
	return "srl_nokia-interfaces-l2cp"
}

// SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Xstp represents the /srl_nokia-interfaces/interface/ethernet/l2cp-transparency/xstp YANG schema element.
type SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Xstp struct {
	Tunnel *bool `path:"tunnel" module:"srl_nokia-interfaces-l2cp"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Xstp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Xstp) IsYANGGoStruct() {}

// GetTunnel retrieves the value of the leaf Tunnel from the SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Xstp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Tunnel is set, it can
// safely use t.GetTunnel() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Tunnel == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Xstp) GetTunnel() bool {
	if t == nil || t.Tunnel == nil {
		return false
	}
	return *t.Tunnel
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Xstp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Xstp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Tunnel == nil {
		var v bool = false
		t.Tunnel = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Xstp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Xstp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Xstp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Xstp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Xstp.
func (*SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Xstp) ΛBelongingModule() string {
	return "srl_nokia-interfaces-l2cp"
}

// SrlNokiaInterfaces_Interface_Ethernet_StormControl represents the /srl_nokia-interfaces/interface/ethernet/storm-control YANG schema element.
type SrlNokiaInterfaces_Interface_Ethernet_StormControl struct {
	BroadcastRate      *uint32                                                    `path:"broadcast-rate" module:"srl_nokia-interfaces"`
	MulticastRate      *uint32                                                    `path:"multicast-rate" module:"srl_nokia-interfaces"`
	Units              E_SrlNokiaInterfaces_Interface_Ethernet_StormControl_Units `path:"units" module:"srl_nokia-interfaces"`
	UnknownUnicastRate *uint32                                                    `path:"unknown-unicast-rate" module:"srl_nokia-interfaces"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Ethernet_StormControl implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Ethernet_StormControl) IsYANGGoStruct() {}

// GetBroadcastRate retrieves the value of the leaf BroadcastRate from the SrlNokiaInterfaces_Interface_Ethernet_StormControl
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if BroadcastRate is set, it can
// safely use t.GetBroadcastRate() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.BroadcastRate == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Ethernet_StormControl) GetBroadcastRate() uint32 {
	if t == nil || t.BroadcastRate == nil {
		return 0
	}
	return *t.BroadcastRate
}

// GetMulticastRate retrieves the value of the leaf MulticastRate from the SrlNokiaInterfaces_Interface_Ethernet_StormControl
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MulticastRate is set, it can
// safely use t.GetMulticastRate() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MulticastRate == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Ethernet_StormControl) GetMulticastRate() uint32 {
	if t == nil || t.MulticastRate == nil {
		return 0
	}
	return *t.MulticastRate
}

// GetUnits retrieves the value of the leaf Units from the SrlNokiaInterfaces_Interface_Ethernet_StormControl
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Units is set, it can
// safely use t.GetUnits() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Units == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Ethernet_StormControl) GetUnits() E_SrlNokiaInterfaces_Interface_Ethernet_StormControl_Units {
	if t == nil || t.Units == 0 {
		return SrlNokiaInterfaces_Interface_Ethernet_StormControl_Units_percentage
	}
	return t.Units
}

// GetUnknownUnicastRate retrieves the value of the leaf UnknownUnicastRate from the SrlNokiaInterfaces_Interface_Ethernet_StormControl
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if UnknownUnicastRate is set, it can
// safely use t.GetUnknownUnicastRate() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.UnknownUnicastRate == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Ethernet_StormControl) GetUnknownUnicastRate() uint32 {
	if t == nil || t.UnknownUnicastRate == nil {
		return 0
	}
	return *t.UnknownUnicastRate
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Ethernet_StormControl
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Ethernet_StormControl) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Units == 0 {
		t.Units = SrlNokiaInterfaces_Interface_Ethernet_StormControl_Units_percentage
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Ethernet_StormControl) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Ethernet_StormControl"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Ethernet_StormControl) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Ethernet_StormControl) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Ethernet_StormControl.
func (*SrlNokiaInterfaces_Interface_Ethernet_StormControl) ΛBelongingModule() string {
	return "srl_nokia-interfaces"
}

// SrlNokiaInterfaces_Interface_Ethernet_Synce represents the /srl_nokia-interfaces/interface/ethernet/synce YANG schema element.
type SrlNokiaInterfaces_Interface_Ethernet_Synce struct {
	Ssm *SrlNokiaInterfaces_Interface_Ethernet_Synce_Ssm `path:"ssm" module:"srl_nokia-interfaces"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Ethernet_Synce implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Ethernet_Synce) IsYANGGoStruct() {}

// GetOrCreateSsm retrieves the value of the Ssm field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Ethernet_Synce) GetOrCreateSsm() *SrlNokiaInterfaces_Interface_Ethernet_Synce_Ssm {
	if t.Ssm != nil {
		return t.Ssm
	}
	t.Ssm = &SrlNokiaInterfaces_Interface_Ethernet_Synce_Ssm{}
	return t.Ssm
}

// GetSsm returns the value of the Ssm struct pointer
// from SrlNokiaInterfaces_Interface_Ethernet_Synce. If the receiver or the field Ssm is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Ethernet_Synce) GetSsm() *SrlNokiaInterfaces_Interface_Ethernet_Synce_Ssm {
	if t != nil && t.Ssm != nil {
		return t.Ssm
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Ethernet_Synce
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Ethernet_Synce) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Ssm.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Ethernet_Synce) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Ethernet_Synce"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Ethernet_Synce) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Ethernet_Synce) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Ethernet_Synce.
func (*SrlNokiaInterfaces_Interface_Ethernet_Synce) ΛBelongingModule() string {
	return "srl_nokia-interfaces"
}

// SrlNokiaInterfaces_Interface_Ethernet_Synce_Ssm represents the /srl_nokia-interfaces/interface/ethernet/synce/ssm YANG schema element.
type SrlNokiaInterfaces_Interface_Ethernet_Synce_Ssm struct {
	AdminState E_SrlNokiaCommon_AdminState `path:"admin-state" module:"srl_nokia-interfaces"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Ethernet_Synce_Ssm implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Ethernet_Synce_Ssm) IsYANGGoStruct() {}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaInterfaces_Interface_Ethernet_Synce_Ssm
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Ethernet_Synce_Ssm) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_disable
	}
	return t.AdminState
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Ethernet_Synce_Ssm
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Ethernet_Synce_Ssm) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_disable
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Ethernet_Synce_Ssm) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Ethernet_Synce_Ssm"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Ethernet_Synce_Ssm) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Ethernet_Synce_Ssm) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Ethernet_Synce_Ssm.
func (*SrlNokiaInterfaces_Interface_Ethernet_Synce_Ssm) ΛBelongingModule() string {
	return "srl_nokia-interfaces"
}

// SrlNokiaInterfaces_Interface_Lag represents the /srl_nokia-interfaces/interface/lag YANG schema element.
type SrlNokiaInterfaces_Interface_Lag struct {
	Lacp                *SrlNokiaInterfaces_Interface_Lag_Lacp   `path:"lacp" module:"srl_nokia-lacp" yangPresence:"true"`
	LacpFallbackMode    E_SrlNokiaInterfacesLag_LacpFallbackType `path:"lacp-fallback-mode" module:"srl_nokia-interfaces-lag"`
	LacpFallbackTimeout *uint16                                  `path:"lacp-fallback-timeout" module:"srl_nokia-interfaces-lag"`
	LagType             E_SrlNokiaInterfacesLag_LagType          `path:"lag-type" module:"srl_nokia-interfaces-lag"`
	MemberSpeed         E_SrlNokiaInterfacesLag_MemberSpeedType  `path:"member-speed" module:"srl_nokia-interfaces-lag"`
	MinLinks            *uint16                                  `path:"min-links" module:"srl_nokia-interfaces-lag"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Lag implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Lag) IsYANGGoStruct() {}

// GetOrCreateLacp retrieves the value of the Lacp field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Lag) GetOrCreateLacp() *SrlNokiaInterfaces_Interface_Lag_Lacp {
	if t.Lacp != nil {
		return t.Lacp
	}
	t.Lacp = &SrlNokiaInterfaces_Interface_Lag_Lacp{}
	return t.Lacp
}

// GetLacp returns the value of the Lacp struct pointer
// from SrlNokiaInterfaces_Interface_Lag. If the receiver or the field Lacp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Lag) GetLacp() *SrlNokiaInterfaces_Interface_Lag_Lacp {
	if t != nil && t.Lacp != nil {
		return t.Lacp
	}
	return nil
}

// GetLacpFallbackMode retrieves the value of the leaf LacpFallbackMode from the SrlNokiaInterfaces_Interface_Lag
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LacpFallbackMode is set, it can
// safely use t.GetLacpFallbackMode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LacpFallbackMode == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Lag) GetLacpFallbackMode() E_SrlNokiaInterfacesLag_LacpFallbackType {
	if t == nil || t.LacpFallbackMode == 0 {
		return 0
	}
	return t.LacpFallbackMode
}

// GetLacpFallbackTimeout retrieves the value of the leaf LacpFallbackTimeout from the SrlNokiaInterfaces_Interface_Lag
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LacpFallbackTimeout is set, it can
// safely use t.GetLacpFallbackTimeout() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LacpFallbackTimeout == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Lag) GetLacpFallbackTimeout() uint16 {
	if t == nil || t.LacpFallbackTimeout == nil {
		return 0
	}
	return *t.LacpFallbackTimeout
}

// GetLagType retrieves the value of the leaf LagType from the SrlNokiaInterfaces_Interface_Lag
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LagType is set, it can
// safely use t.GetLagType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LagType == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Lag) GetLagType() E_SrlNokiaInterfacesLag_LagType {
	if t == nil || t.LagType == 0 {
		return SrlNokiaInterfacesLag_LagType_static
	}
	return t.LagType
}

// GetMemberSpeed retrieves the value of the leaf MemberSpeed from the SrlNokiaInterfaces_Interface_Lag
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MemberSpeed is set, it can
// safely use t.GetMemberSpeed() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MemberSpeed == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Lag) GetMemberSpeed() E_SrlNokiaInterfacesLag_MemberSpeedType {
	if t == nil || t.MemberSpeed == 0 {
		return 0
	}
	return t.MemberSpeed
}

// GetMinLinks retrieves the value of the leaf MinLinks from the SrlNokiaInterfaces_Interface_Lag
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MinLinks is set, it can
// safely use t.GetMinLinks() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MinLinks == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Lag) GetMinLinks() uint16 {
	if t == nil || t.MinLinks == nil {
		return 1
	}
	return *t.MinLinks
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Lag
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Lag) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.LagType == 0 {
		t.LagType = SrlNokiaInterfacesLag_LagType_static
	}
	if t.MinLinks == nil {
		var v uint16 = 1
		t.MinLinks = &v
	}
	t.Lacp.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Lag) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Lag"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Lag) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Lag) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Lag.
func (*SrlNokiaInterfaces_Interface_Lag) ΛBelongingModule() string {
	return "srl_nokia-interfaces-lag"
}

// SrlNokiaInterfaces_Interface_Lag_Lacp represents the /srl_nokia-interfaces/interface/lag/lacp YANG schema element.
type SrlNokiaInterfaces_Interface_Lag_Lacp struct {
	AdminKey       *uint16                         `path:"admin-key" module:"srl_nokia-lacp"`
	Interval       E_SrlNokiaLacp_LacpPeriodType   `path:"interval" module:"srl_nokia-lacp"`
	LacpMode       E_SrlNokiaLacp_LacpActivityType `path:"lacp-mode" module:"srl_nokia-lacp"`
	SystemIdMac    *string                         `path:"system-id-mac" module:"srl_nokia-lacp"`
	SystemPriority *uint16                         `path:"system-priority" module:"srl_nokia-lacp"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Lag_Lacp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Lag_Lacp) IsYANGGoStruct() {}

// GetAdminKey retrieves the value of the leaf AdminKey from the SrlNokiaInterfaces_Interface_Lag_Lacp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminKey is set, it can
// safely use t.GetAdminKey() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminKey == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Lag_Lacp) GetAdminKey() uint16 {
	if t == nil || t.AdminKey == nil {
		return 0
	}
	return *t.AdminKey
}

// GetInterval retrieves the value of the leaf Interval from the SrlNokiaInterfaces_Interface_Lag_Lacp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interval is set, it can
// safely use t.GetInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interval == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Lag_Lacp) GetInterval() E_SrlNokiaLacp_LacpPeriodType {
	if t == nil || t.Interval == 0 {
		return SrlNokiaLacp_LacpPeriodType_SLOW
	}
	return t.Interval
}

// GetLacpMode retrieves the value of the leaf LacpMode from the SrlNokiaInterfaces_Interface_Lag_Lacp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LacpMode is set, it can
// safely use t.GetLacpMode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LacpMode == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Lag_Lacp) GetLacpMode() E_SrlNokiaLacp_LacpActivityType {
	if t == nil || t.LacpMode == 0 {
		return SrlNokiaLacp_LacpActivityType_ACTIVE
	}
	return t.LacpMode
}

// GetSystemIdMac retrieves the value of the leaf SystemIdMac from the SrlNokiaInterfaces_Interface_Lag_Lacp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SystemIdMac is set, it can
// safely use t.GetSystemIdMac() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SystemIdMac == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Lag_Lacp) GetSystemIdMac() string {
	if t == nil || t.SystemIdMac == nil {
		return ""
	}
	return *t.SystemIdMac
}

// GetSystemPriority retrieves the value of the leaf SystemPriority from the SrlNokiaInterfaces_Interface_Lag_Lacp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SystemPriority is set, it can
// safely use t.GetSystemPriority() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SystemPriority == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Lag_Lacp) GetSystemPriority() uint16 {
	if t == nil || t.SystemPriority == nil {
		return 0
	}
	return *t.SystemPriority
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Lag_Lacp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Lag_Lacp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Interval == 0 {
		t.Interval = SrlNokiaLacp_LacpPeriodType_SLOW
	}
	if t.LacpMode == 0 {
		t.LacpMode = SrlNokiaLacp_LacpActivityType_ACTIVE
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Lag_Lacp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Lag_Lacp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Lag_Lacp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Lag_Lacp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Lag_Lacp.
func (*SrlNokiaInterfaces_Interface_Lag_Lacp) ΛBelongingModule() string {
	return "srl_nokia-lacp"
}

// SrlNokiaInterfaces_Interface_Linux represents the /srl_nokia-interfaces/interface/linux YANG schema element.
type SrlNokiaInterfaces_Interface_Linux struct {
	DeviceName *string `path:"device-name" module:"srl_nokia-interfaces-vxdp"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Linux implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Linux) IsYANGGoStruct() {}

// GetDeviceName retrieves the value of the leaf DeviceName from the SrlNokiaInterfaces_Interface_Linux
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DeviceName is set, it can
// safely use t.GetDeviceName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DeviceName == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Linux) GetDeviceName() string {
	if t == nil || t.DeviceName == nil {
		return ""
	}
	return *t.DeviceName
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Linux
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Linux) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Linux) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Linux"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Linux) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Linux) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Linux.
func (*SrlNokiaInterfaces_Interface_Linux) ΛBelongingModule() string {
	return "srl_nokia-interfaces-vxdp"
}

// SrlNokiaInterfaces_Interface_P4Rt represents the /srl_nokia-interfaces/interface/p4rt YANG schema element.
type SrlNokiaInterfaces_Interface_P4Rt struct {
	Id *uint32 `path:"id" module:"srl_nokia-interfaces-p4rt"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_P4Rt implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_P4Rt) IsYANGGoStruct() {}

// GetId retrieves the value of the leaf Id from the SrlNokiaInterfaces_Interface_P4Rt
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Id is set, it can
// safely use t.GetId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Id == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_P4Rt) GetId() uint32 {
	if t == nil || t.Id == nil {
		return 0
	}
	return *t.Id
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_P4Rt
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_P4Rt) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_P4Rt) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_P4Rt"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_P4Rt) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_P4Rt) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_P4Rt.
func (*SrlNokiaInterfaces_Interface_P4Rt) ΛBelongingModule() string {
	return "srl_nokia-interfaces-p4rt"
}

// SrlNokiaInterfaces_Interface_Qos represents the /srl_nokia-interfaces/interface/qos YANG schema element.
type SrlNokiaInterfaces_Interface_Qos struct {
	Output *SrlNokiaInterfaces_Interface_Qos_Output `path:"output" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Qos implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Qos) IsYANGGoStruct() {}

// GetOrCreateOutput retrieves the value of the Output field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Qos) GetOrCreateOutput() *SrlNokiaInterfaces_Interface_Qos_Output {
	if t.Output != nil {
		return t.Output
	}
	t.Output = &SrlNokiaInterfaces_Interface_Qos_Output{}
	return t.Output
}

// GetOutput returns the value of the Output struct pointer
// from SrlNokiaInterfaces_Interface_Qos. If the receiver or the field Output is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Qos) GetOutput() *SrlNokiaInterfaces_Interface_Qos_Output {
	if t != nil && t.Output != nil {
		return t.Output
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Qos
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Qos) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Output.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Qos) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Qos"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Qos) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Qos) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Qos.
func (*SrlNokiaInterfaces_Interface_Qos) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaInterfaces_Interface_Qos_Output represents the /srl_nokia-interfaces/interface/qos/output YANG schema element.
type SrlNokiaInterfaces_Interface_Qos_Output struct {
	Queue     map[SrlNokiaInterfaces_Interface_Qos_Output_Queue_QueueName_Union]*SrlNokiaInterfaces_Interface_Qos_Output_Queue `path:"queue" module:"srl_nokia-qos"`
	Scheduler *SrlNokiaInterfaces_Interface_Qos_Output_Scheduler                                                               `path:"scheduler" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Qos_Output implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Qos_Output) IsYANGGoStruct() {}

// NewQueue creates a new entry in the Queue list of the
// SrlNokiaInterfaces_Interface_Qos_Output struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaInterfaces_Interface_Qos_Output) NewQueue(QueueName SrlNokiaInterfaces_Interface_Qos_Output_Queue_QueueName_Union) (*SrlNokiaInterfaces_Interface_Qos_Output_Queue, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Queue == nil {
		t.Queue = make(map[SrlNokiaInterfaces_Interface_Qos_Output_Queue_QueueName_Union]*SrlNokiaInterfaces_Interface_Qos_Output_Queue)
	}

	key := QueueName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Queue[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Queue", key)
	}

	t.Queue[key] = &SrlNokiaInterfaces_Interface_Qos_Output_Queue{
		QueueName: QueueName,
	}

	return t.Queue[key], nil
}

// RenameQueue renames an entry in the list Queue within
// the SrlNokiaInterfaces_Interface_Qos_Output struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaInterfaces_Interface_Qos_Output) RenameQueue(
	oldK, newK SrlNokiaInterfaces_Interface_Qos_Output_Queue_QueueName_Union,
) error {
	if _, ok := t.Queue[newK]; ok {
		return fmt.Errorf("key %v already exists in Queue", newK)
	}

	e, ok := t.Queue[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Queue", oldK)
	}
	e.QueueName = newK

	t.Queue[newK] = e
	delete(t.Queue, oldK)
	return nil
}

// GetOrCreateQueue retrieves the value with the specified keys from
// the receiver SrlNokiaInterfaces_Interface_Qos_Output. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaInterfaces_Interface_Qos_Output) GetOrCreateQueue(
	QueueName SrlNokiaInterfaces_Interface_Qos_Output_Queue_QueueName_Union,
) *SrlNokiaInterfaces_Interface_Qos_Output_Queue {
	key := QueueName

	if v, ok := t.Queue[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewQueue(QueueName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateQueue got unexpected error: %v", err))
	}
	return v
}

// GetQueue retrieves the value with the specified key from
// the Queue map field of SrlNokiaInterfaces_Interface_Qos_Output. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaInterfaces_Interface_Qos_Output) GetQueue(QueueName SrlNokiaInterfaces_Interface_Qos_Output_Queue_QueueName_Union) *SrlNokiaInterfaces_Interface_Qos_Output_Queue {
	if t == nil {
		return nil
	}

	key := QueueName

	if lm, ok := t.Queue[key]; ok {
		return lm
	}
	return nil
}

// DeleteQueue deletes the value with the specified keys from
// the receiver SrlNokiaInterfaces_Interface_Qos_Output. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaInterfaces_Interface_Qos_Output) DeleteQueue(
	QueueName SrlNokiaInterfaces_Interface_Qos_Output_Queue_QueueName_Union,
) {
	key := QueueName

	delete(t.Queue, key)
}

// AppendQueue appends the supplied SrlNokiaInterfaces_Interface_Qos_Output_Queue struct to the
// list Queue of SrlNokiaInterfaces_Interface_Qos_Output. If the key value(s) specified in
// the supplied SrlNokiaInterfaces_Interface_Qos_Output_Queue already exist in the list, an error is
// returned.
func (t *SrlNokiaInterfaces_Interface_Qos_Output) AppendQueue(v *SrlNokiaInterfaces_Interface_Qos_Output_Queue) error {
	key := v.QueueName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Queue == nil {
		t.Queue = make(map[SrlNokiaInterfaces_Interface_Qos_Output_Queue_QueueName_Union]*SrlNokiaInterfaces_Interface_Qos_Output_Queue)
	}

	if _, ok := t.Queue[key]; ok {
		return fmt.Errorf("duplicate key for list Queue %v", key)
	}

	t.Queue[key] = v
	return nil
}

// GetOrCreateScheduler retrieves the value of the Scheduler field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Qos_Output) GetOrCreateScheduler() *SrlNokiaInterfaces_Interface_Qos_Output_Scheduler {
	if t.Scheduler != nil {
		return t.Scheduler
	}
	t.Scheduler = &SrlNokiaInterfaces_Interface_Qos_Output_Scheduler{}
	return t.Scheduler
}

// GetScheduler returns the value of the Scheduler struct pointer
// from SrlNokiaInterfaces_Interface_Qos_Output. If the receiver or the field Scheduler is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Qos_Output) GetScheduler() *SrlNokiaInterfaces_Interface_Qos_Output_Scheduler {
	if t != nil && t.Scheduler != nil {
		return t.Scheduler
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Qos_Output
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Qos_Output) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Scheduler.PopulateDefaults()
	for _, e := range t.Queue {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Qos_Output) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Qos_Output"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Qos_Output) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Qos_Output) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Qos_Output.
func (*SrlNokiaInterfaces_Interface_Qos_Output) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaInterfaces_Interface_Qos_Output_Queue represents the /srl_nokia-interfaces/interface/qos/output/queue YANG schema element.
type SrlNokiaInterfaces_Interface_Qos_Output_Queue struct {
	QueueName   SrlNokiaInterfaces_Interface_Qos_Output_Queue_QueueName_Union `path:"queue-name" module:"srl_nokia-qos"`
	Scheduling  *SrlNokiaInterfaces_Interface_Qos_Output_Queue_Scheduling     `path:"scheduling" module:"srl_nokia-qos"`
	Template    *string                                                       `path:"template" module:"srl_nokia-qos"`
	VoqTemplate *string                                                       `path:"voq-template" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Qos_Output_Queue implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Qos_Output_Queue) IsYANGGoStruct() {}

// GetOrCreateScheduling retrieves the value of the Scheduling field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Qos_Output_Queue) GetOrCreateScheduling() *SrlNokiaInterfaces_Interface_Qos_Output_Queue_Scheduling {
	if t.Scheduling != nil {
		return t.Scheduling
	}
	t.Scheduling = &SrlNokiaInterfaces_Interface_Qos_Output_Queue_Scheduling{}
	return t.Scheduling
}

// GetScheduling returns the value of the Scheduling struct pointer
// from SrlNokiaInterfaces_Interface_Qos_Output_Queue. If the receiver or the field Scheduling is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Qos_Output_Queue) GetScheduling() *SrlNokiaInterfaces_Interface_Qos_Output_Queue_Scheduling {
	if t != nil && t.Scheduling != nil {
		return t.Scheduling
	}
	return nil
}

// GetQueueName retrieves the value of the leaf QueueName from the SrlNokiaInterfaces_Interface_Qos_Output_Queue
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if QueueName is set, it can
// safely use t.GetQueueName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.QueueName == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Qos_Output_Queue) GetQueueName() SrlNokiaInterfaces_Interface_Qos_Output_Queue_QueueName_Union {
	if t == nil || t.QueueName == nil {
		return nil
	}
	return t.QueueName
}

// GetTemplate retrieves the value of the leaf Template from the SrlNokiaInterfaces_Interface_Qos_Output_Queue
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Template is set, it can
// safely use t.GetTemplate() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Template == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Qos_Output_Queue) GetTemplate() string {
	if t == nil || t.Template == nil {
		return ""
	}
	return *t.Template
}

// GetVoqTemplate retrieves the value of the leaf VoqTemplate from the SrlNokiaInterfaces_Interface_Qos_Output_Queue
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VoqTemplate is set, it can
// safely use t.GetVoqTemplate() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VoqTemplate == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Qos_Output_Queue) GetVoqTemplate() string {
	if t == nil || t.VoqTemplate == nil {
		return ""
	}
	return *t.VoqTemplate
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Qos_Output_Queue
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Qos_Output_Queue) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Scheduling.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the SrlNokiaInterfaces_Interface_Qos_Output_Queue struct, which is a YANG list entry.
func (t *SrlNokiaInterfaces_Interface_Qos_Output_Queue) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"queue-name": t.QueueName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Qos_Output_Queue) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Qos_Output_Queue"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Qos_Output_Queue) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Qos_Output_Queue) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Qos_Output_Queue.
func (*SrlNokiaInterfaces_Interface_Qos_Output_Queue) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaInterfaces_Interface_Qos_Output_Queue_Scheduling represents the /srl_nokia-interfaces/interface/qos/output/queue/scheduling YANG schema element.
type SrlNokiaInterfaces_Interface_Qos_Output_Queue_Scheduling struct {
	PeakRatePercent *uint8 `path:"peak-rate-percent" module:"srl_nokia-qos"`
	StrictPriority  *bool  `path:"strict-priority" module:"srl_nokia-qos"`
	Weight          *uint8 `path:"weight" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Qos_Output_Queue_Scheduling implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Qos_Output_Queue_Scheduling) IsYANGGoStruct() {}

// GetPeakRatePercent retrieves the value of the leaf PeakRatePercent from the SrlNokiaInterfaces_Interface_Qos_Output_Queue_Scheduling
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PeakRatePercent is set, it can
// safely use t.GetPeakRatePercent() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PeakRatePercent == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Qos_Output_Queue_Scheduling) GetPeakRatePercent() uint8 {
	if t == nil || t.PeakRatePercent == nil {
		return 100
	}
	return *t.PeakRatePercent
}

// GetStrictPriority retrieves the value of the leaf StrictPriority from the SrlNokiaInterfaces_Interface_Qos_Output_Queue_Scheduling
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if StrictPriority is set, it can
// safely use t.GetStrictPriority() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.StrictPriority == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Qos_Output_Queue_Scheduling) GetStrictPriority() bool {
	if t == nil || t.StrictPriority == nil {
		return false
	}
	return *t.StrictPriority
}

// GetWeight retrieves the value of the leaf Weight from the SrlNokiaInterfaces_Interface_Qos_Output_Queue_Scheduling
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Weight is set, it can
// safely use t.GetWeight() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Weight == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Qos_Output_Queue_Scheduling) GetWeight() uint8 {
	if t == nil || t.Weight == nil {
		return 0
	}
	return *t.Weight
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Qos_Output_Queue_Scheduling
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Qos_Output_Queue_Scheduling) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.PeakRatePercent == nil {
		var v uint8 = 100
		t.PeakRatePercent = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Qos_Output_Queue_Scheduling) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Qos_Output_Queue_Scheduling"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Qos_Output_Queue_Scheduling) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Qos_Output_Queue_Scheduling) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Qos_Output_Queue_Scheduling.
func (*SrlNokiaInterfaces_Interface_Qos_Output_Queue_Scheduling) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaInterfaces_Interface_Qos_Output_Scheduler represents the /srl_nokia-interfaces/interface/qos/output/scheduler YANG schema element.
type SrlNokiaInterfaces_Interface_Qos_Output_Scheduler struct {
	Tier map[uint8]*SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier `path:"tier" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Qos_Output_Scheduler implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Qos_Output_Scheduler) IsYANGGoStruct() {}

// NewTier creates a new entry in the Tier list of the
// SrlNokiaInterfaces_Interface_Qos_Output_Scheduler struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaInterfaces_Interface_Qos_Output_Scheduler) NewTier(Level uint8) (*SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Tier == nil {
		t.Tier = make(map[uint8]*SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier)
	}

	key := Level

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Tier[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Tier", key)
	}

	t.Tier[key] = &SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier{
		Level: &Level,
	}

	return t.Tier[key], nil
}

// RenameTier renames an entry in the list Tier within
// the SrlNokiaInterfaces_Interface_Qos_Output_Scheduler struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaInterfaces_Interface_Qos_Output_Scheduler) RenameTier(oldK, newK uint8) error {
	if _, ok := t.Tier[newK]; ok {
		return fmt.Errorf("key %v already exists in Tier", newK)
	}

	e, ok := t.Tier[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Tier", oldK)
	}
	e.Level = &newK

	t.Tier[newK] = e
	delete(t.Tier, oldK)
	return nil
}

// GetOrCreateTier retrieves the value with the specified keys from
// the receiver SrlNokiaInterfaces_Interface_Qos_Output_Scheduler. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaInterfaces_Interface_Qos_Output_Scheduler) GetOrCreateTier(Level uint8) *SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier {
	key := Level

	if v, ok := t.Tier[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewTier(Level)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateTier got unexpected error: %v", err))
	}
	return v
}

// GetTier retrieves the value with the specified key from
// the Tier map field of SrlNokiaInterfaces_Interface_Qos_Output_Scheduler. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaInterfaces_Interface_Qos_Output_Scheduler) GetTier(Level uint8) *SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier {
	if t == nil {
		return nil
	}

	key := Level

	if lm, ok := t.Tier[key]; ok {
		return lm
	}
	return nil
}

// DeleteTier deletes the value with the specified keys from
// the receiver SrlNokiaInterfaces_Interface_Qos_Output_Scheduler. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaInterfaces_Interface_Qos_Output_Scheduler) DeleteTier(Level uint8) {
	key := Level

	delete(t.Tier, key)
}

// AppendTier appends the supplied SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier struct to the
// list Tier of SrlNokiaInterfaces_Interface_Qos_Output_Scheduler. If the key value(s) specified in
// the supplied SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier already exist in the list, an error is
// returned.
func (t *SrlNokiaInterfaces_Interface_Qos_Output_Scheduler) AppendTier(
	v *SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier,
) error {
	if v.Level == nil {
		return fmt.Errorf("invalid nil key received for Level")
	}

	key := *v.Level

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Tier == nil {
		t.Tier = make(map[uint8]*SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier)
	}

	if _, ok := t.Tier[key]; ok {
		return fmt.Errorf("duplicate key for list Tier %v", key)
	}

	t.Tier[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Qos_Output_Scheduler
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Qos_Output_Scheduler) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Tier {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Qos_Output_Scheduler) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Qos_Output_Scheduler"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Qos_Output_Scheduler) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Qos_Output_Scheduler) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Qos_Output_Scheduler.
func (*SrlNokiaInterfaces_Interface_Qos_Output_Scheduler) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier represents the /srl_nokia-interfaces/interface/qos/output/scheduler/tier YANG schema element.
type SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier struct {
	Level *uint8                                                                 `path:"level" module:"srl_nokia-qos"`
	Node  map[uint8]*SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier_Node `path:"node" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier) IsYANGGoStruct() {}

// NewNode creates a new entry in the Node list of the
// SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier) NewNode(NodeNumber uint8) (*SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier_Node, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Node == nil {
		t.Node = make(map[uint8]*SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier_Node)
	}

	key := NodeNumber

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Node[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Node", key)
	}

	t.Node[key] = &SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier_Node{
		NodeNumber: &NodeNumber,
	}

	return t.Node[key], nil
}

// RenameNode renames an entry in the list Node within
// the SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier) RenameNode(oldK, newK uint8) error {
	if _, ok := t.Node[newK]; ok {
		return fmt.Errorf("key %v already exists in Node", newK)
	}

	e, ok := t.Node[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Node", oldK)
	}
	e.NodeNumber = &newK

	t.Node[newK] = e
	delete(t.Node, oldK)
	return nil
}

// GetOrCreateNode retrieves the value with the specified keys from
// the receiver SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier) GetOrCreateNode(NodeNumber uint8) *SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier_Node {
	key := NodeNumber

	if v, ok := t.Node[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNode(NodeNumber)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNode got unexpected error: %v", err))
	}
	return v
}

// GetNode retrieves the value with the specified key from
// the Node map field of SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier) GetNode(NodeNumber uint8) *SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier_Node {
	if t == nil {
		return nil
	}

	key := NodeNumber

	if lm, ok := t.Node[key]; ok {
		return lm
	}
	return nil
}

// DeleteNode deletes the value with the specified keys from
// the receiver SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier) DeleteNode(NodeNumber uint8) {
	key := NodeNumber

	delete(t.Node, key)
}

// AppendNode appends the supplied SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier_Node struct to the
// list Node of SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier. If the key value(s) specified in
// the supplied SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier_Node already exist in the list, an error is
// returned.
func (t *SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier) AppendNode(
	v *SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier_Node,
) error {
	if v.NodeNumber == nil {
		return fmt.Errorf("invalid nil key received for NodeNumber")
	}

	key := *v.NodeNumber

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Node == nil {
		t.Node = make(map[uint8]*SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier_Node)
	}

	if _, ok := t.Node[key]; ok {
		return fmt.Errorf("duplicate key for list Node %v", key)
	}

	t.Node[key] = v
	return nil
}

// GetLevel retrieves the value of the leaf Level from the SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Level is set, it can
// safely use t.GetLevel() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Level == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier) GetLevel() uint8 {
	if t == nil || t.Level == nil {
		return 0
	}
	return *t.Level
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Node {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier struct, which is a YANG list entry.
func (t *SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Level == nil {
		return nil, fmt.Errorf("nil value for key Level")
	}

	return map[string]interface{}{
		"level": *t.Level,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier.
func (*SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier_Node represents the /srl_nokia-interfaces/interface/qos/output/scheduler/tier/node YANG schema element.
type SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier_Node struct {
	NodeNumber     *uint8 `path:"node-number" module:"srl_nokia-qos"`
	StrictPriority *bool  `path:"strict-priority" module:"srl_nokia-qos"`
	Weight         *uint8 `path:"weight" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier_Node implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier_Node) IsYANGGoStruct() {}

// GetNodeNumber retrieves the value of the leaf NodeNumber from the SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier_Node
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NodeNumber is set, it can
// safely use t.GetNodeNumber() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NodeNumber == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier_Node) GetNodeNumber() uint8 {
	if t == nil || t.NodeNumber == nil {
		return 0
	}
	return *t.NodeNumber
}

// GetStrictPriority retrieves the value of the leaf StrictPriority from the SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier_Node
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if StrictPriority is set, it can
// safely use t.GetStrictPriority() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.StrictPriority == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier_Node) GetStrictPriority() bool {
	if t == nil || t.StrictPriority == nil {
		return false
	}
	return *t.StrictPriority
}

// GetWeight retrieves the value of the leaf Weight from the SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier_Node
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Weight is set, it can
// safely use t.GetWeight() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Weight == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier_Node) GetWeight() uint8 {
	if t == nil || t.Weight == nil {
		return 1
	}
	return *t.Weight
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier_Node
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier_Node) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Weight == nil {
		var v uint8 = 1
		t.Weight = &v
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier_Node struct, which is a YANG list entry.
func (t *SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier_Node) ΛListKeyMap() (map[string]interface{}, error) {
	if t.NodeNumber == nil {
		return nil, fmt.Errorf("nil value for key NodeNumber")
	}

	return map[string]interface{}{
		"node-number": *t.NodeNumber,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier_Node) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier_Node"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier_Node) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier_Node) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier_Node.
func (*SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier_Node) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaInterfaces_Interface_Sflow represents the /srl_nokia-interfaces/interface/sflow YANG schema element.
type SrlNokiaInterfaces_Interface_Sflow struct {
	AdminState E_SrlNokiaCommon_AdminState `path:"admin-state" module:"srl_nokia-interfaces"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Sflow implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Sflow) IsYANGGoStruct() {}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaInterfaces_Interface_Sflow
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Sflow) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return 0
	}
	return t.AdminState
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Sflow
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Sflow) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Sflow) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Sflow"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Sflow) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Sflow) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Sflow.
func (*SrlNokiaInterfaces_Interface_Sflow) ΛBelongingModule() string {
	return "srl_nokia-interfaces"
}

// SrlNokiaInterfaces_Interface_Subinterface represents the /srl_nokia-interfaces/interface/subinterface YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface struct {
	Acl                    *SrlNokiaInterfaces_Interface_Subinterface_Acl                    `path:"acl" module:"srl_nokia-acl"`
	AdminState             E_SrlNokiaCommon_AdminState                                       `path:"admin-state" module:"srl_nokia-interfaces"`
	AnycastGw              *SrlNokiaInterfaces_Interface_Subinterface_AnycastGw              `path:"anycast-gw" module:"srl_nokia-interfaces" yangPresence:"true"`
	BridgeTable            *SrlNokiaInterfaces_Interface_Subinterface_BridgeTable            `path:"bridge-table" module:"srl_nokia-interfaces" yangPresence:"true"`
	Description            *string                                                           `path:"description" module:"srl_nokia-interfaces"`
	EthCfm                 *SrlNokiaInterfaces_Interface_Subinterface_EthCfm                 `path:"eth-cfm" module:"srl_nokia-ethcfm"`
	Index                  *uint32                                                           `path:"index" module:"srl_nokia-interfaces"`
	IpMtu                  *uint16                                                           `path:"ip-mtu" module:"srl_nokia-interfaces"`
	Ipv4                   *SrlNokiaInterfaces_Interface_Subinterface_Ipv4                   `path:"ipv4" module:"srl_nokia-interfaces"`
	Ipv6                   *SrlNokiaInterfaces_Interface_Subinterface_Ipv6                   `path:"ipv6" module:"srl_nokia-interfaces"`
	L2Mtu                  *uint16                                                           `path:"l2-mtu" module:"srl_nokia-interfaces"`
	LocalMirrorDestination *SrlNokiaInterfaces_Interface_Subinterface_LocalMirrorDestination `path:"local-mirror-destination" module:"srl_nokia-interfaces-local-mirror-destination" yangPresence:"true"`
	MplsMtu                *uint16                                                           `path:"mpls-mtu" module:"srl_nokia-interfaces"`
	Qos                    *SrlNokiaInterfaces_Interface_Subinterface_Qos                    `path:"qos" module:"srl_nokia-qos" yangPresence:"true"`
	RaGuard                *SrlNokiaInterfaces_Interface_Subinterface_RaGuard                `path:"ra-guard" module:"srl_nokia-ra_guard" yangPresence:"true"`
	Type                   E_SrlNokiaInterfaces_SiType                                       `path:"type" module:"srl_nokia-interfaces"`
	Uuid                   *string                                                           `path:"uuid" module:"srl_nokia-interfaces-vxdp"`
	Vlan                   *SrlNokiaInterfaces_Interface_Subinterface_Vlan                   `path:"vlan" module:"srl_nokia-interfaces-vlans"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface) IsYANGGoStruct() {}

// GetOrCreateAcl retrieves the value of the Acl field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Subinterface) GetOrCreateAcl() *SrlNokiaInterfaces_Interface_Subinterface_Acl {
	if t.Acl != nil {
		return t.Acl
	}
	t.Acl = &SrlNokiaInterfaces_Interface_Subinterface_Acl{}
	return t.Acl
}

// GetOrCreateAnycastGw retrieves the value of the AnycastGw field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Subinterface) GetOrCreateAnycastGw() *SrlNokiaInterfaces_Interface_Subinterface_AnycastGw {
	if t.AnycastGw != nil {
		return t.AnycastGw
	}
	t.AnycastGw = &SrlNokiaInterfaces_Interface_Subinterface_AnycastGw{}
	return t.AnycastGw
}

// GetOrCreateBridgeTable retrieves the value of the BridgeTable field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Subinterface) GetOrCreateBridgeTable() *SrlNokiaInterfaces_Interface_Subinterface_BridgeTable {
	if t.BridgeTable != nil {
		return t.BridgeTable
	}
	t.BridgeTable = &SrlNokiaInterfaces_Interface_Subinterface_BridgeTable{}
	return t.BridgeTable
}

// GetOrCreateEthCfm retrieves the value of the EthCfm field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Subinterface) GetOrCreateEthCfm() *SrlNokiaInterfaces_Interface_Subinterface_EthCfm {
	if t.EthCfm != nil {
		return t.EthCfm
	}
	t.EthCfm = &SrlNokiaInterfaces_Interface_Subinterface_EthCfm{}
	return t.EthCfm
}

// GetOrCreateIpv4 retrieves the value of the Ipv4 field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Subinterface) GetOrCreateIpv4() *SrlNokiaInterfaces_Interface_Subinterface_Ipv4 {
	if t.Ipv4 != nil {
		return t.Ipv4
	}
	t.Ipv4 = &SrlNokiaInterfaces_Interface_Subinterface_Ipv4{}
	return t.Ipv4
}

// GetOrCreateIpv6 retrieves the value of the Ipv6 field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Subinterface) GetOrCreateIpv6() *SrlNokiaInterfaces_Interface_Subinterface_Ipv6 {
	if t.Ipv6 != nil {
		return t.Ipv6
	}
	t.Ipv6 = &SrlNokiaInterfaces_Interface_Subinterface_Ipv6{}
	return t.Ipv6
}

// GetOrCreateLocalMirrorDestination retrieves the value of the LocalMirrorDestination field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Subinterface) GetOrCreateLocalMirrorDestination() *SrlNokiaInterfaces_Interface_Subinterface_LocalMirrorDestination {
	if t.LocalMirrorDestination != nil {
		return t.LocalMirrorDestination
	}
	t.LocalMirrorDestination = &SrlNokiaInterfaces_Interface_Subinterface_LocalMirrorDestination{}
	return t.LocalMirrorDestination
}

// GetOrCreateQos retrieves the value of the Qos field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Subinterface) GetOrCreateQos() *SrlNokiaInterfaces_Interface_Subinterface_Qos {
	if t.Qos != nil {
		return t.Qos
	}
	t.Qos = &SrlNokiaInterfaces_Interface_Subinterface_Qos{}
	return t.Qos
}

// GetOrCreateRaGuard retrieves the value of the RaGuard field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Subinterface) GetOrCreateRaGuard() *SrlNokiaInterfaces_Interface_Subinterface_RaGuard {
	if t.RaGuard != nil {
		return t.RaGuard
	}
	t.RaGuard = &SrlNokiaInterfaces_Interface_Subinterface_RaGuard{}
	return t.RaGuard
}

// GetOrCreateVlan retrieves the value of the Vlan field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Subinterface) GetOrCreateVlan() *SrlNokiaInterfaces_Interface_Subinterface_Vlan {
	if t.Vlan != nil {
		return t.Vlan
	}
	t.Vlan = &SrlNokiaInterfaces_Interface_Subinterface_Vlan{}
	return t.Vlan
}

// GetAcl returns the value of the Acl struct pointer
// from SrlNokiaInterfaces_Interface_Subinterface. If the receiver or the field Acl is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface) GetAcl() *SrlNokiaInterfaces_Interface_Subinterface_Acl {
	if t != nil && t.Acl != nil {
		return t.Acl
	}
	return nil
}

// GetAnycastGw returns the value of the AnycastGw struct pointer
// from SrlNokiaInterfaces_Interface_Subinterface. If the receiver or the field AnycastGw is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface) GetAnycastGw() *SrlNokiaInterfaces_Interface_Subinterface_AnycastGw {
	if t != nil && t.AnycastGw != nil {
		return t.AnycastGw
	}
	return nil
}

// GetBridgeTable returns the value of the BridgeTable struct pointer
// from SrlNokiaInterfaces_Interface_Subinterface. If the receiver or the field BridgeTable is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface) GetBridgeTable() *SrlNokiaInterfaces_Interface_Subinterface_BridgeTable {
	if t != nil && t.BridgeTable != nil {
		return t.BridgeTable
	}
	return nil
}

// GetEthCfm returns the value of the EthCfm struct pointer
// from SrlNokiaInterfaces_Interface_Subinterface. If the receiver or the field EthCfm is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface) GetEthCfm() *SrlNokiaInterfaces_Interface_Subinterface_EthCfm {
	if t != nil && t.EthCfm != nil {
		return t.EthCfm
	}
	return nil
}

// GetIpv4 returns the value of the Ipv4 struct pointer
// from SrlNokiaInterfaces_Interface_Subinterface. If the receiver or the field Ipv4 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface) GetIpv4() *SrlNokiaInterfaces_Interface_Subinterface_Ipv4 {
	if t != nil && t.Ipv4 != nil {
		return t.Ipv4
	}
	return nil
}

// GetIpv6 returns the value of the Ipv6 struct pointer
// from SrlNokiaInterfaces_Interface_Subinterface. If the receiver or the field Ipv6 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface) GetIpv6() *SrlNokiaInterfaces_Interface_Subinterface_Ipv6 {
	if t != nil && t.Ipv6 != nil {
		return t.Ipv6
	}
	return nil
}

// GetLocalMirrorDestination returns the value of the LocalMirrorDestination struct pointer
// from SrlNokiaInterfaces_Interface_Subinterface. If the receiver or the field LocalMirrorDestination is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface) GetLocalMirrorDestination() *SrlNokiaInterfaces_Interface_Subinterface_LocalMirrorDestination {
	if t != nil && t.LocalMirrorDestination != nil {
		return t.LocalMirrorDestination
	}
	return nil
}

// GetQos returns the value of the Qos struct pointer
// from SrlNokiaInterfaces_Interface_Subinterface. If the receiver or the field Qos is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface) GetQos() *SrlNokiaInterfaces_Interface_Subinterface_Qos {
	if t != nil && t.Qos != nil {
		return t.Qos
	}
	return nil
}

// GetRaGuard returns the value of the RaGuard struct pointer
// from SrlNokiaInterfaces_Interface_Subinterface. If the receiver or the field RaGuard is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface) GetRaGuard() *SrlNokiaInterfaces_Interface_Subinterface_RaGuard {
	if t != nil && t.RaGuard != nil {
		return t.RaGuard
	}
	return nil
}

// GetVlan returns the value of the Vlan struct pointer
// from SrlNokiaInterfaces_Interface_Subinterface. If the receiver or the field Vlan is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface) GetVlan() *SrlNokiaInterfaces_Interface_Subinterface_Vlan {
	if t != nil && t.Vlan != nil {
		return t.Vlan
	}
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaInterfaces_Interface_Subinterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_enable
	}
	return t.AdminState
}

// GetDescription retrieves the value of the leaf Description from the SrlNokiaInterfaces_Interface_Subinterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetIndex retrieves the value of the leaf Index from the SrlNokiaInterfaces_Interface_Subinterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Index is set, it can
// safely use t.GetIndex() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Index == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface) GetIndex() uint32 {
	if t == nil || t.Index == nil {
		return 0
	}
	return *t.Index
}

// GetIpMtu retrieves the value of the leaf IpMtu from the SrlNokiaInterfaces_Interface_Subinterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IpMtu is set, it can
// safely use t.GetIpMtu() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IpMtu == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface) GetIpMtu() uint16 {
	if t == nil || t.IpMtu == nil {
		return 0
	}
	return *t.IpMtu
}

// GetL2Mtu retrieves the value of the leaf L2Mtu from the SrlNokiaInterfaces_Interface_Subinterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if L2Mtu is set, it can
// safely use t.GetL2Mtu() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.L2Mtu == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface) GetL2Mtu() uint16 {
	if t == nil || t.L2Mtu == nil {
		return 0
	}
	return *t.L2Mtu
}

// GetMplsMtu retrieves the value of the leaf MplsMtu from the SrlNokiaInterfaces_Interface_Subinterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MplsMtu is set, it can
// safely use t.GetMplsMtu() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MplsMtu == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface) GetMplsMtu() uint16 {
	if t == nil || t.MplsMtu == nil {
		return 0
	}
	return *t.MplsMtu
}

// GetType retrieves the value of the leaf Type from the SrlNokiaInterfaces_Interface_Subinterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Type is set, it can
// safely use t.GetType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Type == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface) GetType() E_SrlNokiaInterfaces_SiType {
	if t == nil || t.Type == 0 {
		return 0
	}
	return t.Type
}

// GetUuid retrieves the value of the leaf Uuid from the SrlNokiaInterfaces_Interface_Subinterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Uuid is set, it can
// safely use t.GetUuid() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Uuid == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface) GetUuid() string {
	if t == nil || t.Uuid == nil {
		return ""
	}
	return *t.Uuid
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_enable
	}
	t.Acl.PopulateDefaults()
	t.AnycastGw.PopulateDefaults()
	t.BridgeTable.PopulateDefaults()
	t.EthCfm.PopulateDefaults()
	t.Ipv4.PopulateDefaults()
	t.Ipv6.PopulateDefaults()
	t.LocalMirrorDestination.PopulateDefaults()
	t.Qos.PopulateDefaults()
	t.RaGuard.PopulateDefaults()
	t.Vlan.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the SrlNokiaInterfaces_Interface_Subinterface struct, which is a YANG list entry.
func (t *SrlNokiaInterfaces_Interface_Subinterface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Index == nil {
		return nil, fmt.Errorf("nil value for key Index")
	}

	return map[string]interface{}{
		"index": *t.Index,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface.
func (*SrlNokiaInterfaces_Interface_Subinterface) ΛBelongingModule() string {
	return "srl_nokia-interfaces"
}

// SrlNokiaInterfaces_Interface_Subinterface_Acl represents the /srl_nokia-interfaces/interface/subinterface/acl YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_Acl struct {
	Input  *SrlNokiaInterfaces_Interface_Subinterface_Acl_Input  `path:"input" module:"srl_nokia-acl"`
	Output *SrlNokiaInterfaces_Interface_Subinterface_Acl_Output `path:"output" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_Acl implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_Acl) IsYANGGoStruct() {}

// GetOrCreateInput retrieves the value of the Input field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Acl) GetOrCreateInput() *SrlNokiaInterfaces_Interface_Subinterface_Acl_Input {
	if t.Input != nil {
		return t.Input
	}
	t.Input = &SrlNokiaInterfaces_Interface_Subinterface_Acl_Input{}
	return t.Input
}

// GetOrCreateOutput retrieves the value of the Output field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Acl) GetOrCreateOutput() *SrlNokiaInterfaces_Interface_Subinterface_Acl_Output {
	if t.Output != nil {
		return t.Output
	}
	t.Output = &SrlNokiaInterfaces_Interface_Subinterface_Acl_Output{}
	return t.Output
}

// GetInput returns the value of the Input struct pointer
// from SrlNokiaInterfaces_Interface_Subinterface_Acl. If the receiver or the field Input is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Acl) GetInput() *SrlNokiaInterfaces_Interface_Subinterface_Acl_Input {
	if t != nil && t.Input != nil {
		return t.Input
	}
	return nil
}

// GetOutput returns the value of the Output struct pointer
// from SrlNokiaInterfaces_Interface_Subinterface_Acl. If the receiver or the field Output is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Acl) GetOutput() *SrlNokiaInterfaces_Interface_Subinterface_Acl_Output {
	if t != nil && t.Output != nil {
		return t.Output
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_Acl
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Acl) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Input.PopulateDefaults()
	t.Output.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Acl) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Acl"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Acl) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Acl) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_Acl.
func (*SrlNokiaInterfaces_Interface_Subinterface_Acl) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaInterfaces_Interface_Subinterface_Acl_Input represents the /srl_nokia-interfaces/interface/subinterface/acl/input YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_Acl_Input struct {
	Ipv4Filter []string `path:"ipv4-filter" module:"srl_nokia-acl"`
	Ipv6Filter []string `path:"ipv6-filter" module:"srl_nokia-acl"`
	MacFilter  []string `path:"mac-filter" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_Acl_Input implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_Acl_Input) IsYANGGoStruct() {}

// GetIpv4Filter retrieves the value of the leaf Ipv4Filter from the SrlNokiaInterfaces_Interface_Subinterface_Acl_Input
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ipv4Filter is set, it can
// safely use t.GetIpv4Filter() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ipv4Filter == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Acl_Input) GetIpv4Filter() []string {
	if t == nil || t.Ipv4Filter == nil {
		return nil
	}
	return t.Ipv4Filter
}

// GetIpv6Filter retrieves the value of the leaf Ipv6Filter from the SrlNokiaInterfaces_Interface_Subinterface_Acl_Input
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ipv6Filter is set, it can
// safely use t.GetIpv6Filter() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ipv6Filter == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Acl_Input) GetIpv6Filter() []string {
	if t == nil || t.Ipv6Filter == nil {
		return nil
	}
	return t.Ipv6Filter
}

// GetMacFilter retrieves the value of the leaf MacFilter from the SrlNokiaInterfaces_Interface_Subinterface_Acl_Input
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MacFilter is set, it can
// safely use t.GetMacFilter() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MacFilter == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Acl_Input) GetMacFilter() []string {
	if t == nil || t.MacFilter == nil {
		return nil
	}
	return t.MacFilter
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_Acl_Input
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Acl_Input) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Acl_Input) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Acl_Input"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Acl_Input) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Acl_Input) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_Acl_Input.
func (*SrlNokiaInterfaces_Interface_Subinterface_Acl_Input) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaInterfaces_Interface_Subinterface_Acl_Output represents the /srl_nokia-interfaces/interface/subinterface/acl/output YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_Acl_Output struct {
	Ipv4Filter []string `path:"ipv4-filter" module:"srl_nokia-acl"`
	Ipv6Filter []string `path:"ipv6-filter" module:"srl_nokia-acl"`
	MacFilter  []string `path:"mac-filter" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_Acl_Output implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_Acl_Output) IsYANGGoStruct() {}

// GetIpv4Filter retrieves the value of the leaf Ipv4Filter from the SrlNokiaInterfaces_Interface_Subinterface_Acl_Output
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ipv4Filter is set, it can
// safely use t.GetIpv4Filter() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ipv4Filter == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Acl_Output) GetIpv4Filter() []string {
	if t == nil || t.Ipv4Filter == nil {
		return nil
	}
	return t.Ipv4Filter
}

// GetIpv6Filter retrieves the value of the leaf Ipv6Filter from the SrlNokiaInterfaces_Interface_Subinterface_Acl_Output
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ipv6Filter is set, it can
// safely use t.GetIpv6Filter() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ipv6Filter == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Acl_Output) GetIpv6Filter() []string {
	if t == nil || t.Ipv6Filter == nil {
		return nil
	}
	return t.Ipv6Filter
}

// GetMacFilter retrieves the value of the leaf MacFilter from the SrlNokiaInterfaces_Interface_Subinterface_Acl_Output
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MacFilter is set, it can
// safely use t.GetMacFilter() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MacFilter == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Acl_Output) GetMacFilter() []string {
	if t == nil || t.MacFilter == nil {
		return nil
	}
	return t.MacFilter
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_Acl_Output
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Acl_Output) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Acl_Output) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Acl_Output"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Acl_Output) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Acl_Output) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_Acl_Output.
func (*SrlNokiaInterfaces_Interface_Subinterface_Acl_Output) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaInterfaces_Interface_Subinterface_AnycastGw represents the /srl_nokia-interfaces/interface/subinterface/anycast-gw YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_AnycastGw struct {
	AnycastGwMac    *string `path:"anycast-gw-mac" module:"srl_nokia-interfaces"`
	VirtualRouterId *uint8  `path:"virtual-router-id" module:"srl_nokia-interfaces"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_AnycastGw implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_AnycastGw) IsYANGGoStruct() {}

// GetAnycastGwMac retrieves the value of the leaf AnycastGwMac from the SrlNokiaInterfaces_Interface_Subinterface_AnycastGw
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AnycastGwMac is set, it can
// safely use t.GetAnycastGwMac() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AnycastGwMac == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_AnycastGw) GetAnycastGwMac() string {
	if t == nil || t.AnycastGwMac == nil {
		return ""
	}
	return *t.AnycastGwMac
}

// GetVirtualRouterId retrieves the value of the leaf VirtualRouterId from the SrlNokiaInterfaces_Interface_Subinterface_AnycastGw
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VirtualRouterId is set, it can
// safely use t.GetVirtualRouterId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VirtualRouterId == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_AnycastGw) GetVirtualRouterId() uint8 {
	if t == nil || t.VirtualRouterId == nil {
		return 1
	}
	return *t.VirtualRouterId
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_AnycastGw
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_AnycastGw) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.VirtualRouterId == nil {
		var v uint8 = 1
		t.VirtualRouterId = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_AnycastGw) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_AnycastGw"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_AnycastGw) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_AnycastGw) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_AnycastGw.
func (*SrlNokiaInterfaces_Interface_Subinterface_AnycastGw) ΛBelongingModule() string {
	return "srl_nokia-interfaces"
}

// SrlNokiaInterfaces_Interface_Subinterface_BridgeTable represents the /srl_nokia-interfaces/interface/subinterface/bridge-table YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_BridgeTable struct {
	DiscardUnknownSrcMac *bool                                                                 `path:"discard-unknown-src-mac" module:"srl_nokia-interfaces"`
	MacDuplication       *SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacDuplication `path:"mac-duplication" module:"srl_nokia-interfaces"`
	MacLearning          *SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLearning    `path:"mac-learning" module:"srl_nokia-interfaces"`
	MacLimit             *SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLimit       `path:"mac-limit" module:"srl_nokia-interfaces"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_BridgeTable implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_BridgeTable) IsYANGGoStruct() {}

// GetOrCreateMacDuplication retrieves the value of the MacDuplication field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Subinterface_BridgeTable) GetOrCreateMacDuplication() *SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacDuplication {
	if t.MacDuplication != nil {
		return t.MacDuplication
	}
	t.MacDuplication = &SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacDuplication{}
	return t.MacDuplication
}

// GetOrCreateMacLearning retrieves the value of the MacLearning field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Subinterface_BridgeTable) GetOrCreateMacLearning() *SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLearning {
	if t.MacLearning != nil {
		return t.MacLearning
	}
	t.MacLearning = &SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLearning{}
	return t.MacLearning
}

// GetOrCreateMacLimit retrieves the value of the MacLimit field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Subinterface_BridgeTable) GetOrCreateMacLimit() *SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLimit {
	if t.MacLimit != nil {
		return t.MacLimit
	}
	t.MacLimit = &SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLimit{}
	return t.MacLimit
}

// GetMacDuplication returns the value of the MacDuplication struct pointer
// from SrlNokiaInterfaces_Interface_Subinterface_BridgeTable. If the receiver or the field MacDuplication is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_BridgeTable) GetMacDuplication() *SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacDuplication {
	if t != nil && t.MacDuplication != nil {
		return t.MacDuplication
	}
	return nil
}

// GetMacLearning returns the value of the MacLearning struct pointer
// from SrlNokiaInterfaces_Interface_Subinterface_BridgeTable. If the receiver or the field MacLearning is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_BridgeTable) GetMacLearning() *SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLearning {
	if t != nil && t.MacLearning != nil {
		return t.MacLearning
	}
	return nil
}

// GetMacLimit returns the value of the MacLimit struct pointer
// from SrlNokiaInterfaces_Interface_Subinterface_BridgeTable. If the receiver or the field MacLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_BridgeTable) GetMacLimit() *SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLimit {
	if t != nil && t.MacLimit != nil {
		return t.MacLimit
	}
	return nil
}

// GetDiscardUnknownSrcMac retrieves the value of the leaf DiscardUnknownSrcMac from the SrlNokiaInterfaces_Interface_Subinterface_BridgeTable
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DiscardUnknownSrcMac is set, it can
// safely use t.GetDiscardUnknownSrcMac() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DiscardUnknownSrcMac == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_BridgeTable) GetDiscardUnknownSrcMac() bool {
	if t == nil || t.DiscardUnknownSrcMac == nil {
		return false
	}
	return *t.DiscardUnknownSrcMac
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_BridgeTable
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_BridgeTable) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.DiscardUnknownSrcMac == nil {
		var v bool = false
		t.DiscardUnknownSrcMac = &v
	}
	t.MacDuplication.PopulateDefaults()
	t.MacLearning.PopulateDefaults()
	t.MacLimit.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_BridgeTable) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_BridgeTable"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_BridgeTable) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_BridgeTable) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_BridgeTable.
func (*SrlNokiaInterfaces_Interface_Subinterface_BridgeTable) ΛBelongingModule() string {
	return "srl_nokia-interfaces"
}

// SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacDuplication represents the /srl_nokia-interfaces/interface/subinterface/bridge-table/mac-duplication YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacDuplication struct {
	Action E_SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacDuplication_Action `path:"action" module:"srl_nokia-interfaces"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacDuplication implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacDuplication) IsYANGGoStruct() {}

// GetAction retrieves the value of the leaf Action from the SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacDuplication
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Action is set, it can
// safely use t.GetAction() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Action == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacDuplication) GetAction() E_SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacDuplication_Action {
	if t == nil || t.Action == 0 {
		return SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacDuplication_Action_use_net_instance_action
	}
	return t.Action
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacDuplication
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacDuplication) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Action == 0 {
		t.Action = SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacDuplication_Action_use_net_instance_action
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacDuplication) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacDuplication"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacDuplication) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacDuplication) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacDuplication.
func (*SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacDuplication) ΛBelongingModule() string {
	return "srl_nokia-interfaces"
}

// SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLearning represents the /srl_nokia-interfaces/interface/subinterface/bridge-table/mac-learning YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLearning struct {
	AdminState E_SrlNokiaCommon_AdminState                                              `path:"admin-state" module:"srl_nokia-interfaces"`
	Aging      *SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLearning_Aging `path:"aging" module:"srl_nokia-interfaces"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLearning implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLearning) IsYANGGoStruct() {}

// GetOrCreateAging retrieves the value of the Aging field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLearning) GetOrCreateAging() *SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLearning_Aging {
	if t.Aging != nil {
		return t.Aging
	}
	t.Aging = &SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLearning_Aging{}
	return t.Aging
}

// GetAging returns the value of the Aging struct pointer
// from SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLearning. If the receiver or the field Aging is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLearning) GetAging() *SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLearning_Aging {
	if t != nil && t.Aging != nil {
		return t.Aging
	}
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLearning
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLearning) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_enable
	}
	return t.AdminState
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLearning
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLearning) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_enable
	}
	t.Aging.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLearning) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLearning"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLearning) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLearning) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLearning.
func (*SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLearning) ΛBelongingModule() string {
	return "srl_nokia-interfaces"
}

// SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLearning_Aging represents the /srl_nokia-interfaces/interface/subinterface/bridge-table/mac-learning/aging YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLearning_Aging struct {
	AdminState E_SrlNokiaCommon_AdminState `path:"admin-state" module:"srl_nokia-interfaces"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLearning_Aging implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLearning_Aging) IsYANGGoStruct() {}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLearning_Aging
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLearning_Aging) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_enable
	}
	return t.AdminState
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLearning_Aging
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLearning_Aging) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_enable
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLearning_Aging) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLearning_Aging"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLearning_Aging) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLearning_Aging) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLearning_Aging.
func (*SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLearning_Aging) ΛBelongingModule() string {
	return "srl_nokia-interfaces"
}

// SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLimit represents the /srl_nokia-interfaces/interface/subinterface/bridge-table/mac-limit YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLimit struct {
	MaximumEntries      *int32 `path:"maximum-entries" module:"srl_nokia-interfaces"`
	WarningThresholdPct *int32 `path:"warning-threshold-pct" module:"srl_nokia-interfaces"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLimit implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLimit) IsYANGGoStruct() {}

// GetMaximumEntries retrieves the value of the leaf MaximumEntries from the SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLimit
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MaximumEntries is set, it can
// safely use t.GetMaximumEntries() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MaximumEntries == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLimit) GetMaximumEntries() int32 {
	if t == nil || t.MaximumEntries == nil {
		return 250
	}
	return *t.MaximumEntries
}

// GetWarningThresholdPct retrieves the value of the leaf WarningThresholdPct from the SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLimit
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if WarningThresholdPct is set, it can
// safely use t.GetWarningThresholdPct() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.WarningThresholdPct == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLimit) GetWarningThresholdPct() int32 {
	if t == nil || t.WarningThresholdPct == nil {
		return 95
	}
	return *t.WarningThresholdPct
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLimit
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLimit) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.MaximumEntries == nil {
		var v int32 = 250
		t.MaximumEntries = &v
	}
	if t.WarningThresholdPct == nil {
		var v int32 = 95
		t.WarningThresholdPct = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLimit) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLimit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLimit) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLimit.
func (*SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLimit) ΛBelongingModule() string {
	return "srl_nokia-interfaces"
}

// SrlNokiaInterfaces_Interface_Subinterface_EthCfm represents the /srl_nokia-interfaces/interface/subinterface/eth-cfm YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_EthCfm struct {
	IngressSquelching *SrlNokiaInterfaces_Interface_Subinterface_EthCfm_IngressSquelching `path:"ingress-squelching" module:"srl_nokia-ethcfm"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_EthCfm implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_EthCfm) IsYANGGoStruct() {}

// GetOrCreateIngressSquelching retrieves the value of the IngressSquelching field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Subinterface_EthCfm) GetOrCreateIngressSquelching() *SrlNokiaInterfaces_Interface_Subinterface_EthCfm_IngressSquelching {
	if t.IngressSquelching != nil {
		return t.IngressSquelching
	}
	t.IngressSquelching = &SrlNokiaInterfaces_Interface_Subinterface_EthCfm_IngressSquelching{}
	return t.IngressSquelching
}

// GetIngressSquelching returns the value of the IngressSquelching struct pointer
// from SrlNokiaInterfaces_Interface_Subinterface_EthCfm. If the receiver or the field IngressSquelching is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_EthCfm) GetIngressSquelching() *SrlNokiaInterfaces_Interface_Subinterface_EthCfm_IngressSquelching {
	if t != nil && t.IngressSquelching != nil {
		return t.IngressSquelching
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_EthCfm
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_EthCfm) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.IngressSquelching.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_EthCfm) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_EthCfm"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_EthCfm) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_EthCfm) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_EthCfm.
func (*SrlNokiaInterfaces_Interface_Subinterface_EthCfm) ΛBelongingModule() string {
	return "srl_nokia-ethcfm"
}

// SrlNokiaInterfaces_Interface_Subinterface_EthCfm_IngressSquelching represents the /srl_nokia-interfaces/interface/subinterface/eth-cfm/ingress-squelching YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_EthCfm_IngressSquelching struct {
	SquelchLevels *string `path:"squelch-levels" module:"srl_nokia-ethcfm"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_EthCfm_IngressSquelching implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_EthCfm_IngressSquelching) IsYANGGoStruct() {}

// GetSquelchLevels retrieves the value of the leaf SquelchLevels from the SrlNokiaInterfaces_Interface_Subinterface_EthCfm_IngressSquelching
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SquelchLevels is set, it can
// safely use t.GetSquelchLevels() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SquelchLevels == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_EthCfm_IngressSquelching) GetSquelchLevels() string {
	if t == nil || t.SquelchLevels == nil {
		return ""
	}
	return *t.SquelchLevels
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_EthCfm_IngressSquelching
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_EthCfm_IngressSquelching) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_EthCfm_IngressSquelching) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_EthCfm_IngressSquelching"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_EthCfm_IngressSquelching) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_EthCfm_IngressSquelching) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_EthCfm_IngressSquelching.
func (*SrlNokiaInterfaces_Interface_Subinterface_EthCfm_IngressSquelching) ΛBelongingModule() string {
	return "srl_nokia-ethcfm"
}

// SrlNokiaInterfaces_Interface_Subinterface_Ipv4 represents the /srl_nokia-interfaces/interface/subinterface/ipv4 YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_Ipv4 struct {
	Address                map[string]*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address `path:"address" module:"srl_nokia-interfaces"`
	AdminState             E_SrlNokiaCommon_AdminState                                        `path:"admin-state" module:"srl_nokia-interfaces"`
	AllowDirectedBroadcast *bool                                                              `path:"allow-directed-broadcast" module:"srl_nokia-interfaces"`
	Arp                    *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp                `path:"arp" module:"srl_nokia-interfaces-nbr"`
	DhcpClient             *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpClient         `path:"dhcp-client" module:"srl_nokia-interfaces-ip-dhcp" yangPresence:"true"`
	DhcpRelay              *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpRelay          `path:"dhcp-relay" module:"srl_nokia-interfaces-ip-dhcp-relay" yangPresence:"true"`
	DhcpServer             *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpServer         `path:"dhcp-server" module:"srl_nokia-interfaces-ip-dhcp-server" yangPresence:"true"`
	Unnumbered             *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Unnumbered         `path:"unnumbered" module:"srl_nokia-interfaces"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_Ipv4 implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv4) IsYANGGoStruct() {}

// NewAddress creates a new entry in the Address list of the
// SrlNokiaInterfaces_Interface_Subinterface_Ipv4 struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4) NewAddress(IpPrefix string) (*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Address == nil {
		t.Address = make(map[string]*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address)
	}

	key := IpPrefix

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Address[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Address", key)
	}

	t.Address[key] = &SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address{
		IpPrefix: &IpPrefix,
	}

	return t.Address[key], nil
}

// RenameAddress renames an entry in the list Address within
// the SrlNokiaInterfaces_Interface_Subinterface_Ipv4 struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4) RenameAddress(oldK, newK string) error {
	if _, ok := t.Address[newK]; ok {
		return fmt.Errorf("key %v already exists in Address", newK)
	}

	e, ok := t.Address[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Address", oldK)
	}
	e.IpPrefix = &newK

	t.Address[newK] = e
	delete(t.Address, oldK)
	return nil
}

// GetOrCreateAddress retrieves the value with the specified keys from
// the receiver SrlNokiaInterfaces_Interface_Subinterface_Ipv4. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4) GetOrCreateAddress(IpPrefix string) *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address {
	key := IpPrefix

	if v, ok := t.Address[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAddress(IpPrefix)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAddress got unexpected error: %v", err))
	}
	return v
}

// GetAddress retrieves the value with the specified key from
// the Address map field of SrlNokiaInterfaces_Interface_Subinterface_Ipv4. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4) GetAddress(IpPrefix string) *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address {
	if t == nil {
		return nil
	}

	key := IpPrefix

	if lm, ok := t.Address[key]; ok {
		return lm
	}
	return nil
}

// DeleteAddress deletes the value with the specified keys from
// the receiver SrlNokiaInterfaces_Interface_Subinterface_Ipv4. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4) DeleteAddress(IpPrefix string) {
	key := IpPrefix

	delete(t.Address, key)
}

// AppendAddress appends the supplied SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address struct to the
// list Address of SrlNokiaInterfaces_Interface_Subinterface_Ipv4. If the key value(s) specified in
// the supplied SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address already exist in the list, an error is
// returned.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4) AppendAddress(
	v *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address,
) error {
	if v.IpPrefix == nil {
		return fmt.Errorf("invalid nil key received for IpPrefix")
	}

	key := *v.IpPrefix

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Address == nil {
		t.Address = make(map[string]*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address)
	}

	if _, ok := t.Address[key]; ok {
		return fmt.Errorf("duplicate key for list Address %v", key)
	}

	t.Address[key] = v
	return nil
}

// GetOrCreateArp retrieves the value of the Arp field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4) GetOrCreateArp() *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp {
	if t.Arp != nil {
		return t.Arp
	}
	t.Arp = &SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp{}
	return t.Arp
}

// GetOrCreateDhcpClient retrieves the value of the DhcpClient field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4) GetOrCreateDhcpClient() *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpClient {
	if t.DhcpClient != nil {
		return t.DhcpClient
	}
	t.DhcpClient = &SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpClient{}
	return t.DhcpClient
}

// GetOrCreateDhcpRelay retrieves the value of the DhcpRelay field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4) GetOrCreateDhcpRelay() *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpRelay {
	if t.DhcpRelay != nil {
		return t.DhcpRelay
	}
	t.DhcpRelay = &SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpRelay{}
	return t.DhcpRelay
}

// GetOrCreateDhcpServer retrieves the value of the DhcpServer field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4) GetOrCreateDhcpServer() *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpServer {
	if t.DhcpServer != nil {
		return t.DhcpServer
	}
	t.DhcpServer = &SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpServer{}
	return t.DhcpServer
}

// GetOrCreateUnnumbered retrieves the value of the Unnumbered field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4) GetOrCreateUnnumbered() *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Unnumbered {
	if t.Unnumbered != nil {
		return t.Unnumbered
	}
	t.Unnumbered = &SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Unnumbered{}
	return t.Unnumbered
}

// GetArp returns the value of the Arp struct pointer
// from SrlNokiaInterfaces_Interface_Subinterface_Ipv4. If the receiver or the field Arp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4) GetArp() *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp {
	if t != nil && t.Arp != nil {
		return t.Arp
	}
	return nil
}

// GetDhcpClient returns the value of the DhcpClient struct pointer
// from SrlNokiaInterfaces_Interface_Subinterface_Ipv4. If the receiver or the field DhcpClient is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4) GetDhcpClient() *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpClient {
	if t != nil && t.DhcpClient != nil {
		return t.DhcpClient
	}
	return nil
}

// GetDhcpRelay returns the value of the DhcpRelay struct pointer
// from SrlNokiaInterfaces_Interface_Subinterface_Ipv4. If the receiver or the field DhcpRelay is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4) GetDhcpRelay() *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpRelay {
	if t != nil && t.DhcpRelay != nil {
		return t.DhcpRelay
	}
	return nil
}

// GetDhcpServer returns the value of the DhcpServer struct pointer
// from SrlNokiaInterfaces_Interface_Subinterface_Ipv4. If the receiver or the field DhcpServer is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4) GetDhcpServer() *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpServer {
	if t != nil && t.DhcpServer != nil {
		return t.DhcpServer
	}
	return nil
}

// GetUnnumbered returns the value of the Unnumbered struct pointer
// from SrlNokiaInterfaces_Interface_Subinterface_Ipv4. If the receiver or the field Unnumbered is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4) GetUnnumbered() *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Unnumbered {
	if t != nil && t.Unnumbered != nil {
		return t.Unnumbered
	}
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaInterfaces_Interface_Subinterface_Ipv4
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_disable
	}
	return t.AdminState
}

// GetAllowDirectedBroadcast retrieves the value of the leaf AllowDirectedBroadcast from the SrlNokiaInterfaces_Interface_Subinterface_Ipv4
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AllowDirectedBroadcast is set, it can
// safely use t.GetAllowDirectedBroadcast() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AllowDirectedBroadcast == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4) GetAllowDirectedBroadcast() bool {
	if t == nil || t.AllowDirectedBroadcast == nil {
		return false
	}
	return *t.AllowDirectedBroadcast
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_Ipv4
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_disable
	}
	if t.AllowDirectedBroadcast == nil {
		var v bool = false
		t.AllowDirectedBroadcast = &v
	}
	t.Arp.PopulateDefaults()
	t.DhcpClient.PopulateDefaults()
	t.DhcpRelay.PopulateDefaults()
	t.DhcpServer.PopulateDefaults()
	t.Unnumbered.PopulateDefaults()
	for _, e := range t.Address {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Ipv4"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_Ipv4.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv4) ΛBelongingModule() string {
	return "srl_nokia-interfaces"
}

// SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address represents the /srl_nokia-interfaces/interface/subinterface/ipv4/address YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address struct {
	AnycastGw *bool                                                        `path:"anycast-gw" module:"srl_nokia-interfaces"`
	IpPrefix  *string                                                      `path:"ip-prefix" module:"srl_nokia-interfaces"`
	Primary   YANGEmpty                                                    `path:"primary" module:"srl_nokia-interfaces"`
	Vrrp      *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp `path:"vrrp" module:"srl_nokia-interfaces-ip-vrrp" yangPresence:"true"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address) IsYANGGoStruct() {}

// GetOrCreateVrrp retrieves the value of the Vrrp field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address) GetOrCreateVrrp() *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp {
	if t.Vrrp != nil {
		return t.Vrrp
	}
	t.Vrrp = &SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp{}
	return t.Vrrp
}

// GetVrrp returns the value of the Vrrp struct pointer
// from SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address. If the receiver or the field Vrrp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address) GetVrrp() *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp {
	if t != nil && t.Vrrp != nil {
		return t.Vrrp
	}
	return nil
}

// GetAnycastGw retrieves the value of the leaf AnycastGw from the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AnycastGw is set, it can
// safely use t.GetAnycastGw() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AnycastGw == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address) GetAnycastGw() bool {
	if t == nil || t.AnycastGw == nil {
		return false
	}
	return *t.AnycastGw
}

// GetIpPrefix retrieves the value of the leaf IpPrefix from the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IpPrefix is set, it can
// safely use t.GetIpPrefix() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IpPrefix == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address) GetIpPrefix() string {
	if t == nil || t.IpPrefix == nil {
		return ""
	}
	return *t.IpPrefix
}

// GetPrimary retrieves the value of the leaf Primary from the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Primary is set, it can
// safely use t.GetPrimary() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Primary == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address) GetPrimary() YANGEmpty {
	if t == nil || t.Primary == false {
		return false
	}
	return t.Primary
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Vrrp.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address struct, which is a YANG list entry.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address) ΛListKeyMap() (map[string]interface{}, error) {
	if t.IpPrefix == nil {
		return nil, fmt.Errorf("nil value for key IpPrefix")
	}

	return map[string]interface{}{
		"ip-prefix": *t.IpPrefix,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address) ΛBelongingModule() string {
	return "srl_nokia-interfaces"
}

// SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp represents the /srl_nokia-interfaces/interface/subinterface/ipv4/address/vrrp YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp struct {
	VrrpGroup map[uint8]*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup `path:"vrrp-group" module:"srl_nokia-interfaces-ip-vrrp"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp) IsYANGGoStruct() {}

// NewVrrpGroup creates a new entry in the VrrpGroup list of the
// SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp) NewVrrpGroup(
	VirtualRouterId uint8,
) (*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.VrrpGroup == nil {
		t.VrrpGroup = make(map[uint8]*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup)
	}

	key := VirtualRouterId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.VrrpGroup[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list VrrpGroup", key)
	}

	t.VrrpGroup[key] = &SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup{
		VirtualRouterId: &VirtualRouterId,
	}

	return t.VrrpGroup[key], nil
}

// RenameVrrpGroup renames an entry in the list VrrpGroup within
// the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp) RenameVrrpGroup(oldK, newK uint8) error {
	if _, ok := t.VrrpGroup[newK]; ok {
		return fmt.Errorf("key %v already exists in VrrpGroup", newK)
	}

	e, ok := t.VrrpGroup[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in VrrpGroup", oldK)
	}
	e.VirtualRouterId = &newK

	t.VrrpGroup[newK] = e
	delete(t.VrrpGroup, oldK)
	return nil
}

// GetOrCreateVrrpGroup retrieves the value with the specified keys from
// the receiver SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp) GetOrCreateVrrpGroup(
	VirtualRouterId uint8,
) *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup {
	key := VirtualRouterId

	if v, ok := t.VrrpGroup[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewVrrpGroup(VirtualRouterId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateVrrpGroup got unexpected error: %v", err))
	}
	return v
}

// GetVrrpGroup retrieves the value with the specified key from
// the VrrpGroup map field of SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp) GetVrrpGroup(
	VirtualRouterId uint8,
) *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup {
	if t == nil {
		return nil
	}

	key := VirtualRouterId

	if lm, ok := t.VrrpGroup[key]; ok {
		return lm
	}
	return nil
}

// DeleteVrrpGroup deletes the value with the specified keys from
// the receiver SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp) DeleteVrrpGroup(VirtualRouterId uint8) {
	key := VirtualRouterId

	delete(t.VrrpGroup, key)
}

// AppendVrrpGroup appends the supplied SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup struct to the
// list VrrpGroup of SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp. If the key value(s) specified in
// the supplied SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup already exist in the list, an error is
// returned.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp) AppendVrrpGroup(
	v *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup,
) error {
	if v.VirtualRouterId == nil {
		return fmt.Errorf("invalid nil key received for VirtualRouterId")
	}

	key := *v.VirtualRouterId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.VrrpGroup == nil {
		t.VrrpGroup = make(map[uint8]*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup)
	}

	if _, ok := t.VrrpGroup[key]; ok {
		return fmt.Errorf("duplicate key for list VrrpGroup %v", key)
	}

	t.VrrpGroup[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.VrrpGroup {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp) ΛBelongingModule() string {
	return "srl_nokia-interfaces-ip-vrrp"
}

// SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup represents the /srl_nokia-interfaces/interface/subinterface/ipv4/address/vrrp/vrrp-group YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup struct {
	AcceptMode            *bool                                                                                    `path:"accept-mode" module:"srl_nokia-interfaces-ip-vrrp"`
	AdminState            E_SrlNokiaCommon_AdminState                                                              `path:"admin-state" module:"srl_nokia-interfaces-ip-vrrp"`
	AdvertiseInterval     *uint16                                                                                  `path:"advertise-interval" module:"srl_nokia-interfaces-ip-vrrp"`
	Authentication        *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_Authentication    `path:"authentication" module:"srl_nokia-interfaces-ip-vrrp"`
	InitDelay             *uint16                                                                                  `path:"init-delay" module:"srl_nokia-interfaces-ip-vrrp"`
	InterfaceTracking     *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking `path:"interface-tracking" module:"srl_nokia-interfaces-ip-vrrp"`
	MasterInheritInterval *bool                                                                                    `path:"master-inherit-interval" module:"srl_nokia-interfaces-ip-vrrp"`
	OperInterval          *uint16                                                                                  `path:"oper-interval" module:"srl_nokia-interfaces-ip-vrrp"`
	Preempt               *bool                                                                                    `path:"preempt" module:"srl_nokia-interfaces-ip-vrrp"`
	PreemptDelay          *uint16                                                                                  `path:"preempt-delay" module:"srl_nokia-interfaces-ip-vrrp"`
	Priority              *uint8                                                                                   `path:"priority" module:"srl_nokia-interfaces-ip-vrrp"`
	Statistics            *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_Statistics        `path:"statistics" module:"srl_nokia-interfaces-ip-vrrp"`
	Version               *uint8                                                                                   `path:"version" module:"srl_nokia-interfaces-ip-vrrp"`
	VirtualAddress        []string                                                                                 `path:"virtual-address" module:"srl_nokia-interfaces-ip-vrrp"`
	VirtualRouterId       *uint8                                                                                   `path:"virtual-router-id" module:"srl_nokia-interfaces-ip-vrrp"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup) IsYANGGoStruct() {}

// GetOrCreateAuthentication retrieves the value of the Authentication field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup) GetOrCreateAuthentication() *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_Authentication {
	if t.Authentication != nil {
		return t.Authentication
	}
	t.Authentication = &SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_Authentication{}
	return t.Authentication
}

// GetOrCreateInterfaceTracking retrieves the value of the InterfaceTracking field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup) GetOrCreateInterfaceTracking() *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking {
	if t.InterfaceTracking != nil {
		return t.InterfaceTracking
	}
	t.InterfaceTracking = &SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking{}
	return t.InterfaceTracking
}

// GetOrCreateStatistics retrieves the value of the Statistics field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup) GetOrCreateStatistics() *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_Statistics {
	if t.Statistics != nil {
		return t.Statistics
	}
	t.Statistics = &SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_Statistics{}
	return t.Statistics
}

// GetAuthentication returns the value of the Authentication struct pointer
// from SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup. If the receiver or the field Authentication is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup) GetAuthentication() *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_Authentication {
	if t != nil && t.Authentication != nil {
		return t.Authentication
	}
	return nil
}

// GetInterfaceTracking returns the value of the InterfaceTracking struct pointer
// from SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup. If the receiver or the field InterfaceTracking is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup) GetInterfaceTracking() *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking {
	if t != nil && t.InterfaceTracking != nil {
		return t.InterfaceTracking
	}
	return nil
}

// GetStatistics returns the value of the Statistics struct pointer
// from SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup. If the receiver or the field Statistics is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup) GetStatistics() *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_Statistics {
	if t != nil && t.Statistics != nil {
		return t.Statistics
	}
	return nil
}

// GetAcceptMode retrieves the value of the leaf AcceptMode from the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AcceptMode is set, it can
// safely use t.GetAcceptMode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AcceptMode == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup) GetAcceptMode() bool {
	if t == nil || t.AcceptMode == nil {
		return false
	}
	return *t.AcceptMode
}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_enable
	}
	return t.AdminState
}

// GetAdvertiseInterval retrieves the value of the leaf AdvertiseInterval from the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdvertiseInterval is set, it can
// safely use t.GetAdvertiseInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdvertiseInterval == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup) GetAdvertiseInterval() uint16 {
	if t == nil || t.AdvertiseInterval == nil {
		return 1000
	}
	return *t.AdvertiseInterval
}

// GetInitDelay retrieves the value of the leaf InitDelay from the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InitDelay is set, it can
// safely use t.GetInitDelay() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InitDelay == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup) GetInitDelay() uint16 {
	if t == nil || t.InitDelay == nil {
		return 0
	}
	return *t.InitDelay
}

// GetMasterInheritInterval retrieves the value of the leaf MasterInheritInterval from the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MasterInheritInterval is set, it can
// safely use t.GetMasterInheritInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MasterInheritInterval == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup) GetMasterInheritInterval() bool {
	if t == nil || t.MasterInheritInterval == nil {
		return false
	}
	return *t.MasterInheritInterval
}

// GetOperInterval retrieves the value of the leaf OperInterval from the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OperInterval is set, it can
// safely use t.GetOperInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OperInterval == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup) GetOperInterval() uint16 {
	if t == nil || t.OperInterval == nil {
		return 0
	}
	return *t.OperInterval
}

// GetPreempt retrieves the value of the leaf Preempt from the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Preempt is set, it can
// safely use t.GetPreempt() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Preempt == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup) GetPreempt() bool {
	if t == nil || t.Preempt == nil {
		return false
	}
	return *t.Preempt
}

// GetPreemptDelay retrieves the value of the leaf PreemptDelay from the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PreemptDelay is set, it can
// safely use t.GetPreemptDelay() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PreemptDelay == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup) GetPreemptDelay() uint16 {
	if t == nil || t.PreemptDelay == nil {
		return 0
	}
	return *t.PreemptDelay
}

// GetPriority retrieves the value of the leaf Priority from the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Priority is set, it can
// safely use t.GetPriority() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Priority == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup) GetPriority() uint8 {
	if t == nil || t.Priority == nil {
		return 100
	}
	return *t.Priority
}

// GetVersion retrieves the value of the leaf Version from the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Version is set, it can
// safely use t.GetVersion() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Version == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup) GetVersion() uint8 {
	if t == nil || t.Version == nil {
		return 2
	}
	return *t.Version
}

// GetVirtualAddress retrieves the value of the leaf VirtualAddress from the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VirtualAddress is set, it can
// safely use t.GetVirtualAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VirtualAddress == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup) GetVirtualAddress() []string {
	if t == nil || t.VirtualAddress == nil {
		return nil
	}
	return t.VirtualAddress
}

// GetVirtualRouterId retrieves the value of the leaf VirtualRouterId from the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VirtualRouterId is set, it can
// safely use t.GetVirtualRouterId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VirtualRouterId == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup) GetVirtualRouterId() uint8 {
	if t == nil || t.VirtualRouterId == nil {
		return 0
	}
	return *t.VirtualRouterId
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_enable
	}
	if t.AdvertiseInterval == nil {
		var v uint16 = 1000
		t.AdvertiseInterval = &v
	}
	if t.MasterInheritInterval == nil {
		var v bool = false
		t.MasterInheritInterval = &v
	}
	if t.Priority == nil {
		var v uint8 = 100
		t.Priority = &v
	}
	if t.Version == nil {
		var v uint8 = 2
		t.Version = &v
	}
	t.Authentication.PopulateDefaults()
	t.InterfaceTracking.PopulateDefaults()
	t.Statistics.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup struct, which is a YANG list entry.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup) ΛListKeyMap() (map[string]interface{}, error) {
	if t.VirtualRouterId == nil {
		return nil, fmt.Errorf("nil value for key VirtualRouterId")
	}

	return map[string]interface{}{
		"virtual-router-id": *t.VirtualRouterId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup) ΛBelongingModule() string {
	return "srl_nokia-interfaces-ip-vrrp"
}

// SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_Authentication represents the /srl_nokia-interfaces/interface/subinterface/ipv4/address/vrrp/vrrp-group/authentication YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_Authentication struct {
	Keychain *string `path:"keychain" module:"srl_nokia-interfaces-ip-vrrp"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_Authentication implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_Authentication) IsYANGGoStruct() {
}

// GetKeychain retrieves the value of the leaf Keychain from the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_Authentication
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Keychain is set, it can
// safely use t.GetKeychain() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Keychain == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_Authentication) GetKeychain() string {
	if t == nil || t.Keychain == nil {
		return ""
	}
	return *t.Keychain
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_Authentication
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_Authentication) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_Authentication) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_Authentication"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_Authentication) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_Authentication) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_Authentication.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_Authentication) ΛBelongingModule() string {
	return "srl_nokia-interfaces-ip-vrrp"
}

// SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking represents the /srl_nokia-interfaces/interface/subinterface/ipv4/address/vrrp/vrrp-group/interface-tracking YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking struct {
	TrackInterface map[string]*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface `path:"track-interface" module:"srl_nokia-interfaces-ip-vrrp"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking) IsYANGGoStruct() {
}

// NewTrackInterface creates a new entry in the TrackInterface list of the
// SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking) NewTrackInterface(
	Interface string,
) (*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.TrackInterface == nil {
		t.TrackInterface = make(map[string]*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface)
	}

	key := Interface

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.TrackInterface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list TrackInterface", key)
	}

	t.TrackInterface[key] = &SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface{
		Interface: &Interface,
	}

	return t.TrackInterface[key], nil
}

// RenameTrackInterface renames an entry in the list TrackInterface within
// the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking) RenameTrackInterface(oldK, newK string) error {
	if _, ok := t.TrackInterface[newK]; ok {
		return fmt.Errorf("key %v already exists in TrackInterface", newK)
	}

	e, ok := t.TrackInterface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in TrackInterface", oldK)
	}
	e.Interface = &newK

	t.TrackInterface[newK] = e
	delete(t.TrackInterface, oldK)
	return nil
}

// GetOrCreateTrackInterface retrieves the value with the specified keys from
// the receiver SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking) GetOrCreateTrackInterface(
	Interface string,
) *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface {
	key := Interface

	if v, ok := t.TrackInterface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewTrackInterface(Interface)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateTrackInterface got unexpected error: %v", err))
	}
	return v
}

// GetTrackInterface retrieves the value with the specified key from
// the TrackInterface map field of SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking) GetTrackInterface(
	Interface string,
) *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface {
	if t == nil {
		return nil
	}

	key := Interface

	if lm, ok := t.TrackInterface[key]; ok {
		return lm
	}
	return nil
}

// DeleteTrackInterface deletes the value with the specified keys from
// the receiver SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking) DeleteTrackInterface(Interface string) {
	key := Interface

	delete(t.TrackInterface, key)
}

// AppendTrackInterface appends the supplied SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface struct to the
// list TrackInterface of SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking. If the key value(s) specified in
// the supplied SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface already exist in the list, an error is
// returned.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking) AppendTrackInterface(
	v *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface,
) error {
	if v.Interface == nil {
		return fmt.Errorf("invalid nil key received for Interface")
	}

	key := *v.Interface

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.TrackInterface == nil {
		t.TrackInterface = make(map[string]*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface)
	}

	if _, ok := t.TrackInterface[key]; ok {
		return fmt.Errorf("duplicate key for list TrackInterface %v", key)
	}

	t.TrackInterface[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.TrackInterface {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking) ΛBelongingModule() string {
	return "srl_nokia-interfaces-ip-vrrp"
}

// SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface represents the /srl_nokia-interfaces/interface/subinterface/ipv4/address/vrrp/vrrp-group/interface-tracking/track-interface YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface struct {
	Interface         *string `path:"interface" module:"srl_nokia-interfaces-ip-vrrp"`
	PriorityDecrement *uint8  `path:"priority-decrement" module:"srl_nokia-interfaces-ip-vrrp"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface) IsYANGGoStruct() {
}

// GetInterface retrieves the value of the leaf Interface from the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interface is set, it can
// safely use t.GetInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interface == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface) GetInterface() string {
	if t == nil || t.Interface == nil {
		return ""
	}
	return *t.Interface
}

// GetPriorityDecrement retrieves the value of the leaf PriorityDecrement from the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PriorityDecrement is set, it can
// safely use t.GetPriorityDecrement() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PriorityDecrement == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface) GetPriorityDecrement() uint8 {
	if t == nil || t.PriorityDecrement == nil {
		return 0
	}
	return *t.PriorityDecrement
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface struct, which is a YANG list entry.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Interface == nil {
		return nil, fmt.Errorf("nil value for key Interface")
	}

	return map[string]interface{}{
		"interface": *t.Interface,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface) ΛBelongingModule() string {
	return "srl_nokia-interfaces-ip-vrrp"
}

// SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_Statistics represents the /srl_nokia-interfaces/interface/subinterface/ipv4/address/vrrp/vrrp-group/statistics YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_Statistics struct{}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_Statistics implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_Statistics) IsYANGGoStruct() {
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_Statistics
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_Statistics) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_Statistics) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_Statistics"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_Statistics) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_Statistics) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_Statistics.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_Statistics) ΛBelongingModule() string {
	return "srl_nokia-interfaces-ip-vrrp"
}

// SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp represents the /srl_nokia-interfaces/interface/subinterface/ipv4/arp YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp struct {
	Debug                     []E_SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Debug             `path:"debug" module:"srl_nokia-interfaces-nbr"`
	DuplicateAddressDetection *bool                                                                    `path:"duplicate-address-detection" module:"srl_nokia-interfaces-nbr"`
	Evpn                      *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn                 `path:"evpn" module:"srl_nokia-interfaces-nbr-evpn" yangPresence:"true"`
	HostRoute                 *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute            `path:"host-route" module:"srl_nokia-interfaces-nbr"`
	LearnUnsolicited          *bool                                                                    `path:"learn-unsolicited" module:"srl_nokia-interfaces-nbr"`
	Neighbor                  map[string]*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Neighbor  `path:"neighbor" module:"srl_nokia-interfaces-nbr"`
	ProxyArp                  *bool                                                                    `path:"proxy-arp" module:"srl_nokia-interfaces-nbr"`
	Timeout                   *uint16                                                                  `path:"timeout" module:"srl_nokia-interfaces-nbr"`
	VirtualIpv4Discovery      *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery `path:"virtual-ipv4-discovery" module:"srl_nokia-interfaces-nbr-virtual-ip-discovery" yangPresence:"true"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp) IsYANGGoStruct() {}

// NewNeighbor creates a new entry in the Neighbor list of the
// SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp) NewNeighbor(Ipv4Address string) (*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Neighbor, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Neighbor)
	}

	key := Ipv4Address

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Neighbor[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Neighbor", key)
	}

	t.Neighbor[key] = &SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Neighbor{
		Ipv4Address: &Ipv4Address,
	}

	return t.Neighbor[key], nil
}

// RenameNeighbor renames an entry in the list Neighbor within
// the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp) RenameNeighbor(oldK, newK string) error {
	if _, ok := t.Neighbor[newK]; ok {
		return fmt.Errorf("key %v already exists in Neighbor", newK)
	}

	e, ok := t.Neighbor[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Neighbor", oldK)
	}
	e.Ipv4Address = &newK

	t.Neighbor[newK] = e
	delete(t.Neighbor, oldK)
	return nil
}

// GetOrCreateNeighbor retrieves the value with the specified keys from
// the receiver SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp) GetOrCreateNeighbor(Ipv4Address string) *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Neighbor {
	key := Ipv4Address

	if v, ok := t.Neighbor[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNeighbor(Ipv4Address)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNeighbor got unexpected error: %v", err))
	}
	return v
}

// GetNeighbor retrieves the value with the specified key from
// the Neighbor map field of SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp) GetNeighbor(Ipv4Address string) *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Neighbor {
	if t == nil {
		return nil
	}

	key := Ipv4Address

	if lm, ok := t.Neighbor[key]; ok {
		return lm
	}
	return nil
}

// DeleteNeighbor deletes the value with the specified keys from
// the receiver SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp) DeleteNeighbor(Ipv4Address string) {
	key := Ipv4Address

	delete(t.Neighbor, key)
}

// AppendNeighbor appends the supplied SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Neighbor struct to the
// list Neighbor of SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp. If the key value(s) specified in
// the supplied SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Neighbor already exist in the list, an error is
// returned.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp) AppendNeighbor(
	v *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Neighbor,
) error {
	if v.Ipv4Address == nil {
		return fmt.Errorf("invalid nil key received for Ipv4Address")
	}

	key := *v.Ipv4Address

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Neighbor)
	}

	if _, ok := t.Neighbor[key]; ok {
		return fmt.Errorf("duplicate key for list Neighbor %v", key)
	}

	t.Neighbor[key] = v
	return nil
}

// GetOrCreateEvpn retrieves the value of the Evpn field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp) GetOrCreateEvpn() *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn {
	if t.Evpn != nil {
		return t.Evpn
	}
	t.Evpn = &SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn{}
	return t.Evpn
}

// GetOrCreateHostRoute retrieves the value of the HostRoute field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp) GetOrCreateHostRoute() *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute {
	if t.HostRoute != nil {
		return t.HostRoute
	}
	t.HostRoute = &SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute{}
	return t.HostRoute
}

// GetOrCreateVirtualIpv4Discovery retrieves the value of the VirtualIpv4Discovery field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp) GetOrCreateVirtualIpv4Discovery() *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery {
	if t.VirtualIpv4Discovery != nil {
		return t.VirtualIpv4Discovery
	}
	t.VirtualIpv4Discovery = &SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery{}
	return t.VirtualIpv4Discovery
}

// GetEvpn returns the value of the Evpn struct pointer
// from SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp. If the receiver or the field Evpn is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp) GetEvpn() *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn {
	if t != nil && t.Evpn != nil {
		return t.Evpn
	}
	return nil
}

// GetHostRoute returns the value of the HostRoute struct pointer
// from SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp. If the receiver or the field HostRoute is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp) GetHostRoute() *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute {
	if t != nil && t.HostRoute != nil {
		return t.HostRoute
	}
	return nil
}

// GetVirtualIpv4Discovery returns the value of the VirtualIpv4Discovery struct pointer
// from SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp. If the receiver or the field VirtualIpv4Discovery is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp) GetVirtualIpv4Discovery() *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery {
	if t != nil && t.VirtualIpv4Discovery != nil {
		return t.VirtualIpv4Discovery
	}
	return nil
}

// GetDebug retrieves the value of the leaf Debug from the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Debug is set, it can
// safely use t.GetDebug() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Debug == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp) GetDebug() []E_SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Debug {
	if t == nil || t.Debug == nil {
		return nil
	}
	return t.Debug
}

// GetDuplicateAddressDetection retrieves the value of the leaf DuplicateAddressDetection from the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DuplicateAddressDetection is set, it can
// safely use t.GetDuplicateAddressDetection() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DuplicateAddressDetection == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp) GetDuplicateAddressDetection() bool {
	if t == nil || t.DuplicateAddressDetection == nil {
		return true
	}
	return *t.DuplicateAddressDetection
}

// GetLearnUnsolicited retrieves the value of the leaf LearnUnsolicited from the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LearnUnsolicited is set, it can
// safely use t.GetLearnUnsolicited() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LearnUnsolicited == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp) GetLearnUnsolicited() bool {
	if t == nil || t.LearnUnsolicited == nil {
		return false
	}
	return *t.LearnUnsolicited
}

// GetProxyArp retrieves the value of the leaf ProxyArp from the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ProxyArp is set, it can
// safely use t.GetProxyArp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ProxyArp == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp) GetProxyArp() bool {
	if t == nil || t.ProxyArp == nil {
		return false
	}
	return *t.ProxyArp
}

// GetTimeout retrieves the value of the leaf Timeout from the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Timeout is set, it can
// safely use t.GetTimeout() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Timeout == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp) GetTimeout() uint16 {
	if t == nil || t.Timeout == nil {
		return 14400
	}
	return *t.Timeout
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.DuplicateAddressDetection == nil {
		var v bool = true
		t.DuplicateAddressDetection = &v
	}
	if t.LearnUnsolicited == nil {
		var v bool = false
		t.LearnUnsolicited = &v
	}
	if t.ProxyArp == nil {
		var v bool = false
		t.ProxyArp = &v
	}
	if t.Timeout == nil {
		var v uint16 = 14400
		t.Timeout = &v
	}
	t.Evpn.PopulateDefaults()
	t.HostRoute.PopulateDefaults()
	t.VirtualIpv4Discovery.PopulateDefaults()
	for _, e := range t.Neighbor {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp) ΛBelongingModule() string {
	return "srl_nokia-interfaces-nbr"
}

// SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn represents the /srl_nokia-interfaces/interface/subinterface/ipv4/arp/evpn YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn struct {
	Advertise map[E_SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn_Advertise_RouteType]*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn_Advertise `path:"advertise" module:"srl_nokia-interfaces-nbr-evpn"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn) IsYANGGoStruct() {}

// NewAdvertise creates a new entry in the Advertise list of the
// SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn) NewAdvertise(
	RouteType E_SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn_Advertise_RouteType,
) (*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn_Advertise, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Advertise == nil {
		t.Advertise = make(map[E_SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn_Advertise_RouteType]*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn_Advertise)
	}

	key := RouteType

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Advertise[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Advertise", key)
	}

	t.Advertise[key] = &SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn_Advertise{
		RouteType: RouteType,
	}

	return t.Advertise[key], nil
}

// RenameAdvertise renames an entry in the list Advertise within
// the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn) RenameAdvertise(
	oldK, newK E_SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn_Advertise_RouteType,
) error {
	if _, ok := t.Advertise[newK]; ok {
		return fmt.Errorf("key %v already exists in Advertise", newK)
	}

	e, ok := t.Advertise[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Advertise", oldK)
	}
	e.RouteType = newK

	t.Advertise[newK] = e
	delete(t.Advertise, oldK)
	return nil
}

// GetOrCreateAdvertise retrieves the value with the specified keys from
// the receiver SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn) GetOrCreateAdvertise(
	RouteType E_SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn_Advertise_RouteType,
) *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn_Advertise {
	key := RouteType

	if v, ok := t.Advertise[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAdvertise(RouteType)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAdvertise got unexpected error: %v", err))
	}
	return v
}

// GetAdvertise retrieves the value with the specified key from
// the Advertise map field of SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn) GetAdvertise(
	RouteType E_SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn_Advertise_RouteType,
) *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn_Advertise {
	if t == nil {
		return nil
	}

	key := RouteType

	if lm, ok := t.Advertise[key]; ok {
		return lm
	}
	return nil
}

// DeleteAdvertise deletes the value with the specified keys from
// the receiver SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn) DeleteAdvertise(
	RouteType E_SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn_Advertise_RouteType,
) {
	key := RouteType

	delete(t.Advertise, key)
}

// AppendAdvertise appends the supplied SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn_Advertise struct to the
// list Advertise of SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn. If the key value(s) specified in
// the supplied SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn_Advertise already exist in the list, an error is
// returned.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn) AppendAdvertise(
	v *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn_Advertise,
) error {
	key := v.RouteType

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Advertise == nil {
		t.Advertise = make(map[E_SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn_Advertise_RouteType]*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn_Advertise)
	}

	if _, ok := t.Advertise[key]; ok {
		return fmt.Errorf("duplicate key for list Advertise %v", key)
	}

	t.Advertise[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Advertise {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn) ΛBelongingModule() string {
	return "srl_nokia-interfaces-nbr-evpn"
}

// SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn_Advertise represents the /srl_nokia-interfaces/interface/subinterface/ipv4/arp/evpn/advertise YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn_Advertise struct {
	InternalTags *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn_Advertise_InternalTags `path:"internal-tags" module:"srl_nokia-interfaces-nbr-evpn"`
	RouteType    E_SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn_Advertise_RouteType   `path:"route-type" module:"srl_nokia-interfaces-nbr-evpn"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn_Advertise implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn_Advertise) IsYANGGoStruct() {}

// GetOrCreateInternalTags retrieves the value of the InternalTags field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn_Advertise) GetOrCreateInternalTags() *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn_Advertise_InternalTags {
	if t.InternalTags != nil {
		return t.InternalTags
	}
	t.InternalTags = &SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn_Advertise_InternalTags{}
	return t.InternalTags
}

// GetInternalTags returns the value of the InternalTags struct pointer
// from SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn_Advertise. If the receiver or the field InternalTags is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn_Advertise) GetInternalTags() *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn_Advertise_InternalTags {
	if t != nil && t.InternalTags != nil {
		return t.InternalTags
	}
	return nil
}

// GetRouteType retrieves the value of the leaf RouteType from the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn_Advertise
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RouteType is set, it can
// safely use t.GetRouteType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RouteType == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn_Advertise) GetRouteType() E_SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn_Advertise_RouteType {
	if t == nil || t.RouteType == 0 {
		return 0
	}
	return t.RouteType
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn_Advertise
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn_Advertise) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.InternalTags.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn_Advertise struct, which is a YANG list entry.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn_Advertise) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"route-type": t.RouteType,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn_Advertise) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn_Advertise"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn_Advertise) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn_Advertise) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn_Advertise.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn_Advertise) ΛBelongingModule() string {
	return "srl_nokia-interfaces-nbr-evpn"
}

// SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn_Advertise_InternalTags represents the /srl_nokia-interfaces/interface/subinterface/ipv4/arp/evpn/advertise/internal-tags YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn_Advertise_InternalTags struct {
	TagSet []string `path:"tag-set" module:"srl_nokia-interfaces-nbr-evpn"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn_Advertise_InternalTags implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn_Advertise_InternalTags) IsYANGGoStruct() {
}

// GetTagSet retrieves the value of the leaf TagSet from the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn_Advertise_InternalTags
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TagSet is set, it can
// safely use t.GetTagSet() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TagSet == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn_Advertise_InternalTags) GetTagSet() []string {
	if t == nil || t.TagSet == nil {
		return nil
	}
	return t.TagSet
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn_Advertise_InternalTags
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn_Advertise_InternalTags) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn_Advertise_InternalTags) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn_Advertise_InternalTags"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn_Advertise_InternalTags) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn_Advertise_InternalTags) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn_Advertise_InternalTags.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn_Advertise_InternalTags) ΛBelongingModule() string {
	return "srl_nokia-interfaces-nbr-evpn"
}

// SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute represents the /srl_nokia-interfaces/interface/subinterface/ipv4/arp/host-route YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute struct {
	Populate map[E_SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate_RouteType]*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate `path:"populate" module:"srl_nokia-interfaces-nbr"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute) IsYANGGoStruct() {}

// NewPopulate creates a new entry in the Populate list of the
// SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute) NewPopulate(
	RouteType E_SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate_RouteType,
) (*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Populate == nil {
		t.Populate = make(map[E_SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate_RouteType]*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate)
	}

	key := RouteType

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Populate[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Populate", key)
	}

	t.Populate[key] = &SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate{
		RouteType: RouteType,
	}

	return t.Populate[key], nil
}

// RenamePopulate renames an entry in the list Populate within
// the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute) RenamePopulate(
	oldK, newK E_SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate_RouteType,
) error {
	if _, ok := t.Populate[newK]; ok {
		return fmt.Errorf("key %v already exists in Populate", newK)
	}

	e, ok := t.Populate[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Populate", oldK)
	}
	e.RouteType = newK

	t.Populate[newK] = e
	delete(t.Populate, oldK)
	return nil
}

// GetOrCreatePopulate retrieves the value with the specified keys from
// the receiver SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute) GetOrCreatePopulate(
	RouteType E_SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate_RouteType,
) *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate {
	key := RouteType

	if v, ok := t.Populate[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPopulate(RouteType)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePopulate got unexpected error: %v", err))
	}
	return v
}

// GetPopulate retrieves the value with the specified key from
// the Populate map field of SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute) GetPopulate(
	RouteType E_SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate_RouteType,
) *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate {
	if t == nil {
		return nil
	}

	key := RouteType

	if lm, ok := t.Populate[key]; ok {
		return lm
	}
	return nil
}

// DeletePopulate deletes the value with the specified keys from
// the receiver SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute) DeletePopulate(
	RouteType E_SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate_RouteType,
) {
	key := RouteType

	delete(t.Populate, key)
}

// AppendPopulate appends the supplied SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate struct to the
// list Populate of SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute. If the key value(s) specified in
// the supplied SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate already exist in the list, an error is
// returned.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute) AppendPopulate(
	v *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate,
) error {
	key := v.RouteType

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Populate == nil {
		t.Populate = make(map[E_SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate_RouteType]*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate)
	}

	if _, ok := t.Populate[key]; ok {
		return fmt.Errorf("duplicate key for list Populate %v", key)
	}

	t.Populate[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Populate {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute) ΛBelongingModule() string {
	return "srl_nokia-interfaces-nbr"
}

// SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate represents the /srl_nokia-interfaces/interface/subinterface/ipv4/arp/host-route/populate YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate struct {
	DatapathProgramming *bool                                                                               `path:"datapath-programming" module:"srl_nokia-interfaces-nbr"`
	InternalTags        *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate_InternalTags `path:"internal-tags" module:"srl_nokia-interfaces-nbr"`
	RouteType           E_SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate_RouteType   `path:"route-type" module:"srl_nokia-interfaces-nbr"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate) IsYANGGoStruct() {}

// GetOrCreateInternalTags retrieves the value of the InternalTags field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate) GetOrCreateInternalTags() *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate_InternalTags {
	if t.InternalTags != nil {
		return t.InternalTags
	}
	t.InternalTags = &SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate_InternalTags{}
	return t.InternalTags
}

// GetInternalTags returns the value of the InternalTags struct pointer
// from SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate. If the receiver or the field InternalTags is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate) GetInternalTags() *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate_InternalTags {
	if t != nil && t.InternalTags != nil {
		return t.InternalTags
	}
	return nil
}

// GetDatapathProgramming retrieves the value of the leaf DatapathProgramming from the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DatapathProgramming is set, it can
// safely use t.GetDatapathProgramming() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DatapathProgramming == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate) GetDatapathProgramming() bool {
	if t == nil || t.DatapathProgramming == nil {
		return false
	}
	return *t.DatapathProgramming
}

// GetRouteType retrieves the value of the leaf RouteType from the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RouteType is set, it can
// safely use t.GetRouteType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RouteType == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate) GetRouteType() E_SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate_RouteType {
	if t == nil || t.RouteType == 0 {
		return 0
	}
	return t.RouteType
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.InternalTags.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate struct, which is a YANG list entry.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"route-type": t.RouteType,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate) ΛBelongingModule() string {
	return "srl_nokia-interfaces-nbr"
}

// SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate_InternalTags represents the /srl_nokia-interfaces/interface/subinterface/ipv4/arp/host-route/populate/internal-tags YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate_InternalTags struct {
	TagSet *string `path:"tag-set" module:"srl_nokia-interfaces-nbr"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate_InternalTags implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate_InternalTags) IsYANGGoStruct() {
}

// GetTagSet retrieves the value of the leaf TagSet from the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate_InternalTags
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TagSet is set, it can
// safely use t.GetTagSet() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TagSet == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate_InternalTags) GetTagSet() string {
	if t == nil || t.TagSet == nil {
		return ""
	}
	return *t.TagSet
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate_InternalTags
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate_InternalTags) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate_InternalTags) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate_InternalTags"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate_InternalTags) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate_InternalTags) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate_InternalTags.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate_InternalTags) ΛBelongingModule() string {
	return "srl_nokia-interfaces-nbr"
}
