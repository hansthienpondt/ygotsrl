/*
Package ygotsrl is a generated package which contains definitions
of structs which represent a YANG schema. The generated schema can be
compressed by a series of transformations (compression was false
in this case).

This package was generated by /home/hans/go/pkg/mod/github.com/openconfig/ygot@v0.29.17/genutil/names.go
using the following YANG input files:
	- work/srlinux-yang-models/srl_nokia/models/acl/srl_nokia-acl-policers.yang
	- work/srlinux-yang-models/srl_nokia/models/acl/srl_nokia-acl-qos.yang
	- work/srlinux-yang-models/srl_nokia/models/acl/srl_nokia-acl.yang
	- work/srlinux-yang-models/srl_nokia/models/acl/srl_nokia-packet-match-types.yang
	- work/srlinux-yang-models/srl_nokia/models/bfd/srl_nokia-bfd.yang
	- work/srlinux-yang-models/srl_nokia/models/bfd/srl_nokia-micro-bfd.yang
	- work/srlinux-yang-models/srl_nokia/models/common/srl_nokia-common.yang
	- work/srlinux-yang-models/srl_nokia/models/common/srl_nokia-extensions.yang
	- work/srlinux-yang-models/srl_nokia/models/common/srl_nokia-features.yang
	- work/srlinux-yang-models/srl_nokia/models/ethcfm/srl_nokia-ethcfm-types.yang
	- work/srlinux-yang-models/srl_nokia/models/ethcfm/srl_nokia-ethcfm.yang
	- work/srlinux-yang-models/srl_nokia/models/ethcfm/srl_nokia-oam-pm-ethcfm.yang
	- work/srlinux-yang-models/srl_nokia/models/grpc/srl_nokia-gnsi-authz.yang
	- work/srlinux-yang-models/srl_nokia/models/grpc/srl_nokia-gnsi-certz.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-if-ip.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-if-mpls.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-bridge-table-mac-duplication-entries.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-bridge-table-mac-learning-entries.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-bridge-table-mac-table.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-bridge-table-statistics.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-bridge-table.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-ethernet-segment-association.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-ip-dhcp-relay.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-ip-dhcp-server.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-ip-dhcp.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-ip-vrrp.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-l2cp.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-lag.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-local-mirror-destination.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-nbr-evpn.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-nbr-virtual-ip-discovery.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-nbr.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-p4rt.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-router-adv.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-vlans.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-vxdp.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-lacp.yang
	- work/srlinux-yang-models/srl_nokia/models/ipamps/srl_nokia-ippm-source-udp-pool.yang
	- work/srlinux-yang-models/srl_nokia/models/ipamps/srl_nokia-link-measurement.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-aggregate-routes.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bgp-evpn-bgp-instance-mpls-bridge-table-multicast-destinations.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bgp-evpn-bgp-instance-mpls-bridge-table-statistics.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bgp-evpn-bgp-instance-mpls-bridge-table-unicast-destinations.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bgp-evpn-bgp-instance-mpls-vpws-destinations.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bgp-evpn.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bgp-ipvpn.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bgp-vpn.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bgp.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table-mac-duplication-entries.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table-mac-duplication.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table-mac-learning-entries.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table-mac-learning.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table-mac-limit.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table-mac-table.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table-proxy-arp-nd.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table-reserved-macs.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table-shg.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table-static-mac.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-connection-point.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-icmp.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-igmp-snooping.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-igmp-types.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-igmp.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-ip-route-tables.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-isis-lsdb-types.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-isis-lsdb.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-isis.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-ldp.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-linux.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-maintenance-policies.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-mld-snooping.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-mld.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-mpls-route-tables.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-mpls.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-multicast-mfib-tables.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-mvpn-l3.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-network-instance-mtu.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-network-instance.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-next-hop-groups.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-ospf-lsdb.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-ospf-types.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-ospf.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-ospfv3-lsas.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-pcep.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-pim.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-policy-forwarding.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-rib-bgp.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-segment-routing.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-static-routes.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-tcp-udp.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-te-policies.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-traffic-engineering.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-tunnel-tables.yang
	- work/srlinux-yang-models/srl_nokia/models/oam/srl_nokia-lsp-ping-trace.yang
	- work/srlinux-yang-models/srl_nokia/models/oam/srl_nokia-oam-pm-ip.yang
	- work/srlinux-yang-models/srl_nokia/models/oam/srl_nokia-oam-pm-types.yang
	- work/srlinux-yang-models/srl_nokia/models/oam/srl_nokia-oam-pm.yang
	- work/srlinux-yang-models/srl_nokia/models/oam/srl_nokia-oam.yang
	- work/srlinux-yang-models/srl_nokia/models/oam/srl_nokia-stamp.yang
	- work/srlinux-yang-models/srl_nokia/models/oam/srl_nokia-twamp.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-acl.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-cgroup.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-chassis.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-control.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-cpu.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-datapath-resources.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-disk.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-fabric.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-fan.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-healthz.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-lc.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-linecard-fib.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-memory.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-mtu.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-p4rt.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-pipeline-counters.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-psu.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-qos.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-redundancy.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-resource-mgmt.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-resource-monitoring.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-secure-boot.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-tcam.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-tpm.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-vxdp.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform.yang
	- work/srlinux-yang-models/srl_nokia/models/qos/srl_nokia-qos-policers.yang
	- work/srlinux-yang-models/srl_nokia/models/qos/srl_nokia-qos.yang
	- work/srlinux-yang-models/srl_nokia/models/routing-policy/srl_nokia-policy-types.yang
	- work/srlinux-yang-models/srl_nokia/models/routing-policy/srl_nokia-routing-policy.yang
	- work/srlinux-yang-models/srl_nokia/models/sync/srl_nokia-sync-freq.yang
	- work/srlinux-yang-models/srl_nokia/models/sync/srl_nokia-sync-interfaces.yang
	- work/srlinux-yang-models/srl_nokia/models/sync/srl_nokia-sync-ptp.yang
	- work/srlinux-yang-models/srl_nokia/models/sync/srl_nokia-sync-types.yang
	- work/srlinux-yang-models/srl_nokia/models/sync/srl_nokia-sync.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-aaa-password.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-aaa-radius.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-aaa-tacacs.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-aaa-types.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-aaa.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-app-mgmt.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-boot.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-configuration-role.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-configuration.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-dhcp-server.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-dns.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-event-handler.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-ftp.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-gnmi-server.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-gribi-server.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-json-rpc.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-keychains.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-license.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-lldp-types.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-lldp.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-load-balancing.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-logging.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-maintenance-mode.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-mirroring.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-mpls-label-management.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-mpls-services-evpn-label-management.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-mpls-services-network-instance-label-management.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-mtu.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-ntp.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-openconfig.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-p4rt-server.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-packet-link-qual.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-ra_guard.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-sflow.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-snmp-trace.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-snmp.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-ssh.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system-banner.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system-bridge-table-proxy-arp.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system-bridge-table.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system-info.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system-multicast-mfib-table.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system-multicast.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system-name.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system-network-instance-bgp-evpn-ethernet-segments.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system-network-instance-bgp-vpn.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system-network-instance.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system-protocols.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-timezone.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-tls.yang
	- work/srlinux-yang-models/srl_nokia/models/transport-security/srl_nokia-macsec.yang
	- work/srlinux-yang-models/srl_nokia/models/transport-security/srl_nokia-transport-security.yang
	- work/srlinux-yang-models/srl_nokia/models/tunnel/srl_nokia-tunnel-interfaces-vxlan-interface-bridge-table-multicast-destinations.yang
	- work/srlinux-yang-models/srl_nokia/models/tunnel/srl_nokia-tunnel-interfaces-vxlan-interface-bridge-table-unicast-destinations.yang
	- work/srlinux-yang-models/srl_nokia/models/tunnel/srl_nokia-tunnel-interfaces-vxlan-interface-bridge-table-unicast-es-destination-vteps.yang
	- work/srlinux-yang-models/srl_nokia/models/tunnel/srl_nokia-tunnel-interfaces-vxlan-interface-bridge-table.yang
	- work/srlinux-yang-models/srl_nokia/models/tunnel/srl_nokia-tunnel-interfaces.yang
	- work/srlinux-yang-models/srl_nokia/models/tunnel/srl_nokia-tunnel.yang
	- work/srlinux-yang-models/srl_nokia/models/tunnel/srl_nokia-vxlan-tunnel-vtep.yang
Imported modules were sourced from:
	- work/srlinux-yang-models/...
*/
package ygotsrl

import (
	"fmt"
	"reflect"

	"github.com/openconfig/ygot/ygot"
	"github.com/openconfig/ygot/ytypes"
)

// SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType represents the /srl_nokia-oam/oam/performance-monitoring/ethcfm/delay/bin-group/bin-type YANG schema element.
type SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType struct {
	Bin            map[uint8]*SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType_Bin                                              `path:"bin" module:"srl_nokia-oam-pm-ethcfm"`
	BinCount       *uint8                                                                                                                          `path:"bin-count" module:"srl_nokia-oam-pm-ethcfm"`
	BinMetric      E_SrlNokiaOamPmTypes_BinMetricType                                                                                              `path:"bin-metric" module:"srl_nokia-oam-pm-ethcfm"`
	DelayEvent     map[E_SrlNokiaOamPmTypes_DelayDirectionType]*SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType_DelayEvent     `path:"delay-event" module:"srl_nokia-oam-pm-ethcfm"`
	ExcludeFromAvg map[E_SrlNokiaOamPmTypes_DelayDirectionType]*SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType_ExcludeFromAvg `path:"exclude-from-avg" module:"srl_nokia-oam-pm-ethcfm"`
}

// IsYANGGoStruct ensures that SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType) IsYANGGoStruct() {}

// NewBin creates a new entry in the Bin list of the
// SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType) NewBin(
	BinNumber uint8,
) (*SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType_Bin, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Bin == nil {
		t.Bin = make(map[uint8]*SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType_Bin)
	}

	key := BinNumber

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Bin[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Bin", key)
	}

	t.Bin[key] = &SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType_Bin{
		BinNumber: &BinNumber,
	}

	return t.Bin[key], nil
}

// RenameBin renames an entry in the list Bin within
// the SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType) RenameBin(oldK, newK uint8) error {
	if _, ok := t.Bin[newK]; ok {
		return fmt.Errorf("key %v already exists in Bin", newK)
	}

	e, ok := t.Bin[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Bin", oldK)
	}
	e.BinNumber = &newK

	t.Bin[newK] = e
	delete(t.Bin, oldK)
	return nil
}

// GetOrCreateBin retrieves the value with the specified keys from
// the receiver SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType) GetOrCreateBin(
	BinNumber uint8,
) *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType_Bin {
	key := BinNumber

	if v, ok := t.Bin[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewBin(BinNumber)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateBin got unexpected error: %v", err))
	}
	return v
}

// GetBin retrieves the value with the specified key from
// the Bin map field of SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType) GetBin(
	BinNumber uint8,
) *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType_Bin {
	if t == nil {
		return nil
	}

	key := BinNumber

	if lm, ok := t.Bin[key]; ok {
		return lm
	}
	return nil
}

// DeleteBin deletes the value with the specified keys from
// the receiver SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType) DeleteBin(BinNumber uint8) {
	key := BinNumber

	delete(t.Bin, key)
}

// AppendBin appends the supplied SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType_Bin struct to the
// list Bin of SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType. If the key value(s) specified in
// the supplied SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType_Bin already exist in the list, an error is
// returned.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType) AppendBin(
	v *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType_Bin,
) error {
	if v.BinNumber == nil {
		return fmt.Errorf("invalid nil key received for BinNumber")
	}

	key := *v.BinNumber

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Bin == nil {
		t.Bin = make(map[uint8]*SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType_Bin)
	}

	if _, ok := t.Bin[key]; ok {
		return fmt.Errorf("duplicate key for list Bin %v", key)
	}

	t.Bin[key] = v
	return nil
}

// NewDelayEvent creates a new entry in the DelayEvent list of the
// SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType) NewDelayEvent(
	Direction E_SrlNokiaOamPmTypes_DelayDirectionType,
) (*SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType_DelayEvent, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.DelayEvent == nil {
		t.DelayEvent = make(map[E_SrlNokiaOamPmTypes_DelayDirectionType]*SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType_DelayEvent)
	}

	key := Direction

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.DelayEvent[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list DelayEvent", key)
	}

	t.DelayEvent[key] = &SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType_DelayEvent{
		Direction: Direction,
	}

	return t.DelayEvent[key], nil
}

// RenameDelayEvent renames an entry in the list DelayEvent within
// the SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType) RenameDelayEvent(oldK, newK E_SrlNokiaOamPmTypes_DelayDirectionType) error {
	if _, ok := t.DelayEvent[newK]; ok {
		return fmt.Errorf("key %v already exists in DelayEvent", newK)
	}

	e, ok := t.DelayEvent[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in DelayEvent", oldK)
	}
	e.Direction = newK

	t.DelayEvent[newK] = e
	delete(t.DelayEvent, oldK)
	return nil
}

// GetOrCreateDelayEvent retrieves the value with the specified keys from
// the receiver SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType) GetOrCreateDelayEvent(
	Direction E_SrlNokiaOamPmTypes_DelayDirectionType,
) *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType_DelayEvent {
	key := Direction

	if v, ok := t.DelayEvent[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewDelayEvent(Direction)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateDelayEvent got unexpected error: %v", err))
	}
	return v
}

// GetDelayEvent retrieves the value with the specified key from
// the DelayEvent map field of SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType) GetDelayEvent(
	Direction E_SrlNokiaOamPmTypes_DelayDirectionType,
) *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType_DelayEvent {
	if t == nil {
		return nil
	}

	key := Direction

	if lm, ok := t.DelayEvent[key]; ok {
		return lm
	}
	return nil
}

// DeleteDelayEvent deletes the value with the specified keys from
// the receiver SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType) DeleteDelayEvent(Direction E_SrlNokiaOamPmTypes_DelayDirectionType) {
	key := Direction

	delete(t.DelayEvent, key)
}

// AppendDelayEvent appends the supplied SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType_DelayEvent struct to the
// list DelayEvent of SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType. If the key value(s) specified in
// the supplied SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType_DelayEvent already exist in the list, an error is
// returned.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType) AppendDelayEvent(
	v *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType_DelayEvent,
) error {
	key := v.Direction

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.DelayEvent == nil {
		t.DelayEvent = make(map[E_SrlNokiaOamPmTypes_DelayDirectionType]*SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType_DelayEvent)
	}

	if _, ok := t.DelayEvent[key]; ok {
		return fmt.Errorf("duplicate key for list DelayEvent %v", key)
	}

	t.DelayEvent[key] = v
	return nil
}

// NewExcludeFromAvg creates a new entry in the ExcludeFromAvg list of the
// SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType) NewExcludeFromAvg(
	Direction E_SrlNokiaOamPmTypes_DelayDirectionType,
) (*SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType_ExcludeFromAvg, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ExcludeFromAvg == nil {
		t.ExcludeFromAvg = make(map[E_SrlNokiaOamPmTypes_DelayDirectionType]*SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType_ExcludeFromAvg)
	}

	key := Direction

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.ExcludeFromAvg[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list ExcludeFromAvg", key)
	}

	t.ExcludeFromAvg[key] = &SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType_ExcludeFromAvg{
		Direction: Direction,
	}

	return t.ExcludeFromAvg[key], nil
}

// RenameExcludeFromAvg renames an entry in the list ExcludeFromAvg within
// the SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType) RenameExcludeFromAvg(oldK, newK E_SrlNokiaOamPmTypes_DelayDirectionType) error {
	if _, ok := t.ExcludeFromAvg[newK]; ok {
		return fmt.Errorf("key %v already exists in ExcludeFromAvg", newK)
	}

	e, ok := t.ExcludeFromAvg[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in ExcludeFromAvg", oldK)
	}
	e.Direction = newK

	t.ExcludeFromAvg[newK] = e
	delete(t.ExcludeFromAvg, oldK)
	return nil
}

// GetOrCreateExcludeFromAvg retrieves the value with the specified keys from
// the receiver SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType) GetOrCreateExcludeFromAvg(
	Direction E_SrlNokiaOamPmTypes_DelayDirectionType,
) *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType_ExcludeFromAvg {
	key := Direction

	if v, ok := t.ExcludeFromAvg[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewExcludeFromAvg(Direction)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateExcludeFromAvg got unexpected error: %v", err))
	}
	return v
}

// GetExcludeFromAvg retrieves the value with the specified key from
// the ExcludeFromAvg map field of SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType) GetExcludeFromAvg(
	Direction E_SrlNokiaOamPmTypes_DelayDirectionType,
) *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType_ExcludeFromAvg {
	if t == nil {
		return nil
	}

	key := Direction

	if lm, ok := t.ExcludeFromAvg[key]; ok {
		return lm
	}
	return nil
}

// DeleteExcludeFromAvg deletes the value with the specified keys from
// the receiver SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType) DeleteExcludeFromAvg(Direction E_SrlNokiaOamPmTypes_DelayDirectionType) {
	key := Direction

	delete(t.ExcludeFromAvg, key)
}

// AppendExcludeFromAvg appends the supplied SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType_ExcludeFromAvg struct to the
// list ExcludeFromAvg of SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType. If the key value(s) specified in
// the supplied SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType_ExcludeFromAvg already exist in the list, an error is
// returned.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType) AppendExcludeFromAvg(
	v *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType_ExcludeFromAvg,
) error {
	key := v.Direction

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ExcludeFromAvg == nil {
		t.ExcludeFromAvg = make(map[E_SrlNokiaOamPmTypes_DelayDirectionType]*SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType_ExcludeFromAvg)
	}

	if _, ok := t.ExcludeFromAvg[key]; ok {
		return fmt.Errorf("duplicate key for list ExcludeFromAvg %v", key)
	}

	t.ExcludeFromAvg[key] = v
	return nil
}

// GetBinCount retrieves the value of the leaf BinCount from the SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if BinCount is set, it can
// safely use t.GetBinCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.BinCount == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType) GetBinCount() uint8 {
	if t == nil || t.BinCount == nil {
		return 0
	}
	return *t.BinCount
}

// GetBinMetric retrieves the value of the leaf BinMetric from the SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if BinMetric is set, it can
// safely use t.GetBinMetric() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.BinMetric == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType) GetBinMetric() E_SrlNokiaOamPmTypes_BinMetricType {
	if t == nil || t.BinMetric == 0 {
		return 0
	}
	return t.BinMetric
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Bin {
		e.PopulateDefaults()
	}
	for _, e := range t.DelayEvent {
		e.PopulateDefaults()
	}
	for _, e := range t.ExcludeFromAvg {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType struct, which is a YANG list entry.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"bin-metric": t.BinMetric,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType.
func (*SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType) ΛBelongingModule() string {
	return "srl_nokia-oam-pm-ethcfm"
}

// SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType_Bin represents the /srl_nokia-oam/oam/performance-monitoring/ethcfm/delay/bin-group/bin-type/bin YANG schema element.
type SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType_Bin struct {
	BinNumber  *uint8  `path:"bin-number" module:"srl_nokia-oam-pm-ethcfm"`
	LowerBound *uint32 `path:"lower-bound" module:"srl_nokia-oam-pm-ethcfm"`
}

// IsYANGGoStruct ensures that SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType_Bin implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType_Bin) IsYANGGoStruct() {}

// GetBinNumber retrieves the value of the leaf BinNumber from the SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType_Bin
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if BinNumber is set, it can
// safely use t.GetBinNumber() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.BinNumber == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType_Bin) GetBinNumber() uint8 {
	if t == nil || t.BinNumber == nil {
		return 0
	}
	return *t.BinNumber
}

// GetLowerBound retrieves the value of the leaf LowerBound from the SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType_Bin
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LowerBound is set, it can
// safely use t.GetLowerBound() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LowerBound == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType_Bin) GetLowerBound() uint32 {
	if t == nil || t.LowerBound == nil {
		return 0
	}
	return *t.LowerBound
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType_Bin
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType_Bin) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType_Bin struct, which is a YANG list entry.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType_Bin) ΛListKeyMap() (map[string]interface{}, error) {
	if t.BinNumber == nil {
		return nil, fmt.Errorf("nil value for key BinNumber")
	}

	return map[string]interface{}{
		"bin-number": *t.BinNumber,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType_Bin) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType_Bin"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType_Bin) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType_Bin) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType_Bin.
func (*SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType_Bin) ΛBelongingModule() string {
	return "srl_nokia-oam-pm-ethcfm"
}

// SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType_DelayEvent represents the /srl_nokia-oam/oam/performance-monitoring/ethcfm/delay/bin-group/bin-type/delay-event YANG schema element.
type SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType_DelayEvent struct {
	ClearThreshold   *uint32                                 `path:"clear-threshold" module:"srl_nokia-oam-pm-ethcfm"`
	Direction        E_SrlNokiaOamPmTypes_DelayDirectionType `path:"direction" module:"srl_nokia-oam-pm-ethcfm"`
	ExcludeLowestBin *uint32                                 `path:"exclude-lowest-bin" module:"srl_nokia-oam-pm-ethcfm"`
	LowestBin        *uint32                                 `path:"lowest-bin" module:"srl_nokia-oam-pm-ethcfm"`
	RaiseThreshold   *uint32                                 `path:"raise-threshold" module:"srl_nokia-oam-pm-ethcfm"`
}

// IsYANGGoStruct ensures that SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType_DelayEvent implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType_DelayEvent) IsYANGGoStruct() {
}

// GetClearThreshold retrieves the value of the leaf ClearThreshold from the SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType_DelayEvent
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ClearThreshold is set, it can
// safely use t.GetClearThreshold() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ClearThreshold == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType_DelayEvent) GetClearThreshold() uint32 {
	if t == nil || t.ClearThreshold == nil {
		return 0
	}
	return *t.ClearThreshold
}

// GetDirection retrieves the value of the leaf Direction from the SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType_DelayEvent
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Direction is set, it can
// safely use t.GetDirection() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Direction == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType_DelayEvent) GetDirection() E_SrlNokiaOamPmTypes_DelayDirectionType {
	if t == nil || t.Direction == 0 {
		return 0
	}
	return t.Direction
}

// GetExcludeLowestBin retrieves the value of the leaf ExcludeLowestBin from the SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType_DelayEvent
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ExcludeLowestBin is set, it can
// safely use t.GetExcludeLowestBin() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ExcludeLowestBin == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType_DelayEvent) GetExcludeLowestBin() uint32 {
	if t == nil || t.ExcludeLowestBin == nil {
		return 0
	}
	return *t.ExcludeLowestBin
}

// GetLowestBin retrieves the value of the leaf LowestBin from the SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType_DelayEvent
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LowestBin is set, it can
// safely use t.GetLowestBin() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LowestBin == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType_DelayEvent) GetLowestBin() uint32 {
	if t == nil || t.LowestBin == nil {
		return 0
	}
	return *t.LowestBin
}

// GetRaiseThreshold retrieves the value of the leaf RaiseThreshold from the SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType_DelayEvent
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RaiseThreshold is set, it can
// safely use t.GetRaiseThreshold() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RaiseThreshold == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType_DelayEvent) GetRaiseThreshold() uint32 {
	if t == nil || t.RaiseThreshold == nil {
		return 0
	}
	return *t.RaiseThreshold
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType_DelayEvent
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType_DelayEvent) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType_DelayEvent struct, which is a YANG list entry.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType_DelayEvent) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"direction": t.Direction,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType_DelayEvent) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType_DelayEvent"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType_DelayEvent) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType_DelayEvent) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType_DelayEvent.
func (*SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType_DelayEvent) ΛBelongingModule() string {
	return "srl_nokia-oam-pm-ethcfm"
}

// SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType_ExcludeFromAvg represents the /srl_nokia-oam/oam/performance-monitoring/ethcfm/delay/bin-group/bin-type/exclude-from-avg YANG schema element.
type SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType_ExcludeFromAvg struct {
	Bins      *string                                 `path:"bins" module:"srl_nokia-oam-pm-ethcfm"`
	Direction E_SrlNokiaOamPmTypes_DelayDirectionType `path:"direction" module:"srl_nokia-oam-pm-ethcfm"`
}

// IsYANGGoStruct ensures that SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType_ExcludeFromAvg implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType_ExcludeFromAvg) IsYANGGoStruct() {
}

// GetBins retrieves the value of the leaf Bins from the SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType_ExcludeFromAvg
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Bins is set, it can
// safely use t.GetBins() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Bins == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType_ExcludeFromAvg) GetBins() string {
	if t == nil || t.Bins == nil {
		return ""
	}
	return *t.Bins
}

// GetDirection retrieves the value of the leaf Direction from the SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType_ExcludeFromAvg
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Direction is set, it can
// safely use t.GetDirection() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Direction == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType_ExcludeFromAvg) GetDirection() E_SrlNokiaOamPmTypes_DelayDirectionType {
	if t == nil || t.Direction == 0 {
		return 0
	}
	return t.Direction
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType_ExcludeFromAvg
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType_ExcludeFromAvg) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType_ExcludeFromAvg struct, which is a YANG list entry.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType_ExcludeFromAvg) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"direction": t.Direction,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType_ExcludeFromAvg) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType_ExcludeFromAvg"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType_ExcludeFromAvg) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType_ExcludeFromAvg) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType_ExcludeFromAvg.
func (*SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Delay_BinGroup_BinType_ExcludeFromAvg) ΛBelongingModule() string {
	return "srl_nokia-oam-pm-ethcfm"
}

// SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss represents the /srl_nokia-oam/oam/performance-monitoring/ethcfm/loss YANG schema element.
type SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss struct {
	LossEventsTemplate map[string]*SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate `path:"loss-events-template" module:"srl_nokia-oam-pm-ethcfm"`
}

// IsYANGGoStruct ensures that SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss) IsYANGGoStruct() {}

// NewLossEventsTemplate creates a new entry in the LossEventsTemplate list of the
// SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss) NewLossEventsTemplate(
	LossEventsTemplateName string,
) (*SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.LossEventsTemplate == nil {
		t.LossEventsTemplate = make(map[string]*SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate)
	}

	key := LossEventsTemplateName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.LossEventsTemplate[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list LossEventsTemplate", key)
	}

	t.LossEventsTemplate[key] = &SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate{
		LossEventsTemplateName: &LossEventsTemplateName,
	}

	return t.LossEventsTemplate[key], nil
}

// RenameLossEventsTemplate renames an entry in the list LossEventsTemplate within
// the SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss) RenameLossEventsTemplate(oldK, newK string) error {
	if _, ok := t.LossEventsTemplate[newK]; ok {
		return fmt.Errorf("key %v already exists in LossEventsTemplate", newK)
	}

	e, ok := t.LossEventsTemplate[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in LossEventsTemplate", oldK)
	}
	e.LossEventsTemplateName = &newK

	t.LossEventsTemplate[newK] = e
	delete(t.LossEventsTemplate, oldK)
	return nil
}

// GetOrCreateLossEventsTemplate retrieves the value with the specified keys from
// the receiver SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss) GetOrCreateLossEventsTemplate(
	LossEventsTemplateName string,
) *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate {
	key := LossEventsTemplateName

	if v, ok := t.LossEventsTemplate[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewLossEventsTemplate(LossEventsTemplateName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateLossEventsTemplate got unexpected error: %v", err))
	}
	return v
}

// GetLossEventsTemplate retrieves the value with the specified key from
// the LossEventsTemplate map field of SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss) GetLossEventsTemplate(
	LossEventsTemplateName string,
) *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate {
	if t == nil {
		return nil
	}

	key := LossEventsTemplateName

	if lm, ok := t.LossEventsTemplate[key]; ok {
		return lm
	}
	return nil
}

// DeleteLossEventsTemplate deletes the value with the specified keys from
// the receiver SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss) DeleteLossEventsTemplate(LossEventsTemplateName string) {
	key := LossEventsTemplateName

	delete(t.LossEventsTemplate, key)
}

// AppendLossEventsTemplate appends the supplied SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate struct to the
// list LossEventsTemplate of SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss. If the key value(s) specified in
// the supplied SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate already exist in the list, an error is
// returned.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss) AppendLossEventsTemplate(
	v *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate,
) error {
	if v.LossEventsTemplateName == nil {
		return fmt.Errorf("invalid nil key received for LossEventsTemplateName")
	}

	key := *v.LossEventsTemplateName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.LossEventsTemplate == nil {
		t.LossEventsTemplate = make(map[string]*SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate)
	}

	if _, ok := t.LossEventsTemplate[key]; ok {
		return fmt.Errorf("duplicate key for list LossEventsTemplate %v", key)
	}

	t.LossEventsTemplate[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.LossEventsTemplate {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss.
func (*SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss) ΛBelongingModule() string {
	return "srl_nokia-oam-pm-ethcfm"
}

// SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate represents the /srl_nokia-oam/oam/performance-monitoring/ethcfm/loss/loss-events-template YANG schema element.
type SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate struct {
	AvgFlrEvent                     map[E_SrlNokiaOamPmTypes_LossDirectionType]*SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_AvgFlrEvent                              `path:"avg-flr-event" module:"srl_nokia-oam-pm-ethcfm"`
	ChliEvent                       map[E_SrlNokiaOamPmTypes_LossDirectionAggregateType]*SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_ChliEvent                       `path:"chli-event" module:"srl_nokia-oam-pm-ethcfm"`
	HliEvent                        map[E_SrlNokiaOamPmTypes_LossDirectionAggregateType]*SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_HliEvent                        `path:"hli-event" module:"srl_nokia-oam-pm-ethcfm"`
	LossEventsTemplateName          *string                                                                                                                                                   `path:"loss-events-template-name" module:"srl_nokia-oam-pm-ethcfm"`
	UnavailabilityEvent             map[E_SrlNokiaOamPmTypes_LossDirectionAggregateType]*SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_UnavailabilityEvent             `path:"unavailability-event" module:"srl_nokia-oam-pm-ethcfm"`
	UndeterminedAvailabilityEvent   map[E_SrlNokiaOamPmTypes_LossDirectionAggregateType]*SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_UndeterminedAvailabilityEvent   `path:"undetermined-availability-event" module:"srl_nokia-oam-pm-ethcfm"`
	UndeterminedUnavailabilityEvent map[E_SrlNokiaOamPmTypes_LossDirectionAggregateType]*SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_UndeterminedUnavailabilityEvent `path:"undetermined-unavailability-event" module:"srl_nokia-oam-pm-ethcfm"`
}

// IsYANGGoStruct ensures that SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate) IsYANGGoStruct() {}

// NewAvgFlrEvent creates a new entry in the AvgFlrEvent list of the
// SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate) NewAvgFlrEvent(
	Direction E_SrlNokiaOamPmTypes_LossDirectionType,
) (*SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_AvgFlrEvent, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AvgFlrEvent == nil {
		t.AvgFlrEvent = make(map[E_SrlNokiaOamPmTypes_LossDirectionType]*SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_AvgFlrEvent)
	}

	key := Direction

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.AvgFlrEvent[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list AvgFlrEvent", key)
	}

	t.AvgFlrEvent[key] = &SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_AvgFlrEvent{
		Direction: Direction,
	}

	return t.AvgFlrEvent[key], nil
}

// RenameAvgFlrEvent renames an entry in the list AvgFlrEvent within
// the SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate) RenameAvgFlrEvent(oldK, newK E_SrlNokiaOamPmTypes_LossDirectionType) error {
	if _, ok := t.AvgFlrEvent[newK]; ok {
		return fmt.Errorf("key %v already exists in AvgFlrEvent", newK)
	}

	e, ok := t.AvgFlrEvent[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in AvgFlrEvent", oldK)
	}
	e.Direction = newK

	t.AvgFlrEvent[newK] = e
	delete(t.AvgFlrEvent, oldK)
	return nil
}

// GetOrCreateAvgFlrEvent retrieves the value with the specified keys from
// the receiver SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate) GetOrCreateAvgFlrEvent(
	Direction E_SrlNokiaOamPmTypes_LossDirectionType,
) *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_AvgFlrEvent {
	key := Direction

	if v, ok := t.AvgFlrEvent[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAvgFlrEvent(Direction)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAvgFlrEvent got unexpected error: %v", err))
	}
	return v
}

// GetAvgFlrEvent retrieves the value with the specified key from
// the AvgFlrEvent map field of SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate) GetAvgFlrEvent(
	Direction E_SrlNokiaOamPmTypes_LossDirectionType,
) *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_AvgFlrEvent {
	if t == nil {
		return nil
	}

	key := Direction

	if lm, ok := t.AvgFlrEvent[key]; ok {
		return lm
	}
	return nil
}

// DeleteAvgFlrEvent deletes the value with the specified keys from
// the receiver SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate) DeleteAvgFlrEvent(Direction E_SrlNokiaOamPmTypes_LossDirectionType) {
	key := Direction

	delete(t.AvgFlrEvent, key)
}

// AppendAvgFlrEvent appends the supplied SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_AvgFlrEvent struct to the
// list AvgFlrEvent of SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate. If the key value(s) specified in
// the supplied SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_AvgFlrEvent already exist in the list, an error is
// returned.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate) AppendAvgFlrEvent(
	v *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_AvgFlrEvent,
) error {
	key := v.Direction

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AvgFlrEvent == nil {
		t.AvgFlrEvent = make(map[E_SrlNokiaOamPmTypes_LossDirectionType]*SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_AvgFlrEvent)
	}

	if _, ok := t.AvgFlrEvent[key]; ok {
		return fmt.Errorf("duplicate key for list AvgFlrEvent %v", key)
	}

	t.AvgFlrEvent[key] = v
	return nil
}

// NewChliEvent creates a new entry in the ChliEvent list of the
// SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate) NewChliEvent(
	Direction E_SrlNokiaOamPmTypes_LossDirectionAggregateType,
) (*SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_ChliEvent, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ChliEvent == nil {
		t.ChliEvent = make(map[E_SrlNokiaOamPmTypes_LossDirectionAggregateType]*SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_ChliEvent)
	}

	key := Direction

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.ChliEvent[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list ChliEvent", key)
	}

	t.ChliEvent[key] = &SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_ChliEvent{
		Direction: Direction,
	}

	return t.ChliEvent[key], nil
}

// RenameChliEvent renames an entry in the list ChliEvent within
// the SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate) RenameChliEvent(
	oldK, newK E_SrlNokiaOamPmTypes_LossDirectionAggregateType,
) error {
	if _, ok := t.ChliEvent[newK]; ok {
		return fmt.Errorf("key %v already exists in ChliEvent", newK)
	}

	e, ok := t.ChliEvent[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in ChliEvent", oldK)
	}
	e.Direction = newK

	t.ChliEvent[newK] = e
	delete(t.ChliEvent, oldK)
	return nil
}

// GetOrCreateChliEvent retrieves the value with the specified keys from
// the receiver SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate) GetOrCreateChliEvent(
	Direction E_SrlNokiaOamPmTypes_LossDirectionAggregateType,
) *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_ChliEvent {
	key := Direction

	if v, ok := t.ChliEvent[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewChliEvent(Direction)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateChliEvent got unexpected error: %v", err))
	}
	return v
}

// GetChliEvent retrieves the value with the specified key from
// the ChliEvent map field of SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate) GetChliEvent(
	Direction E_SrlNokiaOamPmTypes_LossDirectionAggregateType,
) *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_ChliEvent {
	if t == nil {
		return nil
	}

	key := Direction

	if lm, ok := t.ChliEvent[key]; ok {
		return lm
	}
	return nil
}

// DeleteChliEvent deletes the value with the specified keys from
// the receiver SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate) DeleteChliEvent(
	Direction E_SrlNokiaOamPmTypes_LossDirectionAggregateType,
) {
	key := Direction

	delete(t.ChliEvent, key)
}

// AppendChliEvent appends the supplied SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_ChliEvent struct to the
// list ChliEvent of SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate. If the key value(s) specified in
// the supplied SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_ChliEvent already exist in the list, an error is
// returned.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate) AppendChliEvent(
	v *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_ChliEvent,
) error {
	key := v.Direction

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ChliEvent == nil {
		t.ChliEvent = make(map[E_SrlNokiaOamPmTypes_LossDirectionAggregateType]*SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_ChliEvent)
	}

	if _, ok := t.ChliEvent[key]; ok {
		return fmt.Errorf("duplicate key for list ChliEvent %v", key)
	}

	t.ChliEvent[key] = v
	return nil
}

// NewHliEvent creates a new entry in the HliEvent list of the
// SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate) NewHliEvent(
	Direction E_SrlNokiaOamPmTypes_LossDirectionAggregateType,
) (*SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_HliEvent, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.HliEvent == nil {
		t.HliEvent = make(map[E_SrlNokiaOamPmTypes_LossDirectionAggregateType]*SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_HliEvent)
	}

	key := Direction

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.HliEvent[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list HliEvent", key)
	}

	t.HliEvent[key] = &SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_HliEvent{
		Direction: Direction,
	}

	return t.HliEvent[key], nil
}

// RenameHliEvent renames an entry in the list HliEvent within
// the SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate) RenameHliEvent(
	oldK, newK E_SrlNokiaOamPmTypes_LossDirectionAggregateType,
) error {
	if _, ok := t.HliEvent[newK]; ok {
		return fmt.Errorf("key %v already exists in HliEvent", newK)
	}

	e, ok := t.HliEvent[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in HliEvent", oldK)
	}
	e.Direction = newK

	t.HliEvent[newK] = e
	delete(t.HliEvent, oldK)
	return nil
}

// GetOrCreateHliEvent retrieves the value with the specified keys from
// the receiver SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate) GetOrCreateHliEvent(
	Direction E_SrlNokiaOamPmTypes_LossDirectionAggregateType,
) *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_HliEvent {
	key := Direction

	if v, ok := t.HliEvent[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewHliEvent(Direction)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateHliEvent got unexpected error: %v", err))
	}
	return v
}

// GetHliEvent retrieves the value with the specified key from
// the HliEvent map field of SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate) GetHliEvent(
	Direction E_SrlNokiaOamPmTypes_LossDirectionAggregateType,
) *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_HliEvent {
	if t == nil {
		return nil
	}

	key := Direction

	if lm, ok := t.HliEvent[key]; ok {
		return lm
	}
	return nil
}

// DeleteHliEvent deletes the value with the specified keys from
// the receiver SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate) DeleteHliEvent(
	Direction E_SrlNokiaOamPmTypes_LossDirectionAggregateType,
) {
	key := Direction

	delete(t.HliEvent, key)
}

// AppendHliEvent appends the supplied SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_HliEvent struct to the
// list HliEvent of SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate. If the key value(s) specified in
// the supplied SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_HliEvent already exist in the list, an error is
// returned.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate) AppendHliEvent(
	v *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_HliEvent,
) error {
	key := v.Direction

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.HliEvent == nil {
		t.HliEvent = make(map[E_SrlNokiaOamPmTypes_LossDirectionAggregateType]*SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_HliEvent)
	}

	if _, ok := t.HliEvent[key]; ok {
		return fmt.Errorf("duplicate key for list HliEvent %v", key)
	}

	t.HliEvent[key] = v
	return nil
}

// NewUnavailabilityEvent creates a new entry in the UnavailabilityEvent list of the
// SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate) NewUnavailabilityEvent(
	Direction E_SrlNokiaOamPmTypes_LossDirectionAggregateType,
) (*SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_UnavailabilityEvent, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.UnavailabilityEvent == nil {
		t.UnavailabilityEvent = make(map[E_SrlNokiaOamPmTypes_LossDirectionAggregateType]*SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_UnavailabilityEvent)
	}

	key := Direction

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.UnavailabilityEvent[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list UnavailabilityEvent", key)
	}

	t.UnavailabilityEvent[key] = &SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_UnavailabilityEvent{
		Direction: Direction,
	}

	return t.UnavailabilityEvent[key], nil
}

// RenameUnavailabilityEvent renames an entry in the list UnavailabilityEvent within
// the SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate) RenameUnavailabilityEvent(
	oldK, newK E_SrlNokiaOamPmTypes_LossDirectionAggregateType,
) error {
	if _, ok := t.UnavailabilityEvent[newK]; ok {
		return fmt.Errorf("key %v already exists in UnavailabilityEvent", newK)
	}

	e, ok := t.UnavailabilityEvent[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in UnavailabilityEvent", oldK)
	}
	e.Direction = newK

	t.UnavailabilityEvent[newK] = e
	delete(t.UnavailabilityEvent, oldK)
	return nil
}

// GetOrCreateUnavailabilityEvent retrieves the value with the specified keys from
// the receiver SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate) GetOrCreateUnavailabilityEvent(
	Direction E_SrlNokiaOamPmTypes_LossDirectionAggregateType,
) *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_UnavailabilityEvent {
	key := Direction

	if v, ok := t.UnavailabilityEvent[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewUnavailabilityEvent(Direction)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateUnavailabilityEvent got unexpected error: %v", err))
	}
	return v
}

// GetUnavailabilityEvent retrieves the value with the specified key from
// the UnavailabilityEvent map field of SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate) GetUnavailabilityEvent(
	Direction E_SrlNokiaOamPmTypes_LossDirectionAggregateType,
) *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_UnavailabilityEvent {
	if t == nil {
		return nil
	}

	key := Direction

	if lm, ok := t.UnavailabilityEvent[key]; ok {
		return lm
	}
	return nil
}

// DeleteUnavailabilityEvent deletes the value with the specified keys from
// the receiver SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate) DeleteUnavailabilityEvent(
	Direction E_SrlNokiaOamPmTypes_LossDirectionAggregateType,
) {
	key := Direction

	delete(t.UnavailabilityEvent, key)
}

// AppendUnavailabilityEvent appends the supplied SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_UnavailabilityEvent struct to the
// list UnavailabilityEvent of SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate. If the key value(s) specified in
// the supplied SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_UnavailabilityEvent already exist in the list, an error is
// returned.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate) AppendUnavailabilityEvent(
	v *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_UnavailabilityEvent,
) error {
	key := v.Direction

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.UnavailabilityEvent == nil {
		t.UnavailabilityEvent = make(map[E_SrlNokiaOamPmTypes_LossDirectionAggregateType]*SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_UnavailabilityEvent)
	}

	if _, ok := t.UnavailabilityEvent[key]; ok {
		return fmt.Errorf("duplicate key for list UnavailabilityEvent %v", key)
	}

	t.UnavailabilityEvent[key] = v
	return nil
}

// NewUndeterminedAvailabilityEvent creates a new entry in the UndeterminedAvailabilityEvent list of the
// SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate) NewUndeterminedAvailabilityEvent(
	Direction E_SrlNokiaOamPmTypes_LossDirectionAggregateType,
) (*SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_UndeterminedAvailabilityEvent, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.UndeterminedAvailabilityEvent == nil {
		t.UndeterminedAvailabilityEvent = make(map[E_SrlNokiaOamPmTypes_LossDirectionAggregateType]*SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_UndeterminedAvailabilityEvent)
	}

	key := Direction

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.UndeterminedAvailabilityEvent[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list UndeterminedAvailabilityEvent", key)
	}

	t.UndeterminedAvailabilityEvent[key] = &SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_UndeterminedAvailabilityEvent{
		Direction: Direction,
	}

	return t.UndeterminedAvailabilityEvent[key], nil
}

// RenameUndeterminedAvailabilityEvent renames an entry in the list UndeterminedAvailabilityEvent within
// the SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate) RenameUndeterminedAvailabilityEvent(
	oldK, newK E_SrlNokiaOamPmTypes_LossDirectionAggregateType,
) error {
	if _, ok := t.UndeterminedAvailabilityEvent[newK]; ok {
		return fmt.Errorf("key %v already exists in UndeterminedAvailabilityEvent", newK)
	}

	e, ok := t.UndeterminedAvailabilityEvent[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in UndeterminedAvailabilityEvent", oldK)
	}
	e.Direction = newK

	t.UndeterminedAvailabilityEvent[newK] = e
	delete(t.UndeterminedAvailabilityEvent, oldK)
	return nil
}

// GetOrCreateUndeterminedAvailabilityEvent retrieves the value with the specified keys from
// the receiver SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate) GetOrCreateUndeterminedAvailabilityEvent(
	Direction E_SrlNokiaOamPmTypes_LossDirectionAggregateType,
) *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_UndeterminedAvailabilityEvent {
	key := Direction

	if v, ok := t.UndeterminedAvailabilityEvent[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewUndeterminedAvailabilityEvent(Direction)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateUndeterminedAvailabilityEvent got unexpected error: %v", err))
	}
	return v
}

// GetUndeterminedAvailabilityEvent retrieves the value with the specified key from
// the UndeterminedAvailabilityEvent map field of SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate) GetUndeterminedAvailabilityEvent(
	Direction E_SrlNokiaOamPmTypes_LossDirectionAggregateType,
) *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_UndeterminedAvailabilityEvent {
	if t == nil {
		return nil
	}

	key := Direction

	if lm, ok := t.UndeterminedAvailabilityEvent[key]; ok {
		return lm
	}
	return nil
}

// DeleteUndeterminedAvailabilityEvent deletes the value with the specified keys from
// the receiver SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate) DeleteUndeterminedAvailabilityEvent(
	Direction E_SrlNokiaOamPmTypes_LossDirectionAggregateType,
) {
	key := Direction

	delete(t.UndeterminedAvailabilityEvent, key)
}

// AppendUndeterminedAvailabilityEvent appends the supplied SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_UndeterminedAvailabilityEvent struct to the
// list UndeterminedAvailabilityEvent of SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate. If the key value(s) specified in
// the supplied SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_UndeterminedAvailabilityEvent already exist in the list, an error is
// returned.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate) AppendUndeterminedAvailabilityEvent(
	v *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_UndeterminedAvailabilityEvent,
) error {
	key := v.Direction

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.UndeterminedAvailabilityEvent == nil {
		t.UndeterminedAvailabilityEvent = make(map[E_SrlNokiaOamPmTypes_LossDirectionAggregateType]*SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_UndeterminedAvailabilityEvent)
	}

	if _, ok := t.UndeterminedAvailabilityEvent[key]; ok {
		return fmt.Errorf("duplicate key for list UndeterminedAvailabilityEvent %v", key)
	}

	t.UndeterminedAvailabilityEvent[key] = v
	return nil
}

// NewUndeterminedUnavailabilityEvent creates a new entry in the UndeterminedUnavailabilityEvent list of the
// SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate) NewUndeterminedUnavailabilityEvent(
	Direction E_SrlNokiaOamPmTypes_LossDirectionAggregateType,
) (*SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_UndeterminedUnavailabilityEvent, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.UndeterminedUnavailabilityEvent == nil {
		t.UndeterminedUnavailabilityEvent = make(map[E_SrlNokiaOamPmTypes_LossDirectionAggregateType]*SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_UndeterminedUnavailabilityEvent)
	}

	key := Direction

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.UndeterminedUnavailabilityEvent[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list UndeterminedUnavailabilityEvent", key)
	}

	t.UndeterminedUnavailabilityEvent[key] = &SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_UndeterminedUnavailabilityEvent{
		Direction: Direction,
	}

	return t.UndeterminedUnavailabilityEvent[key], nil
}

// RenameUndeterminedUnavailabilityEvent renames an entry in the list UndeterminedUnavailabilityEvent within
// the SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate) RenameUndeterminedUnavailabilityEvent(
	oldK, newK E_SrlNokiaOamPmTypes_LossDirectionAggregateType,
) error {
	if _, ok := t.UndeterminedUnavailabilityEvent[newK]; ok {
		return fmt.Errorf("key %v already exists in UndeterminedUnavailabilityEvent", newK)
	}

	e, ok := t.UndeterminedUnavailabilityEvent[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in UndeterminedUnavailabilityEvent", oldK)
	}
	e.Direction = newK

	t.UndeterminedUnavailabilityEvent[newK] = e
	delete(t.UndeterminedUnavailabilityEvent, oldK)
	return nil
}

// GetOrCreateUndeterminedUnavailabilityEvent retrieves the value with the specified keys from
// the receiver SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate) GetOrCreateUndeterminedUnavailabilityEvent(
	Direction E_SrlNokiaOamPmTypes_LossDirectionAggregateType,
) *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_UndeterminedUnavailabilityEvent {
	key := Direction

	if v, ok := t.UndeterminedUnavailabilityEvent[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewUndeterminedUnavailabilityEvent(Direction)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateUndeterminedUnavailabilityEvent got unexpected error: %v", err))
	}
	return v
}

// GetUndeterminedUnavailabilityEvent retrieves the value with the specified key from
// the UndeterminedUnavailabilityEvent map field of SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate) GetUndeterminedUnavailabilityEvent(
	Direction E_SrlNokiaOamPmTypes_LossDirectionAggregateType,
) *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_UndeterminedUnavailabilityEvent {
	if t == nil {
		return nil
	}

	key := Direction

	if lm, ok := t.UndeterminedUnavailabilityEvent[key]; ok {
		return lm
	}
	return nil
}

// DeleteUndeterminedUnavailabilityEvent deletes the value with the specified keys from
// the receiver SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate) DeleteUndeterminedUnavailabilityEvent(
	Direction E_SrlNokiaOamPmTypes_LossDirectionAggregateType,
) {
	key := Direction

	delete(t.UndeterminedUnavailabilityEvent, key)
}

// AppendUndeterminedUnavailabilityEvent appends the supplied SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_UndeterminedUnavailabilityEvent struct to the
// list UndeterminedUnavailabilityEvent of SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate. If the key value(s) specified in
// the supplied SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_UndeterminedUnavailabilityEvent already exist in the list, an error is
// returned.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate) AppendUndeterminedUnavailabilityEvent(
	v *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_UndeterminedUnavailabilityEvent,
) error {
	key := v.Direction

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.UndeterminedUnavailabilityEvent == nil {
		t.UndeterminedUnavailabilityEvent = make(map[E_SrlNokiaOamPmTypes_LossDirectionAggregateType]*SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_UndeterminedUnavailabilityEvent)
	}

	if _, ok := t.UndeterminedUnavailabilityEvent[key]; ok {
		return fmt.Errorf("duplicate key for list UndeterminedUnavailabilityEvent %v", key)
	}

	t.UndeterminedUnavailabilityEvent[key] = v
	return nil
}

// GetLossEventsTemplateName retrieves the value of the leaf LossEventsTemplateName from the SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LossEventsTemplateName is set, it can
// safely use t.GetLossEventsTemplateName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LossEventsTemplateName == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate) GetLossEventsTemplateName() string {
	if t == nil || t.LossEventsTemplateName == nil {
		return ""
	}
	return *t.LossEventsTemplateName
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.AvgFlrEvent {
		e.PopulateDefaults()
	}
	for _, e := range t.ChliEvent {
		e.PopulateDefaults()
	}
	for _, e := range t.HliEvent {
		e.PopulateDefaults()
	}
	for _, e := range t.UnavailabilityEvent {
		e.PopulateDefaults()
	}
	for _, e := range t.UndeterminedAvailabilityEvent {
		e.PopulateDefaults()
	}
	for _, e := range t.UndeterminedUnavailabilityEvent {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate struct, which is a YANG list entry.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate) ΛListKeyMap() (map[string]interface{}, error) {
	if t.LossEventsTemplateName == nil {
		return nil, fmt.Errorf("nil value for key LossEventsTemplateName")
	}

	return map[string]interface{}{
		"loss-events-template-name": *t.LossEventsTemplateName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate.
func (*SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate) ΛBelongingModule() string {
	return "srl_nokia-oam-pm-ethcfm"
}

// SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_AvgFlrEvent represents the /srl_nokia-oam/oam/performance-monitoring/ethcfm/loss/loss-events-template/avg-flr-event YANG schema element.
type SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_AvgFlrEvent struct {
	ClearThreshold *float64                               `path:"clear-threshold" module:"srl_nokia-oam-pm-ethcfm"`
	Direction      E_SrlNokiaOamPmTypes_LossDirectionType `path:"direction" module:"srl_nokia-oam-pm-ethcfm"`
	RaiseThreshold *float64                               `path:"raise-threshold" module:"srl_nokia-oam-pm-ethcfm"`
}

// IsYANGGoStruct ensures that SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_AvgFlrEvent implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_AvgFlrEvent) IsYANGGoStruct() {
}

// GetClearThreshold retrieves the value of the leaf ClearThreshold from the SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_AvgFlrEvent
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ClearThreshold is set, it can
// safely use t.GetClearThreshold() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ClearThreshold == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_AvgFlrEvent) GetClearThreshold() float64 {
	if t == nil || t.ClearThreshold == nil {
		return 0.0
	}
	return *t.ClearThreshold
}

// GetDirection retrieves the value of the leaf Direction from the SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_AvgFlrEvent
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Direction is set, it can
// safely use t.GetDirection() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Direction == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_AvgFlrEvent) GetDirection() E_SrlNokiaOamPmTypes_LossDirectionType {
	if t == nil || t.Direction == 0 {
		return 0
	}
	return t.Direction
}

// GetRaiseThreshold retrieves the value of the leaf RaiseThreshold from the SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_AvgFlrEvent
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RaiseThreshold is set, it can
// safely use t.GetRaiseThreshold() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RaiseThreshold == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_AvgFlrEvent) GetRaiseThreshold() float64 {
	if t == nil || t.RaiseThreshold == nil {
		return 0.0
	}
	return *t.RaiseThreshold
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_AvgFlrEvent
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_AvgFlrEvent) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_AvgFlrEvent struct, which is a YANG list entry.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_AvgFlrEvent) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"direction": t.Direction,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_AvgFlrEvent) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_AvgFlrEvent"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_AvgFlrEvent) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_AvgFlrEvent) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_AvgFlrEvent.
func (*SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_AvgFlrEvent) ΛBelongingModule() string {
	return "srl_nokia-oam-pm-ethcfm"
}

// SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_ChliEvent represents the /srl_nokia-oam/oam/performance-monitoring/ethcfm/loss/loss-events-template/chli-event YANG schema element.
type SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_ChliEvent struct {
	ClearThreshold *uint32                                         `path:"clear-threshold" module:"srl_nokia-oam-pm-ethcfm"`
	Direction      E_SrlNokiaOamPmTypes_LossDirectionAggregateType `path:"direction" module:"srl_nokia-oam-pm-ethcfm"`
	RaiseThreshold *uint32                                         `path:"raise-threshold" module:"srl_nokia-oam-pm-ethcfm"`
}

// IsYANGGoStruct ensures that SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_ChliEvent implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_ChliEvent) IsYANGGoStruct() {
}

// GetClearThreshold retrieves the value of the leaf ClearThreshold from the SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_ChliEvent
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ClearThreshold is set, it can
// safely use t.GetClearThreshold() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ClearThreshold == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_ChliEvent) GetClearThreshold() uint32 {
	if t == nil || t.ClearThreshold == nil {
		return 0
	}
	return *t.ClearThreshold
}

// GetDirection retrieves the value of the leaf Direction from the SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_ChliEvent
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Direction is set, it can
// safely use t.GetDirection() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Direction == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_ChliEvent) GetDirection() E_SrlNokiaOamPmTypes_LossDirectionAggregateType {
	if t == nil || t.Direction == 0 {
		return 0
	}
	return t.Direction
}

// GetRaiseThreshold retrieves the value of the leaf RaiseThreshold from the SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_ChliEvent
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RaiseThreshold is set, it can
// safely use t.GetRaiseThreshold() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RaiseThreshold == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_ChliEvent) GetRaiseThreshold() uint32 {
	if t == nil || t.RaiseThreshold == nil {
		return 0
	}
	return *t.RaiseThreshold
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_ChliEvent
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_ChliEvent) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_ChliEvent struct, which is a YANG list entry.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_ChliEvent) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"direction": t.Direction,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_ChliEvent) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_ChliEvent"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_ChliEvent) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_ChliEvent) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_ChliEvent.
func (*SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_ChliEvent) ΛBelongingModule() string {
	return "srl_nokia-oam-pm-ethcfm"
}

// SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_HliEvent represents the /srl_nokia-oam/oam/performance-monitoring/ethcfm/loss/loss-events-template/hli-event YANG schema element.
type SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_HliEvent struct {
	ClearThreshold *uint32                                         `path:"clear-threshold" module:"srl_nokia-oam-pm-ethcfm"`
	Direction      E_SrlNokiaOamPmTypes_LossDirectionAggregateType `path:"direction" module:"srl_nokia-oam-pm-ethcfm"`
	RaiseThreshold *uint32                                         `path:"raise-threshold" module:"srl_nokia-oam-pm-ethcfm"`
}

// IsYANGGoStruct ensures that SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_HliEvent implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_HliEvent) IsYANGGoStruct() {
}

// GetClearThreshold retrieves the value of the leaf ClearThreshold from the SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_HliEvent
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ClearThreshold is set, it can
// safely use t.GetClearThreshold() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ClearThreshold == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_HliEvent) GetClearThreshold() uint32 {
	if t == nil || t.ClearThreshold == nil {
		return 0
	}
	return *t.ClearThreshold
}

// GetDirection retrieves the value of the leaf Direction from the SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_HliEvent
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Direction is set, it can
// safely use t.GetDirection() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Direction == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_HliEvent) GetDirection() E_SrlNokiaOamPmTypes_LossDirectionAggregateType {
	if t == nil || t.Direction == 0 {
		return 0
	}
	return t.Direction
}

// GetRaiseThreshold retrieves the value of the leaf RaiseThreshold from the SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_HliEvent
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RaiseThreshold is set, it can
// safely use t.GetRaiseThreshold() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RaiseThreshold == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_HliEvent) GetRaiseThreshold() uint32 {
	if t == nil || t.RaiseThreshold == nil {
		return 0
	}
	return *t.RaiseThreshold
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_HliEvent
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_HliEvent) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_HliEvent struct, which is a YANG list entry.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_HliEvent) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"direction": t.Direction,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_HliEvent) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_HliEvent"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_HliEvent) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_HliEvent) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_HliEvent.
func (*SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_HliEvent) ΛBelongingModule() string {
	return "srl_nokia-oam-pm-ethcfm"
}

// SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_UnavailabilityEvent represents the /srl_nokia-oam/oam/performance-monitoring/ethcfm/loss/loss-events-template/unavailability-event YANG schema element.
type SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_UnavailabilityEvent struct {
	ClearThreshold *uint32                                         `path:"clear-threshold" module:"srl_nokia-oam-pm-ethcfm"`
	Direction      E_SrlNokiaOamPmTypes_LossDirectionAggregateType `path:"direction" module:"srl_nokia-oam-pm-ethcfm"`
	RaiseThreshold *uint32                                         `path:"raise-threshold" module:"srl_nokia-oam-pm-ethcfm"`
}

// IsYANGGoStruct ensures that SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_UnavailabilityEvent implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_UnavailabilityEvent) IsYANGGoStruct() {
}

// GetClearThreshold retrieves the value of the leaf ClearThreshold from the SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_UnavailabilityEvent
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ClearThreshold is set, it can
// safely use t.GetClearThreshold() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ClearThreshold == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_UnavailabilityEvent) GetClearThreshold() uint32 {
	if t == nil || t.ClearThreshold == nil {
		return 0
	}
	return *t.ClearThreshold
}

// GetDirection retrieves the value of the leaf Direction from the SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_UnavailabilityEvent
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Direction is set, it can
// safely use t.GetDirection() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Direction == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_UnavailabilityEvent) GetDirection() E_SrlNokiaOamPmTypes_LossDirectionAggregateType {
	if t == nil || t.Direction == 0 {
		return 0
	}
	return t.Direction
}

// GetRaiseThreshold retrieves the value of the leaf RaiseThreshold from the SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_UnavailabilityEvent
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RaiseThreshold is set, it can
// safely use t.GetRaiseThreshold() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RaiseThreshold == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_UnavailabilityEvent) GetRaiseThreshold() uint32 {
	if t == nil || t.RaiseThreshold == nil {
		return 0
	}
	return *t.RaiseThreshold
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_UnavailabilityEvent
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_UnavailabilityEvent) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_UnavailabilityEvent struct, which is a YANG list entry.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_UnavailabilityEvent) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"direction": t.Direction,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_UnavailabilityEvent) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_UnavailabilityEvent"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_UnavailabilityEvent) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_UnavailabilityEvent) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_UnavailabilityEvent.
func (*SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_UnavailabilityEvent) ΛBelongingModule() string {
	return "srl_nokia-oam-pm-ethcfm"
}

// SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_UndeterminedAvailabilityEvent represents the /srl_nokia-oam/oam/performance-monitoring/ethcfm/loss/loss-events-template/undetermined-availability-event YANG schema element.
type SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_UndeterminedAvailabilityEvent struct {
	ClearThreshold *uint32                                         `path:"clear-threshold" module:"srl_nokia-oam-pm-ethcfm"`
	Direction      E_SrlNokiaOamPmTypes_LossDirectionAggregateType `path:"direction" module:"srl_nokia-oam-pm-ethcfm"`
	RaiseThreshold *uint32                                         `path:"raise-threshold" module:"srl_nokia-oam-pm-ethcfm"`
}

// IsYANGGoStruct ensures that SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_UndeterminedAvailabilityEvent implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_UndeterminedAvailabilityEvent) IsYANGGoStruct() {
}

// GetClearThreshold retrieves the value of the leaf ClearThreshold from the SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_UndeterminedAvailabilityEvent
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ClearThreshold is set, it can
// safely use t.GetClearThreshold() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ClearThreshold == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_UndeterminedAvailabilityEvent) GetClearThreshold() uint32 {
	if t == nil || t.ClearThreshold == nil {
		return 0
	}
	return *t.ClearThreshold
}

// GetDirection retrieves the value of the leaf Direction from the SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_UndeterminedAvailabilityEvent
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Direction is set, it can
// safely use t.GetDirection() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Direction == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_UndeterminedAvailabilityEvent) GetDirection() E_SrlNokiaOamPmTypes_LossDirectionAggregateType {
	if t == nil || t.Direction == 0 {
		return 0
	}
	return t.Direction
}

// GetRaiseThreshold retrieves the value of the leaf RaiseThreshold from the SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_UndeterminedAvailabilityEvent
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RaiseThreshold is set, it can
// safely use t.GetRaiseThreshold() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RaiseThreshold == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_UndeterminedAvailabilityEvent) GetRaiseThreshold() uint32 {
	if t == nil || t.RaiseThreshold == nil {
		return 0
	}
	return *t.RaiseThreshold
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_UndeterminedAvailabilityEvent
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_UndeterminedAvailabilityEvent) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_UndeterminedAvailabilityEvent struct, which is a YANG list entry.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_UndeterminedAvailabilityEvent) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"direction": t.Direction,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_UndeterminedAvailabilityEvent) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_UndeterminedAvailabilityEvent"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_UndeterminedAvailabilityEvent) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_UndeterminedAvailabilityEvent) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_UndeterminedAvailabilityEvent.
func (*SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_UndeterminedAvailabilityEvent) ΛBelongingModule() string {
	return "srl_nokia-oam-pm-ethcfm"
}

// SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_UndeterminedUnavailabilityEvent represents the /srl_nokia-oam/oam/performance-monitoring/ethcfm/loss/loss-events-template/undetermined-unavailability-event YANG schema element.
type SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_UndeterminedUnavailabilityEvent struct {
	ClearThreshold *uint32                                         `path:"clear-threshold" module:"srl_nokia-oam-pm-ethcfm"`
	Direction      E_SrlNokiaOamPmTypes_LossDirectionAggregateType `path:"direction" module:"srl_nokia-oam-pm-ethcfm"`
	RaiseThreshold *uint32                                         `path:"raise-threshold" module:"srl_nokia-oam-pm-ethcfm"`
}

// IsYANGGoStruct ensures that SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_UndeterminedUnavailabilityEvent implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_UndeterminedUnavailabilityEvent) IsYANGGoStruct() {
}

// GetClearThreshold retrieves the value of the leaf ClearThreshold from the SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_UndeterminedUnavailabilityEvent
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ClearThreshold is set, it can
// safely use t.GetClearThreshold() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ClearThreshold == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_UndeterminedUnavailabilityEvent) GetClearThreshold() uint32 {
	if t == nil || t.ClearThreshold == nil {
		return 0
	}
	return *t.ClearThreshold
}

// GetDirection retrieves the value of the leaf Direction from the SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_UndeterminedUnavailabilityEvent
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Direction is set, it can
// safely use t.GetDirection() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Direction == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_UndeterminedUnavailabilityEvent) GetDirection() E_SrlNokiaOamPmTypes_LossDirectionAggregateType {
	if t == nil || t.Direction == 0 {
		return 0
	}
	return t.Direction
}

// GetRaiseThreshold retrieves the value of the leaf RaiseThreshold from the SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_UndeterminedUnavailabilityEvent
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RaiseThreshold is set, it can
// safely use t.GetRaiseThreshold() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RaiseThreshold == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_UndeterminedUnavailabilityEvent) GetRaiseThreshold() uint32 {
	if t == nil || t.RaiseThreshold == nil {
		return 0
	}
	return *t.RaiseThreshold
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_UndeterminedUnavailabilityEvent
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_UndeterminedUnavailabilityEvent) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_UndeterminedUnavailabilityEvent struct, which is a YANG list entry.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_UndeterminedUnavailabilityEvent) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"direction": t.Direction,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_UndeterminedUnavailabilityEvent) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_UndeterminedUnavailabilityEvent"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_UndeterminedUnavailabilityEvent) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_UndeterminedUnavailabilityEvent) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_UndeterminedUnavailabilityEvent.
func (*SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Loss_LossEventsTemplate_UndeterminedUnavailabilityEvent) ΛBelongingModule() string {
	return "srl_nokia-oam-pm-ethcfm"
}

// SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session represents the /srl_nokia-oam/oam/performance-monitoring/ethcfm/session YANG schema element.
type SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session struct {
	Description              *string                                                                                                                            `path:"description" module:"srl_nokia-oam-pm-ethcfm"`
	EthCfmSingleEndedDmmTest *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_EthCfmSingleEndedDmmTest                                                     `path:"eth-cfm-single-ended-dmm-test" module:"srl_nokia-oam-pm-ethcfm"`
	EthCfmSingleEndedSlmTest *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_EthCfmSingleEndedSlmTest                                                     `path:"eth-cfm-single-ended-slm-test" module:"srl_nokia-oam-pm-ethcfm"`
	MeasurementInterval      map[E_SrlNokiaOamPmTypes_MeasurementIntervalDurationType]*SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_MeasurementInterval `path:"measurement-interval" module:"srl_nokia-oam-pm-ethcfm"`
	Priority                 *uint8                                                                                                                             `path:"priority" module:"srl_nokia-oam-pm-ethcfm"`
	SessionName              *string                                                                                                                            `path:"session-name" module:"srl_nokia-oam-pm-ethcfm"`
	SessionType              E_SrlNokiaOamPmTypes_OamPmSessionType                                                                                              `path:"session-type" module:"srl_nokia-oam-pm-ethcfm"`
	Source                   *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_Source                                                                       `path:"source" module:"srl_nokia-oam-pm-ethcfm"`
	Target                   SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_Target_Union                                                                  `path:"target" module:"srl_nokia-oam-pm-ethcfm"`
}

// IsYANGGoStruct ensures that SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session) IsYANGGoStruct() {}

// NewMeasurementInterval creates a new entry in the MeasurementInterval list of the
// SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session) NewMeasurementInterval(
	MiDuration E_SrlNokiaOamPmTypes_MeasurementIntervalDurationType,
) (*SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_MeasurementInterval, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.MeasurementInterval == nil {
		t.MeasurementInterval = make(map[E_SrlNokiaOamPmTypes_MeasurementIntervalDurationType]*SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_MeasurementInterval)
	}

	key := MiDuration

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.MeasurementInterval[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list MeasurementInterval", key)
	}

	t.MeasurementInterval[key] = &SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_MeasurementInterval{
		MiDuration: MiDuration,
	}

	return t.MeasurementInterval[key], nil
}

// RenameMeasurementInterval renames an entry in the list MeasurementInterval within
// the SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session) RenameMeasurementInterval(
	oldK, newK E_SrlNokiaOamPmTypes_MeasurementIntervalDurationType,
) error {
	if _, ok := t.MeasurementInterval[newK]; ok {
		return fmt.Errorf("key %v already exists in MeasurementInterval", newK)
	}

	e, ok := t.MeasurementInterval[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in MeasurementInterval", oldK)
	}
	e.MiDuration = newK

	t.MeasurementInterval[newK] = e
	delete(t.MeasurementInterval, oldK)
	return nil
}

// GetOrCreateMeasurementInterval retrieves the value with the specified keys from
// the receiver SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session) GetOrCreateMeasurementInterval(
	MiDuration E_SrlNokiaOamPmTypes_MeasurementIntervalDurationType,
) *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_MeasurementInterval {
	key := MiDuration

	if v, ok := t.MeasurementInterval[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewMeasurementInterval(MiDuration)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateMeasurementInterval got unexpected error: %v", err))
	}
	return v
}

// GetMeasurementInterval retrieves the value with the specified key from
// the MeasurementInterval map field of SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session) GetMeasurementInterval(
	MiDuration E_SrlNokiaOamPmTypes_MeasurementIntervalDurationType,
) *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_MeasurementInterval {
	if t == nil {
		return nil
	}

	key := MiDuration

	if lm, ok := t.MeasurementInterval[key]; ok {
		return lm
	}
	return nil
}

// DeleteMeasurementInterval deletes the value with the specified keys from
// the receiver SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session) DeleteMeasurementInterval(
	MiDuration E_SrlNokiaOamPmTypes_MeasurementIntervalDurationType,
) {
	key := MiDuration

	delete(t.MeasurementInterval, key)
}

// AppendMeasurementInterval appends the supplied SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_MeasurementInterval struct to the
// list MeasurementInterval of SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session. If the key value(s) specified in
// the supplied SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_MeasurementInterval already exist in the list, an error is
// returned.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session) AppendMeasurementInterval(
	v *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_MeasurementInterval,
) error {
	key := v.MiDuration

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.MeasurementInterval == nil {
		t.MeasurementInterval = make(map[E_SrlNokiaOamPmTypes_MeasurementIntervalDurationType]*SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_MeasurementInterval)
	}

	if _, ok := t.MeasurementInterval[key]; ok {
		return fmt.Errorf("duplicate key for list MeasurementInterval %v", key)
	}

	t.MeasurementInterval[key] = v
	return nil
}

// GetOrCreateEthCfmSingleEndedDmmTest retrieves the value of the EthCfmSingleEndedDmmTest field
// or returns the existing field if it already exists.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session) GetOrCreateEthCfmSingleEndedDmmTest() *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_EthCfmSingleEndedDmmTest {
	if t.EthCfmSingleEndedDmmTest != nil {
		return t.EthCfmSingleEndedDmmTest
	}
	t.EthCfmSingleEndedDmmTest = &SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_EthCfmSingleEndedDmmTest{}
	return t.EthCfmSingleEndedDmmTest
}

// GetOrCreateEthCfmSingleEndedSlmTest retrieves the value of the EthCfmSingleEndedSlmTest field
// or returns the existing field if it already exists.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session) GetOrCreateEthCfmSingleEndedSlmTest() *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_EthCfmSingleEndedSlmTest {
	if t.EthCfmSingleEndedSlmTest != nil {
		return t.EthCfmSingleEndedSlmTest
	}
	t.EthCfmSingleEndedSlmTest = &SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_EthCfmSingleEndedSlmTest{}
	return t.EthCfmSingleEndedSlmTest
}

// GetOrCreateSource retrieves the value of the Source field
// or returns the existing field if it already exists.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session) GetOrCreateSource() *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_Source {
	if t.Source != nil {
		return t.Source
	}
	t.Source = &SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_Source{}
	return t.Source
}

// GetEthCfmSingleEndedDmmTest returns the value of the EthCfmSingleEndedDmmTest struct pointer
// from SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session. If the receiver or the field EthCfmSingleEndedDmmTest is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session) GetEthCfmSingleEndedDmmTest() *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_EthCfmSingleEndedDmmTest {
	if t != nil && t.EthCfmSingleEndedDmmTest != nil {
		return t.EthCfmSingleEndedDmmTest
	}
	return nil
}

// GetEthCfmSingleEndedSlmTest returns the value of the EthCfmSingleEndedSlmTest struct pointer
// from SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session. If the receiver or the field EthCfmSingleEndedSlmTest is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session) GetEthCfmSingleEndedSlmTest() *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_EthCfmSingleEndedSlmTest {
	if t != nil && t.EthCfmSingleEndedSlmTest != nil {
		return t.EthCfmSingleEndedSlmTest
	}
	return nil
}

// GetSource returns the value of the Source struct pointer
// from SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session. If the receiver or the field Source is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session) GetSource() *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_Source {
	if t != nil && t.Source != nil {
		return t.Source
	}
	return nil
}

// GetDescription retrieves the value of the leaf Description from the SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetPriority retrieves the value of the leaf Priority from the SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Priority is set, it can
// safely use t.GetPriority() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Priority == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session) GetPriority() uint8 {
	if t == nil || t.Priority == nil {
		return 7
	}
	return *t.Priority
}

// GetSessionName retrieves the value of the leaf SessionName from the SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SessionName is set, it can
// safely use t.GetSessionName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SessionName == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session) GetSessionName() string {
	if t == nil || t.SessionName == nil {
		return ""
	}
	return *t.SessionName
}

// GetSessionType retrieves the value of the leaf SessionType from the SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SessionType is set, it can
// safely use t.GetSessionType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SessionType == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session) GetSessionType() E_SrlNokiaOamPmTypes_OamPmSessionType {
	if t == nil || t.SessionType == 0 {
		return SrlNokiaOamPmTypes_OamPmSessionType_proactive
	}
	return t.SessionType
}

// GetTarget retrieves the value of the leaf Target from the SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Target is set, it can
// safely use t.GetTarget() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Target == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session) GetTarget() SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_Target_Union {
	if t == nil || t.Target == nil {
		return nil
	}
	return t.Target
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Priority == nil {
		var v uint8 = 7
		t.Priority = &v
	}
	if t.SessionType == 0 {
		t.SessionType = SrlNokiaOamPmTypes_OamPmSessionType_proactive
	}
	t.EthCfmSingleEndedDmmTest.PopulateDefaults()
	t.EthCfmSingleEndedSlmTest.PopulateDefaults()
	t.Source.PopulateDefaults()
	for _, e := range t.MeasurementInterval {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session struct, which is a YANG list entry.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session) ΛListKeyMap() (map[string]interface{}, error) {
	if t.SessionName == nil {
		return nil, fmt.Errorf("nil value for key SessionName")
	}

	return map[string]interface{}{
		"session-name": *t.SessionName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session.
func (*SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session) ΛBelongingModule() string {
	return "srl_nokia-oam-pm-ethcfm"
}

// SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_EthCfmSingleEndedDmmTest represents the /srl_nokia-oam/oam/performance-monitoring/ethcfm/session/eth-cfm-single-ended-dmm-test YANG schema element.
type SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_EthCfmSingleEndedDmmTest struct {
	AdminState   E_SrlNokiaCommon_AdminState                                                                `path:"admin-state" module:"srl_nokia-oam-pm-ethcfm"`
	BinGroup     *string                                                                                    `path:"bin-group" module:"srl_nokia-oam-pm-ethcfm"`
	DataTlvSize  *uint32                                                                                    `path:"data-tlv-size" module:"srl_nokia-oam-pm-ethcfm"`
	Interval     E_SrlNokiaOamPmTypes_OamPmInterval                                                         `path:"interval" module:"srl_nokia-oam-pm-ethcfm"`
	TestDuration *uint32                                                                                    `path:"test-duration" module:"srl_nokia-oam-pm-ethcfm"`
	TestId       SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_EthCfmSingleEndedDmmTest_TestId_Union `path:"test-id" module:"srl_nokia-oam-pm-ethcfm"`
}

// IsYANGGoStruct ensures that SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_EthCfmSingleEndedDmmTest implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_EthCfmSingleEndedDmmTest) IsYANGGoStruct() {
}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_EthCfmSingleEndedDmmTest
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_EthCfmSingleEndedDmmTest) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_disable
	}
	return t.AdminState
}

// GetBinGroup retrieves the value of the leaf BinGroup from the SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_EthCfmSingleEndedDmmTest
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if BinGroup is set, it can
// safely use t.GetBinGroup() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.BinGroup == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_EthCfmSingleEndedDmmTest) GetBinGroup() string {
	if t == nil || t.BinGroup == nil {
		return "default"
	}
	return *t.BinGroup
}

// GetDataTlvSize retrieves the value of the leaf DataTlvSize from the SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_EthCfmSingleEndedDmmTest
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DataTlvSize is set, it can
// safely use t.GetDataTlvSize() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DataTlvSize == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_EthCfmSingleEndedDmmTest) GetDataTlvSize() uint32 {
	if t == nil || t.DataTlvSize == nil {
		return 0
	}
	return *t.DataTlvSize
}

// GetInterval retrieves the value of the leaf Interval from the SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_EthCfmSingleEndedDmmTest
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interval is set, it can
// safely use t.GetInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interval == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_EthCfmSingleEndedDmmTest) GetInterval() E_SrlNokiaOamPmTypes_OamPmInterval {
	if t == nil || t.Interval == 0 {
		return SrlNokiaOamPmTypes_OamPmInterval_1s
	}
	return t.Interval
}

// GetTestDuration retrieves the value of the leaf TestDuration from the SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_EthCfmSingleEndedDmmTest
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TestDuration is set, it can
// safely use t.GetTestDuration() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TestDuration == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_EthCfmSingleEndedDmmTest) GetTestDuration() uint32 {
	if t == nil || t.TestDuration == nil {
		return 0
	}
	return *t.TestDuration
}

// GetTestId retrieves the value of the leaf TestId from the SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_EthCfmSingleEndedDmmTest
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TestId is set, it can
// safely use t.GetTestId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TestId == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_EthCfmSingleEndedDmmTest) GetTestId() SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_EthCfmSingleEndedDmmTest_TestId_Union {
	if t == nil || t.TestId == nil {
		return SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_EthCfmSingleEndedDmmTest_TestId_Enum_auto
	}
	return t.TestId
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_EthCfmSingleEndedDmmTest
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_EthCfmSingleEndedDmmTest) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_disable
	}
	if t.BinGroup == nil {
		var v string = "default"
		t.BinGroup = &v
	}
	if t.DataTlvSize == nil {
		var v uint32 = 0
		t.DataTlvSize = &v
	}
	if t.Interval == 0 {
		t.Interval = SrlNokiaOamPmTypes_OamPmInterval_1s
	}
	if t.TestId == nil {
		t.TestId = SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_EthCfmSingleEndedDmmTest_TestId_Enum_auto
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_EthCfmSingleEndedDmmTest) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_EthCfmSingleEndedDmmTest"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_EthCfmSingleEndedDmmTest) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_EthCfmSingleEndedDmmTest) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_EthCfmSingleEndedDmmTest.
func (*SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_EthCfmSingleEndedDmmTest) ΛBelongingModule() string {
	return "srl_nokia-oam-pm-ethcfm"
}

// SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_EthCfmSingleEndedSlmTest represents the /srl_nokia-oam/oam/performance-monitoring/ethcfm/session/eth-cfm-single-ended-slm-test YANG schema element.
type SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_EthCfmSingleEndedSlmTest struct {
	AdminState    E_SrlNokiaCommon_AdminState                                                                `path:"admin-state" module:"srl_nokia-oam-pm-ethcfm"`
	DataTlvSize   *uint32                                                                                    `path:"data-tlv-size" module:"srl_nokia-oam-pm-ethcfm"`
	FlrThreshold  *uint8                                                                                     `path:"flr-threshold" module:"srl_nokia-oam-pm-ethcfm"`
	HliForceCount *bool                                                                                      `path:"hli-force-count" module:"srl_nokia-oam-pm-ethcfm"`
	Interval      E_SrlNokiaOamPmTypes_OamPmIntervalSlm                                                      `path:"interval" module:"srl_nokia-oam-pm-ethcfm"`
	LossEvent     *string                                                                                    `path:"loss-event" module:"srl_nokia-oam-pm-ethcfm"`
	TestDuration  *uint32                                                                                    `path:"test-duration" module:"srl_nokia-oam-pm-ethcfm"`
	TestId        SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_EthCfmSingleEndedSlmTest_TestId_Union `path:"test-id" module:"srl_nokia-oam-pm-ethcfm"`
	Timing        *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_EthCfmSingleEndedSlmTest_Timing      `path:"timing" module:"srl_nokia-oam-pm-ethcfm"`
}

// IsYANGGoStruct ensures that SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_EthCfmSingleEndedSlmTest implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_EthCfmSingleEndedSlmTest) IsYANGGoStruct() {
}

// GetOrCreateTiming retrieves the value of the Timing field
// or returns the existing field if it already exists.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_EthCfmSingleEndedSlmTest) GetOrCreateTiming() *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_EthCfmSingleEndedSlmTest_Timing {
	if t.Timing != nil {
		return t.Timing
	}
	t.Timing = &SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_EthCfmSingleEndedSlmTest_Timing{}
	return t.Timing
}

// GetTiming returns the value of the Timing struct pointer
// from SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_EthCfmSingleEndedSlmTest. If the receiver or the field Timing is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_EthCfmSingleEndedSlmTest) GetTiming() *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_EthCfmSingleEndedSlmTest_Timing {
	if t != nil && t.Timing != nil {
		return t.Timing
	}
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_EthCfmSingleEndedSlmTest
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_EthCfmSingleEndedSlmTest) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_disable
	}
	return t.AdminState
}

// GetDataTlvSize retrieves the value of the leaf DataTlvSize from the SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_EthCfmSingleEndedSlmTest
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DataTlvSize is set, it can
// safely use t.GetDataTlvSize() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DataTlvSize == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_EthCfmSingleEndedSlmTest) GetDataTlvSize() uint32 {
	if t == nil || t.DataTlvSize == nil {
		return 0
	}
	return *t.DataTlvSize
}

// GetFlrThreshold retrieves the value of the leaf FlrThreshold from the SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_EthCfmSingleEndedSlmTest
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FlrThreshold is set, it can
// safely use t.GetFlrThreshold() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FlrThreshold == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_EthCfmSingleEndedSlmTest) GetFlrThreshold() uint8 {
	if t == nil || t.FlrThreshold == nil {
		return 50
	}
	return *t.FlrThreshold
}

// GetHliForceCount retrieves the value of the leaf HliForceCount from the SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_EthCfmSingleEndedSlmTest
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if HliForceCount is set, it can
// safely use t.GetHliForceCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.HliForceCount == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_EthCfmSingleEndedSlmTest) GetHliForceCount() bool {
	if t == nil || t.HliForceCount == nil {
		return false
	}
	return *t.HliForceCount
}

// GetInterval retrieves the value of the leaf Interval from the SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_EthCfmSingleEndedSlmTest
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interval is set, it can
// safely use t.GetInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interval == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_EthCfmSingleEndedSlmTest) GetInterval() E_SrlNokiaOamPmTypes_OamPmIntervalSlm {
	if t == nil || t.Interval == 0 {
		return SrlNokiaOamPmTypes_OamPmIntervalSlm_1s
	}
	return t.Interval
}

// GetLossEvent retrieves the value of the leaf LossEvent from the SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_EthCfmSingleEndedSlmTest
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LossEvent is set, it can
// safely use t.GetLossEvent() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LossEvent == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_EthCfmSingleEndedSlmTest) GetLossEvent() string {
	if t == nil || t.LossEvent == nil {
		return ""
	}
	return *t.LossEvent
}

// GetTestDuration retrieves the value of the leaf TestDuration from the SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_EthCfmSingleEndedSlmTest
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TestDuration is set, it can
// safely use t.GetTestDuration() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TestDuration == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_EthCfmSingleEndedSlmTest) GetTestDuration() uint32 {
	if t == nil || t.TestDuration == nil {
		return 0
	}
	return *t.TestDuration
}

// GetTestId retrieves the value of the leaf TestId from the SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_EthCfmSingleEndedSlmTest
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TestId is set, it can
// safely use t.GetTestId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TestId == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_EthCfmSingleEndedSlmTest) GetTestId() SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_EthCfmSingleEndedSlmTest_TestId_Union {
	if t == nil || t.TestId == nil {
		return SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_EthCfmSingleEndedDmmTest_TestId_Enum_auto
	}
	return t.TestId
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_EthCfmSingleEndedSlmTest
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_EthCfmSingleEndedSlmTest) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_disable
	}
	if t.DataTlvSize == nil {
		var v uint32 = 0
		t.DataTlvSize = &v
	}
	if t.FlrThreshold == nil {
		var v uint8 = 50
		t.FlrThreshold = &v
	}
	if t.HliForceCount == nil {
		var v bool = false
		t.HliForceCount = &v
	}
	if t.Interval == 0 {
		t.Interval = SrlNokiaOamPmTypes_OamPmIntervalSlm_1s
	}
	if t.TestId == nil {
		t.TestId = SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_EthCfmSingleEndedDmmTest_TestId_Enum_auto
	}
	t.Timing.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_EthCfmSingleEndedSlmTest) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_EthCfmSingleEndedSlmTest"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_EthCfmSingleEndedSlmTest) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_EthCfmSingleEndedSlmTest) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_EthCfmSingleEndedSlmTest.
func (*SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_EthCfmSingleEndedSlmTest) ΛBelongingModule() string {
	return "srl_nokia-oam-pm-ethcfm"
}

// SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_EthCfmSingleEndedSlmTest_Timing represents the /srl_nokia-oam/oam/performance-monitoring/ethcfm/session/eth-cfm-single-ended-slm-test/timing YANG schema element.
type SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_EthCfmSingleEndedSlmTest_Timing struct {
	ChliThreshold     *uint8  `path:"chli-threshold" module:"srl_nokia-oam-pm-ethcfm"`
	ConsecutiveDeltaT *uint8  `path:"consecutive-delta-t" module:"srl_nokia-oam-pm-ethcfm"`
	FramesPerDeltaT   *uint32 `path:"frames-per-delta-t" module:"srl_nokia-oam-pm-ethcfm"`
}

// IsYANGGoStruct ensures that SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_EthCfmSingleEndedSlmTest_Timing implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_EthCfmSingleEndedSlmTest_Timing) IsYANGGoStruct() {
}

// GetChliThreshold retrieves the value of the leaf ChliThreshold from the SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_EthCfmSingleEndedSlmTest_Timing
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ChliThreshold is set, it can
// safely use t.GetChliThreshold() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ChliThreshold == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_EthCfmSingleEndedSlmTest_Timing) GetChliThreshold() uint8 {
	if t == nil || t.ChliThreshold == nil {
		return 5
	}
	return *t.ChliThreshold
}

// GetConsecutiveDeltaT retrieves the value of the leaf ConsecutiveDeltaT from the SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_EthCfmSingleEndedSlmTest_Timing
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ConsecutiveDeltaT is set, it can
// safely use t.GetConsecutiveDeltaT() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ConsecutiveDeltaT == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_EthCfmSingleEndedSlmTest_Timing) GetConsecutiveDeltaT() uint8 {
	if t == nil || t.ConsecutiveDeltaT == nil {
		return 10
	}
	return *t.ConsecutiveDeltaT
}

// GetFramesPerDeltaT retrieves the value of the leaf FramesPerDeltaT from the SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_EthCfmSingleEndedSlmTest_Timing
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FramesPerDeltaT is set, it can
// safely use t.GetFramesPerDeltaT() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FramesPerDeltaT == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_EthCfmSingleEndedSlmTest_Timing) GetFramesPerDeltaT() uint32 {
	if t == nil || t.FramesPerDeltaT == nil {
		return 1
	}
	return *t.FramesPerDeltaT
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_EthCfmSingleEndedSlmTest_Timing
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_EthCfmSingleEndedSlmTest_Timing) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.ChliThreshold == nil {
		var v uint8 = 5
		t.ChliThreshold = &v
	}
	if t.ConsecutiveDeltaT == nil {
		var v uint8 = 10
		t.ConsecutiveDeltaT = &v
	}
	if t.FramesPerDeltaT == nil {
		var v uint32 = 1
		t.FramesPerDeltaT = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_EthCfmSingleEndedSlmTest_Timing) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_EthCfmSingleEndedSlmTest_Timing"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_EthCfmSingleEndedSlmTest_Timing) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_EthCfmSingleEndedSlmTest_Timing) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_EthCfmSingleEndedSlmTest_Timing.
func (*SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_EthCfmSingleEndedSlmTest_Timing) ΛBelongingModule() string {
	return "srl_nokia-oam-pm-ethcfm"
}

// SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_MeasurementInterval represents the /srl_nokia-oam/oam/performance-monitoring/ethcfm/session/measurement-interval YANG schema element.
type SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_MeasurementInterval struct {
	BoundaryType    E_SrlNokiaOamPmTypes_MeasurementIntervalBoundaryType                                      `path:"boundary-type" module:"srl_nokia-oam-pm-ethcfm"`
	ClockOffset     *uint32                                                                                   `path:"clock-offset" module:"srl_nokia-oam-pm-ethcfm"`
	IntervalsStored *uint8                                                                                    `path:"intervals-stored" module:"srl_nokia-oam-pm-ethcfm"`
	MiDuration      E_SrlNokiaOamPmTypes_MeasurementIntervalDurationType                                      `path:"mi-duration" module:"srl_nokia-oam-pm-ethcfm"`
	ThresholdAlerts *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_MeasurementInterval_ThresholdAlerts `path:"threshold-alerts" module:"srl_nokia-oam-pm-ethcfm"`
}

// IsYANGGoStruct ensures that SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_MeasurementInterval implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_MeasurementInterval) IsYANGGoStruct() {}

// GetOrCreateThresholdAlerts retrieves the value of the ThresholdAlerts field
// or returns the existing field if it already exists.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_MeasurementInterval) GetOrCreateThresholdAlerts() *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_MeasurementInterval_ThresholdAlerts {
	if t.ThresholdAlerts != nil {
		return t.ThresholdAlerts
	}
	t.ThresholdAlerts = &SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_MeasurementInterval_ThresholdAlerts{}
	return t.ThresholdAlerts
}

// GetThresholdAlerts returns the value of the ThresholdAlerts struct pointer
// from SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_MeasurementInterval. If the receiver or the field ThresholdAlerts is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_MeasurementInterval) GetThresholdAlerts() *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_MeasurementInterval_ThresholdAlerts {
	if t != nil && t.ThresholdAlerts != nil {
		return t.ThresholdAlerts
	}
	return nil
}

// GetBoundaryType retrieves the value of the leaf BoundaryType from the SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_MeasurementInterval
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if BoundaryType is set, it can
// safely use t.GetBoundaryType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.BoundaryType == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_MeasurementInterval) GetBoundaryType() E_SrlNokiaOamPmTypes_MeasurementIntervalBoundaryType {
	if t == nil || t.BoundaryType == 0 {
		return SrlNokiaOamPmTypes_MeasurementIntervalBoundaryType_clock_aligned
	}
	return t.BoundaryType
}

// GetClockOffset retrieves the value of the leaf ClockOffset from the SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_MeasurementInterval
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ClockOffset is set, it can
// safely use t.GetClockOffset() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ClockOffset == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_MeasurementInterval) GetClockOffset() uint32 {
	if t == nil || t.ClockOffset == nil {
		return 0
	}
	return *t.ClockOffset
}

// GetIntervalsStored retrieves the value of the leaf IntervalsStored from the SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_MeasurementInterval
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IntervalsStored is set, it can
// safely use t.GetIntervalsStored() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IntervalsStored == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_MeasurementInterval) GetIntervalsStored() uint8 {
	if t == nil || t.IntervalsStored == nil {
		return 0
	}
	return *t.IntervalsStored
}

// GetMiDuration retrieves the value of the leaf MiDuration from the SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_MeasurementInterval
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MiDuration is set, it can
// safely use t.GetMiDuration() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MiDuration == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_MeasurementInterval) GetMiDuration() E_SrlNokiaOamPmTypes_MeasurementIntervalDurationType {
	if t == nil || t.MiDuration == 0 {
		return 0
	}
	return t.MiDuration
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_MeasurementInterval
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_MeasurementInterval) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.BoundaryType == 0 {
		t.BoundaryType = SrlNokiaOamPmTypes_MeasurementIntervalBoundaryType_clock_aligned
	}
	if t.ClockOffset == nil {
		var v uint32 = 0
		t.ClockOffset = &v
	}
	t.ThresholdAlerts.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_MeasurementInterval struct, which is a YANG list entry.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_MeasurementInterval) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"mi-duration": t.MiDuration,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_MeasurementInterval) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_MeasurementInterval"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_MeasurementInterval) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_MeasurementInterval) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_MeasurementInterval.
func (*SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_MeasurementInterval) ΛBelongingModule() string {
	return "srl_nokia-oam-pm-ethcfm"
}

// SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_MeasurementInterval_ThresholdAlerts represents the /srl_nokia-oam/oam/performance-monitoring/ethcfm/session/measurement-interval/threshold-alerts YANG schema element.
type SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_MeasurementInterval_ThresholdAlerts struct {
	DelayEvent E_SrlNokiaCommon_AdminState `path:"delay-event" module:"srl_nokia-oam-pm-ethcfm"`
	LossEvent  E_SrlNokiaCommon_AdminState `path:"loss-event" module:"srl_nokia-oam-pm-ethcfm"`
}

// IsYANGGoStruct ensures that SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_MeasurementInterval_ThresholdAlerts implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_MeasurementInterval_ThresholdAlerts) IsYANGGoStruct() {
}

// GetDelayEvent retrieves the value of the leaf DelayEvent from the SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_MeasurementInterval_ThresholdAlerts
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DelayEvent is set, it can
// safely use t.GetDelayEvent() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DelayEvent == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_MeasurementInterval_ThresholdAlerts) GetDelayEvent() E_SrlNokiaCommon_AdminState {
	if t == nil || t.DelayEvent == 0 {
		return 0
	}
	return t.DelayEvent
}

// GetLossEvent retrieves the value of the leaf LossEvent from the SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_MeasurementInterval_ThresholdAlerts
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LossEvent is set, it can
// safely use t.GetLossEvent() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LossEvent == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_MeasurementInterval_ThresholdAlerts) GetLossEvent() E_SrlNokiaCommon_AdminState {
	if t == nil || t.LossEvent == 0 {
		return 0
	}
	return t.LossEvent
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_MeasurementInterval_ThresholdAlerts
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_MeasurementInterval_ThresholdAlerts) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_MeasurementInterval_ThresholdAlerts) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_MeasurementInterval_ThresholdAlerts"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_MeasurementInterval_ThresholdAlerts) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_MeasurementInterval_ThresholdAlerts) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_MeasurementInterval_ThresholdAlerts.
func (*SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_MeasurementInterval_ThresholdAlerts) ΛBelongingModule() string {
	return "srl_nokia-oam-pm-ethcfm"
}

// SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_Source represents the /srl_nokia-oam/oam/performance-monitoring/ethcfm/session/source YANG schema element.
type SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_Source struct {
	AssociationId *string `path:"association-id" module:"srl_nokia-oam-pm-ethcfm"`
	DomainId      *string `path:"domain-id" module:"srl_nokia-oam-pm-ethcfm"`
	MepId         *uint16 `path:"mep-id" module:"srl_nokia-oam-pm-ethcfm"`
}

// IsYANGGoStruct ensures that SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_Source implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_Source) IsYANGGoStruct() {}

// GetAssociationId retrieves the value of the leaf AssociationId from the SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_Source
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AssociationId is set, it can
// safely use t.GetAssociationId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AssociationId == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_Source) GetAssociationId() string {
	if t == nil || t.AssociationId == nil {
		return ""
	}
	return *t.AssociationId
}

// GetDomainId retrieves the value of the leaf DomainId from the SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_Source
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DomainId is set, it can
// safely use t.GetDomainId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DomainId == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_Source) GetDomainId() string {
	if t == nil || t.DomainId == nil {
		return ""
	}
	return *t.DomainId
}

// GetMepId retrieves the value of the leaf MepId from the SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_Source
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MepId is set, it can
// safely use t.GetMepId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MepId == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_Source) GetMepId() uint16 {
	if t == nil || t.MepId == nil {
		return 0
	}
	return *t.MepId
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_Source
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_Source) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_Source) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_Source"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_Source) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_Source) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_Source.
func (*SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_Source) ΛBelongingModule() string {
	return "srl_nokia-oam-pm-ethcfm"
}

// SrlNokiaOam_Oam_PerformanceMonitoring_Ip represents the /srl_nokia-oam/oam/performance-monitoring/ip YANG schema element.
type SrlNokiaOam_Oam_PerformanceMonitoring_Ip struct {
	Delay   *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay              `path:"delay" module:"srl_nokia-oam-pm-ip"`
	Loss    *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss               `path:"loss" module:"srl_nokia-oam-pm-ip"`
	Session map[string]*SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session `path:"session" module:"srl_nokia-oam-pm-ip"`
}

// IsYANGGoStruct ensures that SrlNokiaOam_Oam_PerformanceMonitoring_Ip implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaOam_Oam_PerformanceMonitoring_Ip) IsYANGGoStruct() {}

// NewSession creates a new entry in the Session list of the
// SrlNokiaOam_Oam_PerformanceMonitoring_Ip struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip) NewSession(SessionName string) (*SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Session == nil {
		t.Session = make(map[string]*SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session)
	}

	key := SessionName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Session[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Session", key)
	}

	t.Session[key] = &SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session{
		SessionName: &SessionName,
	}

	return t.Session[key], nil
}

// RenameSession renames an entry in the list Session within
// the SrlNokiaOam_Oam_PerformanceMonitoring_Ip struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip) RenameSession(oldK, newK string) error {
	if _, ok := t.Session[newK]; ok {
		return fmt.Errorf("key %v already exists in Session", newK)
	}

	e, ok := t.Session[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Session", oldK)
	}
	e.SessionName = &newK

	t.Session[newK] = e
	delete(t.Session, oldK)
	return nil
}

// GetOrCreateSession retrieves the value with the specified keys from
// the receiver SrlNokiaOam_Oam_PerformanceMonitoring_Ip. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip) GetOrCreateSession(SessionName string) *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session {
	key := SessionName

	if v, ok := t.Session[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewSession(SessionName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateSession got unexpected error: %v", err))
	}
	return v
}

// GetSession retrieves the value with the specified key from
// the Session map field of SrlNokiaOam_Oam_PerformanceMonitoring_Ip. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip) GetSession(SessionName string) *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session {
	if t == nil {
		return nil
	}

	key := SessionName

	if lm, ok := t.Session[key]; ok {
		return lm
	}
	return nil
}

// DeleteSession deletes the value with the specified keys from
// the receiver SrlNokiaOam_Oam_PerformanceMonitoring_Ip. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip) DeleteSession(SessionName string) {
	key := SessionName

	delete(t.Session, key)
}

// AppendSession appends the supplied SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session struct to the
// list Session of SrlNokiaOam_Oam_PerformanceMonitoring_Ip. If the key value(s) specified in
// the supplied SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session already exist in the list, an error is
// returned.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip) AppendSession(
	v *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session,
) error {
	if v.SessionName == nil {
		return fmt.Errorf("invalid nil key received for SessionName")
	}

	key := *v.SessionName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Session == nil {
		t.Session = make(map[string]*SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session)
	}

	if _, ok := t.Session[key]; ok {
		return fmt.Errorf("duplicate key for list Session %v", key)
	}

	t.Session[key] = v
	return nil
}

// GetOrCreateDelay retrieves the value of the Delay field
// or returns the existing field if it already exists.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip) GetOrCreateDelay() *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay {
	if t.Delay != nil {
		return t.Delay
	}
	t.Delay = &SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay{}
	return t.Delay
}

// GetOrCreateLoss retrieves the value of the Loss field
// or returns the existing field if it already exists.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip) GetOrCreateLoss() *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss {
	if t.Loss != nil {
		return t.Loss
	}
	t.Loss = &SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss{}
	return t.Loss
}

// GetDelay returns the value of the Delay struct pointer
// from SrlNokiaOam_Oam_PerformanceMonitoring_Ip. If the receiver or the field Delay is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip) GetDelay() *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay {
	if t != nil && t.Delay != nil {
		return t.Delay
	}
	return nil
}

// GetLoss returns the value of the Loss struct pointer
// from SrlNokiaOam_Oam_PerformanceMonitoring_Ip. If the receiver or the field Loss is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip) GetLoss() *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss {
	if t != nil && t.Loss != nil {
		return t.Loss
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaOam_Oam_PerformanceMonitoring_Ip
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Delay.PopulateDefaults()
	t.Loss.PopulateDefaults()
	for _, e := range t.Session {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaOam_Oam_PerformanceMonitoring_Ip"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaOam_Oam_PerformanceMonitoring_Ip.
func (*SrlNokiaOam_Oam_PerformanceMonitoring_Ip) ΛBelongingModule() string {
	return "srl_nokia-oam-pm-ip"
}

// SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay represents the /srl_nokia-oam/oam/performance-monitoring/ip/delay YANG schema element.
type SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay struct {
	BinGroup map[string]*SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup `path:"bin-group" module:"srl_nokia-oam-pm-ip"`
}

// IsYANGGoStruct ensures that SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay) IsYANGGoStruct() {}

// NewBinGroup creates a new entry in the BinGroup list of the
// SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay) NewBinGroup(BinGroupName string) (*SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.BinGroup == nil {
		t.BinGroup = make(map[string]*SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup)
	}

	key := BinGroupName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.BinGroup[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list BinGroup", key)
	}

	t.BinGroup[key] = &SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup{
		BinGroupName: &BinGroupName,
	}

	return t.BinGroup[key], nil
}

// RenameBinGroup renames an entry in the list BinGroup within
// the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay) RenameBinGroup(oldK, newK string) error {
	if _, ok := t.BinGroup[newK]; ok {
		return fmt.Errorf("key %v already exists in BinGroup", newK)
	}

	e, ok := t.BinGroup[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in BinGroup", oldK)
	}
	e.BinGroupName = &newK

	t.BinGroup[newK] = e
	delete(t.BinGroup, oldK)
	return nil
}

// GetOrCreateBinGroup retrieves the value with the specified keys from
// the receiver SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay) GetOrCreateBinGroup(BinGroupName string) *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup {
	key := BinGroupName

	if v, ok := t.BinGroup[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewBinGroup(BinGroupName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateBinGroup got unexpected error: %v", err))
	}
	return v
}

// GetBinGroup retrieves the value with the specified key from
// the BinGroup map field of SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay) GetBinGroup(BinGroupName string) *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup {
	if t == nil {
		return nil
	}

	key := BinGroupName

	if lm, ok := t.BinGroup[key]; ok {
		return lm
	}
	return nil
}

// DeleteBinGroup deletes the value with the specified keys from
// the receiver SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay) DeleteBinGroup(BinGroupName string) {
	key := BinGroupName

	delete(t.BinGroup, key)
}

// AppendBinGroup appends the supplied SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup struct to the
// list BinGroup of SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay. If the key value(s) specified in
// the supplied SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup already exist in the list, an error is
// returned.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay) AppendBinGroup(
	v *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup,
) error {
	if v.BinGroupName == nil {
		return fmt.Errorf("invalid nil key received for BinGroupName")
	}

	key := *v.BinGroupName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.BinGroup == nil {
		t.BinGroup = make(map[string]*SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup)
	}

	if _, ok := t.BinGroup[key]; ok {
		return fmt.Errorf("duplicate key for list BinGroup %v", key)
	}

	t.BinGroup[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.BinGroup {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay.
func (*SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay) ΛBelongingModule() string {
	return "srl_nokia-oam-pm-ip"
}

// SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup represents the /srl_nokia-oam/oam/performance-monitoring/ip/delay/bin-group YANG schema element.
type SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup struct {
	AdminState   E_SrlNokiaCommon_AdminState                                                                             `path:"admin-state" module:"srl_nokia-oam-pm-ip"`
	BinGroupName *string                                                                                                 `path:"bin-group-name" module:"srl_nokia-oam-pm-ip"`
	BinType      map[E_SrlNokiaOamPmTypes_BinMetricType]*SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType `path:"bin-type" module:"srl_nokia-oam-pm-ip"`
	Description  *string                                                                                                 `path:"description" module:"srl_nokia-oam-pm-ip"`
}

// IsYANGGoStruct ensures that SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup) IsYANGGoStruct() {}

// NewBinType creates a new entry in the BinType list of the
// SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup) NewBinType(
	BinMetric E_SrlNokiaOamPmTypes_BinMetricType,
) (*SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.BinType == nil {
		t.BinType = make(map[E_SrlNokiaOamPmTypes_BinMetricType]*SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType)
	}

	key := BinMetric

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.BinType[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list BinType", key)
	}

	t.BinType[key] = &SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType{
		BinMetric: BinMetric,
	}

	return t.BinType[key], nil
}

// RenameBinType renames an entry in the list BinType within
// the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup) RenameBinType(oldK, newK E_SrlNokiaOamPmTypes_BinMetricType) error {
	if _, ok := t.BinType[newK]; ok {
		return fmt.Errorf("key %v already exists in BinType", newK)
	}

	e, ok := t.BinType[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in BinType", oldK)
	}
	e.BinMetric = newK

	t.BinType[newK] = e
	delete(t.BinType, oldK)
	return nil
}

// GetOrCreateBinType retrieves the value with the specified keys from
// the receiver SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup) GetOrCreateBinType(
	BinMetric E_SrlNokiaOamPmTypes_BinMetricType,
) *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType {
	key := BinMetric

	if v, ok := t.BinType[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewBinType(BinMetric)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateBinType got unexpected error: %v", err))
	}
	return v
}

// GetBinType retrieves the value with the specified key from
// the BinType map field of SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup) GetBinType(
	BinMetric E_SrlNokiaOamPmTypes_BinMetricType,
) *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType {
	if t == nil {
		return nil
	}

	key := BinMetric

	if lm, ok := t.BinType[key]; ok {
		return lm
	}
	return nil
}

// DeleteBinType deletes the value with the specified keys from
// the receiver SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup) DeleteBinType(BinMetric E_SrlNokiaOamPmTypes_BinMetricType) {
	key := BinMetric

	delete(t.BinType, key)
}

// AppendBinType appends the supplied SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType struct to the
// list BinType of SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup. If the key value(s) specified in
// the supplied SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType already exist in the list, an error is
// returned.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup) AppendBinType(
	v *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType,
) error {
	key := v.BinMetric

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.BinType == nil {
		t.BinType = make(map[E_SrlNokiaOamPmTypes_BinMetricType]*SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType)
	}

	if _, ok := t.BinType[key]; ok {
		return fmt.Errorf("duplicate key for list BinType %v", key)
	}

	t.BinType[key] = v
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_disable
	}
	return t.AdminState
}

// GetBinGroupName retrieves the value of the leaf BinGroupName from the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if BinGroupName is set, it can
// safely use t.GetBinGroupName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.BinGroupName == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup) GetBinGroupName() string {
	if t == nil || t.BinGroupName == nil {
		return ""
	}
	return *t.BinGroupName
}

// GetDescription retrieves the value of the leaf Description from the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_disable
	}
	for _, e := range t.BinType {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup struct, which is a YANG list entry.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup) ΛListKeyMap() (map[string]interface{}, error) {
	if t.BinGroupName == nil {
		return nil, fmt.Errorf("nil value for key BinGroupName")
	}

	return map[string]interface{}{
		"bin-group-name": *t.BinGroupName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup.
func (*SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup) ΛBelongingModule() string {
	return "srl_nokia-oam-pm-ip"
}

// SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType represents the /srl_nokia-oam/oam/performance-monitoring/ip/delay/bin-group/bin-type YANG schema element.
type SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType struct {
	Bin            map[uint8]*SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType_Bin                                              `path:"bin" module:"srl_nokia-oam-pm-ip"`
	BinCount       *uint8                                                                                                                      `path:"bin-count" module:"srl_nokia-oam-pm-ip"`
	BinMetric      E_SrlNokiaOamPmTypes_BinMetricType                                                                                          `path:"bin-metric" module:"srl_nokia-oam-pm-ip"`
	DelayEvent     map[E_SrlNokiaOamPmTypes_DelayDirectionType]*SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType_DelayEvent     `path:"delay-event" module:"srl_nokia-oam-pm-ip"`
	ExcludeFromAvg map[E_SrlNokiaOamPmTypes_DelayDirectionType]*SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType_ExcludeFromAvg `path:"exclude-from-avg" module:"srl_nokia-oam-pm-ip"`
}

// IsYANGGoStruct ensures that SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType) IsYANGGoStruct() {}

// NewBin creates a new entry in the Bin list of the
// SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType) NewBin(BinNumber uint8) (*SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType_Bin, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Bin == nil {
		t.Bin = make(map[uint8]*SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType_Bin)
	}

	key := BinNumber

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Bin[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Bin", key)
	}

	t.Bin[key] = &SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType_Bin{
		BinNumber: &BinNumber,
	}

	return t.Bin[key], nil
}

// RenameBin renames an entry in the list Bin within
// the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType) RenameBin(oldK, newK uint8) error {
	if _, ok := t.Bin[newK]; ok {
		return fmt.Errorf("key %v already exists in Bin", newK)
	}

	e, ok := t.Bin[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Bin", oldK)
	}
	e.BinNumber = &newK

	t.Bin[newK] = e
	delete(t.Bin, oldK)
	return nil
}

// GetOrCreateBin retrieves the value with the specified keys from
// the receiver SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType) GetOrCreateBin(
	BinNumber uint8,
) *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType_Bin {
	key := BinNumber

	if v, ok := t.Bin[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewBin(BinNumber)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateBin got unexpected error: %v", err))
	}
	return v
}

// GetBin retrieves the value with the specified key from
// the Bin map field of SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType) GetBin(BinNumber uint8) *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType_Bin {
	if t == nil {
		return nil
	}

	key := BinNumber

	if lm, ok := t.Bin[key]; ok {
		return lm
	}
	return nil
}

// DeleteBin deletes the value with the specified keys from
// the receiver SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType) DeleteBin(BinNumber uint8) {
	key := BinNumber

	delete(t.Bin, key)
}

// AppendBin appends the supplied SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType_Bin struct to the
// list Bin of SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType. If the key value(s) specified in
// the supplied SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType_Bin already exist in the list, an error is
// returned.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType) AppendBin(
	v *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType_Bin,
) error {
	if v.BinNumber == nil {
		return fmt.Errorf("invalid nil key received for BinNumber")
	}

	key := *v.BinNumber

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Bin == nil {
		t.Bin = make(map[uint8]*SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType_Bin)
	}

	if _, ok := t.Bin[key]; ok {
		return fmt.Errorf("duplicate key for list Bin %v", key)
	}

	t.Bin[key] = v
	return nil
}

// NewDelayEvent creates a new entry in the DelayEvent list of the
// SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType) NewDelayEvent(
	Direction E_SrlNokiaOamPmTypes_DelayDirectionType,
) (*SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType_DelayEvent, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.DelayEvent == nil {
		t.DelayEvent = make(map[E_SrlNokiaOamPmTypes_DelayDirectionType]*SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType_DelayEvent)
	}

	key := Direction

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.DelayEvent[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list DelayEvent", key)
	}

	t.DelayEvent[key] = &SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType_DelayEvent{
		Direction: Direction,
	}

	return t.DelayEvent[key], nil
}

// RenameDelayEvent renames an entry in the list DelayEvent within
// the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType) RenameDelayEvent(oldK, newK E_SrlNokiaOamPmTypes_DelayDirectionType) error {
	if _, ok := t.DelayEvent[newK]; ok {
		return fmt.Errorf("key %v already exists in DelayEvent", newK)
	}

	e, ok := t.DelayEvent[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in DelayEvent", oldK)
	}
	e.Direction = newK

	t.DelayEvent[newK] = e
	delete(t.DelayEvent, oldK)
	return nil
}

// GetOrCreateDelayEvent retrieves the value with the specified keys from
// the receiver SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType) GetOrCreateDelayEvent(
	Direction E_SrlNokiaOamPmTypes_DelayDirectionType,
) *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType_DelayEvent {
	key := Direction

	if v, ok := t.DelayEvent[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewDelayEvent(Direction)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateDelayEvent got unexpected error: %v", err))
	}
	return v
}

// GetDelayEvent retrieves the value with the specified key from
// the DelayEvent map field of SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType) GetDelayEvent(
	Direction E_SrlNokiaOamPmTypes_DelayDirectionType,
) *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType_DelayEvent {
	if t == nil {
		return nil
	}

	key := Direction

	if lm, ok := t.DelayEvent[key]; ok {
		return lm
	}
	return nil
}

// DeleteDelayEvent deletes the value with the specified keys from
// the receiver SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType) DeleteDelayEvent(Direction E_SrlNokiaOamPmTypes_DelayDirectionType) {
	key := Direction

	delete(t.DelayEvent, key)
}

// AppendDelayEvent appends the supplied SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType_DelayEvent struct to the
// list DelayEvent of SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType. If the key value(s) specified in
// the supplied SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType_DelayEvent already exist in the list, an error is
// returned.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType) AppendDelayEvent(
	v *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType_DelayEvent,
) error {
	key := v.Direction

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.DelayEvent == nil {
		t.DelayEvent = make(map[E_SrlNokiaOamPmTypes_DelayDirectionType]*SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType_DelayEvent)
	}

	if _, ok := t.DelayEvent[key]; ok {
		return fmt.Errorf("duplicate key for list DelayEvent %v", key)
	}

	t.DelayEvent[key] = v
	return nil
}

// NewExcludeFromAvg creates a new entry in the ExcludeFromAvg list of the
// SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType) NewExcludeFromAvg(
	Direction E_SrlNokiaOamPmTypes_DelayDirectionType,
) (*SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType_ExcludeFromAvg, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ExcludeFromAvg == nil {
		t.ExcludeFromAvg = make(map[E_SrlNokiaOamPmTypes_DelayDirectionType]*SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType_ExcludeFromAvg)
	}

	key := Direction

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.ExcludeFromAvg[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list ExcludeFromAvg", key)
	}

	t.ExcludeFromAvg[key] = &SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType_ExcludeFromAvg{
		Direction: Direction,
	}

	return t.ExcludeFromAvg[key], nil
}

// RenameExcludeFromAvg renames an entry in the list ExcludeFromAvg within
// the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType) RenameExcludeFromAvg(oldK, newK E_SrlNokiaOamPmTypes_DelayDirectionType) error {
	if _, ok := t.ExcludeFromAvg[newK]; ok {
		return fmt.Errorf("key %v already exists in ExcludeFromAvg", newK)
	}

	e, ok := t.ExcludeFromAvg[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in ExcludeFromAvg", oldK)
	}
	e.Direction = newK

	t.ExcludeFromAvg[newK] = e
	delete(t.ExcludeFromAvg, oldK)
	return nil
}

// GetOrCreateExcludeFromAvg retrieves the value with the specified keys from
// the receiver SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType) GetOrCreateExcludeFromAvg(
	Direction E_SrlNokiaOamPmTypes_DelayDirectionType,
) *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType_ExcludeFromAvg {
	key := Direction

	if v, ok := t.ExcludeFromAvg[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewExcludeFromAvg(Direction)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateExcludeFromAvg got unexpected error: %v", err))
	}
	return v
}

// GetExcludeFromAvg retrieves the value with the specified key from
// the ExcludeFromAvg map field of SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType) GetExcludeFromAvg(
	Direction E_SrlNokiaOamPmTypes_DelayDirectionType,
) *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType_ExcludeFromAvg {
	if t == nil {
		return nil
	}

	key := Direction

	if lm, ok := t.ExcludeFromAvg[key]; ok {
		return lm
	}
	return nil
}

// DeleteExcludeFromAvg deletes the value with the specified keys from
// the receiver SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType) DeleteExcludeFromAvg(Direction E_SrlNokiaOamPmTypes_DelayDirectionType) {
	key := Direction

	delete(t.ExcludeFromAvg, key)
}

// AppendExcludeFromAvg appends the supplied SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType_ExcludeFromAvg struct to the
// list ExcludeFromAvg of SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType. If the key value(s) specified in
// the supplied SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType_ExcludeFromAvg already exist in the list, an error is
// returned.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType) AppendExcludeFromAvg(
	v *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType_ExcludeFromAvg,
) error {
	key := v.Direction

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ExcludeFromAvg == nil {
		t.ExcludeFromAvg = make(map[E_SrlNokiaOamPmTypes_DelayDirectionType]*SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType_ExcludeFromAvg)
	}

	if _, ok := t.ExcludeFromAvg[key]; ok {
		return fmt.Errorf("duplicate key for list ExcludeFromAvg %v", key)
	}

	t.ExcludeFromAvg[key] = v
	return nil
}

// GetBinCount retrieves the value of the leaf BinCount from the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if BinCount is set, it can
// safely use t.GetBinCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.BinCount == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType) GetBinCount() uint8 {
	if t == nil || t.BinCount == nil {
		return 0
	}
	return *t.BinCount
}

// GetBinMetric retrieves the value of the leaf BinMetric from the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if BinMetric is set, it can
// safely use t.GetBinMetric() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.BinMetric == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType) GetBinMetric() E_SrlNokiaOamPmTypes_BinMetricType {
	if t == nil || t.BinMetric == 0 {
		return 0
	}
	return t.BinMetric
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Bin {
		e.PopulateDefaults()
	}
	for _, e := range t.DelayEvent {
		e.PopulateDefaults()
	}
	for _, e := range t.ExcludeFromAvg {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType struct, which is a YANG list entry.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"bin-metric": t.BinMetric,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType.
func (*SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType) ΛBelongingModule() string {
	return "srl_nokia-oam-pm-ip"
}

// SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType_Bin represents the /srl_nokia-oam/oam/performance-monitoring/ip/delay/bin-group/bin-type/bin YANG schema element.
type SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType_Bin struct {
	BinNumber  *uint8  `path:"bin-number" module:"srl_nokia-oam-pm-ip"`
	LowerBound *uint32 `path:"lower-bound" module:"srl_nokia-oam-pm-ip"`
}

// IsYANGGoStruct ensures that SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType_Bin implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType_Bin) IsYANGGoStruct() {}

// GetBinNumber retrieves the value of the leaf BinNumber from the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType_Bin
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if BinNumber is set, it can
// safely use t.GetBinNumber() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.BinNumber == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType_Bin) GetBinNumber() uint8 {
	if t == nil || t.BinNumber == nil {
		return 0
	}
	return *t.BinNumber
}

// GetLowerBound retrieves the value of the leaf LowerBound from the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType_Bin
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LowerBound is set, it can
// safely use t.GetLowerBound() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LowerBound == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType_Bin) GetLowerBound() uint32 {
	if t == nil || t.LowerBound == nil {
		return 0
	}
	return *t.LowerBound
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType_Bin
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType_Bin) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType_Bin struct, which is a YANG list entry.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType_Bin) ΛListKeyMap() (map[string]interface{}, error) {
	if t.BinNumber == nil {
		return nil, fmt.Errorf("nil value for key BinNumber")
	}

	return map[string]interface{}{
		"bin-number": *t.BinNumber,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType_Bin) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType_Bin"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType_Bin) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType_Bin) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType_Bin.
func (*SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType_Bin) ΛBelongingModule() string {
	return "srl_nokia-oam-pm-ip"
}

// SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType_DelayEvent represents the /srl_nokia-oam/oam/performance-monitoring/ip/delay/bin-group/bin-type/delay-event YANG schema element.
type SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType_DelayEvent struct {
	ClearThreshold   *uint32                                 `path:"clear-threshold" module:"srl_nokia-oam-pm-ip"`
	Direction        E_SrlNokiaOamPmTypes_DelayDirectionType `path:"direction" module:"srl_nokia-oam-pm-ip"`
	ExcludeLowestBin *uint32                                 `path:"exclude-lowest-bin" module:"srl_nokia-oam-pm-ip"`
	LowestBin        *uint32                                 `path:"lowest-bin" module:"srl_nokia-oam-pm-ip"`
	RaiseThreshold   *uint32                                 `path:"raise-threshold" module:"srl_nokia-oam-pm-ip"`
}

// IsYANGGoStruct ensures that SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType_DelayEvent implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType_DelayEvent) IsYANGGoStruct() {}

// GetClearThreshold retrieves the value of the leaf ClearThreshold from the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType_DelayEvent
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ClearThreshold is set, it can
// safely use t.GetClearThreshold() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ClearThreshold == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType_DelayEvent) GetClearThreshold() uint32 {
	if t == nil || t.ClearThreshold == nil {
		return 0
	}
	return *t.ClearThreshold
}

// GetDirection retrieves the value of the leaf Direction from the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType_DelayEvent
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Direction is set, it can
// safely use t.GetDirection() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Direction == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType_DelayEvent) GetDirection() E_SrlNokiaOamPmTypes_DelayDirectionType {
	if t == nil || t.Direction == 0 {
		return 0
	}
	return t.Direction
}

// GetExcludeLowestBin retrieves the value of the leaf ExcludeLowestBin from the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType_DelayEvent
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ExcludeLowestBin is set, it can
// safely use t.GetExcludeLowestBin() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ExcludeLowestBin == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType_DelayEvent) GetExcludeLowestBin() uint32 {
	if t == nil || t.ExcludeLowestBin == nil {
		return 0
	}
	return *t.ExcludeLowestBin
}

// GetLowestBin retrieves the value of the leaf LowestBin from the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType_DelayEvent
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LowestBin is set, it can
// safely use t.GetLowestBin() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LowestBin == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType_DelayEvent) GetLowestBin() uint32 {
	if t == nil || t.LowestBin == nil {
		return 0
	}
	return *t.LowestBin
}

// GetRaiseThreshold retrieves the value of the leaf RaiseThreshold from the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType_DelayEvent
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RaiseThreshold is set, it can
// safely use t.GetRaiseThreshold() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RaiseThreshold == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType_DelayEvent) GetRaiseThreshold() uint32 {
	if t == nil || t.RaiseThreshold == nil {
		return 0
	}
	return *t.RaiseThreshold
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType_DelayEvent
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType_DelayEvent) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType_DelayEvent struct, which is a YANG list entry.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType_DelayEvent) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"direction": t.Direction,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType_DelayEvent) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType_DelayEvent"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType_DelayEvent) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType_DelayEvent) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType_DelayEvent.
func (*SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType_DelayEvent) ΛBelongingModule() string {
	return "srl_nokia-oam-pm-ip"
}

// SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType_ExcludeFromAvg represents the /srl_nokia-oam/oam/performance-monitoring/ip/delay/bin-group/bin-type/exclude-from-avg YANG schema element.
type SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType_ExcludeFromAvg struct {
	Bins      *string                                 `path:"bins" module:"srl_nokia-oam-pm-ip"`
	Direction E_SrlNokiaOamPmTypes_DelayDirectionType `path:"direction" module:"srl_nokia-oam-pm-ip"`
}

// IsYANGGoStruct ensures that SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType_ExcludeFromAvg implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType_ExcludeFromAvg) IsYANGGoStruct() {
}

// GetBins retrieves the value of the leaf Bins from the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType_ExcludeFromAvg
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Bins is set, it can
// safely use t.GetBins() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Bins == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType_ExcludeFromAvg) GetBins() string {
	if t == nil || t.Bins == nil {
		return ""
	}
	return *t.Bins
}

// GetDirection retrieves the value of the leaf Direction from the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType_ExcludeFromAvg
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Direction is set, it can
// safely use t.GetDirection() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Direction == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType_ExcludeFromAvg) GetDirection() E_SrlNokiaOamPmTypes_DelayDirectionType {
	if t == nil || t.Direction == 0 {
		return 0
	}
	return t.Direction
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType_ExcludeFromAvg
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType_ExcludeFromAvg) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType_ExcludeFromAvg struct, which is a YANG list entry.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType_ExcludeFromAvg) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"direction": t.Direction,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType_ExcludeFromAvg) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType_ExcludeFromAvg"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType_ExcludeFromAvg) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType_ExcludeFromAvg) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType_ExcludeFromAvg.
func (*SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Delay_BinGroup_BinType_ExcludeFromAvg) ΛBelongingModule() string {
	return "srl_nokia-oam-pm-ip"
}

// SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss represents the /srl_nokia-oam/oam/performance-monitoring/ip/loss YANG schema element.
type SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss struct {
	LossEventsTemplate map[string]*SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate `path:"loss-events-template" module:"srl_nokia-oam-pm-ip"`
}

// IsYANGGoStruct ensures that SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss) IsYANGGoStruct() {}

// NewLossEventsTemplate creates a new entry in the LossEventsTemplate list of the
// SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss) NewLossEventsTemplate(
	LossEventsTemplateName string,
) (*SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.LossEventsTemplate == nil {
		t.LossEventsTemplate = make(map[string]*SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate)
	}

	key := LossEventsTemplateName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.LossEventsTemplate[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list LossEventsTemplate", key)
	}

	t.LossEventsTemplate[key] = &SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate{
		LossEventsTemplateName: &LossEventsTemplateName,
	}

	return t.LossEventsTemplate[key], nil
}

// RenameLossEventsTemplate renames an entry in the list LossEventsTemplate within
// the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss) RenameLossEventsTemplate(oldK, newK string) error {
	if _, ok := t.LossEventsTemplate[newK]; ok {
		return fmt.Errorf("key %v already exists in LossEventsTemplate", newK)
	}

	e, ok := t.LossEventsTemplate[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in LossEventsTemplate", oldK)
	}
	e.LossEventsTemplateName = &newK

	t.LossEventsTemplate[newK] = e
	delete(t.LossEventsTemplate, oldK)
	return nil
}

// GetOrCreateLossEventsTemplate retrieves the value with the specified keys from
// the receiver SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss) GetOrCreateLossEventsTemplate(
	LossEventsTemplateName string,
) *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate {
	key := LossEventsTemplateName

	if v, ok := t.LossEventsTemplate[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewLossEventsTemplate(LossEventsTemplateName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateLossEventsTemplate got unexpected error: %v", err))
	}
	return v
}

// GetLossEventsTemplate retrieves the value with the specified key from
// the LossEventsTemplate map field of SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss) GetLossEventsTemplate(
	LossEventsTemplateName string,
) *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate {
	if t == nil {
		return nil
	}

	key := LossEventsTemplateName

	if lm, ok := t.LossEventsTemplate[key]; ok {
		return lm
	}
	return nil
}

// DeleteLossEventsTemplate deletes the value with the specified keys from
// the receiver SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss) DeleteLossEventsTemplate(LossEventsTemplateName string) {
	key := LossEventsTemplateName

	delete(t.LossEventsTemplate, key)
}

// AppendLossEventsTemplate appends the supplied SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate struct to the
// list LossEventsTemplate of SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss. If the key value(s) specified in
// the supplied SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate already exist in the list, an error is
// returned.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss) AppendLossEventsTemplate(
	v *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate,
) error {
	if v.LossEventsTemplateName == nil {
		return fmt.Errorf("invalid nil key received for LossEventsTemplateName")
	}

	key := *v.LossEventsTemplateName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.LossEventsTemplate == nil {
		t.LossEventsTemplate = make(map[string]*SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate)
	}

	if _, ok := t.LossEventsTemplate[key]; ok {
		return fmt.Errorf("duplicate key for list LossEventsTemplate %v", key)
	}

	t.LossEventsTemplate[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.LossEventsTemplate {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss.
func (*SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss) ΛBelongingModule() string {
	return "srl_nokia-oam-pm-ip"
}

// SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate represents the /srl_nokia-oam/oam/performance-monitoring/ip/loss/loss-events-template YANG schema element.
type SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate struct {
	AvgFlrEvent                     map[E_SrlNokiaOamPmTypes_LossDirectionType]*SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_AvgFlrEvent                              `path:"avg-flr-event" module:"srl_nokia-oam-pm-ip"`
	ChliEvent                       map[E_SrlNokiaOamPmTypes_LossDirectionAggregateType]*SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_ChliEvent                       `path:"chli-event" module:"srl_nokia-oam-pm-ip"`
	HliEvent                        map[E_SrlNokiaOamPmTypes_LossDirectionAggregateType]*SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_HliEvent                        `path:"hli-event" module:"srl_nokia-oam-pm-ip"`
	LossEventsTemplateName          *string                                                                                                                                               `path:"loss-events-template-name" module:"srl_nokia-oam-pm-ip"`
	UnavailabilityEvent             map[E_SrlNokiaOamPmTypes_LossDirectionAggregateType]*SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_UnavailabilityEvent             `path:"unavailability-event" module:"srl_nokia-oam-pm-ip"`
	UndeterminedAvailabilityEvent   map[E_SrlNokiaOamPmTypes_LossDirectionAggregateType]*SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_UndeterminedAvailabilityEvent   `path:"undetermined-availability-event" module:"srl_nokia-oam-pm-ip"`
	UndeterminedUnavailabilityEvent map[E_SrlNokiaOamPmTypes_LossDirectionAggregateType]*SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_UndeterminedUnavailabilityEvent `path:"undetermined-unavailability-event" module:"srl_nokia-oam-pm-ip"`
}

// IsYANGGoStruct ensures that SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate) IsYANGGoStruct() {}

// NewAvgFlrEvent creates a new entry in the AvgFlrEvent list of the
// SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate) NewAvgFlrEvent(
	Direction E_SrlNokiaOamPmTypes_LossDirectionType,
) (*SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_AvgFlrEvent, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AvgFlrEvent == nil {
		t.AvgFlrEvent = make(map[E_SrlNokiaOamPmTypes_LossDirectionType]*SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_AvgFlrEvent)
	}

	key := Direction

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.AvgFlrEvent[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list AvgFlrEvent", key)
	}

	t.AvgFlrEvent[key] = &SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_AvgFlrEvent{
		Direction: Direction,
	}

	return t.AvgFlrEvent[key], nil
}

// RenameAvgFlrEvent renames an entry in the list AvgFlrEvent within
// the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate) RenameAvgFlrEvent(oldK, newK E_SrlNokiaOamPmTypes_LossDirectionType) error {
	if _, ok := t.AvgFlrEvent[newK]; ok {
		return fmt.Errorf("key %v already exists in AvgFlrEvent", newK)
	}

	e, ok := t.AvgFlrEvent[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in AvgFlrEvent", oldK)
	}
	e.Direction = newK

	t.AvgFlrEvent[newK] = e
	delete(t.AvgFlrEvent, oldK)
	return nil
}

// GetOrCreateAvgFlrEvent retrieves the value with the specified keys from
// the receiver SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate) GetOrCreateAvgFlrEvent(
	Direction E_SrlNokiaOamPmTypes_LossDirectionType,
) *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_AvgFlrEvent {
	key := Direction

	if v, ok := t.AvgFlrEvent[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAvgFlrEvent(Direction)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAvgFlrEvent got unexpected error: %v", err))
	}
	return v
}

// GetAvgFlrEvent retrieves the value with the specified key from
// the AvgFlrEvent map field of SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate) GetAvgFlrEvent(
	Direction E_SrlNokiaOamPmTypes_LossDirectionType,
) *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_AvgFlrEvent {
	if t == nil {
		return nil
	}

	key := Direction

	if lm, ok := t.AvgFlrEvent[key]; ok {
		return lm
	}
	return nil
}

// DeleteAvgFlrEvent deletes the value with the specified keys from
// the receiver SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate) DeleteAvgFlrEvent(Direction E_SrlNokiaOamPmTypes_LossDirectionType) {
	key := Direction

	delete(t.AvgFlrEvent, key)
}

// AppendAvgFlrEvent appends the supplied SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_AvgFlrEvent struct to the
// list AvgFlrEvent of SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate. If the key value(s) specified in
// the supplied SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_AvgFlrEvent already exist in the list, an error is
// returned.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate) AppendAvgFlrEvent(
	v *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_AvgFlrEvent,
) error {
	key := v.Direction

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AvgFlrEvent == nil {
		t.AvgFlrEvent = make(map[E_SrlNokiaOamPmTypes_LossDirectionType]*SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_AvgFlrEvent)
	}

	if _, ok := t.AvgFlrEvent[key]; ok {
		return fmt.Errorf("duplicate key for list AvgFlrEvent %v", key)
	}

	t.AvgFlrEvent[key] = v
	return nil
}

// NewChliEvent creates a new entry in the ChliEvent list of the
// SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate) NewChliEvent(
	Direction E_SrlNokiaOamPmTypes_LossDirectionAggregateType,
) (*SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_ChliEvent, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ChliEvent == nil {
		t.ChliEvent = make(map[E_SrlNokiaOamPmTypes_LossDirectionAggregateType]*SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_ChliEvent)
	}

	key := Direction

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.ChliEvent[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list ChliEvent", key)
	}

	t.ChliEvent[key] = &SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_ChliEvent{
		Direction: Direction,
	}

	return t.ChliEvent[key], nil
}

// RenameChliEvent renames an entry in the list ChliEvent within
// the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate) RenameChliEvent(
	oldK, newK E_SrlNokiaOamPmTypes_LossDirectionAggregateType,
) error {
	if _, ok := t.ChliEvent[newK]; ok {
		return fmt.Errorf("key %v already exists in ChliEvent", newK)
	}

	e, ok := t.ChliEvent[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in ChliEvent", oldK)
	}
	e.Direction = newK

	t.ChliEvent[newK] = e
	delete(t.ChliEvent, oldK)
	return nil
}

// GetOrCreateChliEvent retrieves the value with the specified keys from
// the receiver SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate) GetOrCreateChliEvent(
	Direction E_SrlNokiaOamPmTypes_LossDirectionAggregateType,
) *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_ChliEvent {
	key := Direction

	if v, ok := t.ChliEvent[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewChliEvent(Direction)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateChliEvent got unexpected error: %v", err))
	}
	return v
}

// GetChliEvent retrieves the value with the specified key from
// the ChliEvent map field of SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate) GetChliEvent(
	Direction E_SrlNokiaOamPmTypes_LossDirectionAggregateType,
) *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_ChliEvent {
	if t == nil {
		return nil
	}

	key := Direction

	if lm, ok := t.ChliEvent[key]; ok {
		return lm
	}
	return nil
}

// DeleteChliEvent deletes the value with the specified keys from
// the receiver SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate) DeleteChliEvent(
	Direction E_SrlNokiaOamPmTypes_LossDirectionAggregateType,
) {
	key := Direction

	delete(t.ChliEvent, key)
}

// AppendChliEvent appends the supplied SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_ChliEvent struct to the
// list ChliEvent of SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate. If the key value(s) specified in
// the supplied SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_ChliEvent already exist in the list, an error is
// returned.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate) AppendChliEvent(
	v *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_ChliEvent,
) error {
	key := v.Direction

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ChliEvent == nil {
		t.ChliEvent = make(map[E_SrlNokiaOamPmTypes_LossDirectionAggregateType]*SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_ChliEvent)
	}

	if _, ok := t.ChliEvent[key]; ok {
		return fmt.Errorf("duplicate key for list ChliEvent %v", key)
	}

	t.ChliEvent[key] = v
	return nil
}

// NewHliEvent creates a new entry in the HliEvent list of the
// SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate) NewHliEvent(
	Direction E_SrlNokiaOamPmTypes_LossDirectionAggregateType,
) (*SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_HliEvent, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.HliEvent == nil {
		t.HliEvent = make(map[E_SrlNokiaOamPmTypes_LossDirectionAggregateType]*SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_HliEvent)
	}

	key := Direction

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.HliEvent[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list HliEvent", key)
	}

	t.HliEvent[key] = &SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_HliEvent{
		Direction: Direction,
	}

	return t.HliEvent[key], nil
}

// RenameHliEvent renames an entry in the list HliEvent within
// the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate) RenameHliEvent(
	oldK, newK E_SrlNokiaOamPmTypes_LossDirectionAggregateType,
) error {
	if _, ok := t.HliEvent[newK]; ok {
		return fmt.Errorf("key %v already exists in HliEvent", newK)
	}

	e, ok := t.HliEvent[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in HliEvent", oldK)
	}
	e.Direction = newK

	t.HliEvent[newK] = e
	delete(t.HliEvent, oldK)
	return nil
}

// GetOrCreateHliEvent retrieves the value with the specified keys from
// the receiver SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate) GetOrCreateHliEvent(
	Direction E_SrlNokiaOamPmTypes_LossDirectionAggregateType,
) *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_HliEvent {
	key := Direction

	if v, ok := t.HliEvent[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewHliEvent(Direction)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateHliEvent got unexpected error: %v", err))
	}
	return v
}

// GetHliEvent retrieves the value with the specified key from
// the HliEvent map field of SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate) GetHliEvent(
	Direction E_SrlNokiaOamPmTypes_LossDirectionAggregateType,
) *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_HliEvent {
	if t == nil {
		return nil
	}

	key := Direction

	if lm, ok := t.HliEvent[key]; ok {
		return lm
	}
	return nil
}

// DeleteHliEvent deletes the value with the specified keys from
// the receiver SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate) DeleteHliEvent(
	Direction E_SrlNokiaOamPmTypes_LossDirectionAggregateType,
) {
	key := Direction

	delete(t.HliEvent, key)
}

// AppendHliEvent appends the supplied SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_HliEvent struct to the
// list HliEvent of SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate. If the key value(s) specified in
// the supplied SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_HliEvent already exist in the list, an error is
// returned.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate) AppendHliEvent(
	v *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_HliEvent,
) error {
	key := v.Direction

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.HliEvent == nil {
		t.HliEvent = make(map[E_SrlNokiaOamPmTypes_LossDirectionAggregateType]*SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_HliEvent)
	}

	if _, ok := t.HliEvent[key]; ok {
		return fmt.Errorf("duplicate key for list HliEvent %v", key)
	}

	t.HliEvent[key] = v
	return nil
}

// NewUnavailabilityEvent creates a new entry in the UnavailabilityEvent list of the
// SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate) NewUnavailabilityEvent(
	Direction E_SrlNokiaOamPmTypes_LossDirectionAggregateType,
) (*SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_UnavailabilityEvent, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.UnavailabilityEvent == nil {
		t.UnavailabilityEvent = make(map[E_SrlNokiaOamPmTypes_LossDirectionAggregateType]*SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_UnavailabilityEvent)
	}

	key := Direction

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.UnavailabilityEvent[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list UnavailabilityEvent", key)
	}

	t.UnavailabilityEvent[key] = &SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_UnavailabilityEvent{
		Direction: Direction,
	}

	return t.UnavailabilityEvent[key], nil
}

// RenameUnavailabilityEvent renames an entry in the list UnavailabilityEvent within
// the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate) RenameUnavailabilityEvent(
	oldK, newK E_SrlNokiaOamPmTypes_LossDirectionAggregateType,
) error {
	if _, ok := t.UnavailabilityEvent[newK]; ok {
		return fmt.Errorf("key %v already exists in UnavailabilityEvent", newK)
	}

	e, ok := t.UnavailabilityEvent[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in UnavailabilityEvent", oldK)
	}
	e.Direction = newK

	t.UnavailabilityEvent[newK] = e
	delete(t.UnavailabilityEvent, oldK)
	return nil
}

// GetOrCreateUnavailabilityEvent retrieves the value with the specified keys from
// the receiver SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate) GetOrCreateUnavailabilityEvent(
	Direction E_SrlNokiaOamPmTypes_LossDirectionAggregateType,
) *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_UnavailabilityEvent {
	key := Direction

	if v, ok := t.UnavailabilityEvent[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewUnavailabilityEvent(Direction)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateUnavailabilityEvent got unexpected error: %v", err))
	}
	return v
}

// GetUnavailabilityEvent retrieves the value with the specified key from
// the UnavailabilityEvent map field of SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate) GetUnavailabilityEvent(
	Direction E_SrlNokiaOamPmTypes_LossDirectionAggregateType,
) *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_UnavailabilityEvent {
	if t == nil {
		return nil
	}

	key := Direction

	if lm, ok := t.UnavailabilityEvent[key]; ok {
		return lm
	}
	return nil
}

// DeleteUnavailabilityEvent deletes the value with the specified keys from
// the receiver SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate) DeleteUnavailabilityEvent(
	Direction E_SrlNokiaOamPmTypes_LossDirectionAggregateType,
) {
	key := Direction

	delete(t.UnavailabilityEvent, key)
}

// AppendUnavailabilityEvent appends the supplied SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_UnavailabilityEvent struct to the
// list UnavailabilityEvent of SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate. If the key value(s) specified in
// the supplied SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_UnavailabilityEvent already exist in the list, an error is
// returned.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate) AppendUnavailabilityEvent(
	v *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_UnavailabilityEvent,
) error {
	key := v.Direction

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.UnavailabilityEvent == nil {
		t.UnavailabilityEvent = make(map[E_SrlNokiaOamPmTypes_LossDirectionAggregateType]*SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_UnavailabilityEvent)
	}

	if _, ok := t.UnavailabilityEvent[key]; ok {
		return fmt.Errorf("duplicate key for list UnavailabilityEvent %v", key)
	}

	t.UnavailabilityEvent[key] = v
	return nil
}

// NewUndeterminedAvailabilityEvent creates a new entry in the UndeterminedAvailabilityEvent list of the
// SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate) NewUndeterminedAvailabilityEvent(
	Direction E_SrlNokiaOamPmTypes_LossDirectionAggregateType,
) (*SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_UndeterminedAvailabilityEvent, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.UndeterminedAvailabilityEvent == nil {
		t.UndeterminedAvailabilityEvent = make(map[E_SrlNokiaOamPmTypes_LossDirectionAggregateType]*SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_UndeterminedAvailabilityEvent)
	}

	key := Direction

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.UndeterminedAvailabilityEvent[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list UndeterminedAvailabilityEvent", key)
	}

	t.UndeterminedAvailabilityEvent[key] = &SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_UndeterminedAvailabilityEvent{
		Direction: Direction,
	}

	return t.UndeterminedAvailabilityEvent[key], nil
}

// RenameUndeterminedAvailabilityEvent renames an entry in the list UndeterminedAvailabilityEvent within
// the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate) RenameUndeterminedAvailabilityEvent(
	oldK, newK E_SrlNokiaOamPmTypes_LossDirectionAggregateType,
) error {
	if _, ok := t.UndeterminedAvailabilityEvent[newK]; ok {
		return fmt.Errorf("key %v already exists in UndeterminedAvailabilityEvent", newK)
	}

	e, ok := t.UndeterminedAvailabilityEvent[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in UndeterminedAvailabilityEvent", oldK)
	}
	e.Direction = newK

	t.UndeterminedAvailabilityEvent[newK] = e
	delete(t.UndeterminedAvailabilityEvent, oldK)
	return nil
}

// GetOrCreateUndeterminedAvailabilityEvent retrieves the value with the specified keys from
// the receiver SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate) GetOrCreateUndeterminedAvailabilityEvent(
	Direction E_SrlNokiaOamPmTypes_LossDirectionAggregateType,
) *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_UndeterminedAvailabilityEvent {
	key := Direction

	if v, ok := t.UndeterminedAvailabilityEvent[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewUndeterminedAvailabilityEvent(Direction)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateUndeterminedAvailabilityEvent got unexpected error: %v", err))
	}
	return v
}

// GetUndeterminedAvailabilityEvent retrieves the value with the specified key from
// the UndeterminedAvailabilityEvent map field of SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate) GetUndeterminedAvailabilityEvent(
	Direction E_SrlNokiaOamPmTypes_LossDirectionAggregateType,
) *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_UndeterminedAvailabilityEvent {
	if t == nil {
		return nil
	}

	key := Direction

	if lm, ok := t.UndeterminedAvailabilityEvent[key]; ok {
		return lm
	}
	return nil
}

// DeleteUndeterminedAvailabilityEvent deletes the value with the specified keys from
// the receiver SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate) DeleteUndeterminedAvailabilityEvent(
	Direction E_SrlNokiaOamPmTypes_LossDirectionAggregateType,
) {
	key := Direction

	delete(t.UndeterminedAvailabilityEvent, key)
}

// AppendUndeterminedAvailabilityEvent appends the supplied SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_UndeterminedAvailabilityEvent struct to the
// list UndeterminedAvailabilityEvent of SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate. If the key value(s) specified in
// the supplied SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_UndeterminedAvailabilityEvent already exist in the list, an error is
// returned.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate) AppendUndeterminedAvailabilityEvent(
	v *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_UndeterminedAvailabilityEvent,
) error {
	key := v.Direction

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.UndeterminedAvailabilityEvent == nil {
		t.UndeterminedAvailabilityEvent = make(map[E_SrlNokiaOamPmTypes_LossDirectionAggregateType]*SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_UndeterminedAvailabilityEvent)
	}

	if _, ok := t.UndeterminedAvailabilityEvent[key]; ok {
		return fmt.Errorf("duplicate key for list UndeterminedAvailabilityEvent %v", key)
	}

	t.UndeterminedAvailabilityEvent[key] = v
	return nil
}

// NewUndeterminedUnavailabilityEvent creates a new entry in the UndeterminedUnavailabilityEvent list of the
// SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate) NewUndeterminedUnavailabilityEvent(
	Direction E_SrlNokiaOamPmTypes_LossDirectionAggregateType,
) (*SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_UndeterminedUnavailabilityEvent, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.UndeterminedUnavailabilityEvent == nil {
		t.UndeterminedUnavailabilityEvent = make(map[E_SrlNokiaOamPmTypes_LossDirectionAggregateType]*SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_UndeterminedUnavailabilityEvent)
	}

	key := Direction

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.UndeterminedUnavailabilityEvent[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list UndeterminedUnavailabilityEvent", key)
	}

	t.UndeterminedUnavailabilityEvent[key] = &SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_UndeterminedUnavailabilityEvent{
		Direction: Direction,
	}

	return t.UndeterminedUnavailabilityEvent[key], nil
}

// RenameUndeterminedUnavailabilityEvent renames an entry in the list UndeterminedUnavailabilityEvent within
// the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate) RenameUndeterminedUnavailabilityEvent(
	oldK, newK E_SrlNokiaOamPmTypes_LossDirectionAggregateType,
) error {
	if _, ok := t.UndeterminedUnavailabilityEvent[newK]; ok {
		return fmt.Errorf("key %v already exists in UndeterminedUnavailabilityEvent", newK)
	}

	e, ok := t.UndeterminedUnavailabilityEvent[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in UndeterminedUnavailabilityEvent", oldK)
	}
	e.Direction = newK

	t.UndeterminedUnavailabilityEvent[newK] = e
	delete(t.UndeterminedUnavailabilityEvent, oldK)
	return nil
}

// GetOrCreateUndeterminedUnavailabilityEvent retrieves the value with the specified keys from
// the receiver SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate) GetOrCreateUndeterminedUnavailabilityEvent(
	Direction E_SrlNokiaOamPmTypes_LossDirectionAggregateType,
) *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_UndeterminedUnavailabilityEvent {
	key := Direction

	if v, ok := t.UndeterminedUnavailabilityEvent[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewUndeterminedUnavailabilityEvent(Direction)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateUndeterminedUnavailabilityEvent got unexpected error: %v", err))
	}
	return v
}

// GetUndeterminedUnavailabilityEvent retrieves the value with the specified key from
// the UndeterminedUnavailabilityEvent map field of SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate) GetUndeterminedUnavailabilityEvent(
	Direction E_SrlNokiaOamPmTypes_LossDirectionAggregateType,
) *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_UndeterminedUnavailabilityEvent {
	if t == nil {
		return nil
	}

	key := Direction

	if lm, ok := t.UndeterminedUnavailabilityEvent[key]; ok {
		return lm
	}
	return nil
}

// DeleteUndeterminedUnavailabilityEvent deletes the value with the specified keys from
// the receiver SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate) DeleteUndeterminedUnavailabilityEvent(
	Direction E_SrlNokiaOamPmTypes_LossDirectionAggregateType,
) {
	key := Direction

	delete(t.UndeterminedUnavailabilityEvent, key)
}

// AppendUndeterminedUnavailabilityEvent appends the supplied SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_UndeterminedUnavailabilityEvent struct to the
// list UndeterminedUnavailabilityEvent of SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate. If the key value(s) specified in
// the supplied SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_UndeterminedUnavailabilityEvent already exist in the list, an error is
// returned.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate) AppendUndeterminedUnavailabilityEvent(
	v *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_UndeterminedUnavailabilityEvent,
) error {
	key := v.Direction

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.UndeterminedUnavailabilityEvent == nil {
		t.UndeterminedUnavailabilityEvent = make(map[E_SrlNokiaOamPmTypes_LossDirectionAggregateType]*SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_UndeterminedUnavailabilityEvent)
	}

	if _, ok := t.UndeterminedUnavailabilityEvent[key]; ok {
		return fmt.Errorf("duplicate key for list UndeterminedUnavailabilityEvent %v", key)
	}

	t.UndeterminedUnavailabilityEvent[key] = v
	return nil
}

// GetLossEventsTemplateName retrieves the value of the leaf LossEventsTemplateName from the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LossEventsTemplateName is set, it can
// safely use t.GetLossEventsTemplateName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LossEventsTemplateName == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate) GetLossEventsTemplateName() string {
	if t == nil || t.LossEventsTemplateName == nil {
		return ""
	}
	return *t.LossEventsTemplateName
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.AvgFlrEvent {
		e.PopulateDefaults()
	}
	for _, e := range t.ChliEvent {
		e.PopulateDefaults()
	}
	for _, e := range t.HliEvent {
		e.PopulateDefaults()
	}
	for _, e := range t.UnavailabilityEvent {
		e.PopulateDefaults()
	}
	for _, e := range t.UndeterminedAvailabilityEvent {
		e.PopulateDefaults()
	}
	for _, e := range t.UndeterminedUnavailabilityEvent {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate struct, which is a YANG list entry.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate) ΛListKeyMap() (map[string]interface{}, error) {
	if t.LossEventsTemplateName == nil {
		return nil, fmt.Errorf("nil value for key LossEventsTemplateName")
	}

	return map[string]interface{}{
		"loss-events-template-name": *t.LossEventsTemplateName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate.
func (*SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate) ΛBelongingModule() string {
	return "srl_nokia-oam-pm-ip"
}

// SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_AvgFlrEvent represents the /srl_nokia-oam/oam/performance-monitoring/ip/loss/loss-events-template/avg-flr-event YANG schema element.
type SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_AvgFlrEvent struct {
	ClearThreshold *float64                               `path:"clear-threshold" module:"srl_nokia-oam-pm-ip"`
	Direction      E_SrlNokiaOamPmTypes_LossDirectionType `path:"direction" module:"srl_nokia-oam-pm-ip"`
	RaiseThreshold *float64                               `path:"raise-threshold" module:"srl_nokia-oam-pm-ip"`
}

// IsYANGGoStruct ensures that SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_AvgFlrEvent implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_AvgFlrEvent) IsYANGGoStruct() {
}

// GetClearThreshold retrieves the value of the leaf ClearThreshold from the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_AvgFlrEvent
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ClearThreshold is set, it can
// safely use t.GetClearThreshold() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ClearThreshold == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_AvgFlrEvent) GetClearThreshold() float64 {
	if t == nil || t.ClearThreshold == nil {
		return 0.0
	}
	return *t.ClearThreshold
}

// GetDirection retrieves the value of the leaf Direction from the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_AvgFlrEvent
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Direction is set, it can
// safely use t.GetDirection() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Direction == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_AvgFlrEvent) GetDirection() E_SrlNokiaOamPmTypes_LossDirectionType {
	if t == nil || t.Direction == 0 {
		return 0
	}
	return t.Direction
}

// GetRaiseThreshold retrieves the value of the leaf RaiseThreshold from the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_AvgFlrEvent
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RaiseThreshold is set, it can
// safely use t.GetRaiseThreshold() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RaiseThreshold == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_AvgFlrEvent) GetRaiseThreshold() float64 {
	if t == nil || t.RaiseThreshold == nil {
		return 0.0
	}
	return *t.RaiseThreshold
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_AvgFlrEvent
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_AvgFlrEvent) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_AvgFlrEvent struct, which is a YANG list entry.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_AvgFlrEvent) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"direction": t.Direction,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_AvgFlrEvent) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_AvgFlrEvent"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_AvgFlrEvent) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_AvgFlrEvent) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_AvgFlrEvent.
func (*SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_AvgFlrEvent) ΛBelongingModule() string {
	return "srl_nokia-oam-pm-ip"
}

// SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_ChliEvent represents the /srl_nokia-oam/oam/performance-monitoring/ip/loss/loss-events-template/chli-event YANG schema element.
type SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_ChliEvent struct {
	ClearThreshold *uint32                                         `path:"clear-threshold" module:"srl_nokia-oam-pm-ip"`
	Direction      E_SrlNokiaOamPmTypes_LossDirectionAggregateType `path:"direction" module:"srl_nokia-oam-pm-ip"`
	RaiseThreshold *uint32                                         `path:"raise-threshold" module:"srl_nokia-oam-pm-ip"`
}

// IsYANGGoStruct ensures that SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_ChliEvent implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_ChliEvent) IsYANGGoStruct() {}

// GetClearThreshold retrieves the value of the leaf ClearThreshold from the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_ChliEvent
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ClearThreshold is set, it can
// safely use t.GetClearThreshold() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ClearThreshold == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_ChliEvent) GetClearThreshold() uint32 {
	if t == nil || t.ClearThreshold == nil {
		return 0
	}
	return *t.ClearThreshold
}

// GetDirection retrieves the value of the leaf Direction from the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_ChliEvent
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Direction is set, it can
// safely use t.GetDirection() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Direction == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_ChliEvent) GetDirection() E_SrlNokiaOamPmTypes_LossDirectionAggregateType {
	if t == nil || t.Direction == 0 {
		return 0
	}
	return t.Direction
}

// GetRaiseThreshold retrieves the value of the leaf RaiseThreshold from the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_ChliEvent
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RaiseThreshold is set, it can
// safely use t.GetRaiseThreshold() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RaiseThreshold == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_ChliEvent) GetRaiseThreshold() uint32 {
	if t == nil || t.RaiseThreshold == nil {
		return 0
	}
	return *t.RaiseThreshold
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_ChliEvent
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_ChliEvent) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_ChliEvent struct, which is a YANG list entry.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_ChliEvent) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"direction": t.Direction,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_ChliEvent) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_ChliEvent"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_ChliEvent) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_ChliEvent) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_ChliEvent.
func (*SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_ChliEvent) ΛBelongingModule() string {
	return "srl_nokia-oam-pm-ip"
}

// SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_HliEvent represents the /srl_nokia-oam/oam/performance-monitoring/ip/loss/loss-events-template/hli-event YANG schema element.
type SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_HliEvent struct {
	ClearThreshold *uint32                                         `path:"clear-threshold" module:"srl_nokia-oam-pm-ip"`
	Direction      E_SrlNokiaOamPmTypes_LossDirectionAggregateType `path:"direction" module:"srl_nokia-oam-pm-ip"`
	RaiseThreshold *uint32                                         `path:"raise-threshold" module:"srl_nokia-oam-pm-ip"`
}

// IsYANGGoStruct ensures that SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_HliEvent implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_HliEvent) IsYANGGoStruct() {}

// GetClearThreshold retrieves the value of the leaf ClearThreshold from the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_HliEvent
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ClearThreshold is set, it can
// safely use t.GetClearThreshold() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ClearThreshold == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_HliEvent) GetClearThreshold() uint32 {
	if t == nil || t.ClearThreshold == nil {
		return 0
	}
	return *t.ClearThreshold
}

// GetDirection retrieves the value of the leaf Direction from the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_HliEvent
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Direction is set, it can
// safely use t.GetDirection() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Direction == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_HliEvent) GetDirection() E_SrlNokiaOamPmTypes_LossDirectionAggregateType {
	if t == nil || t.Direction == 0 {
		return 0
	}
	return t.Direction
}

// GetRaiseThreshold retrieves the value of the leaf RaiseThreshold from the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_HliEvent
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RaiseThreshold is set, it can
// safely use t.GetRaiseThreshold() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RaiseThreshold == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_HliEvent) GetRaiseThreshold() uint32 {
	if t == nil || t.RaiseThreshold == nil {
		return 0
	}
	return *t.RaiseThreshold
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_HliEvent
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_HliEvent) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_HliEvent struct, which is a YANG list entry.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_HliEvent) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"direction": t.Direction,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_HliEvent) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_HliEvent"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_HliEvent) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_HliEvent) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_HliEvent.
func (*SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_HliEvent) ΛBelongingModule() string {
	return "srl_nokia-oam-pm-ip"
}

// SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_UnavailabilityEvent represents the /srl_nokia-oam/oam/performance-monitoring/ip/loss/loss-events-template/unavailability-event YANG schema element.
type SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_UnavailabilityEvent struct {
	ClearThreshold *uint32                                         `path:"clear-threshold" module:"srl_nokia-oam-pm-ip"`
	Direction      E_SrlNokiaOamPmTypes_LossDirectionAggregateType `path:"direction" module:"srl_nokia-oam-pm-ip"`
	RaiseThreshold *uint32                                         `path:"raise-threshold" module:"srl_nokia-oam-pm-ip"`
}

// IsYANGGoStruct ensures that SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_UnavailabilityEvent implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_UnavailabilityEvent) IsYANGGoStruct() {
}

// GetClearThreshold retrieves the value of the leaf ClearThreshold from the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_UnavailabilityEvent
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ClearThreshold is set, it can
// safely use t.GetClearThreshold() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ClearThreshold == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_UnavailabilityEvent) GetClearThreshold() uint32 {
	if t == nil || t.ClearThreshold == nil {
		return 0
	}
	return *t.ClearThreshold
}

// GetDirection retrieves the value of the leaf Direction from the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_UnavailabilityEvent
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Direction is set, it can
// safely use t.GetDirection() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Direction == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_UnavailabilityEvent) GetDirection() E_SrlNokiaOamPmTypes_LossDirectionAggregateType {
	if t == nil || t.Direction == 0 {
		return 0
	}
	return t.Direction
}

// GetRaiseThreshold retrieves the value of the leaf RaiseThreshold from the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_UnavailabilityEvent
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RaiseThreshold is set, it can
// safely use t.GetRaiseThreshold() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RaiseThreshold == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_UnavailabilityEvent) GetRaiseThreshold() uint32 {
	if t == nil || t.RaiseThreshold == nil {
		return 0
	}
	return *t.RaiseThreshold
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_UnavailabilityEvent
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_UnavailabilityEvent) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_UnavailabilityEvent struct, which is a YANG list entry.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_UnavailabilityEvent) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"direction": t.Direction,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_UnavailabilityEvent) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_UnavailabilityEvent"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_UnavailabilityEvent) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_UnavailabilityEvent) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_UnavailabilityEvent.
func (*SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_UnavailabilityEvent) ΛBelongingModule() string {
	return "srl_nokia-oam-pm-ip"
}

// SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_UndeterminedAvailabilityEvent represents the /srl_nokia-oam/oam/performance-monitoring/ip/loss/loss-events-template/undetermined-availability-event YANG schema element.
type SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_UndeterminedAvailabilityEvent struct {
	ClearThreshold *uint32                                         `path:"clear-threshold" module:"srl_nokia-oam-pm-ip"`
	Direction      E_SrlNokiaOamPmTypes_LossDirectionAggregateType `path:"direction" module:"srl_nokia-oam-pm-ip"`
	RaiseThreshold *uint32                                         `path:"raise-threshold" module:"srl_nokia-oam-pm-ip"`
}

// IsYANGGoStruct ensures that SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_UndeterminedAvailabilityEvent implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_UndeterminedAvailabilityEvent) IsYANGGoStruct() {
}

// GetClearThreshold retrieves the value of the leaf ClearThreshold from the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_UndeterminedAvailabilityEvent
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ClearThreshold is set, it can
// safely use t.GetClearThreshold() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ClearThreshold == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_UndeterminedAvailabilityEvent) GetClearThreshold() uint32 {
	if t == nil || t.ClearThreshold == nil {
		return 0
	}
	return *t.ClearThreshold
}

// GetDirection retrieves the value of the leaf Direction from the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_UndeterminedAvailabilityEvent
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Direction is set, it can
// safely use t.GetDirection() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Direction == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_UndeterminedAvailabilityEvent) GetDirection() E_SrlNokiaOamPmTypes_LossDirectionAggregateType {
	if t == nil || t.Direction == 0 {
		return 0
	}
	return t.Direction
}

// GetRaiseThreshold retrieves the value of the leaf RaiseThreshold from the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_UndeterminedAvailabilityEvent
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RaiseThreshold is set, it can
// safely use t.GetRaiseThreshold() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RaiseThreshold == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_UndeterminedAvailabilityEvent) GetRaiseThreshold() uint32 {
	if t == nil || t.RaiseThreshold == nil {
		return 0
	}
	return *t.RaiseThreshold
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_UndeterminedAvailabilityEvent
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_UndeterminedAvailabilityEvent) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_UndeterminedAvailabilityEvent struct, which is a YANG list entry.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_UndeterminedAvailabilityEvent) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"direction": t.Direction,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_UndeterminedAvailabilityEvent) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_UndeterminedAvailabilityEvent"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_UndeterminedAvailabilityEvent) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_UndeterminedAvailabilityEvent) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_UndeterminedAvailabilityEvent.
func (*SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_UndeterminedAvailabilityEvent) ΛBelongingModule() string {
	return "srl_nokia-oam-pm-ip"
}

// SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_UndeterminedUnavailabilityEvent represents the /srl_nokia-oam/oam/performance-monitoring/ip/loss/loss-events-template/undetermined-unavailability-event YANG schema element.
type SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_UndeterminedUnavailabilityEvent struct {
	ClearThreshold *uint32                                         `path:"clear-threshold" module:"srl_nokia-oam-pm-ip"`
	Direction      E_SrlNokiaOamPmTypes_LossDirectionAggregateType `path:"direction" module:"srl_nokia-oam-pm-ip"`
	RaiseThreshold *uint32                                         `path:"raise-threshold" module:"srl_nokia-oam-pm-ip"`
}

// IsYANGGoStruct ensures that SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_UndeterminedUnavailabilityEvent implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_UndeterminedUnavailabilityEvent) IsYANGGoStruct() {
}

// GetClearThreshold retrieves the value of the leaf ClearThreshold from the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_UndeterminedUnavailabilityEvent
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ClearThreshold is set, it can
// safely use t.GetClearThreshold() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ClearThreshold == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_UndeterminedUnavailabilityEvent) GetClearThreshold() uint32 {
	if t == nil || t.ClearThreshold == nil {
		return 0
	}
	return *t.ClearThreshold
}

// GetDirection retrieves the value of the leaf Direction from the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_UndeterminedUnavailabilityEvent
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Direction is set, it can
// safely use t.GetDirection() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Direction == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_UndeterminedUnavailabilityEvent) GetDirection() E_SrlNokiaOamPmTypes_LossDirectionAggregateType {
	if t == nil || t.Direction == 0 {
		return 0
	}
	return t.Direction
}

// GetRaiseThreshold retrieves the value of the leaf RaiseThreshold from the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_UndeterminedUnavailabilityEvent
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RaiseThreshold is set, it can
// safely use t.GetRaiseThreshold() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RaiseThreshold == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_UndeterminedUnavailabilityEvent) GetRaiseThreshold() uint32 {
	if t == nil || t.RaiseThreshold == nil {
		return 0
	}
	return *t.RaiseThreshold
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_UndeterminedUnavailabilityEvent
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_UndeterminedUnavailabilityEvent) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_UndeterminedUnavailabilityEvent struct, which is a YANG list entry.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_UndeterminedUnavailabilityEvent) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"direction": t.Direction,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_UndeterminedUnavailabilityEvent) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_UndeterminedUnavailabilityEvent"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_UndeterminedUnavailabilityEvent) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_UndeterminedUnavailabilityEvent) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_UndeterminedUnavailabilityEvent.
func (*SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Loss_LossEventsTemplate_UndeterminedUnavailabilityEvent) ΛBelongingModule() string {
	return "srl_nokia-oam-pm-ip"
}

// SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session represents the /srl_nokia-oam/oam/performance-monitoring/ip/session YANG schema element.
type SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session struct {
	AllowEgressRemarkDscp *bool                                                                                                                          `path:"allow-egress-remark-dscp" module:"srl_nokia-oam-pm-ip"`
	Description           *string                                                                                                                        `path:"description" module:"srl_nokia-oam-pm-ip"`
	Destination           *string                                                                                                                        `path:"destination" module:"srl_nokia-oam-pm-ip"`
	DestinationUdpPort    *uint16                                                                                                                        `path:"destination-udp-port" module:"srl_nokia-oam-pm-ip"`
	DoNotFragment         *bool                                                                                                                          `path:"do-not-fragment" module:"srl_nokia-oam-pm-ip"`
	Forwarding            *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Forwarding                                                                   `path:"forwarding" module:"srl_nokia-oam-pm-ip" yangPresence:"true"`
	MeasurementInterval   map[E_SrlNokiaOamPmTypes_MeasurementIntervalDurationType]*SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_MeasurementInterval `path:"measurement-interval" module:"srl_nokia-oam-pm-ip"`
	NetworkInstance       *string                                                                                                                        `path:"network-instance" module:"srl_nokia-oam-pm-ip"`
	SessionName           *string                                                                                                                        `path:"session-name" module:"srl_nokia-oam-pm-ip"`
	SessionType           E_SrlNokiaOamPmTypes_OamPmSessionType                                                                                          `path:"session-type" module:"srl_nokia-oam-pm-ip"`
	SourceIpAddress       *string                                                                                                                        `path:"source-ip-address" module:"srl_nokia-oam-pm-ip"`
	SourceUdpPort         SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_SourceUdpPort_Union                                                           `path:"source-udp-port" module:"srl_nokia-oam-pm-ip"`
	Stamp                 *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Stamp                                                                        `path:"stamp" module:"srl_nokia-oam-pm-ip"`
	Ttl                   *uint32                                                                                                                        `path:"ttl" module:"srl_nokia-oam-pm-ip"`
}

// IsYANGGoStruct ensures that SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session) IsYANGGoStruct() {}

// NewMeasurementInterval creates a new entry in the MeasurementInterval list of the
// SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session) NewMeasurementInterval(
	MiDuration E_SrlNokiaOamPmTypes_MeasurementIntervalDurationType,
) (*SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_MeasurementInterval, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.MeasurementInterval == nil {
		t.MeasurementInterval = make(map[E_SrlNokiaOamPmTypes_MeasurementIntervalDurationType]*SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_MeasurementInterval)
	}

	key := MiDuration

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.MeasurementInterval[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list MeasurementInterval", key)
	}

	t.MeasurementInterval[key] = &SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_MeasurementInterval{
		MiDuration: MiDuration,
	}

	return t.MeasurementInterval[key], nil
}

// RenameMeasurementInterval renames an entry in the list MeasurementInterval within
// the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session) RenameMeasurementInterval(
	oldK, newK E_SrlNokiaOamPmTypes_MeasurementIntervalDurationType,
) error {
	if _, ok := t.MeasurementInterval[newK]; ok {
		return fmt.Errorf("key %v already exists in MeasurementInterval", newK)
	}

	e, ok := t.MeasurementInterval[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in MeasurementInterval", oldK)
	}
	e.MiDuration = newK

	t.MeasurementInterval[newK] = e
	delete(t.MeasurementInterval, oldK)
	return nil
}

// GetOrCreateMeasurementInterval retrieves the value with the specified keys from
// the receiver SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session) GetOrCreateMeasurementInterval(
	MiDuration E_SrlNokiaOamPmTypes_MeasurementIntervalDurationType,
) *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_MeasurementInterval {
	key := MiDuration

	if v, ok := t.MeasurementInterval[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewMeasurementInterval(MiDuration)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateMeasurementInterval got unexpected error: %v", err))
	}
	return v
}

// GetMeasurementInterval retrieves the value with the specified key from
// the MeasurementInterval map field of SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session) GetMeasurementInterval(
	MiDuration E_SrlNokiaOamPmTypes_MeasurementIntervalDurationType,
) *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_MeasurementInterval {
	if t == nil {
		return nil
	}

	key := MiDuration

	if lm, ok := t.MeasurementInterval[key]; ok {
		return lm
	}
	return nil
}

// DeleteMeasurementInterval deletes the value with the specified keys from
// the receiver SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session) DeleteMeasurementInterval(
	MiDuration E_SrlNokiaOamPmTypes_MeasurementIntervalDurationType,
) {
	key := MiDuration

	delete(t.MeasurementInterval, key)
}

// AppendMeasurementInterval appends the supplied SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_MeasurementInterval struct to the
// list MeasurementInterval of SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session. If the key value(s) specified in
// the supplied SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_MeasurementInterval already exist in the list, an error is
// returned.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session) AppendMeasurementInterval(
	v *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_MeasurementInterval,
) error {
	key := v.MiDuration

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.MeasurementInterval == nil {
		t.MeasurementInterval = make(map[E_SrlNokiaOamPmTypes_MeasurementIntervalDurationType]*SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_MeasurementInterval)
	}

	if _, ok := t.MeasurementInterval[key]; ok {
		return fmt.Errorf("duplicate key for list MeasurementInterval %v", key)
	}

	t.MeasurementInterval[key] = v
	return nil
}

// GetOrCreateForwarding retrieves the value of the Forwarding field
// or returns the existing field if it already exists.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session) GetOrCreateForwarding() *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Forwarding {
	if t.Forwarding != nil {
		return t.Forwarding
	}
	t.Forwarding = &SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Forwarding{}
	return t.Forwarding
}

// GetOrCreateStamp retrieves the value of the Stamp field
// or returns the existing field if it already exists.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session) GetOrCreateStamp() *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Stamp {
	if t.Stamp != nil {
		return t.Stamp
	}
	t.Stamp = &SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Stamp{}
	return t.Stamp
}

// GetForwarding returns the value of the Forwarding struct pointer
// from SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session. If the receiver or the field Forwarding is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session) GetForwarding() *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Forwarding {
	if t != nil && t.Forwarding != nil {
		return t.Forwarding
	}
	return nil
}

// GetStamp returns the value of the Stamp struct pointer
// from SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session. If the receiver or the field Stamp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session) GetStamp() *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Stamp {
	if t != nil && t.Stamp != nil {
		return t.Stamp
	}
	return nil
}

// GetAllowEgressRemarkDscp retrieves the value of the leaf AllowEgressRemarkDscp from the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AllowEgressRemarkDscp is set, it can
// safely use t.GetAllowEgressRemarkDscp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AllowEgressRemarkDscp == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session) GetAllowEgressRemarkDscp() bool {
	if t == nil || t.AllowEgressRemarkDscp == nil {
		return false
	}
	return *t.AllowEgressRemarkDscp
}

// GetDescription retrieves the value of the leaf Description from the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetDestination retrieves the value of the leaf Destination from the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Destination is set, it can
// safely use t.GetDestination() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Destination == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session) GetDestination() string {
	if t == nil || t.Destination == nil {
		return ""
	}
	return *t.Destination
}

// GetDestinationUdpPort retrieves the value of the leaf DestinationUdpPort from the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DestinationUdpPort is set, it can
// safely use t.GetDestinationUdpPort() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DestinationUdpPort == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session) GetDestinationUdpPort() uint16 {
	if t == nil || t.DestinationUdpPort == nil {
		return 0
	}
	return *t.DestinationUdpPort
}

// GetDoNotFragment retrieves the value of the leaf DoNotFragment from the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DoNotFragment is set, it can
// safely use t.GetDoNotFragment() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DoNotFragment == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session) GetDoNotFragment() bool {
	if t == nil || t.DoNotFragment == nil {
		return false
	}
	return *t.DoNotFragment
}

// GetNetworkInstance retrieves the value of the leaf NetworkInstance from the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NetworkInstance is set, it can
// safely use t.GetNetworkInstance() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NetworkInstance == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session) GetNetworkInstance() string {
	if t == nil || t.NetworkInstance == nil {
		return "default"
	}
	return *t.NetworkInstance
}

// GetSessionName retrieves the value of the leaf SessionName from the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SessionName is set, it can
// safely use t.GetSessionName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SessionName == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session) GetSessionName() string {
	if t == nil || t.SessionName == nil {
		return ""
	}
	return *t.SessionName
}

// GetSessionType retrieves the value of the leaf SessionType from the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SessionType is set, it can
// safely use t.GetSessionType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SessionType == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session) GetSessionType() E_SrlNokiaOamPmTypes_OamPmSessionType {
	if t == nil || t.SessionType == 0 {
		return SrlNokiaOamPmTypes_OamPmSessionType_proactive
	}
	return t.SessionType
}

// GetSourceIpAddress retrieves the value of the leaf SourceIpAddress from the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SourceIpAddress is set, it can
// safely use t.GetSourceIpAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SourceIpAddress == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session) GetSourceIpAddress() string {
	if t == nil || t.SourceIpAddress == nil {
		return ""
	}
	return *t.SourceIpAddress
}

// GetSourceUdpPort retrieves the value of the leaf SourceUdpPort from the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SourceUdpPort is set, it can
// safely use t.GetSourceUdpPort() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SourceUdpPort == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session) GetSourceUdpPort() SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_SourceUdpPort_Union {
	if t == nil || t.SourceUdpPort == nil {
		return SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_SourceUdpPort_Enum_auto
	}
	return t.SourceUdpPort
}

// GetTtl retrieves the value of the leaf Ttl from the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ttl is set, it can
// safely use t.GetTtl() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ttl == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session) GetTtl() uint32 {
	if t == nil || t.Ttl == nil {
		return 255
	}
	return *t.Ttl
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AllowEgressRemarkDscp == nil {
		var v bool = false
		t.AllowEgressRemarkDscp = &v
	}
	if t.DoNotFragment == nil {
		var v bool = false
		t.DoNotFragment = &v
	}
	if t.NetworkInstance == nil {
		var v string = "default"
		t.NetworkInstance = &v
	}
	if t.SessionType == 0 {
		t.SessionType = SrlNokiaOamPmTypes_OamPmSessionType_proactive
	}
	if t.SourceUdpPort == nil {
		t.SourceUdpPort = SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_SourceUdpPort_Enum_auto
	}
	if t.Ttl == nil {
		var v uint32 = 255
		t.Ttl = &v
	}
	t.Forwarding.PopulateDefaults()
	t.Stamp.PopulateDefaults()
	for _, e := range t.MeasurementInterval {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session struct, which is a YANG list entry.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session) ΛListKeyMap() (map[string]interface{}, error) {
	if t.SessionName == nil {
		return nil, fmt.Errorf("nil value for key SessionName")
	}

	return map[string]interface{}{
		"session-name": *t.SessionName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session.
func (*SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session) ΛBelongingModule() string {
	return "srl_nokia-oam-pm-ip"
}

// SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Forwarding represents the /srl_nokia-oam/oam/performance-monitoring/ip/session/forwarding YANG schema element.
type SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Forwarding struct {
	BypassRouting *bool                                                                     `path:"bypass-routing" module:"srl_nokia-oam-pm-ip"`
	InterfaceRef  *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Forwarding_InterfaceRef `path:"interface-ref" module:"srl_nokia-oam-pm-ip"`
	NextHop       *string                                                                   `path:"next-hop" module:"srl_nokia-oam-pm-ip"`
}

// IsYANGGoStruct ensures that SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Forwarding implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Forwarding) IsYANGGoStruct() {}

// GetOrCreateInterfaceRef retrieves the value of the InterfaceRef field
// or returns the existing field if it already exists.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Forwarding) GetOrCreateInterfaceRef() *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Forwarding_InterfaceRef {
	if t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	t.InterfaceRef = &SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Forwarding_InterfaceRef{}
	return t.InterfaceRef
}

// GetInterfaceRef returns the value of the InterfaceRef struct pointer
// from SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Forwarding. If the receiver or the field InterfaceRef is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Forwarding) GetInterfaceRef() *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Forwarding_InterfaceRef {
	if t != nil && t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	return nil
}

// GetBypassRouting retrieves the value of the leaf BypassRouting from the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Forwarding
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if BypassRouting is set, it can
// safely use t.GetBypassRouting() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.BypassRouting == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Forwarding) GetBypassRouting() bool {
	if t == nil || t.BypassRouting == nil {
		return false
	}
	return *t.BypassRouting
}

// GetNextHop retrieves the value of the leaf NextHop from the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Forwarding
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NextHop is set, it can
// safely use t.GetNextHop() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NextHop == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Forwarding) GetNextHop() string {
	if t == nil || t.NextHop == nil {
		return ""
	}
	return *t.NextHop
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Forwarding
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Forwarding) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.BypassRouting == nil {
		var v bool = false
		t.BypassRouting = &v
	}
	t.InterfaceRef.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Forwarding) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Forwarding"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Forwarding) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Forwarding) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Forwarding.
func (*SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Forwarding) ΛBelongingModule() string {
	return "srl_nokia-oam-pm-ip"
}

// SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Forwarding_InterfaceRef represents the /srl_nokia-oam/oam/performance-monitoring/ip/session/forwarding/interface-ref YANG schema element.
type SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Forwarding_InterfaceRef struct {
	Interface    *string `path:"interface" module:"srl_nokia-oam-pm-ip"`
	Subinterface *uint32 `path:"subinterface" module:"srl_nokia-oam-pm-ip"`
}

// IsYANGGoStruct ensures that SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Forwarding_InterfaceRef implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Forwarding_InterfaceRef) IsYANGGoStruct() {}

// GetInterface retrieves the value of the leaf Interface from the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Forwarding_InterfaceRef
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interface is set, it can
// safely use t.GetInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interface == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Forwarding_InterfaceRef) GetInterface() string {
	if t == nil || t.Interface == nil {
		return ""
	}
	return *t.Interface
}

// GetSubinterface retrieves the value of the leaf Subinterface from the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Forwarding_InterfaceRef
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Subinterface is set, it can
// safely use t.GetSubinterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Subinterface == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Forwarding_InterfaceRef) GetSubinterface() uint32 {
	if t == nil || t.Subinterface == nil {
		return 0
	}
	return *t.Subinterface
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Forwarding_InterfaceRef
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Forwarding_InterfaceRef) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Forwarding_InterfaceRef) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Forwarding_InterfaceRef"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Forwarding_InterfaceRef) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Forwarding_InterfaceRef) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Forwarding_InterfaceRef.
func (*SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Forwarding_InterfaceRef) ΛBelongingModule() string {
	return "srl_nokia-oam-pm-ip"
}

// SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_MeasurementInterval represents the /srl_nokia-oam/oam/performance-monitoring/ip/session/measurement-interval YANG schema element.
type SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_MeasurementInterval struct {
	BoundaryType    E_SrlNokiaOamPmTypes_MeasurementIntervalBoundaryType                                  `path:"boundary-type" module:"srl_nokia-oam-pm-ip"`
	ClockOffset     *uint32                                                                               `path:"clock-offset" module:"srl_nokia-oam-pm-ip"`
	IntervalsStored *uint8                                                                                `path:"intervals-stored" module:"srl_nokia-oam-pm-ip"`
	MiDuration      E_SrlNokiaOamPmTypes_MeasurementIntervalDurationType                                  `path:"mi-duration" module:"srl_nokia-oam-pm-ip"`
	ThresholdAlerts *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_MeasurementInterval_ThresholdAlerts `path:"threshold-alerts" module:"srl_nokia-oam-pm-ip"`
}

// IsYANGGoStruct ensures that SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_MeasurementInterval implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_MeasurementInterval) IsYANGGoStruct() {}

// GetOrCreateThresholdAlerts retrieves the value of the ThresholdAlerts field
// or returns the existing field if it already exists.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_MeasurementInterval) GetOrCreateThresholdAlerts() *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_MeasurementInterval_ThresholdAlerts {
	if t.ThresholdAlerts != nil {
		return t.ThresholdAlerts
	}
	t.ThresholdAlerts = &SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_MeasurementInterval_ThresholdAlerts{}
	return t.ThresholdAlerts
}

// GetThresholdAlerts returns the value of the ThresholdAlerts struct pointer
// from SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_MeasurementInterval. If the receiver or the field ThresholdAlerts is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_MeasurementInterval) GetThresholdAlerts() *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_MeasurementInterval_ThresholdAlerts {
	if t != nil && t.ThresholdAlerts != nil {
		return t.ThresholdAlerts
	}
	return nil
}

// GetBoundaryType retrieves the value of the leaf BoundaryType from the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_MeasurementInterval
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if BoundaryType is set, it can
// safely use t.GetBoundaryType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.BoundaryType == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_MeasurementInterval) GetBoundaryType() E_SrlNokiaOamPmTypes_MeasurementIntervalBoundaryType {
	if t == nil || t.BoundaryType == 0 {
		return SrlNokiaOamPmTypes_MeasurementIntervalBoundaryType_clock_aligned
	}
	return t.BoundaryType
}

// GetClockOffset retrieves the value of the leaf ClockOffset from the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_MeasurementInterval
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ClockOffset is set, it can
// safely use t.GetClockOffset() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ClockOffset == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_MeasurementInterval) GetClockOffset() uint32 {
	if t == nil || t.ClockOffset == nil {
		return 0
	}
	return *t.ClockOffset
}

// GetIntervalsStored retrieves the value of the leaf IntervalsStored from the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_MeasurementInterval
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IntervalsStored is set, it can
// safely use t.GetIntervalsStored() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IntervalsStored == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_MeasurementInterval) GetIntervalsStored() uint8 {
	if t == nil || t.IntervalsStored == nil {
		return 0
	}
	return *t.IntervalsStored
}

// GetMiDuration retrieves the value of the leaf MiDuration from the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_MeasurementInterval
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MiDuration is set, it can
// safely use t.GetMiDuration() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MiDuration == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_MeasurementInterval) GetMiDuration() E_SrlNokiaOamPmTypes_MeasurementIntervalDurationType {
	if t == nil || t.MiDuration == 0 {
		return 0
	}
	return t.MiDuration
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_MeasurementInterval
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_MeasurementInterval) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.BoundaryType == 0 {
		t.BoundaryType = SrlNokiaOamPmTypes_MeasurementIntervalBoundaryType_clock_aligned
	}
	if t.ClockOffset == nil {
		var v uint32 = 0
		t.ClockOffset = &v
	}
	t.ThresholdAlerts.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_MeasurementInterval struct, which is a YANG list entry.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_MeasurementInterval) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"mi-duration": t.MiDuration,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_MeasurementInterval) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_MeasurementInterval"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_MeasurementInterval) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_MeasurementInterval) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_MeasurementInterval.
func (*SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_MeasurementInterval) ΛBelongingModule() string {
	return "srl_nokia-oam-pm-ip"
}

// SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_MeasurementInterval_ThresholdAlerts represents the /srl_nokia-oam/oam/performance-monitoring/ip/session/measurement-interval/threshold-alerts YANG schema element.
type SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_MeasurementInterval_ThresholdAlerts struct {
	DelayEvent E_SrlNokiaCommon_AdminState `path:"delay-event" module:"srl_nokia-oam-pm-ip"`
	LossEvent  E_SrlNokiaCommon_AdminState `path:"loss-event" module:"srl_nokia-oam-pm-ip"`
}

// IsYANGGoStruct ensures that SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_MeasurementInterval_ThresholdAlerts implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_MeasurementInterval_ThresholdAlerts) IsYANGGoStruct() {
}

// GetDelayEvent retrieves the value of the leaf DelayEvent from the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_MeasurementInterval_ThresholdAlerts
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DelayEvent is set, it can
// safely use t.GetDelayEvent() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DelayEvent == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_MeasurementInterval_ThresholdAlerts) GetDelayEvent() E_SrlNokiaCommon_AdminState {
	if t == nil || t.DelayEvent == 0 {
		return 0
	}
	return t.DelayEvent
}

// GetLossEvent retrieves the value of the leaf LossEvent from the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_MeasurementInterval_ThresholdAlerts
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LossEvent is set, it can
// safely use t.GetLossEvent() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LossEvent == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_MeasurementInterval_ThresholdAlerts) GetLossEvent() E_SrlNokiaCommon_AdminState {
	if t == nil || t.LossEvent == 0 {
		return 0
	}
	return t.LossEvent
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_MeasurementInterval_ThresholdAlerts
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_MeasurementInterval_ThresholdAlerts) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_MeasurementInterval_ThresholdAlerts) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_MeasurementInterval_ThresholdAlerts"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_MeasurementInterval_ThresholdAlerts) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_MeasurementInterval_ThresholdAlerts) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_MeasurementInterval_ThresholdAlerts.
func (*SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_MeasurementInterval_ThresholdAlerts) ΛBelongingModule() string {
	return "srl_nokia-oam-pm-ip"
}

// SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Stamp represents the /srl_nokia-oam/oam/performance-monitoring/ip/session/stamp YANG schema element.
type SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Stamp struct {
	AdminState               E_SrlNokiaCommon_AdminState                                         `path:"admin-state" module:"srl_nokia-oam-pm-ip"`
	AllowIpv6UdpChecksumZero *bool                                                               `path:"allow-ipv6-udp-checksum-zero" module:"srl_nokia-oam-pm-ip"`
	Delay                    *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Stamp_Delay       `path:"delay" module:"srl_nokia-oam-pm-ip"`
	Interval                 E_SrlNokiaOamPmTypes_OamPmInterval                                  `path:"interval" module:"srl_nokia-oam-pm-ip"`
	Loss                     *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Stamp_Loss        `path:"loss" module:"srl_nokia-oam-pm-ip"`
	PadTlvSize               *uint32                                                             `path:"pad-tlv-size" module:"srl_nokia-oam-pm-ip"`
	TestDuration             *uint32                                                             `path:"test-duration" module:"srl_nokia-oam-pm-ip"`
	TestId                   SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Stamp_TestId_Union `path:"test-id" module:"srl_nokia-oam-pm-ip"`
	TimestampFormat          E_SrlNokiaOamPmTypes_TimestampFormat                                `path:"timestamp-format" module:"srl_nokia-oam-pm-ip"`
}

// IsYANGGoStruct ensures that SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Stamp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Stamp) IsYANGGoStruct() {}

// GetOrCreateDelay retrieves the value of the Delay field
// or returns the existing field if it already exists.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Stamp) GetOrCreateDelay() *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Stamp_Delay {
	if t.Delay != nil {
		return t.Delay
	}
	t.Delay = &SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Stamp_Delay{}
	return t.Delay
}

// GetOrCreateLoss retrieves the value of the Loss field
// or returns the existing field if it already exists.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Stamp) GetOrCreateLoss() *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Stamp_Loss {
	if t.Loss != nil {
		return t.Loss
	}
	t.Loss = &SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Stamp_Loss{}
	return t.Loss
}

// GetDelay returns the value of the Delay struct pointer
// from SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Stamp. If the receiver or the field Delay is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Stamp) GetDelay() *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Stamp_Delay {
	if t != nil && t.Delay != nil {
		return t.Delay
	}
	return nil
}

// GetLoss returns the value of the Loss struct pointer
// from SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Stamp. If the receiver or the field Loss is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Stamp) GetLoss() *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Stamp_Loss {
	if t != nil && t.Loss != nil {
		return t.Loss
	}
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Stamp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Stamp) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_disable
	}
	return t.AdminState
}

// GetAllowIpv6UdpChecksumZero retrieves the value of the leaf AllowIpv6UdpChecksumZero from the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Stamp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AllowIpv6UdpChecksumZero is set, it can
// safely use t.GetAllowIpv6UdpChecksumZero() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AllowIpv6UdpChecksumZero == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Stamp) GetAllowIpv6UdpChecksumZero() bool {
	if t == nil || t.AllowIpv6UdpChecksumZero == nil {
		return false
	}
	return *t.AllowIpv6UdpChecksumZero
}

// GetInterval retrieves the value of the leaf Interval from the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Stamp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interval is set, it can
// safely use t.GetInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interval == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Stamp) GetInterval() E_SrlNokiaOamPmTypes_OamPmInterval {
	if t == nil || t.Interval == 0 {
		return SrlNokiaOamPmTypes_OamPmInterval_1s
	}
	return t.Interval
}

// GetPadTlvSize retrieves the value of the leaf PadTlvSize from the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Stamp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PadTlvSize is set, it can
// safely use t.GetPadTlvSize() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PadTlvSize == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Stamp) GetPadTlvSize() uint32 {
	if t == nil || t.PadTlvSize == nil {
		return 0
	}
	return *t.PadTlvSize
}

// GetTestDuration retrieves the value of the leaf TestDuration from the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Stamp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TestDuration is set, it can
// safely use t.GetTestDuration() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TestDuration == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Stamp) GetTestDuration() uint32 {
	if t == nil || t.TestDuration == nil {
		return 0
	}
	return *t.TestDuration
}

// GetTestId retrieves the value of the leaf TestId from the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Stamp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TestId is set, it can
// safely use t.GetTestId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TestId == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Stamp) GetTestId() SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Stamp_TestId_Union {
	if t == nil || t.TestId == nil {
		return SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_EthCfmSingleEndedDmmTest_TestId_Enum_auto
	}
	return t.TestId
}

// GetTimestampFormat retrieves the value of the leaf TimestampFormat from the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Stamp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TimestampFormat is set, it can
// safely use t.GetTimestampFormat() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TimestampFormat == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Stamp) GetTimestampFormat() E_SrlNokiaOamPmTypes_TimestampFormat {
	if t == nil || t.TimestampFormat == 0 {
		return SrlNokiaOamPmTypes_TimestampFormat_ntp
	}
	return t.TimestampFormat
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Stamp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Stamp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_disable
	}
	if t.AllowIpv6UdpChecksumZero == nil {
		var v bool = false
		t.AllowIpv6UdpChecksumZero = &v
	}
	if t.Interval == 0 {
		t.Interval = SrlNokiaOamPmTypes_OamPmInterval_1s
	}
	if t.PadTlvSize == nil {
		var v uint32 = 0
		t.PadTlvSize = &v
	}
	if t.TestId == nil {
		t.TestId = SrlNokiaOam_Oam_PerformanceMonitoring_Ethcfm_Session_EthCfmSingleEndedDmmTest_TestId_Enum_auto
	}
	if t.TimestampFormat == 0 {
		t.TimestampFormat = SrlNokiaOamPmTypes_TimestampFormat_ntp
	}
	t.Delay.PopulateDefaults()
	t.Loss.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Stamp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Stamp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Stamp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Stamp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Stamp.
func (*SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Stamp) ΛBelongingModule() string {
	return "srl_nokia-oam-pm-ip"
}

// SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Stamp_Delay represents the /srl_nokia-oam/oam/performance-monitoring/ip/session/stamp/delay YANG schema element.
type SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Stamp_Delay struct {
	BinGroup *string `path:"bin-group" module:"srl_nokia-oam-pm-ip"`
}

// IsYANGGoStruct ensures that SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Stamp_Delay implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Stamp_Delay) IsYANGGoStruct() {}

// GetBinGroup retrieves the value of the leaf BinGroup from the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Stamp_Delay
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if BinGroup is set, it can
// safely use t.GetBinGroup() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.BinGroup == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Stamp_Delay) GetBinGroup() string {
	if t == nil || t.BinGroup == nil {
		return "default"
	}
	return *t.BinGroup
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Stamp_Delay
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Stamp_Delay) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.BinGroup == nil {
		var v string = "default"
		t.BinGroup = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Stamp_Delay) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Stamp_Delay"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Stamp_Delay) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Stamp_Delay) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Stamp_Delay.
func (*SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Stamp_Delay) ΛBelongingModule() string {
	return "srl_nokia-oam-pm-ip"
}

// SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Stamp_Loss represents the /srl_nokia-oam/oam/performance-monitoring/ip/session/stamp/loss YANG schema element.
type SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Stamp_Loss struct {
	FlrThreshold  *uint8                                                              `path:"flr-threshold" module:"srl_nokia-oam-pm-ip"`
	HliForceCount *bool                                                               `path:"hli-force-count" module:"srl_nokia-oam-pm-ip"`
	LossEvent     *string                                                             `path:"loss-event" module:"srl_nokia-oam-pm-ip"`
	Timing        *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Stamp_Loss_Timing `path:"timing" module:"srl_nokia-oam-pm-ip"`
}

// IsYANGGoStruct ensures that SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Stamp_Loss implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Stamp_Loss) IsYANGGoStruct() {}

// GetOrCreateTiming retrieves the value of the Timing field
// or returns the existing field if it already exists.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Stamp_Loss) GetOrCreateTiming() *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Stamp_Loss_Timing {
	if t.Timing != nil {
		return t.Timing
	}
	t.Timing = &SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Stamp_Loss_Timing{}
	return t.Timing
}

// GetTiming returns the value of the Timing struct pointer
// from SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Stamp_Loss. If the receiver or the field Timing is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Stamp_Loss) GetTiming() *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Stamp_Loss_Timing {
	if t != nil && t.Timing != nil {
		return t.Timing
	}
	return nil
}

// GetFlrThreshold retrieves the value of the leaf FlrThreshold from the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Stamp_Loss
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FlrThreshold is set, it can
// safely use t.GetFlrThreshold() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FlrThreshold == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Stamp_Loss) GetFlrThreshold() uint8 {
	if t == nil || t.FlrThreshold == nil {
		return 50
	}
	return *t.FlrThreshold
}

// GetHliForceCount retrieves the value of the leaf HliForceCount from the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Stamp_Loss
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if HliForceCount is set, it can
// safely use t.GetHliForceCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.HliForceCount == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Stamp_Loss) GetHliForceCount() bool {
	if t == nil || t.HliForceCount == nil {
		return false
	}
	return *t.HliForceCount
}

// GetLossEvent retrieves the value of the leaf LossEvent from the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Stamp_Loss
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LossEvent is set, it can
// safely use t.GetLossEvent() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LossEvent == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Stamp_Loss) GetLossEvent() string {
	if t == nil || t.LossEvent == nil {
		return ""
	}
	return *t.LossEvent
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Stamp_Loss
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Stamp_Loss) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.FlrThreshold == nil {
		var v uint8 = 50
		t.FlrThreshold = &v
	}
	if t.HliForceCount == nil {
		var v bool = false
		t.HliForceCount = &v
	}
	t.Timing.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Stamp_Loss) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Stamp_Loss"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Stamp_Loss) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Stamp_Loss) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Stamp_Loss.
func (*SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Stamp_Loss) ΛBelongingModule() string {
	return "srl_nokia-oam-pm-ip"
}

// SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Stamp_Loss_Timing represents the /srl_nokia-oam/oam/performance-monitoring/ip/session/stamp/loss/timing YANG schema element.
type SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Stamp_Loss_Timing struct {
	ChliThreshold     *uint8  `path:"chli-threshold" module:"srl_nokia-oam-pm-ip"`
	ConsecutiveDeltaT *uint8  `path:"consecutive-delta-t" module:"srl_nokia-oam-pm-ip"`
	FramesPerDeltaT   *uint32 `path:"frames-per-delta-t" module:"srl_nokia-oam-pm-ip"`
}

// IsYANGGoStruct ensures that SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Stamp_Loss_Timing implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Stamp_Loss_Timing) IsYANGGoStruct() {}

// GetChliThreshold retrieves the value of the leaf ChliThreshold from the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Stamp_Loss_Timing
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ChliThreshold is set, it can
// safely use t.GetChliThreshold() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ChliThreshold == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Stamp_Loss_Timing) GetChliThreshold() uint8 {
	if t == nil || t.ChliThreshold == nil {
		return 5
	}
	return *t.ChliThreshold
}

// GetConsecutiveDeltaT retrieves the value of the leaf ConsecutiveDeltaT from the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Stamp_Loss_Timing
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ConsecutiveDeltaT is set, it can
// safely use t.GetConsecutiveDeltaT() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ConsecutiveDeltaT == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Stamp_Loss_Timing) GetConsecutiveDeltaT() uint8 {
	if t == nil || t.ConsecutiveDeltaT == nil {
		return 10
	}
	return *t.ConsecutiveDeltaT
}

// GetFramesPerDeltaT retrieves the value of the leaf FramesPerDeltaT from the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Stamp_Loss_Timing
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FramesPerDeltaT is set, it can
// safely use t.GetFramesPerDeltaT() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FramesPerDeltaT == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Stamp_Loss_Timing) GetFramesPerDeltaT() uint32 {
	if t == nil || t.FramesPerDeltaT == nil {
		return 1
	}
	return *t.FramesPerDeltaT
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Stamp_Loss_Timing
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Stamp_Loss_Timing) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.ChliThreshold == nil {
		var v uint8 = 5
		t.ChliThreshold = &v
	}
	if t.ConsecutiveDeltaT == nil {
		var v uint8 = 10
		t.ConsecutiveDeltaT = &v
	}
	if t.FramesPerDeltaT == nil {
		var v uint32 = 1
		t.FramesPerDeltaT = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Stamp_Loss_Timing) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Stamp_Loss_Timing"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Stamp_Loss_Timing) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Stamp_Loss_Timing) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Stamp_Loss_Timing.
func (*SrlNokiaOam_Oam_PerformanceMonitoring_Ip_Session_Stamp_Loss_Timing) ΛBelongingModule() string {
	return "srl_nokia-oam-pm-ip"
}

// SrlNokiaOam_Oam_Stamp represents the /srl_nokia-oam/oam/stamp YANG schema element.
type SrlNokiaOam_Oam_Stamp struct {
	SessionReflector *SrlNokiaOam_Oam_Stamp_SessionReflector `path:"session-reflector" module:"srl_nokia-stamp"`
}

// IsYANGGoStruct ensures that SrlNokiaOam_Oam_Stamp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaOam_Oam_Stamp) IsYANGGoStruct() {}

// GetOrCreateSessionReflector retrieves the value of the SessionReflector field
// or returns the existing field if it already exists.
func (t *SrlNokiaOam_Oam_Stamp) GetOrCreateSessionReflector() *SrlNokiaOam_Oam_Stamp_SessionReflector {
	if t.SessionReflector != nil {
		return t.SessionReflector
	}
	t.SessionReflector = &SrlNokiaOam_Oam_Stamp_SessionReflector{}
	return t.SessionReflector
}

// GetSessionReflector returns the value of the SessionReflector struct pointer
// from SrlNokiaOam_Oam_Stamp. If the receiver or the field SessionReflector is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaOam_Oam_Stamp) GetSessionReflector() *SrlNokiaOam_Oam_Stamp_SessionReflector {
	if t != nil && t.SessionReflector != nil {
		return t.SessionReflector
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaOam_Oam_Stamp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaOam_Oam_Stamp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.SessionReflector.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_Stamp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaOam_Oam_Stamp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_Stamp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaOam_Oam_Stamp) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaOam_Oam_Stamp.
func (*SrlNokiaOam_Oam_Stamp) ΛBelongingModule() string {
	return "srl_nokia-stamp"
}

// SrlNokiaOam_Oam_Stamp_SessionReflector represents the /srl_nokia-oam/oam/stamp/session-reflector YANG schema element.
type SrlNokiaOam_Oam_Stamp_SessionReflector struct {
	InactivityTimer *uint32                                                            `path:"inactivity-timer" module:"srl_nokia-stamp"`
	NetworkInstance map[string]*SrlNokiaOam_Oam_Stamp_SessionReflector_NetworkInstance `path:"network-instance" module:"srl_nokia-stamp"`
}

// IsYANGGoStruct ensures that SrlNokiaOam_Oam_Stamp_SessionReflector implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaOam_Oam_Stamp_SessionReflector) IsYANGGoStruct() {}

// NewNetworkInstance creates a new entry in the NetworkInstance list of the
// SrlNokiaOam_Oam_Stamp_SessionReflector struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaOam_Oam_Stamp_SessionReflector) NewNetworkInstance(Name string) (*SrlNokiaOam_Oam_Stamp_SessionReflector_NetworkInstance, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NetworkInstance == nil {
		t.NetworkInstance = make(map[string]*SrlNokiaOam_Oam_Stamp_SessionReflector_NetworkInstance)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.NetworkInstance[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list NetworkInstance", key)
	}

	t.NetworkInstance[key] = &SrlNokiaOam_Oam_Stamp_SessionReflector_NetworkInstance{
		Name: &Name,
	}

	return t.NetworkInstance[key], nil
}

// RenameNetworkInstance renames an entry in the list NetworkInstance within
// the SrlNokiaOam_Oam_Stamp_SessionReflector struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaOam_Oam_Stamp_SessionReflector) RenameNetworkInstance(oldK, newK string) error {
	if _, ok := t.NetworkInstance[newK]; ok {
		return fmt.Errorf("key %v already exists in NetworkInstance", newK)
	}

	e, ok := t.NetworkInstance[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in NetworkInstance", oldK)
	}
	e.Name = &newK

	t.NetworkInstance[newK] = e
	delete(t.NetworkInstance, oldK)
	return nil
}

// GetOrCreateNetworkInstance retrieves the value with the specified keys from
// the receiver SrlNokiaOam_Oam_Stamp_SessionReflector. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaOam_Oam_Stamp_SessionReflector) GetOrCreateNetworkInstance(Name string) *SrlNokiaOam_Oam_Stamp_SessionReflector_NetworkInstance {
	key := Name

	if v, ok := t.NetworkInstance[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNetworkInstance(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNetworkInstance got unexpected error: %v", err))
	}
	return v
}

// GetNetworkInstance retrieves the value with the specified key from
// the NetworkInstance map field of SrlNokiaOam_Oam_Stamp_SessionReflector. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaOam_Oam_Stamp_SessionReflector) GetNetworkInstance(Name string) *SrlNokiaOam_Oam_Stamp_SessionReflector_NetworkInstance {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.NetworkInstance[key]; ok {
		return lm
	}
	return nil
}

// DeleteNetworkInstance deletes the value with the specified keys from
// the receiver SrlNokiaOam_Oam_Stamp_SessionReflector. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaOam_Oam_Stamp_SessionReflector) DeleteNetworkInstance(Name string) {
	key := Name

	delete(t.NetworkInstance, key)
}

// AppendNetworkInstance appends the supplied SrlNokiaOam_Oam_Stamp_SessionReflector_NetworkInstance struct to the
// list NetworkInstance of SrlNokiaOam_Oam_Stamp_SessionReflector. If the key value(s) specified in
// the supplied SrlNokiaOam_Oam_Stamp_SessionReflector_NetworkInstance already exist in the list, an error is
// returned.
func (t *SrlNokiaOam_Oam_Stamp_SessionReflector) AppendNetworkInstance(
	v *SrlNokiaOam_Oam_Stamp_SessionReflector_NetworkInstance,
) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NetworkInstance == nil {
		t.NetworkInstance = make(map[string]*SrlNokiaOam_Oam_Stamp_SessionReflector_NetworkInstance)
	}

	if _, ok := t.NetworkInstance[key]; ok {
		return fmt.Errorf("duplicate key for list NetworkInstance %v", key)
	}

	t.NetworkInstance[key] = v
	return nil
}

// GetInactivityTimer retrieves the value of the leaf InactivityTimer from the SrlNokiaOam_Oam_Stamp_SessionReflector
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InactivityTimer is set, it can
// safely use t.GetInactivityTimer() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InactivityTimer == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_Stamp_SessionReflector) GetInactivityTimer() uint32 {
	if t == nil || t.InactivityTimer == nil {
		return 900
	}
	return *t.InactivityTimer
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaOam_Oam_Stamp_SessionReflector
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaOam_Oam_Stamp_SessionReflector) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.InactivityTimer == nil {
		var v uint32 = 900
		t.InactivityTimer = &v
	}
	for _, e := range t.NetworkInstance {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_Stamp_SessionReflector) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaOam_Oam_Stamp_SessionReflector"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_Stamp_SessionReflector) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaOam_Oam_Stamp_SessionReflector) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaOam_Oam_Stamp_SessionReflector.
func (*SrlNokiaOam_Oam_Stamp_SessionReflector) ΛBelongingModule() string {
	return "srl_nokia-stamp"
}

// SrlNokiaOam_Oam_Stamp_SessionReflector_NetworkInstance represents the /srl_nokia-oam/oam/stamp/session-reflector/network-instance YANG schema element.
type SrlNokiaOam_Oam_Stamp_SessionReflector_NetworkInstance struct {
	AdminState               E_SrlNokiaCommon_AdminState                                                 `path:"admin-state" module:"srl_nokia-stamp"`
	AllowIpv6UdpChecksumZero *bool                                                                       `path:"allow-ipv6-udp-checksum-zero" module:"srl_nokia-stamp"`
	Description              *string                                                                     `path:"description" module:"srl_nokia-stamp"`
	IpPrefix                 map[string]*SrlNokiaOam_Oam_Stamp_SessionReflector_NetworkInstance_IpPrefix `path:"ip-prefix" module:"srl_nokia-stamp"`
	Name                     *string                                                                     `path:"name" module:"srl_nokia-stamp"`
	UdpPort                  *uint16                                                                     `path:"udp-port" module:"srl_nokia-stamp"`
}

// IsYANGGoStruct ensures that SrlNokiaOam_Oam_Stamp_SessionReflector_NetworkInstance implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaOam_Oam_Stamp_SessionReflector_NetworkInstance) IsYANGGoStruct() {}

// NewIpPrefix creates a new entry in the IpPrefix list of the
// SrlNokiaOam_Oam_Stamp_SessionReflector_NetworkInstance struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaOam_Oam_Stamp_SessionReflector_NetworkInstance) NewIpPrefix(IpPrefix string) (*SrlNokiaOam_Oam_Stamp_SessionReflector_NetworkInstance_IpPrefix, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.IpPrefix == nil {
		t.IpPrefix = make(map[string]*SrlNokiaOam_Oam_Stamp_SessionReflector_NetworkInstance_IpPrefix)
	}

	key := IpPrefix

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.IpPrefix[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list IpPrefix", key)
	}

	t.IpPrefix[key] = &SrlNokiaOam_Oam_Stamp_SessionReflector_NetworkInstance_IpPrefix{
		IpPrefix: &IpPrefix,
	}

	return t.IpPrefix[key], nil
}

// RenameIpPrefix renames an entry in the list IpPrefix within
// the SrlNokiaOam_Oam_Stamp_SessionReflector_NetworkInstance struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaOam_Oam_Stamp_SessionReflector_NetworkInstance) RenameIpPrefix(oldK, newK string) error {
	if _, ok := t.IpPrefix[newK]; ok {
		return fmt.Errorf("key %v already exists in IpPrefix", newK)
	}

	e, ok := t.IpPrefix[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in IpPrefix", oldK)
	}
	e.IpPrefix = &newK

	t.IpPrefix[newK] = e
	delete(t.IpPrefix, oldK)
	return nil
}

// GetOrCreateIpPrefix retrieves the value with the specified keys from
// the receiver SrlNokiaOam_Oam_Stamp_SessionReflector_NetworkInstance. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaOam_Oam_Stamp_SessionReflector_NetworkInstance) GetOrCreateIpPrefix(
	IpPrefix string,
) *SrlNokiaOam_Oam_Stamp_SessionReflector_NetworkInstance_IpPrefix {
	key := IpPrefix

	if v, ok := t.IpPrefix[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewIpPrefix(IpPrefix)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateIpPrefix got unexpected error: %v", err))
	}
	return v
}

// GetIpPrefix retrieves the value with the specified key from
// the IpPrefix map field of SrlNokiaOam_Oam_Stamp_SessionReflector_NetworkInstance. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaOam_Oam_Stamp_SessionReflector_NetworkInstance) GetIpPrefix(IpPrefix string) *SrlNokiaOam_Oam_Stamp_SessionReflector_NetworkInstance_IpPrefix {
	if t == nil {
		return nil
	}

	key := IpPrefix

	if lm, ok := t.IpPrefix[key]; ok {
		return lm
	}
	return nil
}

// DeleteIpPrefix deletes the value with the specified keys from
// the receiver SrlNokiaOam_Oam_Stamp_SessionReflector_NetworkInstance. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaOam_Oam_Stamp_SessionReflector_NetworkInstance) DeleteIpPrefix(IpPrefix string) {
	key := IpPrefix

	delete(t.IpPrefix, key)
}

// AppendIpPrefix appends the supplied SrlNokiaOam_Oam_Stamp_SessionReflector_NetworkInstance_IpPrefix struct to the
// list IpPrefix of SrlNokiaOam_Oam_Stamp_SessionReflector_NetworkInstance. If the key value(s) specified in
// the supplied SrlNokiaOam_Oam_Stamp_SessionReflector_NetworkInstance_IpPrefix already exist in the list, an error is
// returned.
func (t *SrlNokiaOam_Oam_Stamp_SessionReflector_NetworkInstance) AppendIpPrefix(
	v *SrlNokiaOam_Oam_Stamp_SessionReflector_NetworkInstance_IpPrefix,
) error {
	if v.IpPrefix == nil {
		return fmt.Errorf("invalid nil key received for IpPrefix")
	}

	key := *v.IpPrefix

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.IpPrefix == nil {
		t.IpPrefix = make(map[string]*SrlNokiaOam_Oam_Stamp_SessionReflector_NetworkInstance_IpPrefix)
	}

	if _, ok := t.IpPrefix[key]; ok {
		return fmt.Errorf("duplicate key for list IpPrefix %v", key)
	}

	t.IpPrefix[key] = v
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaOam_Oam_Stamp_SessionReflector_NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_Stamp_SessionReflector_NetworkInstance) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_disable
	}
	return t.AdminState
}

// GetAllowIpv6UdpChecksumZero retrieves the value of the leaf AllowIpv6UdpChecksumZero from the SrlNokiaOam_Oam_Stamp_SessionReflector_NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AllowIpv6UdpChecksumZero is set, it can
// safely use t.GetAllowIpv6UdpChecksumZero() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AllowIpv6UdpChecksumZero == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_Stamp_SessionReflector_NetworkInstance) GetAllowIpv6UdpChecksumZero() bool {
	if t == nil || t.AllowIpv6UdpChecksumZero == nil {
		return false
	}
	return *t.AllowIpv6UdpChecksumZero
}

// GetDescription retrieves the value of the leaf Description from the SrlNokiaOam_Oam_Stamp_SessionReflector_NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_Stamp_SessionReflector_NetworkInstance) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetName retrieves the value of the leaf Name from the SrlNokiaOam_Oam_Stamp_SessionReflector_NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_Stamp_SessionReflector_NetworkInstance) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetUdpPort retrieves the value of the leaf UdpPort from the SrlNokiaOam_Oam_Stamp_SessionReflector_NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if UdpPort is set, it can
// safely use t.GetUdpPort() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.UdpPort == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_Stamp_SessionReflector_NetworkInstance) GetUdpPort() uint16 {
	if t == nil || t.UdpPort == nil {
		return 862
	}
	return *t.UdpPort
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaOam_Oam_Stamp_SessionReflector_NetworkInstance
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaOam_Oam_Stamp_SessionReflector_NetworkInstance) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_disable
	}
	if t.AllowIpv6UdpChecksumZero == nil {
		var v bool = false
		t.AllowIpv6UdpChecksumZero = &v
	}
	if t.UdpPort == nil {
		var v uint16 = 862
		t.UdpPort = &v
	}
	for _, e := range t.IpPrefix {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaOam_Oam_Stamp_SessionReflector_NetworkInstance struct, which is a YANG list entry.
func (t *SrlNokiaOam_Oam_Stamp_SessionReflector_NetworkInstance) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_Stamp_SessionReflector_NetworkInstance) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaOam_Oam_Stamp_SessionReflector_NetworkInstance"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_Stamp_SessionReflector_NetworkInstance) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaOam_Oam_Stamp_SessionReflector_NetworkInstance) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaOam_Oam_Stamp_SessionReflector_NetworkInstance.
func (*SrlNokiaOam_Oam_Stamp_SessionReflector_NetworkInstance) ΛBelongingModule() string {
	return "srl_nokia-stamp"
}

// SrlNokiaOam_Oam_Stamp_SessionReflector_NetworkInstance_IpPrefix represents the /srl_nokia-oam/oam/stamp/session-reflector/network-instance/ip-prefix YANG schema element.
type SrlNokiaOam_Oam_Stamp_SessionReflector_NetworkInstance_IpPrefix struct {
	IpPrefix *string `path:"ip-prefix" module:"srl_nokia-stamp"`
}

// IsYANGGoStruct ensures that SrlNokiaOam_Oam_Stamp_SessionReflector_NetworkInstance_IpPrefix implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaOam_Oam_Stamp_SessionReflector_NetworkInstance_IpPrefix) IsYANGGoStruct() {}

// GetIpPrefix retrieves the value of the leaf IpPrefix from the SrlNokiaOam_Oam_Stamp_SessionReflector_NetworkInstance_IpPrefix
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IpPrefix is set, it can
// safely use t.GetIpPrefix() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IpPrefix == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_Stamp_SessionReflector_NetworkInstance_IpPrefix) GetIpPrefix() string {
	if t == nil || t.IpPrefix == nil {
		return ""
	}
	return *t.IpPrefix
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaOam_Oam_Stamp_SessionReflector_NetworkInstance_IpPrefix
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaOam_Oam_Stamp_SessionReflector_NetworkInstance_IpPrefix) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the SrlNokiaOam_Oam_Stamp_SessionReflector_NetworkInstance_IpPrefix struct, which is a YANG list entry.
func (t *SrlNokiaOam_Oam_Stamp_SessionReflector_NetworkInstance_IpPrefix) ΛListKeyMap() (map[string]interface{}, error) {
	if t.IpPrefix == nil {
		return nil, fmt.Errorf("nil value for key IpPrefix")
	}

	return map[string]interface{}{
		"ip-prefix": *t.IpPrefix,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_Stamp_SessionReflector_NetworkInstance_IpPrefix) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaOam_Oam_Stamp_SessionReflector_NetworkInstance_IpPrefix"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_Stamp_SessionReflector_NetworkInstance_IpPrefix) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaOam_Oam_Stamp_SessionReflector_NetworkInstance_IpPrefix) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaOam_Oam_Stamp_SessionReflector_NetworkInstance_IpPrefix.
func (*SrlNokiaOam_Oam_Stamp_SessionReflector_NetworkInstance_IpPrefix) ΛBelongingModule() string {
	return "srl_nokia-stamp"
}

// SrlNokiaOam_Oam_Twamp represents the /srl_nokia-oam/oam/twamp YANG schema element.
type SrlNokiaOam_Oam_Twamp struct {
	Server *SrlNokiaOam_Oam_Twamp_Server `path:"server" module:"srl_nokia-twamp"`
}

// IsYANGGoStruct ensures that SrlNokiaOam_Oam_Twamp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaOam_Oam_Twamp) IsYANGGoStruct() {}

// GetOrCreateServer retrieves the value of the Server field
// or returns the existing field if it already exists.
func (t *SrlNokiaOam_Oam_Twamp) GetOrCreateServer() *SrlNokiaOam_Oam_Twamp_Server {
	if t.Server != nil {
		return t.Server
	}
	t.Server = &SrlNokiaOam_Oam_Twamp_Server{}
	return t.Server
}

// GetServer returns the value of the Server struct pointer
// from SrlNokiaOam_Oam_Twamp. If the receiver or the field Server is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaOam_Oam_Twamp) GetServer() *SrlNokiaOam_Oam_Twamp_Server {
	if t != nil && t.Server != nil {
		return t.Server
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaOam_Oam_Twamp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaOam_Oam_Twamp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Server.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_Twamp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaOam_Oam_Twamp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_Twamp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaOam_Oam_Twamp) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaOam_Oam_Twamp.
func (*SrlNokiaOam_Oam_Twamp) ΛBelongingModule() string {
	return "srl_nokia-twamp"
}

// SrlNokiaOam_Oam_Twamp_Server represents the /srl_nokia-oam/oam/twamp/server YANG schema element.
type SrlNokiaOam_Oam_Twamp_Server struct {
	NetworkInstance map[string]*SrlNokiaOam_Oam_Twamp_Server_NetworkInstance `path:"network-instance" module:"srl_nokia-twamp"`
}

// IsYANGGoStruct ensures that SrlNokiaOam_Oam_Twamp_Server implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaOam_Oam_Twamp_Server) IsYANGGoStruct() {}

// NewNetworkInstance creates a new entry in the NetworkInstance list of the
// SrlNokiaOam_Oam_Twamp_Server struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaOam_Oam_Twamp_Server) NewNetworkInstance(Name string) (*SrlNokiaOam_Oam_Twamp_Server_NetworkInstance, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NetworkInstance == nil {
		t.NetworkInstance = make(map[string]*SrlNokiaOam_Oam_Twamp_Server_NetworkInstance)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.NetworkInstance[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list NetworkInstance", key)
	}

	t.NetworkInstance[key] = &SrlNokiaOam_Oam_Twamp_Server_NetworkInstance{
		Name: &Name,
	}

	return t.NetworkInstance[key], nil
}

// RenameNetworkInstance renames an entry in the list NetworkInstance within
// the SrlNokiaOam_Oam_Twamp_Server struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaOam_Oam_Twamp_Server) RenameNetworkInstance(oldK, newK string) error {
	if _, ok := t.NetworkInstance[newK]; ok {
		return fmt.Errorf("key %v already exists in NetworkInstance", newK)
	}

	e, ok := t.NetworkInstance[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in NetworkInstance", oldK)
	}
	e.Name = &newK

	t.NetworkInstance[newK] = e
	delete(t.NetworkInstance, oldK)
	return nil
}

// GetOrCreateNetworkInstance retrieves the value with the specified keys from
// the receiver SrlNokiaOam_Oam_Twamp_Server. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaOam_Oam_Twamp_Server) GetOrCreateNetworkInstance(Name string) *SrlNokiaOam_Oam_Twamp_Server_NetworkInstance {
	key := Name

	if v, ok := t.NetworkInstance[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNetworkInstance(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNetworkInstance got unexpected error: %v", err))
	}
	return v
}

// GetNetworkInstance retrieves the value with the specified key from
// the NetworkInstance map field of SrlNokiaOam_Oam_Twamp_Server. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaOam_Oam_Twamp_Server) GetNetworkInstance(Name string) *SrlNokiaOam_Oam_Twamp_Server_NetworkInstance {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.NetworkInstance[key]; ok {
		return lm
	}
	return nil
}

// DeleteNetworkInstance deletes the value with the specified keys from
// the receiver SrlNokiaOam_Oam_Twamp_Server. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaOam_Oam_Twamp_Server) DeleteNetworkInstance(Name string) {
	key := Name

	delete(t.NetworkInstance, key)
}

// AppendNetworkInstance appends the supplied SrlNokiaOam_Oam_Twamp_Server_NetworkInstance struct to the
// list NetworkInstance of SrlNokiaOam_Oam_Twamp_Server. If the key value(s) specified in
// the supplied SrlNokiaOam_Oam_Twamp_Server_NetworkInstance already exist in the list, an error is
// returned.
func (t *SrlNokiaOam_Oam_Twamp_Server) AppendNetworkInstance(v *SrlNokiaOam_Oam_Twamp_Server_NetworkInstance) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NetworkInstance == nil {
		t.NetworkInstance = make(map[string]*SrlNokiaOam_Oam_Twamp_Server_NetworkInstance)
	}

	if _, ok := t.NetworkInstance[key]; ok {
		return fmt.Errorf("duplicate key for list NetworkInstance %v", key)
	}

	t.NetworkInstance[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaOam_Oam_Twamp_Server
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaOam_Oam_Twamp_Server) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.NetworkInstance {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_Twamp_Server) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaOam_Oam_Twamp_Server"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_Twamp_Server) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaOam_Oam_Twamp_Server) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaOam_Oam_Twamp_Server.
func (*SrlNokiaOam_Oam_Twamp_Server) ΛBelongingModule() string {
	return "srl_nokia-twamp"
}

// SrlNokiaOam_Oam_Twamp_Server_NetworkInstance represents the /srl_nokia-oam/oam/twamp/server/network-instance YANG schema element.
type SrlNokiaOam_Oam_Twamp_Server_NetworkInstance struct {
	AdminState                  E_SrlNokiaCommon_AdminState                                               `path:"admin-state" module:"srl_nokia-twamp"`
	AllowIpv6UdpChecksumZero    *bool                                                                     `path:"allow-ipv6-udp-checksum-zero" module:"srl_nokia-twamp"`
	ClientConnection            map[string]*SrlNokiaOam_Oam_Twamp_Server_NetworkInstance_ClientConnection `path:"client-connection" module:"srl_nokia-twamp"`
	ControlPacketDscp           SrlNokiaOam_Oam_Twamp_Server_NetworkInstance_ControlPacketDscp_Union      `path:"control-packet-dscp" module:"srl_nokia-twamp"`
	Description                 *string                                                                   `path:"description" module:"srl_nokia-twamp"`
	EnforceTestSessionStartTime *bool                                                                     `path:"enforce-test-session-start-time" module:"srl_nokia-twamp"`
	MaximumConnections          *uint32                                                                   `path:"maximum-connections" module:"srl_nokia-twamp"`
	MaximumSessions             *uint32                                                                   `path:"maximum-sessions" module:"srl_nokia-twamp"`
	Name                        *string                                                                   `path:"name" module:"srl_nokia-twamp"`
	Servwait                    *uint32                                                                   `path:"servwait" module:"srl_nokia-twamp"`
	SessionReflector            *SrlNokiaOam_Oam_Twamp_Server_NetworkInstance_SessionReflector            `path:"session-reflector" module:"srl_nokia-twamp"`
}

// IsYANGGoStruct ensures that SrlNokiaOam_Oam_Twamp_Server_NetworkInstance implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaOam_Oam_Twamp_Server_NetworkInstance) IsYANGGoStruct() {}

// NewClientConnection creates a new entry in the ClientConnection list of the
// SrlNokiaOam_Oam_Twamp_Server_NetworkInstance struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaOam_Oam_Twamp_Server_NetworkInstance) NewClientConnection(Prefix string) (*SrlNokiaOam_Oam_Twamp_Server_NetworkInstance_ClientConnection, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ClientConnection == nil {
		t.ClientConnection = make(map[string]*SrlNokiaOam_Oam_Twamp_Server_NetworkInstance_ClientConnection)
	}

	key := Prefix

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.ClientConnection[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list ClientConnection", key)
	}

	t.ClientConnection[key] = &SrlNokiaOam_Oam_Twamp_Server_NetworkInstance_ClientConnection{
		Prefix: &Prefix,
	}

	return t.ClientConnection[key], nil
}

// RenameClientConnection renames an entry in the list ClientConnection within
// the SrlNokiaOam_Oam_Twamp_Server_NetworkInstance struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaOam_Oam_Twamp_Server_NetworkInstance) RenameClientConnection(oldK, newK string) error {
	if _, ok := t.ClientConnection[newK]; ok {
		return fmt.Errorf("key %v already exists in ClientConnection", newK)
	}

	e, ok := t.ClientConnection[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in ClientConnection", oldK)
	}
	e.Prefix = &newK

	t.ClientConnection[newK] = e
	delete(t.ClientConnection, oldK)
	return nil
}

// GetOrCreateClientConnection retrieves the value with the specified keys from
// the receiver SrlNokiaOam_Oam_Twamp_Server_NetworkInstance. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaOam_Oam_Twamp_Server_NetworkInstance) GetOrCreateClientConnection(Prefix string) *SrlNokiaOam_Oam_Twamp_Server_NetworkInstance_ClientConnection {
	key := Prefix

	if v, ok := t.ClientConnection[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewClientConnection(Prefix)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateClientConnection got unexpected error: %v", err))
	}
	return v
}

// GetClientConnection retrieves the value with the specified key from
// the ClientConnection map field of SrlNokiaOam_Oam_Twamp_Server_NetworkInstance. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaOam_Oam_Twamp_Server_NetworkInstance) GetClientConnection(Prefix string) *SrlNokiaOam_Oam_Twamp_Server_NetworkInstance_ClientConnection {
	if t == nil {
		return nil
	}

	key := Prefix

	if lm, ok := t.ClientConnection[key]; ok {
		return lm
	}
	return nil
}

// DeleteClientConnection deletes the value with the specified keys from
// the receiver SrlNokiaOam_Oam_Twamp_Server_NetworkInstance. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaOam_Oam_Twamp_Server_NetworkInstance) DeleteClientConnection(Prefix string) {
	key := Prefix

	delete(t.ClientConnection, key)
}

// AppendClientConnection appends the supplied SrlNokiaOam_Oam_Twamp_Server_NetworkInstance_ClientConnection struct to the
// list ClientConnection of SrlNokiaOam_Oam_Twamp_Server_NetworkInstance. If the key value(s) specified in
// the supplied SrlNokiaOam_Oam_Twamp_Server_NetworkInstance_ClientConnection already exist in the list, an error is
// returned.
func (t *SrlNokiaOam_Oam_Twamp_Server_NetworkInstance) AppendClientConnection(
	v *SrlNokiaOam_Oam_Twamp_Server_NetworkInstance_ClientConnection,
) error {
	if v.Prefix == nil {
		return fmt.Errorf("invalid nil key received for Prefix")
	}

	key := *v.Prefix

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ClientConnection == nil {
		t.ClientConnection = make(map[string]*SrlNokiaOam_Oam_Twamp_Server_NetworkInstance_ClientConnection)
	}

	if _, ok := t.ClientConnection[key]; ok {
		return fmt.Errorf("duplicate key for list ClientConnection %v", key)
	}

	t.ClientConnection[key] = v
	return nil
}

// GetOrCreateSessionReflector retrieves the value of the SessionReflector field
// or returns the existing field if it already exists.
func (t *SrlNokiaOam_Oam_Twamp_Server_NetworkInstance) GetOrCreateSessionReflector() *SrlNokiaOam_Oam_Twamp_Server_NetworkInstance_SessionReflector {
	if t.SessionReflector != nil {
		return t.SessionReflector
	}
	t.SessionReflector = &SrlNokiaOam_Oam_Twamp_Server_NetworkInstance_SessionReflector{}
	return t.SessionReflector
}

// GetSessionReflector returns the value of the SessionReflector struct pointer
// from SrlNokiaOam_Oam_Twamp_Server_NetworkInstance. If the receiver or the field SessionReflector is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaOam_Oam_Twamp_Server_NetworkInstance) GetSessionReflector() *SrlNokiaOam_Oam_Twamp_Server_NetworkInstance_SessionReflector {
	if t != nil && t.SessionReflector != nil {
		return t.SessionReflector
	}
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaOam_Oam_Twamp_Server_NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_Twamp_Server_NetworkInstance) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_disable
	}
	return t.AdminState
}

// GetAllowIpv6UdpChecksumZero retrieves the value of the leaf AllowIpv6UdpChecksumZero from the SrlNokiaOam_Oam_Twamp_Server_NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AllowIpv6UdpChecksumZero is set, it can
// safely use t.GetAllowIpv6UdpChecksumZero() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AllowIpv6UdpChecksumZero == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_Twamp_Server_NetworkInstance) GetAllowIpv6UdpChecksumZero() bool {
	if t == nil || t.AllowIpv6UdpChecksumZero == nil {
		return false
	}
	return *t.AllowIpv6UdpChecksumZero
}

// GetControlPacketDscp retrieves the value of the leaf ControlPacketDscp from the SrlNokiaOam_Oam_Twamp_Server_NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ControlPacketDscp is set, it can
// safely use t.GetControlPacketDscp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ControlPacketDscp == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_Twamp_Server_NetworkInstance) GetControlPacketDscp() SrlNokiaOam_Oam_Twamp_Server_NetworkInstance_ControlPacketDscp_Union {
	if t == nil || t.ControlPacketDscp == nil {
		return SrlNokiaCommon_DscpName_CS7
	}
	return t.ControlPacketDscp
}

// GetDescription retrieves the value of the leaf Description from the SrlNokiaOam_Oam_Twamp_Server_NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_Twamp_Server_NetworkInstance) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetEnforceTestSessionStartTime retrieves the value of the leaf EnforceTestSessionStartTime from the SrlNokiaOam_Oam_Twamp_Server_NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EnforceTestSessionStartTime is set, it can
// safely use t.GetEnforceTestSessionStartTime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EnforceTestSessionStartTime == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_Twamp_Server_NetworkInstance) GetEnforceTestSessionStartTime() bool {
	if t == nil || t.EnforceTestSessionStartTime == nil {
		return true
	}
	return *t.EnforceTestSessionStartTime
}

// GetMaximumConnections retrieves the value of the leaf MaximumConnections from the SrlNokiaOam_Oam_Twamp_Server_NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MaximumConnections is set, it can
// safely use t.GetMaximumConnections() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MaximumConnections == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_Twamp_Server_NetworkInstance) GetMaximumConnections() uint32 {
	if t == nil || t.MaximumConnections == nil {
		return 32
	}
	return *t.MaximumConnections
}

// GetMaximumSessions retrieves the value of the leaf MaximumSessions from the SrlNokiaOam_Oam_Twamp_Server_NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MaximumSessions is set, it can
// safely use t.GetMaximumSessions() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MaximumSessions == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_Twamp_Server_NetworkInstance) GetMaximumSessions() uint32 {
	if t == nil || t.MaximumSessions == nil {
		return 32
	}
	return *t.MaximumSessions
}

// GetName retrieves the value of the leaf Name from the SrlNokiaOam_Oam_Twamp_Server_NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_Twamp_Server_NetworkInstance) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetServwait retrieves the value of the leaf Servwait from the SrlNokiaOam_Oam_Twamp_Server_NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Servwait is set, it can
// safely use t.GetServwait() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Servwait == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_Twamp_Server_NetworkInstance) GetServwait() uint32 {
	if t == nil || t.Servwait == nil {
		return 900
	}
	return *t.Servwait
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaOam_Oam_Twamp_Server_NetworkInstance
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaOam_Oam_Twamp_Server_NetworkInstance) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_disable
	}
	if t.AllowIpv6UdpChecksumZero == nil {
		var v bool = false
		t.AllowIpv6UdpChecksumZero = &v
	}
	if t.ControlPacketDscp == nil {
		t.ControlPacketDscp = SrlNokiaCommon_DscpName_CS7
	}
	if t.EnforceTestSessionStartTime == nil {
		var v bool = true
		t.EnforceTestSessionStartTime = &v
	}
	if t.MaximumConnections == nil {
		var v uint32 = 32
		t.MaximumConnections = &v
	}
	if t.MaximumSessions == nil {
		var v uint32 = 32
		t.MaximumSessions = &v
	}
	if t.Servwait == nil {
		var v uint32 = 900
		t.Servwait = &v
	}
	t.SessionReflector.PopulateDefaults()
	for _, e := range t.ClientConnection {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaOam_Oam_Twamp_Server_NetworkInstance struct, which is a YANG list entry.
func (t *SrlNokiaOam_Oam_Twamp_Server_NetworkInstance) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_Twamp_Server_NetworkInstance) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaOam_Oam_Twamp_Server_NetworkInstance"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_Twamp_Server_NetworkInstance) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaOam_Oam_Twamp_Server_NetworkInstance) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaOam_Oam_Twamp_Server_NetworkInstance.
func (*SrlNokiaOam_Oam_Twamp_Server_NetworkInstance) ΛBelongingModule() string {
	return "srl_nokia-twamp"
}

// SrlNokiaOam_Oam_Twamp_Server_NetworkInstance_ClientConnection represents the /srl_nokia-oam/oam/twamp/server/network-instance/client-connection YANG schema element.
type SrlNokiaOam_Oam_Twamp_Server_NetworkInstance_ClientConnection struct {
	MaximumConnections *uint16 `path:"maximum-connections" module:"srl_nokia-twamp"`
	MaximumSessions    *uint16 `path:"maximum-sessions" module:"srl_nokia-twamp"`
	Prefix             *string `path:"prefix" module:"srl_nokia-twamp"`
}

// IsYANGGoStruct ensures that SrlNokiaOam_Oam_Twamp_Server_NetworkInstance_ClientConnection implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaOam_Oam_Twamp_Server_NetworkInstance_ClientConnection) IsYANGGoStruct() {}

// GetMaximumConnections retrieves the value of the leaf MaximumConnections from the SrlNokiaOam_Oam_Twamp_Server_NetworkInstance_ClientConnection
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MaximumConnections is set, it can
// safely use t.GetMaximumConnections() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MaximumConnections == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_Twamp_Server_NetworkInstance_ClientConnection) GetMaximumConnections() uint16 {
	if t == nil || t.MaximumConnections == nil {
		return 32
	}
	return *t.MaximumConnections
}

// GetMaximumSessions retrieves the value of the leaf MaximumSessions from the SrlNokiaOam_Oam_Twamp_Server_NetworkInstance_ClientConnection
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MaximumSessions is set, it can
// safely use t.GetMaximumSessions() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MaximumSessions == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_Twamp_Server_NetworkInstance_ClientConnection) GetMaximumSessions() uint16 {
	if t == nil || t.MaximumSessions == nil {
		return 32
	}
	return *t.MaximumSessions
}

// GetPrefix retrieves the value of the leaf Prefix from the SrlNokiaOam_Oam_Twamp_Server_NetworkInstance_ClientConnection
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Prefix is set, it can
// safely use t.GetPrefix() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Prefix == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_Twamp_Server_NetworkInstance_ClientConnection) GetPrefix() string {
	if t == nil || t.Prefix == nil {
		return ""
	}
	return *t.Prefix
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaOam_Oam_Twamp_Server_NetworkInstance_ClientConnection
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaOam_Oam_Twamp_Server_NetworkInstance_ClientConnection) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.MaximumConnections == nil {
		var v uint16 = 32
		t.MaximumConnections = &v
	}
	if t.MaximumSessions == nil {
		var v uint16 = 32
		t.MaximumSessions = &v
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaOam_Oam_Twamp_Server_NetworkInstance_ClientConnection struct, which is a YANG list entry.
func (t *SrlNokiaOam_Oam_Twamp_Server_NetworkInstance_ClientConnection) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Prefix == nil {
		return nil, fmt.Errorf("nil value for key Prefix")
	}

	return map[string]interface{}{
		"prefix": *t.Prefix,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_Twamp_Server_NetworkInstance_ClientConnection) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaOam_Oam_Twamp_Server_NetworkInstance_ClientConnection"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_Twamp_Server_NetworkInstance_ClientConnection) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaOam_Oam_Twamp_Server_NetworkInstance_ClientConnection) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaOam_Oam_Twamp_Server_NetworkInstance_ClientConnection.
func (*SrlNokiaOam_Oam_Twamp_Server_NetworkInstance_ClientConnection) ΛBelongingModule() string {
	return "srl_nokia-twamp"
}

// SrlNokiaOam_Oam_Twamp_Server_NetworkInstance_SessionReflector represents the /srl_nokia-oam/oam/twamp/server/network-instance/session-reflector YANG schema element.
type SrlNokiaOam_Oam_Twamp_Server_NetworkInstance_SessionReflector struct{}

// IsYANGGoStruct ensures that SrlNokiaOam_Oam_Twamp_Server_NetworkInstance_SessionReflector implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaOam_Oam_Twamp_Server_NetworkInstance_SessionReflector) IsYANGGoStruct() {}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaOam_Oam_Twamp_Server_NetworkInstance_SessionReflector
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaOam_Oam_Twamp_Server_NetworkInstance_SessionReflector) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_Twamp_Server_NetworkInstance_SessionReflector) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaOam_Oam_Twamp_Server_NetworkInstance_SessionReflector"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_Twamp_Server_NetworkInstance_SessionReflector) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaOam_Oam_Twamp_Server_NetworkInstance_SessionReflector) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaOam_Oam_Twamp_Server_NetworkInstance_SessionReflector.
func (*SrlNokiaOam_Oam_Twamp_Server_NetworkInstance_SessionReflector) ΛBelongingModule() string {
	return "srl_nokia-twamp"
}

// SrlNokiaPlatform_Platform represents the /srl_nokia-platform/platform YANG schema element.
type SrlNokiaPlatform_Platform struct {
	Chassis            *SrlNokiaPlatform_Platform_Chassis            `path:"chassis" module:"srl_nokia-platform-chassis"`
	Control            map[string]*SrlNokiaPlatform_Platform_Control `path:"control" module:"srl_nokia-platform-control"`
	Fabric             map[uint8]*SrlNokiaPlatform_Platform_Fabric   `path:"fabric" module:"srl_nokia-platform-fabric"`
	Linecard           map[uint8]*SrlNokiaPlatform_Platform_Linecard `path:"linecard" module:"srl_nokia-platform-lc"`
	Redundancy         *SrlNokiaPlatform_Platform_Redundancy         `path:"redundancy" module:"srl_nokia-platform-redundancy"`
	ResourceManagement *SrlNokiaPlatform_Platform_ResourceManagement `path:"resource-management" module:"srl_nokia-platform-resource-mgmt"`
	ResourceMonitoring *SrlNokiaPlatform_Platform_ResourceMonitoring `path:"resource-monitoring" module:"srl_nokia-platform-resource-monitoring"`
	Vxdp               *SrlNokiaPlatform_Platform_Vxdp               `path:"vxdp" module:"srl_nokia-platform-vxdp" yangPresence:"true"`
}

// IsYANGGoStruct ensures that SrlNokiaPlatform_Platform implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaPlatform_Platform) IsYANGGoStruct() {}

// NewControl creates a new entry in the Control list of the
// SrlNokiaPlatform_Platform struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaPlatform_Platform) NewControl(Slot string) (*SrlNokiaPlatform_Platform_Control, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Control == nil {
		t.Control = make(map[string]*SrlNokiaPlatform_Platform_Control)
	}

	key := Slot

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Control[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Control", key)
	}

	t.Control[key] = &SrlNokiaPlatform_Platform_Control{
		Slot: &Slot,
	}

	return t.Control[key], nil
}

// RenameControl renames an entry in the list Control within
// the SrlNokiaPlatform_Platform struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaPlatform_Platform) RenameControl(oldK, newK string) error {
	if _, ok := t.Control[newK]; ok {
		return fmt.Errorf("key %v already exists in Control", newK)
	}

	e, ok := t.Control[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Control", oldK)
	}
	e.Slot = &newK

	t.Control[newK] = e
	delete(t.Control, oldK)
	return nil
}

// GetOrCreateControl retrieves the value with the specified keys from
// the receiver SrlNokiaPlatform_Platform. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaPlatform_Platform) GetOrCreateControl(Slot string) *SrlNokiaPlatform_Platform_Control {
	key := Slot

	if v, ok := t.Control[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewControl(Slot)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateControl got unexpected error: %v", err))
	}
	return v
}

// GetControl retrieves the value with the specified key from
// the Control map field of SrlNokiaPlatform_Platform. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaPlatform_Platform) GetControl(Slot string) *SrlNokiaPlatform_Platform_Control {
	if t == nil {
		return nil
	}

	key := Slot

	if lm, ok := t.Control[key]; ok {
		return lm
	}
	return nil
}

// DeleteControl deletes the value with the specified keys from
// the receiver SrlNokiaPlatform_Platform. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaPlatform_Platform) DeleteControl(Slot string) {
	key := Slot

	delete(t.Control, key)
}

// AppendControl appends the supplied SrlNokiaPlatform_Platform_Control struct to the
// list Control of SrlNokiaPlatform_Platform. If the key value(s) specified in
// the supplied SrlNokiaPlatform_Platform_Control already exist in the list, an error is
// returned.
func (t *SrlNokiaPlatform_Platform) AppendControl(v *SrlNokiaPlatform_Platform_Control) error {
	if v.Slot == nil {
		return fmt.Errorf("invalid nil key received for Slot")
	}

	key := *v.Slot

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Control == nil {
		t.Control = make(map[string]*SrlNokiaPlatform_Platform_Control)
	}

	if _, ok := t.Control[key]; ok {
		return fmt.Errorf("duplicate key for list Control %v", key)
	}

	t.Control[key] = v
	return nil
}

// NewFabric creates a new entry in the Fabric list of the
// SrlNokiaPlatform_Platform struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaPlatform_Platform) NewFabric(Slot uint8) (*SrlNokiaPlatform_Platform_Fabric, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Fabric == nil {
		t.Fabric = make(map[uint8]*SrlNokiaPlatform_Platform_Fabric)
	}

	key := Slot

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Fabric[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Fabric", key)
	}

	t.Fabric[key] = &SrlNokiaPlatform_Platform_Fabric{
		Slot: &Slot,
	}

	return t.Fabric[key], nil
}

// RenameFabric renames an entry in the list Fabric within
// the SrlNokiaPlatform_Platform struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaPlatform_Platform) RenameFabric(oldK, newK uint8) error {
	if _, ok := t.Fabric[newK]; ok {
		return fmt.Errorf("key %v already exists in Fabric", newK)
	}

	e, ok := t.Fabric[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Fabric", oldK)
	}
	e.Slot = &newK

	t.Fabric[newK] = e
	delete(t.Fabric, oldK)
	return nil
}

// GetOrCreateFabric retrieves the value with the specified keys from
// the receiver SrlNokiaPlatform_Platform. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaPlatform_Platform) GetOrCreateFabric(Slot uint8) *SrlNokiaPlatform_Platform_Fabric {
	key := Slot

	if v, ok := t.Fabric[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewFabric(Slot)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateFabric got unexpected error: %v", err))
	}
	return v
}

// GetFabric retrieves the value with the specified key from
// the Fabric map field of SrlNokiaPlatform_Platform. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaPlatform_Platform) GetFabric(Slot uint8) *SrlNokiaPlatform_Platform_Fabric {
	if t == nil {
		return nil
	}

	key := Slot

	if lm, ok := t.Fabric[key]; ok {
		return lm
	}
	return nil
}

// DeleteFabric deletes the value with the specified keys from
// the receiver SrlNokiaPlatform_Platform. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaPlatform_Platform) DeleteFabric(Slot uint8) {
	key := Slot

	delete(t.Fabric, key)
}

// AppendFabric appends the supplied SrlNokiaPlatform_Platform_Fabric struct to the
// list Fabric of SrlNokiaPlatform_Platform. If the key value(s) specified in
// the supplied SrlNokiaPlatform_Platform_Fabric already exist in the list, an error is
// returned.
func (t *SrlNokiaPlatform_Platform) AppendFabric(v *SrlNokiaPlatform_Platform_Fabric) error {
	if v.Slot == nil {
		return fmt.Errorf("invalid nil key received for Slot")
	}

	key := *v.Slot

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Fabric == nil {
		t.Fabric = make(map[uint8]*SrlNokiaPlatform_Platform_Fabric)
	}

	if _, ok := t.Fabric[key]; ok {
		return fmt.Errorf("duplicate key for list Fabric %v", key)
	}

	t.Fabric[key] = v
	return nil
}

// NewLinecard creates a new entry in the Linecard list of the
// SrlNokiaPlatform_Platform struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaPlatform_Platform) NewLinecard(Slot uint8) (*SrlNokiaPlatform_Platform_Linecard, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Linecard == nil {
		t.Linecard = make(map[uint8]*SrlNokiaPlatform_Platform_Linecard)
	}

	key := Slot

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Linecard[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Linecard", key)
	}

	t.Linecard[key] = &SrlNokiaPlatform_Platform_Linecard{
		Slot: &Slot,
	}

	return t.Linecard[key], nil
}

// RenameLinecard renames an entry in the list Linecard within
// the SrlNokiaPlatform_Platform struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaPlatform_Platform) RenameLinecard(oldK, newK uint8) error {
	if _, ok := t.Linecard[newK]; ok {
		return fmt.Errorf("key %v already exists in Linecard", newK)
	}

	e, ok := t.Linecard[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Linecard", oldK)
	}
	e.Slot = &newK

	t.Linecard[newK] = e
	delete(t.Linecard, oldK)
	return nil
}

// GetOrCreateLinecard retrieves the value with the specified keys from
// the receiver SrlNokiaPlatform_Platform. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaPlatform_Platform) GetOrCreateLinecard(Slot uint8) *SrlNokiaPlatform_Platform_Linecard {
	key := Slot

	if v, ok := t.Linecard[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewLinecard(Slot)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateLinecard got unexpected error: %v", err))
	}
	return v
}

// GetLinecard retrieves the value with the specified key from
// the Linecard map field of SrlNokiaPlatform_Platform. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaPlatform_Platform) GetLinecard(Slot uint8) *SrlNokiaPlatform_Platform_Linecard {
	if t == nil {
		return nil
	}

	key := Slot

	if lm, ok := t.Linecard[key]; ok {
		return lm
	}
	return nil
}

// DeleteLinecard deletes the value with the specified keys from
// the receiver SrlNokiaPlatform_Platform. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaPlatform_Platform) DeleteLinecard(Slot uint8) {
	key := Slot

	delete(t.Linecard, key)
}

// AppendLinecard appends the supplied SrlNokiaPlatform_Platform_Linecard struct to the
// list Linecard of SrlNokiaPlatform_Platform. If the key value(s) specified in
// the supplied SrlNokiaPlatform_Platform_Linecard already exist in the list, an error is
// returned.
func (t *SrlNokiaPlatform_Platform) AppendLinecard(v *SrlNokiaPlatform_Platform_Linecard) error {
	if v.Slot == nil {
		return fmt.Errorf("invalid nil key received for Slot")
	}

	key := *v.Slot

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Linecard == nil {
		t.Linecard = make(map[uint8]*SrlNokiaPlatform_Platform_Linecard)
	}

	if _, ok := t.Linecard[key]; ok {
		return fmt.Errorf("duplicate key for list Linecard %v", key)
	}

	t.Linecard[key] = v
	return nil
}

// GetOrCreateChassis retrieves the value of the Chassis field
// or returns the existing field if it already exists.
func (t *SrlNokiaPlatform_Platform) GetOrCreateChassis() *SrlNokiaPlatform_Platform_Chassis {
	if t.Chassis != nil {
		return t.Chassis
	}
	t.Chassis = &SrlNokiaPlatform_Platform_Chassis{}
	return t.Chassis
}

// GetOrCreateRedundancy retrieves the value of the Redundancy field
// or returns the existing field if it already exists.
func (t *SrlNokiaPlatform_Platform) GetOrCreateRedundancy() *SrlNokiaPlatform_Platform_Redundancy {
	if t.Redundancy != nil {
		return t.Redundancy
	}
	t.Redundancy = &SrlNokiaPlatform_Platform_Redundancy{}
	return t.Redundancy
}

// GetOrCreateResourceManagement retrieves the value of the ResourceManagement field
// or returns the existing field if it already exists.
func (t *SrlNokiaPlatform_Platform) GetOrCreateResourceManagement() *SrlNokiaPlatform_Platform_ResourceManagement {
	if t.ResourceManagement != nil {
		return t.ResourceManagement
	}
	t.ResourceManagement = &SrlNokiaPlatform_Platform_ResourceManagement{}
	return t.ResourceManagement
}

// GetOrCreateResourceMonitoring retrieves the value of the ResourceMonitoring field
// or returns the existing field if it already exists.
func (t *SrlNokiaPlatform_Platform) GetOrCreateResourceMonitoring() *SrlNokiaPlatform_Platform_ResourceMonitoring {
	if t.ResourceMonitoring != nil {
		return t.ResourceMonitoring
	}
	t.ResourceMonitoring = &SrlNokiaPlatform_Platform_ResourceMonitoring{}
	return t.ResourceMonitoring
}

// GetOrCreateVxdp retrieves the value of the Vxdp field
// or returns the existing field if it already exists.
func (t *SrlNokiaPlatform_Platform) GetOrCreateVxdp() *SrlNokiaPlatform_Platform_Vxdp {
	if t.Vxdp != nil {
		return t.Vxdp
	}
	t.Vxdp = &SrlNokiaPlatform_Platform_Vxdp{}
	return t.Vxdp
}

// GetChassis returns the value of the Chassis struct pointer
// from SrlNokiaPlatform_Platform. If the receiver or the field Chassis is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaPlatform_Platform) GetChassis() *SrlNokiaPlatform_Platform_Chassis {
	if t != nil && t.Chassis != nil {
		return t.Chassis
	}
	return nil
}

// GetRedundancy returns the value of the Redundancy struct pointer
// from SrlNokiaPlatform_Platform. If the receiver or the field Redundancy is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaPlatform_Platform) GetRedundancy() *SrlNokiaPlatform_Platform_Redundancy {
	if t != nil && t.Redundancy != nil {
		return t.Redundancy
	}
	return nil
}

// GetResourceManagement returns the value of the ResourceManagement struct pointer
// from SrlNokiaPlatform_Platform. If the receiver or the field ResourceManagement is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaPlatform_Platform) GetResourceManagement() *SrlNokiaPlatform_Platform_ResourceManagement {
	if t != nil && t.ResourceManagement != nil {
		return t.ResourceManagement
	}
	return nil
}

// GetResourceMonitoring returns the value of the ResourceMonitoring struct pointer
// from SrlNokiaPlatform_Platform. If the receiver or the field ResourceMonitoring is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaPlatform_Platform) GetResourceMonitoring() *SrlNokiaPlatform_Platform_ResourceMonitoring {
	if t != nil && t.ResourceMonitoring != nil {
		return t.ResourceMonitoring
	}
	return nil
}

// GetVxdp returns the value of the Vxdp struct pointer
// from SrlNokiaPlatform_Platform. If the receiver or the field Vxdp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaPlatform_Platform) GetVxdp() *SrlNokiaPlatform_Platform_Vxdp {
	if t != nil && t.Vxdp != nil {
		return t.Vxdp
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaPlatform_Platform
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaPlatform_Platform) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Chassis.PopulateDefaults()
	t.Redundancy.PopulateDefaults()
	t.ResourceManagement.PopulateDefaults()
	t.ResourceMonitoring.PopulateDefaults()
	t.Vxdp.PopulateDefaults()
	for _, e := range t.Control {
		e.PopulateDefaults()
	}
	for _, e := range t.Fabric {
		e.PopulateDefaults()
	}
	for _, e := range t.Linecard {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaPlatform_Platform.
func (*SrlNokiaPlatform_Platform) ΛBelongingModule() string {
	return "srl_nokia-platform"
}

// SrlNokiaPlatform_Platform_Chassis represents the /srl_nokia-platform/platform/chassis YANG schema element.
type SrlNokiaPlatform_Platform_Chassis struct {
	MacAddress           *string                                  `path:"mac-address" module:"srl_nokia-platform-vxdp"`
	MacAddressAllocation *uint32                                  `path:"mac-address-allocation" module:"srl_nokia-platform-vxdp"`
	Power                *SrlNokiaPlatform_Platform_Chassis_Power `path:"power" module:"srl_nokia-platform-chassis"`
	SecondaryMacAddress  *string                                  `path:"secondary-mac-address" module:"srl_nokia-platform-chassis"`
	Uuid                 *string                                  `path:"uuid" module:"srl_nokia-platform-vxdp"`
}

// IsYANGGoStruct ensures that SrlNokiaPlatform_Platform_Chassis implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaPlatform_Platform_Chassis) IsYANGGoStruct() {}

// GetOrCreatePower retrieves the value of the Power field
// or returns the existing field if it already exists.
func (t *SrlNokiaPlatform_Platform_Chassis) GetOrCreatePower() *SrlNokiaPlatform_Platform_Chassis_Power {
	if t.Power != nil {
		return t.Power
	}
	t.Power = &SrlNokiaPlatform_Platform_Chassis_Power{}
	return t.Power
}

// GetPower returns the value of the Power struct pointer
// from SrlNokiaPlatform_Platform_Chassis. If the receiver or the field Power is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaPlatform_Platform_Chassis) GetPower() *SrlNokiaPlatform_Platform_Chassis_Power {
	if t != nil && t.Power != nil {
		return t.Power
	}
	return nil
}

// GetMacAddress retrieves the value of the leaf MacAddress from the SrlNokiaPlatform_Platform_Chassis
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MacAddress is set, it can
// safely use t.GetMacAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MacAddress == nil' before retrieving the leaf's value.
func (t *SrlNokiaPlatform_Platform_Chassis) GetMacAddress() string {
	if t == nil || t.MacAddress == nil {
		return ""
	}
	return *t.MacAddress
}

// GetMacAddressAllocation retrieves the value of the leaf MacAddressAllocation from the SrlNokiaPlatform_Platform_Chassis
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MacAddressAllocation is set, it can
// safely use t.GetMacAddressAllocation() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MacAddressAllocation == nil' before retrieving the leaf's value.
func (t *SrlNokiaPlatform_Platform_Chassis) GetMacAddressAllocation() uint32 {
	if t == nil || t.MacAddressAllocation == nil {
		return 1024
	}
	return *t.MacAddressAllocation
}

// GetSecondaryMacAddress retrieves the value of the leaf SecondaryMacAddress from the SrlNokiaPlatform_Platform_Chassis
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SecondaryMacAddress is set, it can
// safely use t.GetSecondaryMacAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SecondaryMacAddress == nil' before retrieving the leaf's value.
func (t *SrlNokiaPlatform_Platform_Chassis) GetSecondaryMacAddress() string {
	if t == nil || t.SecondaryMacAddress == nil {
		return ""
	}
	return *t.SecondaryMacAddress
}

// GetUuid retrieves the value of the leaf Uuid from the SrlNokiaPlatform_Platform_Chassis
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Uuid is set, it can
// safely use t.GetUuid() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Uuid == nil' before retrieving the leaf's value.
func (t *SrlNokiaPlatform_Platform_Chassis) GetUuid() string {
	if t == nil || t.Uuid == nil {
		return ""
	}
	return *t.Uuid
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaPlatform_Platform_Chassis
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaPlatform_Platform_Chassis) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.MacAddressAllocation == nil {
		var v uint32 = 1024
		t.MacAddressAllocation = &v
	}
	t.Power.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Chassis) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_Chassis"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Chassis) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_Chassis) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaPlatform_Platform_Chassis.
func (*SrlNokiaPlatform_Platform_Chassis) ΛBelongingModule() string {
	return "srl_nokia-platform-chassis"
}

// SrlNokiaPlatform_Platform_Chassis_Power represents the /srl_nokia-platform/platform/chassis/power YANG schema element.
type SrlNokiaPlatform_Platform_Chassis_Power struct {
	Redundancy *SrlNokiaPlatform_Platform_Chassis_Power_Redundancy `path:"redundancy" module:"srl_nokia-platform-chassis"`
}

// IsYANGGoStruct ensures that SrlNokiaPlatform_Platform_Chassis_Power implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaPlatform_Platform_Chassis_Power) IsYANGGoStruct() {}

// GetOrCreateRedundancy retrieves the value of the Redundancy field
// or returns the existing field if it already exists.
func (t *SrlNokiaPlatform_Platform_Chassis_Power) GetOrCreateRedundancy() *SrlNokiaPlatform_Platform_Chassis_Power_Redundancy {
	if t.Redundancy != nil {
		return t.Redundancy
	}
	t.Redundancy = &SrlNokiaPlatform_Platform_Chassis_Power_Redundancy{}
	return t.Redundancy
}

// GetRedundancy returns the value of the Redundancy struct pointer
// from SrlNokiaPlatform_Platform_Chassis_Power. If the receiver or the field Redundancy is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaPlatform_Platform_Chassis_Power) GetRedundancy() *SrlNokiaPlatform_Platform_Chassis_Power_Redundancy {
	if t != nil && t.Redundancy != nil {
		return t.Redundancy
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaPlatform_Platform_Chassis_Power
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaPlatform_Platform_Chassis_Power) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Redundancy.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Chassis_Power) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_Chassis_Power"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Chassis_Power) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_Chassis_Power) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaPlatform_Platform_Chassis_Power.
func (*SrlNokiaPlatform_Platform_Chassis_Power) ΛBelongingModule() string {
	return "srl_nokia-platform-chassis"
}

// SrlNokiaPlatform_Platform_Chassis_Power_Redundancy represents the /srl_nokia-platform/platform/chassis/power/redundancy YANG schema element.
type SrlNokiaPlatform_Platform_Chassis_Power_Redundancy struct {
	Mode E_SrlNokiaPlatform_Platform_Chassis_Power_Redundancy_Mode `path:"mode" module:"srl_nokia-platform-chassis"`
}

// IsYANGGoStruct ensures that SrlNokiaPlatform_Platform_Chassis_Power_Redundancy implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaPlatform_Platform_Chassis_Power_Redundancy) IsYANGGoStruct() {}

// GetMode retrieves the value of the leaf Mode from the SrlNokiaPlatform_Platform_Chassis_Power_Redundancy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Mode is set, it can
// safely use t.GetMode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Mode == nil' before retrieving the leaf's value.
func (t *SrlNokiaPlatform_Platform_Chassis_Power_Redundancy) GetMode() E_SrlNokiaPlatform_Platform_Chassis_Power_Redundancy_Mode {
	if t == nil || t.Mode == 0 {
		return SrlNokiaPlatform_Platform_Chassis_Power_Redundancy_Mode_none
	}
	return t.Mode
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaPlatform_Platform_Chassis_Power_Redundancy
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaPlatform_Platform_Chassis_Power_Redundancy) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Mode == 0 {
		t.Mode = SrlNokiaPlatform_Platform_Chassis_Power_Redundancy_Mode_none
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Chassis_Power_Redundancy) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_Chassis_Power_Redundancy"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Chassis_Power_Redundancy) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_Chassis_Power_Redundancy) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaPlatform_Platform_Chassis_Power_Redundancy.
func (*SrlNokiaPlatform_Platform_Chassis_Power_Redundancy) ΛBelongingModule() string {
	return "srl_nokia-platform-chassis"
}

// SrlNokiaPlatform_Platform_Control represents the /srl_nokia-platform/platform/control YANG schema element.
type SrlNokiaPlatform_Platform_Control struct {
	Interface map[E_SrlNokiaPlatformControl_ControlInterfaces]*SrlNokiaPlatform_Platform_Control_Interface `path:"interface" module:"srl_nokia-platform-control"`
	Slot      *string                                                                                      `path:"slot" module:"srl_nokia-platform-control"`
}

// IsYANGGoStruct ensures that SrlNokiaPlatform_Platform_Control implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaPlatform_Platform_Control) IsYANGGoStruct() {}

// NewInterface creates a new entry in the Interface list of the
// SrlNokiaPlatform_Platform_Control struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaPlatform_Platform_Control) NewInterface(Name E_SrlNokiaPlatformControl_ControlInterfaces) (*SrlNokiaPlatform_Platform_Control_Interface, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[E_SrlNokiaPlatformControl_ControlInterfaces]*SrlNokiaPlatform_Platform_Control_Interface)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Interface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Interface", key)
	}

	t.Interface[key] = &SrlNokiaPlatform_Platform_Control_Interface{
		Name: Name,
	}

	return t.Interface[key], nil
}

// RenameInterface renames an entry in the list Interface within
// the SrlNokiaPlatform_Platform_Control struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaPlatform_Platform_Control) RenameInterface(
	oldK, newK E_SrlNokiaPlatformControl_ControlInterfaces,
) error {
	if _, ok := t.Interface[newK]; ok {
		return fmt.Errorf("key %v already exists in Interface", newK)
	}

	e, ok := t.Interface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Interface", oldK)
	}
	e.Name = newK

	t.Interface[newK] = e
	delete(t.Interface, oldK)
	return nil
}

// GetOrCreateInterface retrieves the value with the specified keys from
// the receiver SrlNokiaPlatform_Platform_Control. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaPlatform_Platform_Control) GetOrCreateInterface(
	Name E_SrlNokiaPlatformControl_ControlInterfaces,
) *SrlNokiaPlatform_Platform_Control_Interface {
	key := Name

	if v, ok := t.Interface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInterface(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInterface got unexpected error: %v", err))
	}
	return v
}

// GetInterface retrieves the value with the specified key from
// the Interface map field of SrlNokiaPlatform_Platform_Control. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaPlatform_Platform_Control) GetInterface(Name E_SrlNokiaPlatformControl_ControlInterfaces) *SrlNokiaPlatform_Platform_Control_Interface {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Interface[key]; ok {
		return lm
	}
	return nil
}

// DeleteInterface deletes the value with the specified keys from
// the receiver SrlNokiaPlatform_Platform_Control. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaPlatform_Platform_Control) DeleteInterface(Name E_SrlNokiaPlatformControl_ControlInterfaces) {
	key := Name

	delete(t.Interface, key)
}

// AppendInterface appends the supplied SrlNokiaPlatform_Platform_Control_Interface struct to the
// list Interface of SrlNokiaPlatform_Platform_Control. If the key value(s) specified in
// the supplied SrlNokiaPlatform_Platform_Control_Interface already exist in the list, an error is
// returned.
func (t *SrlNokiaPlatform_Platform_Control) AppendInterface(v *SrlNokiaPlatform_Platform_Control_Interface) error {
	key := v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[E_SrlNokiaPlatformControl_ControlInterfaces]*SrlNokiaPlatform_Platform_Control_Interface)
	}

	if _, ok := t.Interface[key]; ok {
		return fmt.Errorf("duplicate key for list Interface %v", key)
	}

	t.Interface[key] = v
	return nil
}

// GetSlot retrieves the value of the leaf Slot from the SrlNokiaPlatform_Platform_Control
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Slot is set, it can
// safely use t.GetSlot() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Slot == nil' before retrieving the leaf's value.
func (t *SrlNokiaPlatform_Platform_Control) GetSlot() string {
	if t == nil || t.Slot == nil {
		return ""
	}
	return *t.Slot
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaPlatform_Platform_Control
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaPlatform_Platform_Control) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Interface {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaPlatform_Platform_Control struct, which is a YANG list entry.
func (t *SrlNokiaPlatform_Platform_Control) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Slot == nil {
		return nil, fmt.Errorf("nil value for key Slot")
	}

	return map[string]interface{}{
		"slot": *t.Slot,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Control) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_Control"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Control) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_Control) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaPlatform_Platform_Control.
func (*SrlNokiaPlatform_Platform_Control) ΛBelongingModule() string {
	return "srl_nokia-platform-control"
}

// SrlNokiaPlatform_Platform_Control_Interface represents the /srl_nokia-platform/platform/control/interface YANG schema element.
type SrlNokiaPlatform_Platform_Control_Interface struct {
	AdminState E_SrlNokiaCommon_AdminState                 `path:"admin-state" module:"srl_nokia-platform-control"`
	Name       E_SrlNokiaPlatformControl_ControlInterfaces `path:"name" module:"srl_nokia-platform-control"`
}

// IsYANGGoStruct ensures that SrlNokiaPlatform_Platform_Control_Interface implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaPlatform_Platform_Control_Interface) IsYANGGoStruct() {}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaPlatform_Platform_Control_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaPlatform_Platform_Control_Interface) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return 0
	}
	return t.AdminState
}

// GetName retrieves the value of the leaf Name from the SrlNokiaPlatform_Platform_Control_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaPlatform_Platform_Control_Interface) GetName() E_SrlNokiaPlatformControl_ControlInterfaces {
	if t == nil || t.Name == 0 {
		return 0
	}
	return t.Name
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaPlatform_Platform_Control_Interface
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaPlatform_Platform_Control_Interface) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the SrlNokiaPlatform_Platform_Control_Interface struct, which is a YANG list entry.
func (t *SrlNokiaPlatform_Platform_Control_Interface) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"name": t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Control_Interface) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_Control_Interface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Control_Interface) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_Control_Interface) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaPlatform_Platform_Control_Interface.
func (*SrlNokiaPlatform_Platform_Control_Interface) ΛBelongingModule() string {
	return "srl_nokia-platform-control"
}

// SrlNokiaPlatform_Platform_Fabric represents the /srl_nokia-platform/platform/fabric YANG schema element.
type SrlNokiaPlatform_Platform_Fabric struct {
	AdminState E_SrlNokiaCommon_AdminState `path:"admin-state" module:"srl_nokia-platform-fabric"`
	Slot       *uint8                      `path:"slot" module:"srl_nokia-platform-fabric"`
}

// IsYANGGoStruct ensures that SrlNokiaPlatform_Platform_Fabric implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaPlatform_Platform_Fabric) IsYANGGoStruct() {}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaPlatform_Platform_Fabric
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaPlatform_Platform_Fabric) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_enable
	}
	return t.AdminState
}

// GetSlot retrieves the value of the leaf Slot from the SrlNokiaPlatform_Platform_Fabric
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Slot is set, it can
// safely use t.GetSlot() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Slot == nil' before retrieving the leaf's value.
func (t *SrlNokiaPlatform_Platform_Fabric) GetSlot() uint8 {
	if t == nil || t.Slot == nil {
		return 0
	}
	return *t.Slot
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaPlatform_Platform_Fabric
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaPlatform_Platform_Fabric) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_enable
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaPlatform_Platform_Fabric struct, which is a YANG list entry.
func (t *SrlNokiaPlatform_Platform_Fabric) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Slot == nil {
		return nil, fmt.Errorf("nil value for key Slot")
	}

	return map[string]interface{}{
		"slot": *t.Slot,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Fabric) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_Fabric"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Fabric) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_Fabric) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaPlatform_Platform_Fabric.
func (*SrlNokiaPlatform_Platform_Fabric) ΛBelongingModule() string {
	return "srl_nokia-platform-fabric"
}

// SrlNokiaPlatform_Platform_Linecard represents the /srl_nokia-platform/platform/linecard YANG schema element.
type SrlNokiaPlatform_Platform_Linecard struct {
	AdminState        E_SrlNokiaCommon_AdminState                                                                                           `path:"admin-state" module:"srl_nokia-platform-lc"`
	ForwardingComplex map[E_SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Name]*SrlNokiaPlatform_Platform_Linecard_ForwardingComplex `path:"forwarding-complex" module:"srl_nokia-platform-lc"`
	Slot              *uint8                                                                                                                `path:"slot" module:"srl_nokia-platform-lc"`
}

// IsYANGGoStruct ensures that SrlNokiaPlatform_Platform_Linecard implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaPlatform_Platform_Linecard) IsYANGGoStruct() {}

// NewForwardingComplex creates a new entry in the ForwardingComplex list of the
// SrlNokiaPlatform_Platform_Linecard struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaPlatform_Platform_Linecard) NewForwardingComplex(
	Name E_SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Name,
) (*SrlNokiaPlatform_Platform_Linecard_ForwardingComplex, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ForwardingComplex == nil {
		t.ForwardingComplex = make(map[E_SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Name]*SrlNokiaPlatform_Platform_Linecard_ForwardingComplex)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.ForwardingComplex[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list ForwardingComplex", key)
	}

	t.ForwardingComplex[key] = &SrlNokiaPlatform_Platform_Linecard_ForwardingComplex{
		Name: Name,
	}

	return t.ForwardingComplex[key], nil
}

// RenameForwardingComplex renames an entry in the list ForwardingComplex within
// the SrlNokiaPlatform_Platform_Linecard struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaPlatform_Platform_Linecard) RenameForwardingComplex(
	oldK, newK E_SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Name,
) error {
	if _, ok := t.ForwardingComplex[newK]; ok {
		return fmt.Errorf("key %v already exists in ForwardingComplex", newK)
	}

	e, ok := t.ForwardingComplex[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in ForwardingComplex", oldK)
	}
	e.Name = newK

	t.ForwardingComplex[newK] = e
	delete(t.ForwardingComplex, oldK)
	return nil
}

// GetOrCreateForwardingComplex retrieves the value with the specified keys from
// the receiver SrlNokiaPlatform_Platform_Linecard. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaPlatform_Platform_Linecard) GetOrCreateForwardingComplex(
	Name E_SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Name,
) *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex {
	key := Name

	if v, ok := t.ForwardingComplex[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewForwardingComplex(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateForwardingComplex got unexpected error: %v", err))
	}
	return v
}

// GetForwardingComplex retrieves the value with the specified key from
// the ForwardingComplex map field of SrlNokiaPlatform_Platform_Linecard. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaPlatform_Platform_Linecard) GetForwardingComplex(
	Name E_SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Name,
) *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.ForwardingComplex[key]; ok {
		return lm
	}
	return nil
}

// DeleteForwardingComplex deletes the value with the specified keys from
// the receiver SrlNokiaPlatform_Platform_Linecard. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaPlatform_Platform_Linecard) DeleteForwardingComplex(
	Name E_SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Name,
) {
	key := Name

	delete(t.ForwardingComplex, key)
}

// AppendForwardingComplex appends the supplied SrlNokiaPlatform_Platform_Linecard_ForwardingComplex struct to the
// list ForwardingComplex of SrlNokiaPlatform_Platform_Linecard. If the key value(s) specified in
// the supplied SrlNokiaPlatform_Platform_Linecard_ForwardingComplex already exist in the list, an error is
// returned.
func (t *SrlNokiaPlatform_Platform_Linecard) AppendForwardingComplex(
	v *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex,
) error {
	key := v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ForwardingComplex == nil {
		t.ForwardingComplex = make(map[E_SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Name]*SrlNokiaPlatform_Platform_Linecard_ForwardingComplex)
	}

	if _, ok := t.ForwardingComplex[key]; ok {
		return fmt.Errorf("duplicate key for list ForwardingComplex %v", key)
	}

	t.ForwardingComplex[key] = v
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaPlatform_Platform_Linecard
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaPlatform_Platform_Linecard) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_enable
	}
	return t.AdminState
}

// GetSlot retrieves the value of the leaf Slot from the SrlNokiaPlatform_Platform_Linecard
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Slot is set, it can
// safely use t.GetSlot() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Slot == nil' before retrieving the leaf's value.
func (t *SrlNokiaPlatform_Platform_Linecard) GetSlot() uint8 {
	if t == nil || t.Slot == nil {
		return 0
	}
	return *t.Slot
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaPlatform_Platform_Linecard
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaPlatform_Platform_Linecard) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_enable
	}
	for _, e := range t.ForwardingComplex {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaPlatform_Platform_Linecard struct, which is a YANG list entry.
func (t *SrlNokiaPlatform_Platform_Linecard) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Slot == nil {
		return nil, fmt.Errorf("nil value for key Slot")
	}

	return map[string]interface{}{
		"slot": *t.Slot,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Linecard) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_Linecard"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Linecard) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_Linecard) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaPlatform_Platform_Linecard.
func (*SrlNokiaPlatform_Platform_Linecard) ΛBelongingModule() string {
	return "srl_nokia-platform-lc"
}

// SrlNokiaPlatform_Platform_Linecard_ForwardingComplex represents the /srl_nokia-platform/platform/linecard/forwarding-complex YANG schema element.
type SrlNokiaPlatform_Platform_Linecard_ForwardingComplex struct {
	BufferMemory *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_BufferMemory                                                                           `path:"buffer-memory" module:"srl_nokia-platform-qos"`
	Fabric       *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Fabric                                                                                 `path:"fabric" module:"srl_nokia-platform-lc"`
	Name         E_SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Name                                                                                  `path:"name" module:"srl_nokia-platform-lc"`
	P4Rt         *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_P4Rt                                                                                   `path:"p4rt" module:"srl_nokia-platform-p4rt" yangPresence:"true"`
	Pipeline     map[SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Pipeline_Index_Union]*SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Pipeline `path:"pipeline" module:"srl_nokia-platform-lc"`
}

// IsYANGGoStruct ensures that SrlNokiaPlatform_Platform_Linecard_ForwardingComplex implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaPlatform_Platform_Linecard_ForwardingComplex) IsYANGGoStruct() {}

// NewPipeline creates a new entry in the Pipeline list of the
// SrlNokiaPlatform_Platform_Linecard_ForwardingComplex struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex) NewPipeline(
	Index SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Pipeline_Index_Union,
) (*SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Pipeline, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Pipeline == nil {
		t.Pipeline = make(map[SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Pipeline_Index_Union]*SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Pipeline)
	}

	key := Index

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Pipeline[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Pipeline", key)
	}

	t.Pipeline[key] = &SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Pipeline{
		Index: Index,
	}

	return t.Pipeline[key], nil
}

// RenamePipeline renames an entry in the list Pipeline within
// the SrlNokiaPlatform_Platform_Linecard_ForwardingComplex struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex) RenamePipeline(
	oldK, newK SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Pipeline_Index_Union,
) error {
	if _, ok := t.Pipeline[newK]; ok {
		return fmt.Errorf("key %v already exists in Pipeline", newK)
	}

	e, ok := t.Pipeline[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Pipeline", oldK)
	}
	e.Index = newK

	t.Pipeline[newK] = e
	delete(t.Pipeline, oldK)
	return nil
}

// GetOrCreatePipeline retrieves the value with the specified keys from
// the receiver SrlNokiaPlatform_Platform_Linecard_ForwardingComplex. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex) GetOrCreatePipeline(
	Index SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Pipeline_Index_Union,
) *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Pipeline {
	key := Index

	if v, ok := t.Pipeline[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPipeline(Index)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePipeline got unexpected error: %v", err))
	}
	return v
}

// GetPipeline retrieves the value with the specified key from
// the Pipeline map field of SrlNokiaPlatform_Platform_Linecard_ForwardingComplex. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex) GetPipeline(
	Index SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Pipeline_Index_Union,
) *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Pipeline {
	if t == nil {
		return nil
	}

	key := Index

	if lm, ok := t.Pipeline[key]; ok {
		return lm
	}
	return nil
}

// DeletePipeline deletes the value with the specified keys from
// the receiver SrlNokiaPlatform_Platform_Linecard_ForwardingComplex. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex) DeletePipeline(
	Index SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Pipeline_Index_Union,
) {
	key := Index

	delete(t.Pipeline, key)
}

// AppendPipeline appends the supplied SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Pipeline struct to the
// list Pipeline of SrlNokiaPlatform_Platform_Linecard_ForwardingComplex. If the key value(s) specified in
// the supplied SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Pipeline already exist in the list, an error is
// returned.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex) AppendPipeline(
	v *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Pipeline,
) error {
	key := v.Index

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Pipeline == nil {
		t.Pipeline = make(map[SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Pipeline_Index_Union]*SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Pipeline)
	}

	if _, ok := t.Pipeline[key]; ok {
		return fmt.Errorf("duplicate key for list Pipeline %v", key)
	}

	t.Pipeline[key] = v
	return nil
}

// GetOrCreateBufferMemory retrieves the value of the BufferMemory field
// or returns the existing field if it already exists.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex) GetOrCreateBufferMemory() *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_BufferMemory {
	if t.BufferMemory != nil {
		return t.BufferMemory
	}
	t.BufferMemory = &SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_BufferMemory{}
	return t.BufferMemory
}

// GetOrCreateFabric retrieves the value of the Fabric field
// or returns the existing field if it already exists.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex) GetOrCreateFabric() *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Fabric {
	if t.Fabric != nil {
		return t.Fabric
	}
	t.Fabric = &SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Fabric{}
	return t.Fabric
}

// GetOrCreateP4Rt retrieves the value of the P4Rt field
// or returns the existing field if it already exists.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex) GetOrCreateP4Rt() *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_P4Rt {
	if t.P4Rt != nil {
		return t.P4Rt
	}
	t.P4Rt = &SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_P4Rt{}
	return t.P4Rt
}

// GetBufferMemory returns the value of the BufferMemory struct pointer
// from SrlNokiaPlatform_Platform_Linecard_ForwardingComplex. If the receiver or the field BufferMemory is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex) GetBufferMemory() *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_BufferMemory {
	if t != nil && t.BufferMemory != nil {
		return t.BufferMemory
	}
	return nil
}

// GetFabric returns the value of the Fabric struct pointer
// from SrlNokiaPlatform_Platform_Linecard_ForwardingComplex. If the receiver or the field Fabric is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex) GetFabric() *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Fabric {
	if t != nil && t.Fabric != nil {
		return t.Fabric
	}
	return nil
}

// GetP4Rt returns the value of the P4Rt struct pointer
// from SrlNokiaPlatform_Platform_Linecard_ForwardingComplex. If the receiver or the field P4Rt is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex) GetP4Rt() *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_P4Rt {
	if t != nil && t.P4Rt != nil {
		return t.P4Rt
	}
	return nil
}

// GetName retrieves the value of the leaf Name from the SrlNokiaPlatform_Platform_Linecard_ForwardingComplex
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex) GetName() E_SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Name {
	if t == nil || t.Name == 0 {
		return 0
	}
	return t.Name
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaPlatform_Platform_Linecard_ForwardingComplex
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.BufferMemory.PopulateDefaults()
	t.Fabric.PopulateDefaults()
	t.P4Rt.PopulateDefaults()
	for _, e := range t.Pipeline {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaPlatform_Platform_Linecard_ForwardingComplex struct, which is a YANG list entry.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"name": t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_Linecard_ForwardingComplex"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaPlatform_Platform_Linecard_ForwardingComplex.
func (*SrlNokiaPlatform_Platform_Linecard_ForwardingComplex) ΛBelongingModule() string {
	return "srl_nokia-platform-lc"
}

// SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_BufferMemory represents the /srl_nokia-platform/platform/linecard/forwarding-complex/buffer-memory YANG schema element.
type SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_BufferMemory struct{}

// IsYANGGoStruct ensures that SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_BufferMemory implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_BufferMemory) IsYANGGoStruct() {}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_BufferMemory
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_BufferMemory) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_BufferMemory) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_BufferMemory"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_BufferMemory) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_BufferMemory) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_BufferMemory.
func (*SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_BufferMemory) ΛBelongingModule() string {
	return "srl_nokia-platform-qos"
}

// SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Fabric represents the /srl_nokia-platform/platform/linecard/forwarding-complex/fabric YANG schema element.
type SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Fabric struct{}

// IsYANGGoStruct ensures that SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Fabric implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Fabric) IsYANGGoStruct() {}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Fabric
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Fabric) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Fabric) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Fabric"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Fabric) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Fabric) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Fabric.
func (*SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Fabric) ΛBelongingModule() string {
	return "srl_nokia-platform-lc"
}

// SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_P4Rt represents the /srl_nokia-platform/platform/linecard/forwarding-complex/p4rt YANG schema element.
type SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_P4Rt struct {
	Id *uint64 `path:"id" module:"srl_nokia-platform-p4rt"`
}

// IsYANGGoStruct ensures that SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_P4Rt implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_P4Rt) IsYANGGoStruct() {}

// GetId retrieves the value of the leaf Id from the SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_P4Rt
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Id is set, it can
// safely use t.GetId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Id == nil' before retrieving the leaf's value.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_P4Rt) GetId() uint64 {
	if t == nil || t.Id == nil {
		return 0
	}
	return *t.Id
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_P4Rt
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_P4Rt) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_P4Rt) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_P4Rt"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_P4Rt) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_P4Rt) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_P4Rt.
func (*SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_P4Rt) ΛBelongingModule() string {
	return "srl_nokia-platform-p4rt"
}

// SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Pipeline represents the /srl_nokia-platform/platform/linecard/forwarding-complex/pipeline YANG schema element.
type SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Pipeline struct {
	Index SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Pipeline_Index_Union `path:"index" module:"srl_nokia-platform-lc"`
}

// IsYANGGoStruct ensures that SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Pipeline implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Pipeline) IsYANGGoStruct() {}

// GetIndex retrieves the value of the leaf Index from the SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Pipeline
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Index is set, it can
// safely use t.GetIndex() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Index == nil' before retrieving the leaf's value.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Pipeline) GetIndex() SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Pipeline_Index_Union {
	if t == nil || t.Index == nil {
		return nil
	}
	return t.Index
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Pipeline
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Pipeline) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Pipeline struct, which is a YANG list entry.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Pipeline) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"index": t.Index,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Pipeline) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Pipeline"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Pipeline) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Pipeline) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Pipeline.
func (*SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Pipeline) ΛBelongingModule() string {
	return "srl_nokia-platform-lc"
}

// SrlNokiaPlatform_Platform_Redundancy represents the /srl_nokia-platform/platform/redundancy YANG schema element.
type SrlNokiaPlatform_Platform_Redundancy struct {
	Synchronization *SrlNokiaPlatform_Platform_Redundancy_Synchronization `path:"synchronization" module:"srl_nokia-platform-redundancy"`
}

// IsYANGGoStruct ensures that SrlNokiaPlatform_Platform_Redundancy implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaPlatform_Platform_Redundancy) IsYANGGoStruct() {}

// GetOrCreateSynchronization retrieves the value of the Synchronization field
// or returns the existing field if it already exists.
func (t *SrlNokiaPlatform_Platform_Redundancy) GetOrCreateSynchronization() *SrlNokiaPlatform_Platform_Redundancy_Synchronization {
	if t.Synchronization != nil {
		return t.Synchronization
	}
	t.Synchronization = &SrlNokiaPlatform_Platform_Redundancy_Synchronization{}
	return t.Synchronization
}

// GetSynchronization returns the value of the Synchronization struct pointer
// from SrlNokiaPlatform_Platform_Redundancy. If the receiver or the field Synchronization is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaPlatform_Platform_Redundancy) GetSynchronization() *SrlNokiaPlatform_Platform_Redundancy_Synchronization {
	if t != nil && t.Synchronization != nil {
		return t.Synchronization
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaPlatform_Platform_Redundancy
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaPlatform_Platform_Redundancy) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Synchronization.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Redundancy) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_Redundancy"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Redundancy) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_Redundancy) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaPlatform_Platform_Redundancy.
func (*SrlNokiaPlatform_Platform_Redundancy) ΛBelongingModule() string {
	return "srl_nokia-platform-redundancy"
}

// SrlNokiaPlatform_Platform_Redundancy_Synchronization represents the /srl_nokia-platform/platform/redundancy/synchronization YANG schema element.
type SrlNokiaPlatform_Platform_Redundancy_Synchronization struct {
	Overlay *SrlNokiaPlatform_Platform_Redundancy_Synchronization_Overlay `path:"overlay" module:"srl_nokia-platform-redundancy"`
}

// IsYANGGoStruct ensures that SrlNokiaPlatform_Platform_Redundancy_Synchronization implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaPlatform_Platform_Redundancy_Synchronization) IsYANGGoStruct() {}

// GetOrCreateOverlay retrieves the value of the Overlay field
// or returns the existing field if it already exists.
func (t *SrlNokiaPlatform_Platform_Redundancy_Synchronization) GetOrCreateOverlay() *SrlNokiaPlatform_Platform_Redundancy_Synchronization_Overlay {
	if t.Overlay != nil {
		return t.Overlay
	}
	t.Overlay = &SrlNokiaPlatform_Platform_Redundancy_Synchronization_Overlay{}
	return t.Overlay
}

// GetOverlay returns the value of the Overlay struct pointer
// from SrlNokiaPlatform_Platform_Redundancy_Synchronization. If the receiver or the field Overlay is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaPlatform_Platform_Redundancy_Synchronization) GetOverlay() *SrlNokiaPlatform_Platform_Redundancy_Synchronization_Overlay {
	if t != nil && t.Overlay != nil {
		return t.Overlay
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaPlatform_Platform_Redundancy_Synchronization
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaPlatform_Platform_Redundancy_Synchronization) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Overlay.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Redundancy_Synchronization) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_Redundancy_Synchronization"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Redundancy_Synchronization) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_Redundancy_Synchronization) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaPlatform_Platform_Redundancy_Synchronization.
func (*SrlNokiaPlatform_Platform_Redundancy_Synchronization) ΛBelongingModule() string {
	return "srl_nokia-platform-redundancy"
}

// SrlNokiaPlatform_Platform_Redundancy_Synchronization_Overlay represents the /srl_nokia-platform/platform/redundancy/synchronization/overlay YANG schema element.
type SrlNokiaPlatform_Platform_Redundancy_Synchronization_Overlay struct {
	SynchronizationFrequency *uint32 `path:"synchronization-frequency" module:"srl_nokia-platform-redundancy"`
}

// IsYANGGoStruct ensures that SrlNokiaPlatform_Platform_Redundancy_Synchronization_Overlay implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaPlatform_Platform_Redundancy_Synchronization_Overlay) IsYANGGoStruct() {}

// GetSynchronizationFrequency retrieves the value of the leaf SynchronizationFrequency from the SrlNokiaPlatform_Platform_Redundancy_Synchronization_Overlay
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SynchronizationFrequency is set, it can
// safely use t.GetSynchronizationFrequency() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SynchronizationFrequency == nil' before retrieving the leaf's value.
func (t *SrlNokiaPlatform_Platform_Redundancy_Synchronization_Overlay) GetSynchronizationFrequency() uint32 {
	if t == nil || t.SynchronizationFrequency == nil {
		return 60
	}
	return *t.SynchronizationFrequency
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaPlatform_Platform_Redundancy_Synchronization_Overlay
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaPlatform_Platform_Redundancy_Synchronization_Overlay) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.SynchronizationFrequency == nil {
		var v uint32 = 60
		t.SynchronizationFrequency = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Redundancy_Synchronization_Overlay) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_Redundancy_Synchronization_Overlay"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Redundancy_Synchronization_Overlay) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_Redundancy_Synchronization_Overlay) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaPlatform_Platform_Redundancy_Synchronization_Overlay.
func (*SrlNokiaPlatform_Platform_Redundancy_Synchronization_Overlay) ΛBelongingModule() string {
	return "srl_nokia-platform-redundancy"
}
