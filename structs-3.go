/*
Package ygotsrl is a generated package which contains definitions
of structs which represent a YANG schema. The generated schema can be
compressed by a series of transformations (compression was false
in this case).

This package was generated by /home/hans/go/pkg/mod/github.com/openconfig/ygot@v0.29.17/genutil/names.go
using the following YANG input files:
	- work/srlinux-yang-models/srl_nokia/models/acl/srl_nokia-acl-policers.yang
	- work/srlinux-yang-models/srl_nokia/models/acl/srl_nokia-acl-qos.yang
	- work/srlinux-yang-models/srl_nokia/models/acl/srl_nokia-acl.yang
	- work/srlinux-yang-models/srl_nokia/models/acl/srl_nokia-packet-match-types.yang
	- work/srlinux-yang-models/srl_nokia/models/bfd/srl_nokia-bfd.yang
	- work/srlinux-yang-models/srl_nokia/models/bfd/srl_nokia-micro-bfd.yang
	- work/srlinux-yang-models/srl_nokia/models/common/srl_nokia-common.yang
	- work/srlinux-yang-models/srl_nokia/models/common/srl_nokia-extensions.yang
	- work/srlinux-yang-models/srl_nokia/models/common/srl_nokia-features.yang
	- work/srlinux-yang-models/srl_nokia/models/ethcfm/srl_nokia-ethcfm-types.yang
	- work/srlinux-yang-models/srl_nokia/models/ethcfm/srl_nokia-ethcfm.yang
	- work/srlinux-yang-models/srl_nokia/models/ethcfm/srl_nokia-oam-pm-ethcfm.yang
	- work/srlinux-yang-models/srl_nokia/models/grpc/srl_nokia-gnsi-authz.yang
	- work/srlinux-yang-models/srl_nokia/models/grpc/srl_nokia-gnsi-certz.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-if-ip.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-if-mpls.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-bridge-table-mac-duplication-entries.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-bridge-table-mac-learning-entries.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-bridge-table-mac-table.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-bridge-table-statistics.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-bridge-table.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-ethernet-segment-association.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-ip-dhcp-relay.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-ip-dhcp-server.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-ip-dhcp.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-ip-vrrp.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-l2cp.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-lag.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-local-mirror-destination.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-nbr-evpn.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-nbr-virtual-ip-discovery.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-nbr.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-p4rt.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-router-adv.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-vlans.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-vxdp.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-lacp.yang
	- work/srlinux-yang-models/srl_nokia/models/ipamps/srl_nokia-ippm-source-udp-pool.yang
	- work/srlinux-yang-models/srl_nokia/models/ipamps/srl_nokia-link-measurement.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-aggregate-routes.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bgp-evpn-bgp-instance-mpls-bridge-table-multicast-destinations.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bgp-evpn-bgp-instance-mpls-bridge-table-statistics.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bgp-evpn-bgp-instance-mpls-bridge-table-unicast-destinations.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bgp-evpn-bgp-instance-mpls-vpws-destinations.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bgp-evpn.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bgp-ipvpn.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bgp-vpn.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bgp.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table-mac-duplication-entries.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table-mac-duplication.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table-mac-learning-entries.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table-mac-learning.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table-mac-limit.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table-mac-table.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table-proxy-arp-nd.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table-reserved-macs.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table-shg.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table-static-mac.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-connection-point.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-icmp.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-igmp-snooping.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-igmp-types.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-igmp.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-ip-route-tables.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-isis-lsdb-types.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-isis-lsdb.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-isis.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-ldp.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-linux.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-maintenance-policies.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-mld-snooping.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-mld.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-mpls-route-tables.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-mpls.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-multicast-mfib-tables.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-mvpn-l3.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-network-instance-mtu.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-network-instance.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-next-hop-groups.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-ospf-lsdb.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-ospf-types.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-ospf.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-ospfv3-lsas.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-pcep.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-pim.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-policy-forwarding.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-rib-bgp.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-segment-routing.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-static-routes.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-tcp-udp.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-te-policies.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-traffic-engineering.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-tunnel-tables.yang
	- work/srlinux-yang-models/srl_nokia/models/oam/srl_nokia-lsp-ping-trace.yang
	- work/srlinux-yang-models/srl_nokia/models/oam/srl_nokia-oam-pm-ip.yang
	- work/srlinux-yang-models/srl_nokia/models/oam/srl_nokia-oam-pm-types.yang
	- work/srlinux-yang-models/srl_nokia/models/oam/srl_nokia-oam-pm.yang
	- work/srlinux-yang-models/srl_nokia/models/oam/srl_nokia-oam.yang
	- work/srlinux-yang-models/srl_nokia/models/oam/srl_nokia-stamp.yang
	- work/srlinux-yang-models/srl_nokia/models/oam/srl_nokia-twamp.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-acl.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-cgroup.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-chassis.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-control.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-cpu.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-datapath-resources.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-disk.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-fabric.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-fan.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-healthz.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-lc.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-linecard-fib.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-memory.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-mtu.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-p4rt.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-pipeline-counters.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-psu.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-qos.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-redundancy.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-resource-mgmt.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-resource-monitoring.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-secure-boot.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-tcam.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-tpm.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-vxdp.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform.yang
	- work/srlinux-yang-models/srl_nokia/models/qos/srl_nokia-qos-policers.yang
	- work/srlinux-yang-models/srl_nokia/models/qos/srl_nokia-qos.yang
	- work/srlinux-yang-models/srl_nokia/models/routing-policy/srl_nokia-policy-types.yang
	- work/srlinux-yang-models/srl_nokia/models/routing-policy/srl_nokia-routing-policy.yang
	- work/srlinux-yang-models/srl_nokia/models/sync/srl_nokia-sync-freq.yang
	- work/srlinux-yang-models/srl_nokia/models/sync/srl_nokia-sync-interfaces.yang
	- work/srlinux-yang-models/srl_nokia/models/sync/srl_nokia-sync-ptp.yang
	- work/srlinux-yang-models/srl_nokia/models/sync/srl_nokia-sync-types.yang
	- work/srlinux-yang-models/srl_nokia/models/sync/srl_nokia-sync.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-aaa-password.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-aaa-radius.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-aaa-tacacs.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-aaa-types.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-aaa.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-app-mgmt.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-boot.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-configuration-role.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-configuration.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-dhcp-server.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-dns.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-event-handler.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-ftp.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-gnmi-server.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-gribi-server.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-json-rpc.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-keychains.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-license.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-lldp-types.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-lldp.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-load-balancing.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-logging.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-maintenance-mode.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-mirroring.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-mpls-label-management.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-mpls-services-evpn-label-management.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-mpls-services-network-instance-label-management.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-mtu.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-ntp.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-openconfig.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-p4rt-server.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-packet-link-qual.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-ra_guard.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-sflow.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-snmp-trace.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-snmp.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-ssh.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system-banner.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system-bridge-table-proxy-arp.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system-bridge-table.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system-info.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system-multicast-mfib-table.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system-multicast.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system-name.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system-network-instance-bgp-evpn-ethernet-segments.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system-network-instance-bgp-vpn.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system-network-instance.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system-protocols.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-timezone.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-tls.yang
	- work/srlinux-yang-models/srl_nokia/models/transport-security/srl_nokia-macsec.yang
	- work/srlinux-yang-models/srl_nokia/models/transport-security/srl_nokia-transport-security.yang
	- work/srlinux-yang-models/srl_nokia/models/tunnel/srl_nokia-tunnel-interfaces-vxlan-interface-bridge-table-multicast-destinations.yang
	- work/srlinux-yang-models/srl_nokia/models/tunnel/srl_nokia-tunnel-interfaces-vxlan-interface-bridge-table-unicast-destinations.yang
	- work/srlinux-yang-models/srl_nokia/models/tunnel/srl_nokia-tunnel-interfaces-vxlan-interface-bridge-table-unicast-es-destination-vteps.yang
	- work/srlinux-yang-models/srl_nokia/models/tunnel/srl_nokia-tunnel-interfaces-vxlan-interface-bridge-table.yang
	- work/srlinux-yang-models/srl_nokia/models/tunnel/srl_nokia-tunnel-interfaces.yang
	- work/srlinux-yang-models/srl_nokia/models/tunnel/srl_nokia-tunnel.yang
	- work/srlinux-yang-models/srl_nokia/models/tunnel/srl_nokia-vxlan-tunnel-vtep.yang
Imported modules were sourced from:
	- work/srlinux-yang-models/...
*/
package ygotsrl

import (
	"fmt"
	"reflect"

	"github.com/openconfig/ygot/ygot"
	"github.com/openconfig/ygot/ytypes"
)

// SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Neighbor represents the /srl_nokia-interfaces/interface/subinterface/ipv4/arp/neighbor YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Neighbor struct {
	Ipv4Address      *string `path:"ipv4-address" module:"srl_nokia-interfaces-nbr"`
	LinkLayerAddress *string `path:"link-layer-address" module:"srl_nokia-interfaces-nbr"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Neighbor implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Neighbor) IsYANGGoStruct() {}

// GetIpv4Address retrieves the value of the leaf Ipv4Address from the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ipv4Address is set, it can
// safely use t.GetIpv4Address() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ipv4Address == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Neighbor) GetIpv4Address() string {
	if t == nil || t.Ipv4Address == nil {
		return ""
	}
	return *t.Ipv4Address
}

// GetLinkLayerAddress retrieves the value of the leaf LinkLayerAddress from the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LinkLayerAddress is set, it can
// safely use t.GetLinkLayerAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LinkLayerAddress == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Neighbor) GetLinkLayerAddress() string {
	if t == nil || t.LinkLayerAddress == nil {
		return ""
	}
	return *t.LinkLayerAddress
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Neighbor
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Neighbor) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Neighbor struct, which is a YANG list entry.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Neighbor) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Ipv4Address == nil {
		return nil, fmt.Errorf("nil value for key Ipv4Address")
	}

	return map[string]interface{}{
		"ipv4-address": *t.Ipv4Address,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Neighbor) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Neighbor"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Neighbor) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Neighbor) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Neighbor.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Neighbor) ΛBelongingModule() string {
	return "srl_nokia-interfaces-nbr"
}

// SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery represents the /srl_nokia-interfaces/interface/subinterface/ipv4/arp/virtual-ipv4-discovery YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery struct {
	Address map[string]*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery_Address `path:"address" module:"srl_nokia-interfaces-nbr-virtual-ip-discovery"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery) IsYANGGoStruct() {}

// NewAddress creates a new entry in the Address list of the
// SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery) NewAddress(
	Ipv4Address string,
) (*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery_Address, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Address == nil {
		t.Address = make(map[string]*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery_Address)
	}

	key := Ipv4Address

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Address[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Address", key)
	}

	t.Address[key] = &SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery_Address{
		Ipv4Address: &Ipv4Address,
	}

	return t.Address[key], nil
}

// RenameAddress renames an entry in the list Address within
// the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery) RenameAddress(oldK, newK string) error {
	if _, ok := t.Address[newK]; ok {
		return fmt.Errorf("key %v already exists in Address", newK)
	}

	e, ok := t.Address[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Address", oldK)
	}
	e.Ipv4Address = &newK

	t.Address[newK] = e
	delete(t.Address, oldK)
	return nil
}

// GetOrCreateAddress retrieves the value with the specified keys from
// the receiver SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery) GetOrCreateAddress(
	Ipv4Address string,
) *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery_Address {
	key := Ipv4Address

	if v, ok := t.Address[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAddress(Ipv4Address)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAddress got unexpected error: %v", err))
	}
	return v
}

// GetAddress retrieves the value with the specified key from
// the Address map field of SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery) GetAddress(
	Ipv4Address string,
) *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery_Address {
	if t == nil {
		return nil
	}

	key := Ipv4Address

	if lm, ok := t.Address[key]; ok {
		return lm
	}
	return nil
}

// DeleteAddress deletes the value with the specified keys from
// the receiver SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery) DeleteAddress(Ipv4Address string) {
	key := Ipv4Address

	delete(t.Address, key)
}

// AppendAddress appends the supplied SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery_Address struct to the
// list Address of SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery. If the key value(s) specified in
// the supplied SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery_Address already exist in the list, an error is
// returned.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery) AppendAddress(
	v *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery_Address,
) error {
	if v.Ipv4Address == nil {
		return fmt.Errorf("invalid nil key received for Ipv4Address")
	}

	key := *v.Ipv4Address

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Address == nil {
		t.Address = make(map[string]*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery_Address)
	}

	if _, ok := t.Address[key]; ok {
		return fmt.Errorf("duplicate key for list Address %v", key)
	}

	t.Address[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Address {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery) ΛBelongingModule() string {
	return "srl_nokia-interfaces-nbr-virtual-ip-discovery"
}

// SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery_Address represents the /srl_nokia-interfaces/interface/subinterface/ipv4/arp/virtual-ipv4-discovery/address YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery_Address struct {
	AllowedMacs               []string `path:"allowed-macs" module:"srl_nokia-interfaces-nbr-virtual-ip-discovery"`
	Ipv4Address               *string  `path:"ipv4-address" module:"srl_nokia-interfaces-nbr-virtual-ip-discovery"`
	ProbeBridgedSubinterfaces []string `path:"probe-bridged-subinterfaces" module:"srl_nokia-interfaces-nbr-virtual-ip-discovery"`
	ProbeInterval             *uint32  `path:"probe-interval" module:"srl_nokia-interfaces-nbr-virtual-ip-discovery"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery_Address implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery_Address) IsYANGGoStruct() {
}

// GetAllowedMacs retrieves the value of the leaf AllowedMacs from the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery_Address
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AllowedMacs is set, it can
// safely use t.GetAllowedMacs() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AllowedMacs == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery_Address) GetAllowedMacs() []string {
	if t == nil || t.AllowedMacs == nil {
		return nil
	}
	return t.AllowedMacs
}

// GetIpv4Address retrieves the value of the leaf Ipv4Address from the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery_Address
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ipv4Address is set, it can
// safely use t.GetIpv4Address() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ipv4Address == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery_Address) GetIpv4Address() string {
	if t == nil || t.Ipv4Address == nil {
		return ""
	}
	return *t.Ipv4Address
}

// GetProbeBridgedSubinterfaces retrieves the value of the leaf ProbeBridgedSubinterfaces from the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery_Address
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ProbeBridgedSubinterfaces is set, it can
// safely use t.GetProbeBridgedSubinterfaces() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ProbeBridgedSubinterfaces == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery_Address) GetProbeBridgedSubinterfaces() []string {
	if t == nil || t.ProbeBridgedSubinterfaces == nil {
		return nil
	}
	return t.ProbeBridgedSubinterfaces
}

// GetProbeInterval retrieves the value of the leaf ProbeInterval from the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery_Address
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ProbeInterval is set, it can
// safely use t.GetProbeInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ProbeInterval == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery_Address) GetProbeInterval() uint32 {
	if t == nil || t.ProbeInterval == nil {
		return 0
	}
	return *t.ProbeInterval
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery_Address
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery_Address) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.ProbeInterval == nil {
		var v uint32 = 0
		t.ProbeInterval = &v
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery_Address struct, which is a YANG list entry.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery_Address) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Ipv4Address == nil {
		return nil, fmt.Errorf("nil value for key Ipv4Address")
	}

	return map[string]interface{}{
		"ipv4-address": *t.Ipv4Address,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery_Address) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery_Address"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery_Address) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery_Address) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery_Address.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery_Address) ΛBelongingModule() string {
	return "srl_nokia-interfaces-nbr-virtual-ip-discovery"
}

// SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpClient represents the /srl_nokia-interfaces/interface/subinterface/ipv4/dhcp-client YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpClient struct {
	TraceOptions *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpClient_TraceOptions `path:"trace-options" module:"srl_nokia-interfaces-ip-dhcp"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpClient implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpClient) IsYANGGoStruct() {}

// GetOrCreateTraceOptions retrieves the value of the TraceOptions field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpClient) GetOrCreateTraceOptions() *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpClient_TraceOptions {
	if t.TraceOptions != nil {
		return t.TraceOptions
	}
	t.TraceOptions = &SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpClient_TraceOptions{}
	return t.TraceOptions
}

// GetTraceOptions returns the value of the TraceOptions struct pointer
// from SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpClient. If the receiver or the field TraceOptions is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpClient) GetTraceOptions() *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpClient_TraceOptions {
	if t != nil && t.TraceOptions != nil {
		return t.TraceOptions
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpClient
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpClient) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.TraceOptions.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpClient) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpClient"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpClient) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpClient) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpClient.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpClient) ΛBelongingModule() string {
	return "srl_nokia-interfaces-ip-dhcp"
}

// SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpClient_TraceOptions represents the /srl_nokia-interfaces/interface/subinterface/ipv4/dhcp-client/trace-options YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpClient_TraceOptions struct {
	Trace []E_SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpClient_TraceOptions_Trace `path:"trace" module:"srl_nokia-interfaces-ip-dhcp"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpClient_TraceOptions implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpClient_TraceOptions) IsYANGGoStruct() {}

// GetTrace retrieves the value of the leaf Trace from the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpClient_TraceOptions
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Trace is set, it can
// safely use t.GetTrace() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Trace == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpClient_TraceOptions) GetTrace() []E_SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpClient_TraceOptions_Trace {
	if t == nil || t.Trace == nil {
		return nil
	}
	return t.Trace
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpClient_TraceOptions
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpClient_TraceOptions) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpClient_TraceOptions) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpClient_TraceOptions"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpClient_TraceOptions) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpClient_TraceOptions) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpClient_TraceOptions.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpClient_TraceOptions) ΛBelongingModule() string {
	return "srl_nokia-interfaces-ip-dhcp"
}

// SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpRelay represents the /srl_nokia-interfaces/interface/subinterface/ipv4/dhcp-relay YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpRelay struct {
	AdminState           E_SrlNokiaCommon_AdminState                                            `path:"admin-state" module:"srl_nokia-interfaces-ip-dhcp-relay"`
	GiAddress            *string                                                                `path:"gi-address" module:"srl_nokia-interfaces-ip-dhcp-relay"`
	NetworkInstance      *string                                                                `path:"network-instance" module:"srl_nokia-interfaces-ip-dhcp-relay"`
	Option               []E_SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpRelay_Option    `path:"option" module:"srl_nokia-interfaces-ip-dhcp-relay"`
	Server               []string                                                               `path:"server" module:"srl_nokia-interfaces-ip-dhcp-relay"`
	TraceOptions         *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpRelay_TraceOptions `path:"trace-options" module:"srl_nokia-interfaces-ip-dhcp-relay"`
	UseGiAddrAsSrcIpAddr *bool                                                                  `path:"use-gi-addr-as-src-ip-addr" module:"srl_nokia-interfaces-ip-dhcp-relay"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpRelay implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpRelay) IsYANGGoStruct() {}

// GetOrCreateTraceOptions retrieves the value of the TraceOptions field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpRelay) GetOrCreateTraceOptions() *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpRelay_TraceOptions {
	if t.TraceOptions != nil {
		return t.TraceOptions
	}
	t.TraceOptions = &SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpRelay_TraceOptions{}
	return t.TraceOptions
}

// GetTraceOptions returns the value of the TraceOptions struct pointer
// from SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpRelay. If the receiver or the field TraceOptions is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpRelay) GetTraceOptions() *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpRelay_TraceOptions {
	if t != nil && t.TraceOptions != nil {
		return t.TraceOptions
	}
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpRelay
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpRelay) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_enable
	}
	return t.AdminState
}

// GetGiAddress retrieves the value of the leaf GiAddress from the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpRelay
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if GiAddress is set, it can
// safely use t.GetGiAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.GiAddress == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpRelay) GetGiAddress() string {
	if t == nil || t.GiAddress == nil {
		return ""
	}
	return *t.GiAddress
}

// GetNetworkInstance retrieves the value of the leaf NetworkInstance from the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpRelay
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NetworkInstance is set, it can
// safely use t.GetNetworkInstance() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NetworkInstance == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpRelay) GetNetworkInstance() string {
	if t == nil || t.NetworkInstance == nil {
		return ""
	}
	return *t.NetworkInstance
}

// GetOption retrieves the value of the leaf Option from the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpRelay
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Option is set, it can
// safely use t.GetOption() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Option == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpRelay) GetOption() []E_SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpRelay_Option {
	if t == nil || t.Option == nil {
		return nil
	}
	return t.Option
}

// GetServer retrieves the value of the leaf Server from the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpRelay
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Server is set, it can
// safely use t.GetServer() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Server == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpRelay) GetServer() []string {
	if t == nil || t.Server == nil {
		return nil
	}
	return t.Server
}

// GetUseGiAddrAsSrcIpAddr retrieves the value of the leaf UseGiAddrAsSrcIpAddr from the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpRelay
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if UseGiAddrAsSrcIpAddr is set, it can
// safely use t.GetUseGiAddrAsSrcIpAddr() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.UseGiAddrAsSrcIpAddr == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpRelay) GetUseGiAddrAsSrcIpAddr() bool {
	if t == nil || t.UseGiAddrAsSrcIpAddr == nil {
		return false
	}
	return *t.UseGiAddrAsSrcIpAddr
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpRelay
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpRelay) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_enable
	}
	if t.UseGiAddrAsSrcIpAddr == nil {
		var v bool = false
		t.UseGiAddrAsSrcIpAddr = &v
	}
	t.TraceOptions.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpRelay) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpRelay"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpRelay) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpRelay) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpRelay.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpRelay) ΛBelongingModule() string {
	return "srl_nokia-interfaces-ip-dhcp-relay"
}

// SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpRelay_TraceOptions represents the /srl_nokia-interfaces/interface/subinterface/ipv4/dhcp-relay/trace-options YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpRelay_TraceOptions struct {
	Trace []E_SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpRelay_TraceOptions_Trace `path:"trace" module:"srl_nokia-interfaces-ip-dhcp-relay"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpRelay_TraceOptions implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpRelay_TraceOptions) IsYANGGoStruct() {}

// GetTrace retrieves the value of the leaf Trace from the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpRelay_TraceOptions
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Trace is set, it can
// safely use t.GetTrace() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Trace == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpRelay_TraceOptions) GetTrace() []E_SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpRelay_TraceOptions_Trace {
	if t == nil || t.Trace == nil {
		return nil
	}
	return t.Trace
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpRelay_TraceOptions
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpRelay_TraceOptions) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpRelay_TraceOptions) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpRelay_TraceOptions"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpRelay_TraceOptions) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpRelay_TraceOptions) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpRelay_TraceOptions.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpRelay_TraceOptions) ΛBelongingModule() string {
	return "srl_nokia-interfaces-ip-dhcp-relay"
}

// SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpServer represents the /srl_nokia-interfaces/interface/subinterface/ipv4/dhcp-server YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpServer struct {
	AdminState E_SrlNokiaCommon_AdminState `path:"admin-state" module:"srl_nokia-interfaces-ip-dhcp-server"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpServer implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpServer) IsYANGGoStruct() {}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpServer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpServer) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_disable
	}
	return t.AdminState
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpServer
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpServer) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_disable
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpServer) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpServer"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpServer) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpServer) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpServer.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpServer) ΛBelongingModule() string {
	return "srl_nokia-interfaces-ip-dhcp-server"
}

// SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Unnumbered represents the /srl_nokia-interfaces/interface/subinterface/ipv4/unnumbered YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Unnumbered struct {
	AdminState E_SrlNokiaCommon_AdminState `path:"admin-state" module:"srl_nokia-interfaces"`
	Interface  *string                     `path:"interface" module:"srl_nokia-interfaces"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Unnumbered implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Unnumbered) IsYANGGoStruct() {}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Unnumbered
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Unnumbered) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_disable
	}
	return t.AdminState
}

// GetInterface retrieves the value of the leaf Interface from the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Unnumbered
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interface is set, it can
// safely use t.GetInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interface == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Unnumbered) GetInterface() string {
	if t == nil || t.Interface == nil {
		return ""
	}
	return *t.Interface
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Unnumbered
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Unnumbered) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_disable
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Unnumbered) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Unnumbered"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Unnumbered) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Unnumbered) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Unnumbered.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Unnumbered) ΛBelongingModule() string {
	return "srl_nokia-interfaces"
}

// SrlNokiaInterfaces_Interface_Subinterface_Ipv6 represents the /srl_nokia-interfaces/interface/subinterface/ipv6 YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_Ipv6 struct {
	Address             map[string]*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address  `path:"address" module:"srl_nokia-interfaces"`
	AdminState          E_SrlNokiaCommon_AdminState                                         `path:"admin-state" module:"srl_nokia-interfaces"`
	DhcpClient          *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpClient          `path:"dhcp-client" module:"srl_nokia-interfaces-ip-dhcp" yangPresence:"true"`
	DhcpRelay           *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpRelay           `path:"dhcp-relay" module:"srl_nokia-interfaces-ip-dhcp-relay" yangPresence:"true"`
	Dhcpv6Server        *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Dhcpv6Server        `path:"dhcpv6-server" module:"srl_nokia-interfaces-ip-dhcp-server" yangPresence:"true"`
	NeighborDiscovery   *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery   `path:"neighbor-discovery" module:"srl_nokia-interfaces-nbr"`
	RouterAdvertisement *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement `path:"router-advertisement" module:"srl_nokia-interfaces-router-adv"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_Ipv6 implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv6) IsYANGGoStruct() {}

// NewAddress creates a new entry in the Address list of the
// SrlNokiaInterfaces_Interface_Subinterface_Ipv6 struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6) NewAddress(IpPrefix string) (*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Address == nil {
		t.Address = make(map[string]*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address)
	}

	key := IpPrefix

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Address[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Address", key)
	}

	t.Address[key] = &SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address{
		IpPrefix: &IpPrefix,
	}

	return t.Address[key], nil
}

// RenameAddress renames an entry in the list Address within
// the SrlNokiaInterfaces_Interface_Subinterface_Ipv6 struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6) RenameAddress(oldK, newK string) error {
	if _, ok := t.Address[newK]; ok {
		return fmt.Errorf("key %v already exists in Address", newK)
	}

	e, ok := t.Address[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Address", oldK)
	}
	e.IpPrefix = &newK

	t.Address[newK] = e
	delete(t.Address, oldK)
	return nil
}

// GetOrCreateAddress retrieves the value with the specified keys from
// the receiver SrlNokiaInterfaces_Interface_Subinterface_Ipv6. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6) GetOrCreateAddress(IpPrefix string) *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address {
	key := IpPrefix

	if v, ok := t.Address[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAddress(IpPrefix)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAddress got unexpected error: %v", err))
	}
	return v
}

// GetAddress retrieves the value with the specified key from
// the Address map field of SrlNokiaInterfaces_Interface_Subinterface_Ipv6. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6) GetAddress(IpPrefix string) *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address {
	if t == nil {
		return nil
	}

	key := IpPrefix

	if lm, ok := t.Address[key]; ok {
		return lm
	}
	return nil
}

// DeleteAddress deletes the value with the specified keys from
// the receiver SrlNokiaInterfaces_Interface_Subinterface_Ipv6. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6) DeleteAddress(IpPrefix string) {
	key := IpPrefix

	delete(t.Address, key)
}

// AppendAddress appends the supplied SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address struct to the
// list Address of SrlNokiaInterfaces_Interface_Subinterface_Ipv6. If the key value(s) specified in
// the supplied SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address already exist in the list, an error is
// returned.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6) AppendAddress(
	v *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address,
) error {
	if v.IpPrefix == nil {
		return fmt.Errorf("invalid nil key received for IpPrefix")
	}

	key := *v.IpPrefix

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Address == nil {
		t.Address = make(map[string]*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address)
	}

	if _, ok := t.Address[key]; ok {
		return fmt.Errorf("duplicate key for list Address %v", key)
	}

	t.Address[key] = v
	return nil
}

// GetOrCreateDhcpClient retrieves the value of the DhcpClient field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6) GetOrCreateDhcpClient() *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpClient {
	if t.DhcpClient != nil {
		return t.DhcpClient
	}
	t.DhcpClient = &SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpClient{}
	return t.DhcpClient
}

// GetOrCreateDhcpRelay retrieves the value of the DhcpRelay field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6) GetOrCreateDhcpRelay() *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpRelay {
	if t.DhcpRelay != nil {
		return t.DhcpRelay
	}
	t.DhcpRelay = &SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpRelay{}
	return t.DhcpRelay
}

// GetOrCreateDhcpv6Server retrieves the value of the Dhcpv6Server field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6) GetOrCreateDhcpv6Server() *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Dhcpv6Server {
	if t.Dhcpv6Server != nil {
		return t.Dhcpv6Server
	}
	t.Dhcpv6Server = &SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Dhcpv6Server{}
	return t.Dhcpv6Server
}

// GetOrCreateNeighborDiscovery retrieves the value of the NeighborDiscovery field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6) GetOrCreateNeighborDiscovery() *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery {
	if t.NeighborDiscovery != nil {
		return t.NeighborDiscovery
	}
	t.NeighborDiscovery = &SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery{}
	return t.NeighborDiscovery
}

// GetOrCreateRouterAdvertisement retrieves the value of the RouterAdvertisement field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6) GetOrCreateRouterAdvertisement() *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement {
	if t.RouterAdvertisement != nil {
		return t.RouterAdvertisement
	}
	t.RouterAdvertisement = &SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement{}
	return t.RouterAdvertisement
}

// GetDhcpClient returns the value of the DhcpClient struct pointer
// from SrlNokiaInterfaces_Interface_Subinterface_Ipv6. If the receiver or the field DhcpClient is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6) GetDhcpClient() *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpClient {
	if t != nil && t.DhcpClient != nil {
		return t.DhcpClient
	}
	return nil
}

// GetDhcpRelay returns the value of the DhcpRelay struct pointer
// from SrlNokiaInterfaces_Interface_Subinterface_Ipv6. If the receiver or the field DhcpRelay is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6) GetDhcpRelay() *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpRelay {
	if t != nil && t.DhcpRelay != nil {
		return t.DhcpRelay
	}
	return nil
}

// GetDhcpv6Server returns the value of the Dhcpv6Server struct pointer
// from SrlNokiaInterfaces_Interface_Subinterface_Ipv6. If the receiver or the field Dhcpv6Server is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6) GetDhcpv6Server() *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Dhcpv6Server {
	if t != nil && t.Dhcpv6Server != nil {
		return t.Dhcpv6Server
	}
	return nil
}

// GetNeighborDiscovery returns the value of the NeighborDiscovery struct pointer
// from SrlNokiaInterfaces_Interface_Subinterface_Ipv6. If the receiver or the field NeighborDiscovery is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6) GetNeighborDiscovery() *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery {
	if t != nil && t.NeighborDiscovery != nil {
		return t.NeighborDiscovery
	}
	return nil
}

// GetRouterAdvertisement returns the value of the RouterAdvertisement struct pointer
// from SrlNokiaInterfaces_Interface_Subinterface_Ipv6. If the receiver or the field RouterAdvertisement is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6) GetRouterAdvertisement() *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement {
	if t != nil && t.RouterAdvertisement != nil {
		return t.RouterAdvertisement
	}
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaInterfaces_Interface_Subinterface_Ipv6
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_disable
	}
	return t.AdminState
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_Ipv6
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_disable
	}
	t.DhcpClient.PopulateDefaults()
	t.DhcpRelay.PopulateDefaults()
	t.Dhcpv6Server.PopulateDefaults()
	t.NeighborDiscovery.PopulateDefaults()
	t.RouterAdvertisement.PopulateDefaults()
	for _, e := range t.Address {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Ipv6"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_Ipv6.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv6) ΛBelongingModule() string {
	return "srl_nokia-interfaces"
}

// SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address represents the /srl_nokia-interfaces/interface/subinterface/ipv6/address YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address struct {
	AnycastGw *bool                                                        `path:"anycast-gw" module:"srl_nokia-interfaces"`
	IpPrefix  *string                                                      `path:"ip-prefix" module:"srl_nokia-interfaces"`
	Primary   YANGEmpty                                                    `path:"primary" module:"srl_nokia-interfaces"`
	Type      E_SrlNokiaCommon_Ipv6AddressType                             `path:"type" module:"srl_nokia-interfaces"`
	Vrrp      *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp `path:"vrrp" module:"srl_nokia-interfaces-ip-vrrp" yangPresence:"true"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address) IsYANGGoStruct() {}

// GetOrCreateVrrp retrieves the value of the Vrrp field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address) GetOrCreateVrrp() *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp {
	if t.Vrrp != nil {
		return t.Vrrp
	}
	t.Vrrp = &SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp{}
	return t.Vrrp
}

// GetVrrp returns the value of the Vrrp struct pointer
// from SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address. If the receiver or the field Vrrp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address) GetVrrp() *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp {
	if t != nil && t.Vrrp != nil {
		return t.Vrrp
	}
	return nil
}

// GetAnycastGw retrieves the value of the leaf AnycastGw from the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AnycastGw is set, it can
// safely use t.GetAnycastGw() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AnycastGw == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address) GetAnycastGw() bool {
	if t == nil || t.AnycastGw == nil {
		return false
	}
	return *t.AnycastGw
}

// GetIpPrefix retrieves the value of the leaf IpPrefix from the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IpPrefix is set, it can
// safely use t.GetIpPrefix() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IpPrefix == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address) GetIpPrefix() string {
	if t == nil || t.IpPrefix == nil {
		return ""
	}
	return *t.IpPrefix
}

// GetPrimary retrieves the value of the leaf Primary from the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Primary is set, it can
// safely use t.GetPrimary() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Primary == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address) GetPrimary() YANGEmpty {
	if t == nil || t.Primary == false {
		return false
	}
	return t.Primary
}

// GetType retrieves the value of the leaf Type from the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Type is set, it can
// safely use t.GetType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Type == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address) GetType() E_SrlNokiaCommon_Ipv6AddressType {
	if t == nil || t.Type == 0 {
		return SrlNokiaCommon_Ipv6AddressType_global_unicast
	}
	return t.Type
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Type == 0 {
		t.Type = SrlNokiaCommon_Ipv6AddressType_global_unicast
	}
	t.Vrrp.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address struct, which is a YANG list entry.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address) ΛListKeyMap() (map[string]interface{}, error) {
	if t.IpPrefix == nil {
		return nil, fmt.Errorf("nil value for key IpPrefix")
	}

	return map[string]interface{}{
		"ip-prefix": *t.IpPrefix,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address) ΛBelongingModule() string {
	return "srl_nokia-interfaces"
}

// SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp represents the /srl_nokia-interfaces/interface/subinterface/ipv6/address/vrrp YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp struct {
	VrrpGroup map[uint8]*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup `path:"vrrp-group" module:"srl_nokia-interfaces-ip-vrrp"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp) IsYANGGoStruct() {}

// NewVrrpGroup creates a new entry in the VrrpGroup list of the
// SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp) NewVrrpGroup(
	VirtualRouterId uint8,
) (*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.VrrpGroup == nil {
		t.VrrpGroup = make(map[uint8]*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup)
	}

	key := VirtualRouterId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.VrrpGroup[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list VrrpGroup", key)
	}

	t.VrrpGroup[key] = &SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup{
		VirtualRouterId: &VirtualRouterId,
	}

	return t.VrrpGroup[key], nil
}

// RenameVrrpGroup renames an entry in the list VrrpGroup within
// the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp) RenameVrrpGroup(oldK, newK uint8) error {
	if _, ok := t.VrrpGroup[newK]; ok {
		return fmt.Errorf("key %v already exists in VrrpGroup", newK)
	}

	e, ok := t.VrrpGroup[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in VrrpGroup", oldK)
	}
	e.VirtualRouterId = &newK

	t.VrrpGroup[newK] = e
	delete(t.VrrpGroup, oldK)
	return nil
}

// GetOrCreateVrrpGroup retrieves the value with the specified keys from
// the receiver SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp) GetOrCreateVrrpGroup(
	VirtualRouterId uint8,
) *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup {
	key := VirtualRouterId

	if v, ok := t.VrrpGroup[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewVrrpGroup(VirtualRouterId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateVrrpGroup got unexpected error: %v", err))
	}
	return v
}

// GetVrrpGroup retrieves the value with the specified key from
// the VrrpGroup map field of SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp) GetVrrpGroup(
	VirtualRouterId uint8,
) *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup {
	if t == nil {
		return nil
	}

	key := VirtualRouterId

	if lm, ok := t.VrrpGroup[key]; ok {
		return lm
	}
	return nil
}

// DeleteVrrpGroup deletes the value with the specified keys from
// the receiver SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp) DeleteVrrpGroup(VirtualRouterId uint8) {
	key := VirtualRouterId

	delete(t.VrrpGroup, key)
}

// AppendVrrpGroup appends the supplied SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup struct to the
// list VrrpGroup of SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp. If the key value(s) specified in
// the supplied SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup already exist in the list, an error is
// returned.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp) AppendVrrpGroup(
	v *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup,
) error {
	if v.VirtualRouterId == nil {
		return fmt.Errorf("invalid nil key received for VirtualRouterId")
	}

	key := *v.VirtualRouterId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.VrrpGroup == nil {
		t.VrrpGroup = make(map[uint8]*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup)
	}

	if _, ok := t.VrrpGroup[key]; ok {
		return fmt.Errorf("duplicate key for list VrrpGroup %v", key)
	}

	t.VrrpGroup[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.VrrpGroup {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp) ΛBelongingModule() string {
	return "srl_nokia-interfaces-ip-vrrp"
}

// SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup represents the /srl_nokia-interfaces/interface/subinterface/ipv6/address/vrrp/vrrp-group YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup struct {
	AcceptMode            *bool                                                                                    `path:"accept-mode" module:"srl_nokia-interfaces-ip-vrrp"`
	AdminState            E_SrlNokiaCommon_AdminState                                                              `path:"admin-state" module:"srl_nokia-interfaces-ip-vrrp"`
	AdvertiseInterval     *uint16                                                                                  `path:"advertise-interval" module:"srl_nokia-interfaces-ip-vrrp"`
	Authentication        *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_Authentication    `path:"authentication" module:"srl_nokia-interfaces-ip-vrrp"`
	InitDelay             *uint16                                                                                  `path:"init-delay" module:"srl_nokia-interfaces-ip-vrrp"`
	InterfaceTracking     *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking `path:"interface-tracking" module:"srl_nokia-interfaces-ip-vrrp"`
	MasterInheritInterval *bool                                                                                    `path:"master-inherit-interval" module:"srl_nokia-interfaces-ip-vrrp"`
	OperInterval          *uint16                                                                                  `path:"oper-interval" module:"srl_nokia-interfaces-ip-vrrp"`
	Preempt               *bool                                                                                    `path:"preempt" module:"srl_nokia-interfaces-ip-vrrp"`
	PreemptDelay          *uint16                                                                                  `path:"preempt-delay" module:"srl_nokia-interfaces-ip-vrrp"`
	Priority              *uint8                                                                                   `path:"priority" module:"srl_nokia-interfaces-ip-vrrp"`
	Statistics            *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_Statistics        `path:"statistics" module:"srl_nokia-interfaces-ip-vrrp"`
	Version               *uint8                                                                                   `path:"version" module:"srl_nokia-interfaces-ip-vrrp"`
	VirtualAddress        []string                                                                                 `path:"virtual-address" module:"srl_nokia-interfaces-ip-vrrp"`
	VirtualRouterId       *uint8                                                                                   `path:"virtual-router-id" module:"srl_nokia-interfaces-ip-vrrp"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup) IsYANGGoStruct() {}

// GetOrCreateAuthentication retrieves the value of the Authentication field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup) GetOrCreateAuthentication() *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_Authentication {
	if t.Authentication != nil {
		return t.Authentication
	}
	t.Authentication = &SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_Authentication{}
	return t.Authentication
}

// GetOrCreateInterfaceTracking retrieves the value of the InterfaceTracking field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup) GetOrCreateInterfaceTracking() *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking {
	if t.InterfaceTracking != nil {
		return t.InterfaceTracking
	}
	t.InterfaceTracking = &SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking{}
	return t.InterfaceTracking
}

// GetOrCreateStatistics retrieves the value of the Statistics field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup) GetOrCreateStatistics() *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_Statistics {
	if t.Statistics != nil {
		return t.Statistics
	}
	t.Statistics = &SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_Statistics{}
	return t.Statistics
}

// GetAuthentication returns the value of the Authentication struct pointer
// from SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup. If the receiver or the field Authentication is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup) GetAuthentication() *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_Authentication {
	if t != nil && t.Authentication != nil {
		return t.Authentication
	}
	return nil
}

// GetInterfaceTracking returns the value of the InterfaceTracking struct pointer
// from SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup. If the receiver or the field InterfaceTracking is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup) GetInterfaceTracking() *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking {
	if t != nil && t.InterfaceTracking != nil {
		return t.InterfaceTracking
	}
	return nil
}

// GetStatistics returns the value of the Statistics struct pointer
// from SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup. If the receiver or the field Statistics is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup) GetStatistics() *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_Statistics {
	if t != nil && t.Statistics != nil {
		return t.Statistics
	}
	return nil
}

// GetAcceptMode retrieves the value of the leaf AcceptMode from the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AcceptMode is set, it can
// safely use t.GetAcceptMode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AcceptMode == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup) GetAcceptMode() bool {
	if t == nil || t.AcceptMode == nil {
		return false
	}
	return *t.AcceptMode
}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_enable
	}
	return t.AdminState
}

// GetAdvertiseInterval retrieves the value of the leaf AdvertiseInterval from the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdvertiseInterval is set, it can
// safely use t.GetAdvertiseInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdvertiseInterval == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup) GetAdvertiseInterval() uint16 {
	if t == nil || t.AdvertiseInterval == nil {
		return 1000
	}
	return *t.AdvertiseInterval
}

// GetInitDelay retrieves the value of the leaf InitDelay from the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InitDelay is set, it can
// safely use t.GetInitDelay() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InitDelay == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup) GetInitDelay() uint16 {
	if t == nil || t.InitDelay == nil {
		return 0
	}
	return *t.InitDelay
}

// GetMasterInheritInterval retrieves the value of the leaf MasterInheritInterval from the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MasterInheritInterval is set, it can
// safely use t.GetMasterInheritInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MasterInheritInterval == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup) GetMasterInheritInterval() bool {
	if t == nil || t.MasterInheritInterval == nil {
		return false
	}
	return *t.MasterInheritInterval
}

// GetOperInterval retrieves the value of the leaf OperInterval from the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OperInterval is set, it can
// safely use t.GetOperInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OperInterval == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup) GetOperInterval() uint16 {
	if t == nil || t.OperInterval == nil {
		return 0
	}
	return *t.OperInterval
}

// GetPreempt retrieves the value of the leaf Preempt from the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Preempt is set, it can
// safely use t.GetPreempt() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Preempt == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup) GetPreempt() bool {
	if t == nil || t.Preempt == nil {
		return false
	}
	return *t.Preempt
}

// GetPreemptDelay retrieves the value of the leaf PreemptDelay from the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PreemptDelay is set, it can
// safely use t.GetPreemptDelay() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PreemptDelay == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup) GetPreemptDelay() uint16 {
	if t == nil || t.PreemptDelay == nil {
		return 0
	}
	return *t.PreemptDelay
}

// GetPriority retrieves the value of the leaf Priority from the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Priority is set, it can
// safely use t.GetPriority() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Priority == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup) GetPriority() uint8 {
	if t == nil || t.Priority == nil {
		return 100
	}
	return *t.Priority
}

// GetVersion retrieves the value of the leaf Version from the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Version is set, it can
// safely use t.GetVersion() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Version == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup) GetVersion() uint8 {
	if t == nil || t.Version == nil {
		return 3
	}
	return *t.Version
}

// GetVirtualAddress retrieves the value of the leaf VirtualAddress from the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VirtualAddress is set, it can
// safely use t.GetVirtualAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VirtualAddress == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup) GetVirtualAddress() []string {
	if t == nil || t.VirtualAddress == nil {
		return nil
	}
	return t.VirtualAddress
}

// GetVirtualRouterId retrieves the value of the leaf VirtualRouterId from the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VirtualRouterId is set, it can
// safely use t.GetVirtualRouterId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VirtualRouterId == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup) GetVirtualRouterId() uint8 {
	if t == nil || t.VirtualRouterId == nil {
		return 0
	}
	return *t.VirtualRouterId
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_enable
	}
	if t.AdvertiseInterval == nil {
		var v uint16 = 1000
		t.AdvertiseInterval = &v
	}
	if t.MasterInheritInterval == nil {
		var v bool = false
		t.MasterInheritInterval = &v
	}
	if t.Priority == nil {
		var v uint8 = 100
		t.Priority = &v
	}
	if t.Version == nil {
		var v uint8 = 3
		t.Version = &v
	}
	t.Authentication.PopulateDefaults()
	t.InterfaceTracking.PopulateDefaults()
	t.Statistics.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup struct, which is a YANG list entry.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup) ΛListKeyMap() (map[string]interface{}, error) {
	if t.VirtualRouterId == nil {
		return nil, fmt.Errorf("nil value for key VirtualRouterId")
	}

	return map[string]interface{}{
		"virtual-router-id": *t.VirtualRouterId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup) ΛBelongingModule() string {
	return "srl_nokia-interfaces-ip-vrrp"
}

// SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_Authentication represents the /srl_nokia-interfaces/interface/subinterface/ipv6/address/vrrp/vrrp-group/authentication YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_Authentication struct {
	Keychain *string `path:"keychain" module:"srl_nokia-interfaces-ip-vrrp"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_Authentication implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_Authentication) IsYANGGoStruct() {
}

// GetKeychain retrieves the value of the leaf Keychain from the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_Authentication
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Keychain is set, it can
// safely use t.GetKeychain() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Keychain == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_Authentication) GetKeychain() string {
	if t == nil || t.Keychain == nil {
		return ""
	}
	return *t.Keychain
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_Authentication
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_Authentication) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_Authentication) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_Authentication"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_Authentication) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_Authentication) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_Authentication.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_Authentication) ΛBelongingModule() string {
	return "srl_nokia-interfaces-ip-vrrp"
}

// SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking represents the /srl_nokia-interfaces/interface/subinterface/ipv6/address/vrrp/vrrp-group/interface-tracking YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking struct {
	TrackInterface map[string]*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface `path:"track-interface" module:"srl_nokia-interfaces-ip-vrrp"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking) IsYANGGoStruct() {
}

// NewTrackInterface creates a new entry in the TrackInterface list of the
// SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking) NewTrackInterface(
	Interface string,
) (*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.TrackInterface == nil {
		t.TrackInterface = make(map[string]*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface)
	}

	key := Interface

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.TrackInterface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list TrackInterface", key)
	}

	t.TrackInterface[key] = &SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface{
		Interface: &Interface,
	}

	return t.TrackInterface[key], nil
}

// RenameTrackInterface renames an entry in the list TrackInterface within
// the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking) RenameTrackInterface(oldK, newK string) error {
	if _, ok := t.TrackInterface[newK]; ok {
		return fmt.Errorf("key %v already exists in TrackInterface", newK)
	}

	e, ok := t.TrackInterface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in TrackInterface", oldK)
	}
	e.Interface = &newK

	t.TrackInterface[newK] = e
	delete(t.TrackInterface, oldK)
	return nil
}

// GetOrCreateTrackInterface retrieves the value with the specified keys from
// the receiver SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking) GetOrCreateTrackInterface(
	Interface string,
) *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface {
	key := Interface

	if v, ok := t.TrackInterface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewTrackInterface(Interface)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateTrackInterface got unexpected error: %v", err))
	}
	return v
}

// GetTrackInterface retrieves the value with the specified key from
// the TrackInterface map field of SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking) GetTrackInterface(
	Interface string,
) *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface {
	if t == nil {
		return nil
	}

	key := Interface

	if lm, ok := t.TrackInterface[key]; ok {
		return lm
	}
	return nil
}

// DeleteTrackInterface deletes the value with the specified keys from
// the receiver SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking) DeleteTrackInterface(Interface string) {
	key := Interface

	delete(t.TrackInterface, key)
}

// AppendTrackInterface appends the supplied SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface struct to the
// list TrackInterface of SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking. If the key value(s) specified in
// the supplied SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface already exist in the list, an error is
// returned.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking) AppendTrackInterface(
	v *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface,
) error {
	if v.Interface == nil {
		return fmt.Errorf("invalid nil key received for Interface")
	}

	key := *v.Interface

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.TrackInterface == nil {
		t.TrackInterface = make(map[string]*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface)
	}

	if _, ok := t.TrackInterface[key]; ok {
		return fmt.Errorf("duplicate key for list TrackInterface %v", key)
	}

	t.TrackInterface[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.TrackInterface {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking) ΛBelongingModule() string {
	return "srl_nokia-interfaces-ip-vrrp"
}

// SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface represents the /srl_nokia-interfaces/interface/subinterface/ipv6/address/vrrp/vrrp-group/interface-tracking/track-interface YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface struct {
	Interface         *string `path:"interface" module:"srl_nokia-interfaces-ip-vrrp"`
	PriorityDecrement *uint8  `path:"priority-decrement" module:"srl_nokia-interfaces-ip-vrrp"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface) IsYANGGoStruct() {
}

// GetInterface retrieves the value of the leaf Interface from the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interface is set, it can
// safely use t.GetInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interface == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface) GetInterface() string {
	if t == nil || t.Interface == nil {
		return ""
	}
	return *t.Interface
}

// GetPriorityDecrement retrieves the value of the leaf PriorityDecrement from the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PriorityDecrement is set, it can
// safely use t.GetPriorityDecrement() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PriorityDecrement == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface) GetPriorityDecrement() uint8 {
	if t == nil || t.PriorityDecrement == nil {
		return 0
	}
	return *t.PriorityDecrement
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface struct, which is a YANG list entry.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Interface == nil {
		return nil, fmt.Errorf("nil value for key Interface")
	}

	return map[string]interface{}{
		"interface": *t.Interface,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface) ΛBelongingModule() string {
	return "srl_nokia-interfaces-ip-vrrp"
}

// SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_Statistics represents the /srl_nokia-interfaces/interface/subinterface/ipv6/address/vrrp/vrrp-group/statistics YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_Statistics struct{}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_Statistics implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_Statistics) IsYANGGoStruct() {
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_Statistics
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_Statistics) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_Statistics) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_Statistics"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_Statistics) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_Statistics) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_Statistics.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_Statistics) ΛBelongingModule() string {
	return "srl_nokia-interfaces-ip-vrrp"
}

// SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpClient represents the /srl_nokia-interfaces/interface/subinterface/ipv6/dhcp-client YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpClient struct {
	TraceOptions *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpClient_TraceOptions `path:"trace-options" module:"srl_nokia-interfaces-ip-dhcp"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpClient implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpClient) IsYANGGoStruct() {}

// GetOrCreateTraceOptions retrieves the value of the TraceOptions field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpClient) GetOrCreateTraceOptions() *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpClient_TraceOptions {
	if t.TraceOptions != nil {
		return t.TraceOptions
	}
	t.TraceOptions = &SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpClient_TraceOptions{}
	return t.TraceOptions
}

// GetTraceOptions returns the value of the TraceOptions struct pointer
// from SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpClient. If the receiver or the field TraceOptions is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpClient) GetTraceOptions() *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpClient_TraceOptions {
	if t != nil && t.TraceOptions != nil {
		return t.TraceOptions
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpClient
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpClient) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.TraceOptions.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpClient) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpClient"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpClient) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpClient) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpClient.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpClient) ΛBelongingModule() string {
	return "srl_nokia-interfaces-ip-dhcp"
}

// SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpClient_TraceOptions represents the /srl_nokia-interfaces/interface/subinterface/ipv6/dhcp-client/trace-options YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpClient_TraceOptions struct {
	Trace []E_SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpClient_TraceOptions_Trace `path:"trace" module:"srl_nokia-interfaces-ip-dhcp"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpClient_TraceOptions implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpClient_TraceOptions) IsYANGGoStruct() {}

// GetTrace retrieves the value of the leaf Trace from the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpClient_TraceOptions
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Trace is set, it can
// safely use t.GetTrace() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Trace == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpClient_TraceOptions) GetTrace() []E_SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpClient_TraceOptions_Trace {
	if t == nil || t.Trace == nil {
		return nil
	}
	return t.Trace
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpClient_TraceOptions
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpClient_TraceOptions) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpClient_TraceOptions) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpClient_TraceOptions"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpClient_TraceOptions) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpClient_TraceOptions) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpClient_TraceOptions.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpClient_TraceOptions) ΛBelongingModule() string {
	return "srl_nokia-interfaces-ip-dhcp"
}

// SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpRelay represents the /srl_nokia-interfaces/interface/subinterface/ipv6/dhcp-relay YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpRelay struct {
	AdminState      E_SrlNokiaCommon_AdminState                                            `path:"admin-state" module:"srl_nokia-interfaces-ip-dhcp-relay"`
	NetworkInstance *string                                                                `path:"network-instance" module:"srl_nokia-interfaces-ip-dhcp-relay"`
	Option          []E_SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpRelay_Option    `path:"option" module:"srl_nokia-interfaces-ip-dhcp-relay"`
	Server          []string                                                               `path:"server" module:"srl_nokia-interfaces-ip-dhcp-relay"`
	SourceAddress   *string                                                                `path:"source-address" module:"srl_nokia-interfaces-ip-dhcp-relay"`
	TraceOptions    *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpRelay_TraceOptions `path:"trace-options" module:"srl_nokia-interfaces-ip-dhcp-relay"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpRelay implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpRelay) IsYANGGoStruct() {}

// GetOrCreateTraceOptions retrieves the value of the TraceOptions field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpRelay) GetOrCreateTraceOptions() *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpRelay_TraceOptions {
	if t.TraceOptions != nil {
		return t.TraceOptions
	}
	t.TraceOptions = &SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpRelay_TraceOptions{}
	return t.TraceOptions
}

// GetTraceOptions returns the value of the TraceOptions struct pointer
// from SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpRelay. If the receiver or the field TraceOptions is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpRelay) GetTraceOptions() *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpRelay_TraceOptions {
	if t != nil && t.TraceOptions != nil {
		return t.TraceOptions
	}
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpRelay
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpRelay) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_enable
	}
	return t.AdminState
}

// GetNetworkInstance retrieves the value of the leaf NetworkInstance from the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpRelay
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NetworkInstance is set, it can
// safely use t.GetNetworkInstance() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NetworkInstance == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpRelay) GetNetworkInstance() string {
	if t == nil || t.NetworkInstance == nil {
		return ""
	}
	return *t.NetworkInstance
}

// GetOption retrieves the value of the leaf Option from the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpRelay
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Option is set, it can
// safely use t.GetOption() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Option == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpRelay) GetOption() []E_SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpRelay_Option {
	if t == nil || t.Option == nil {
		return nil
	}
	return t.Option
}

// GetServer retrieves the value of the leaf Server from the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpRelay
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Server is set, it can
// safely use t.GetServer() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Server == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpRelay) GetServer() []string {
	if t == nil || t.Server == nil {
		return nil
	}
	return t.Server
}

// GetSourceAddress retrieves the value of the leaf SourceAddress from the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpRelay
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SourceAddress is set, it can
// safely use t.GetSourceAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SourceAddress == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpRelay) GetSourceAddress() string {
	if t == nil || t.SourceAddress == nil {
		return ""
	}
	return *t.SourceAddress
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpRelay
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpRelay) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_enable
	}
	t.TraceOptions.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpRelay) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpRelay"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpRelay) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpRelay) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpRelay.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpRelay) ΛBelongingModule() string {
	return "srl_nokia-interfaces-ip-dhcp-relay"
}

// SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpRelay_TraceOptions represents the /srl_nokia-interfaces/interface/subinterface/ipv6/dhcp-relay/trace-options YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpRelay_TraceOptions struct {
	Trace []E_SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpRelay_TraceOptions_Trace `path:"trace" module:"srl_nokia-interfaces-ip-dhcp-relay"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpRelay_TraceOptions implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpRelay_TraceOptions) IsYANGGoStruct() {}

// GetTrace retrieves the value of the leaf Trace from the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpRelay_TraceOptions
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Trace is set, it can
// safely use t.GetTrace() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Trace == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpRelay_TraceOptions) GetTrace() []E_SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpRelay_TraceOptions_Trace {
	if t == nil || t.Trace == nil {
		return nil
	}
	return t.Trace
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpRelay_TraceOptions
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpRelay_TraceOptions) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpRelay_TraceOptions) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpRelay_TraceOptions"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpRelay_TraceOptions) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpRelay_TraceOptions) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpRelay_TraceOptions.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpRelay_TraceOptions) ΛBelongingModule() string {
	return "srl_nokia-interfaces-ip-dhcp-relay"
}

// SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Dhcpv6Server represents the /srl_nokia-interfaces/interface/subinterface/ipv6/dhcpv6-server YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Dhcpv6Server struct {
	AdminState E_SrlNokiaCommon_AdminState `path:"admin-state" module:"srl_nokia-interfaces-ip-dhcp-server"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Dhcpv6Server implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Dhcpv6Server) IsYANGGoStruct() {}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Dhcpv6Server
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Dhcpv6Server) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_disable
	}
	return t.AdminState
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Dhcpv6Server
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Dhcpv6Server) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_disable
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Dhcpv6Server) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Dhcpv6Server"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Dhcpv6Server) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Dhcpv6Server) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Dhcpv6Server.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Dhcpv6Server) ΛBelongingModule() string {
	return "srl_nokia-interfaces-ip-dhcp-server"
}

// SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery represents the /srl_nokia-interfaces/interface/subinterface/ipv6/neighbor-discovery YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery struct {
	Debug                     []E_SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Debug             `path:"debug" module:"srl_nokia-interfaces-nbr"`
	DuplicateAddressDetection *bool                                                                                  `path:"duplicate-address-detection" module:"srl_nokia-interfaces-nbr"`
	Evpn                      *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Evpn                 `path:"evpn" module:"srl_nokia-interfaces-nbr-evpn" yangPresence:"true"`
	HostRoute                 *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_HostRoute            `path:"host-route" module:"srl_nokia-interfaces-nbr"`
	LearnUnsolicited          E_SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_LearnUnsolicited    `path:"learn-unsolicited" module:"srl_nokia-interfaces-nbr"`
	Limit                     *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Limit                `path:"limit" module:"srl_nokia-interfaces-nbr"`
	Neighbor                  map[string]*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Neighbor  `path:"neighbor" module:"srl_nokia-interfaces-nbr"`
	ProxyNd                   *bool                                                                                  `path:"proxy-nd" module:"srl_nokia-interfaces-nbr"`
	ReachableTime             *uint32                                                                                `path:"reachable-time" module:"srl_nokia-interfaces-nbr"`
	StaleTime                 *uint32                                                                                `path:"stale-time" module:"srl_nokia-interfaces-nbr"`
	VirtualIpv6Discovery      *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_VirtualIpv6Discovery `path:"virtual-ipv6-discovery" module:"srl_nokia-interfaces-nbr-virtual-ip-discovery" yangPresence:"true"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery) IsYANGGoStruct() {}

// NewNeighbor creates a new entry in the Neighbor list of the
// SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery) NewNeighbor(
	Ipv6Address string,
) (*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Neighbor, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Neighbor)
	}

	key := Ipv6Address

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Neighbor[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Neighbor", key)
	}

	t.Neighbor[key] = &SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Neighbor{
		Ipv6Address: &Ipv6Address,
	}

	return t.Neighbor[key], nil
}

// RenameNeighbor renames an entry in the list Neighbor within
// the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery) RenameNeighbor(oldK, newK string) error {
	if _, ok := t.Neighbor[newK]; ok {
		return fmt.Errorf("key %v already exists in Neighbor", newK)
	}

	e, ok := t.Neighbor[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Neighbor", oldK)
	}
	e.Ipv6Address = &newK

	t.Neighbor[newK] = e
	delete(t.Neighbor, oldK)
	return nil
}

// GetOrCreateNeighbor retrieves the value with the specified keys from
// the receiver SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery) GetOrCreateNeighbor(
	Ipv6Address string,
) *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Neighbor {
	key := Ipv6Address

	if v, ok := t.Neighbor[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNeighbor(Ipv6Address)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNeighbor got unexpected error: %v", err))
	}
	return v
}

// GetNeighbor retrieves the value with the specified key from
// the Neighbor map field of SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery) GetNeighbor(
	Ipv6Address string,
) *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Neighbor {
	if t == nil {
		return nil
	}

	key := Ipv6Address

	if lm, ok := t.Neighbor[key]; ok {
		return lm
	}
	return nil
}

// DeleteNeighbor deletes the value with the specified keys from
// the receiver SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery) DeleteNeighbor(Ipv6Address string) {
	key := Ipv6Address

	delete(t.Neighbor, key)
}

// AppendNeighbor appends the supplied SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Neighbor struct to the
// list Neighbor of SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery. If the key value(s) specified in
// the supplied SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Neighbor already exist in the list, an error is
// returned.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery) AppendNeighbor(
	v *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Neighbor,
) error {
	if v.Ipv6Address == nil {
		return fmt.Errorf("invalid nil key received for Ipv6Address")
	}

	key := *v.Ipv6Address

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Neighbor)
	}

	if _, ok := t.Neighbor[key]; ok {
		return fmt.Errorf("duplicate key for list Neighbor %v", key)
	}

	t.Neighbor[key] = v
	return nil
}

// GetOrCreateEvpn retrieves the value of the Evpn field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery) GetOrCreateEvpn() *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Evpn {
	if t.Evpn != nil {
		return t.Evpn
	}
	t.Evpn = &SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Evpn{}
	return t.Evpn
}

// GetOrCreateHostRoute retrieves the value of the HostRoute field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery) GetOrCreateHostRoute() *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_HostRoute {
	if t.HostRoute != nil {
		return t.HostRoute
	}
	t.HostRoute = &SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_HostRoute{}
	return t.HostRoute
}

// GetOrCreateLimit retrieves the value of the Limit field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery) GetOrCreateLimit() *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Limit {
	if t.Limit != nil {
		return t.Limit
	}
	t.Limit = &SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Limit{}
	return t.Limit
}

// GetOrCreateVirtualIpv6Discovery retrieves the value of the VirtualIpv6Discovery field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery) GetOrCreateVirtualIpv6Discovery() *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_VirtualIpv6Discovery {
	if t.VirtualIpv6Discovery != nil {
		return t.VirtualIpv6Discovery
	}
	t.VirtualIpv6Discovery = &SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_VirtualIpv6Discovery{}
	return t.VirtualIpv6Discovery
}

// GetEvpn returns the value of the Evpn struct pointer
// from SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery. If the receiver or the field Evpn is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery) GetEvpn() *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Evpn {
	if t != nil && t.Evpn != nil {
		return t.Evpn
	}
	return nil
}

// GetHostRoute returns the value of the HostRoute struct pointer
// from SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery. If the receiver or the field HostRoute is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery) GetHostRoute() *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_HostRoute {
	if t != nil && t.HostRoute != nil {
		return t.HostRoute
	}
	return nil
}

// GetLimit returns the value of the Limit struct pointer
// from SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery. If the receiver or the field Limit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery) GetLimit() *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Limit {
	if t != nil && t.Limit != nil {
		return t.Limit
	}
	return nil
}

// GetVirtualIpv6Discovery returns the value of the VirtualIpv6Discovery struct pointer
// from SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery. If the receiver or the field VirtualIpv6Discovery is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery) GetVirtualIpv6Discovery() *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_VirtualIpv6Discovery {
	if t != nil && t.VirtualIpv6Discovery != nil {
		return t.VirtualIpv6Discovery
	}
	return nil
}

// GetDebug retrieves the value of the leaf Debug from the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Debug is set, it can
// safely use t.GetDebug() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Debug == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery) GetDebug() []E_SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Debug {
	if t == nil || t.Debug == nil {
		return nil
	}
	return t.Debug
}

// GetDuplicateAddressDetection retrieves the value of the leaf DuplicateAddressDetection from the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DuplicateAddressDetection is set, it can
// safely use t.GetDuplicateAddressDetection() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DuplicateAddressDetection == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery) GetDuplicateAddressDetection() bool {
	if t == nil || t.DuplicateAddressDetection == nil {
		return true
	}
	return *t.DuplicateAddressDetection
}

// GetLearnUnsolicited retrieves the value of the leaf LearnUnsolicited from the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LearnUnsolicited is set, it can
// safely use t.GetLearnUnsolicited() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LearnUnsolicited == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery) GetLearnUnsolicited() E_SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_LearnUnsolicited {
	if t == nil || t.LearnUnsolicited == 0 {
		return SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_LearnUnsolicited_none
	}
	return t.LearnUnsolicited
}

// GetProxyNd retrieves the value of the leaf ProxyNd from the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ProxyNd is set, it can
// safely use t.GetProxyNd() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ProxyNd == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery) GetProxyNd() bool {
	if t == nil || t.ProxyNd == nil {
		return false
	}
	return *t.ProxyNd
}

// GetReachableTime retrieves the value of the leaf ReachableTime from the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ReachableTime is set, it can
// safely use t.GetReachableTime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ReachableTime == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery) GetReachableTime() uint32 {
	if t == nil || t.ReachableTime == nil {
		return 30
	}
	return *t.ReachableTime
}

// GetStaleTime retrieves the value of the leaf StaleTime from the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if StaleTime is set, it can
// safely use t.GetStaleTime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.StaleTime == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery) GetStaleTime() uint32 {
	if t == nil || t.StaleTime == nil {
		return 14400
	}
	return *t.StaleTime
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.DuplicateAddressDetection == nil {
		var v bool = true
		t.DuplicateAddressDetection = &v
	}
	if t.LearnUnsolicited == 0 {
		t.LearnUnsolicited = SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_LearnUnsolicited_none
	}
	if t.ProxyNd == nil {
		var v bool = false
		t.ProxyNd = &v
	}
	if t.ReachableTime == nil {
		var v uint32 = 30
		t.ReachableTime = &v
	}
	if t.StaleTime == nil {
		var v uint32 = 14400
		t.StaleTime = &v
	}
	t.Evpn.PopulateDefaults()
	t.HostRoute.PopulateDefaults()
	t.Limit.PopulateDefaults()
	t.VirtualIpv6Discovery.PopulateDefaults()
	for _, e := range t.Neighbor {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery) ΛBelongingModule() string {
	return "srl_nokia-interfaces-nbr"
}

// SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Evpn represents the /srl_nokia-interfaces/interface/subinterface/ipv6/neighbor-discovery/evpn YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Evpn struct {
	Advertise map[E_SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn_Advertise_RouteType]*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Evpn_Advertise `path:"advertise" module:"srl_nokia-interfaces-nbr-evpn"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Evpn implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Evpn) IsYANGGoStruct() {}

// NewAdvertise creates a new entry in the Advertise list of the
// SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Evpn struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Evpn) NewAdvertise(
	RouteType E_SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn_Advertise_RouteType,
) (*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Evpn_Advertise, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Advertise == nil {
		t.Advertise = make(map[E_SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn_Advertise_RouteType]*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Evpn_Advertise)
	}

	key := RouteType

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Advertise[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Advertise", key)
	}

	t.Advertise[key] = &SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Evpn_Advertise{
		RouteType: RouteType,
	}

	return t.Advertise[key], nil
}

// RenameAdvertise renames an entry in the list Advertise within
// the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Evpn struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Evpn) RenameAdvertise(
	oldK, newK E_SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn_Advertise_RouteType,
) error {
	if _, ok := t.Advertise[newK]; ok {
		return fmt.Errorf("key %v already exists in Advertise", newK)
	}

	e, ok := t.Advertise[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Advertise", oldK)
	}
	e.RouteType = newK

	t.Advertise[newK] = e
	delete(t.Advertise, oldK)
	return nil
}

// GetOrCreateAdvertise retrieves the value with the specified keys from
// the receiver SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Evpn. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Evpn) GetOrCreateAdvertise(
	RouteType E_SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn_Advertise_RouteType,
) *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Evpn_Advertise {
	key := RouteType

	if v, ok := t.Advertise[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAdvertise(RouteType)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAdvertise got unexpected error: %v", err))
	}
	return v
}

// GetAdvertise retrieves the value with the specified key from
// the Advertise map field of SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Evpn. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Evpn) GetAdvertise(
	RouteType E_SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn_Advertise_RouteType,
) *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Evpn_Advertise {
	if t == nil {
		return nil
	}

	key := RouteType

	if lm, ok := t.Advertise[key]; ok {
		return lm
	}
	return nil
}

// DeleteAdvertise deletes the value with the specified keys from
// the receiver SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Evpn. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Evpn) DeleteAdvertise(
	RouteType E_SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn_Advertise_RouteType,
) {
	key := RouteType

	delete(t.Advertise, key)
}

// AppendAdvertise appends the supplied SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Evpn_Advertise struct to the
// list Advertise of SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Evpn. If the key value(s) specified in
// the supplied SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Evpn_Advertise already exist in the list, an error is
// returned.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Evpn) AppendAdvertise(
	v *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Evpn_Advertise,
) error {
	key := v.RouteType

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Advertise == nil {
		t.Advertise = make(map[E_SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn_Advertise_RouteType]*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Evpn_Advertise)
	}

	if _, ok := t.Advertise[key]; ok {
		return fmt.Errorf("duplicate key for list Advertise %v", key)
	}

	t.Advertise[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Evpn
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Evpn) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Advertise {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Evpn) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Evpn"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Evpn) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Evpn) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Evpn.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Evpn) ΛBelongingModule() string {
	return "srl_nokia-interfaces-nbr-evpn"
}

// SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Evpn_Advertise represents the /srl_nokia-interfaces/interface/subinterface/ipv6/neighbor-discovery/evpn/advertise YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Evpn_Advertise struct {
	InternalTags *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Evpn_Advertise_InternalTags `path:"internal-tags" module:"srl_nokia-interfaces-nbr-evpn"`
	RouteType    E_SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn_Advertise_RouteType                 `path:"route-type" module:"srl_nokia-interfaces-nbr-evpn"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Evpn_Advertise implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Evpn_Advertise) IsYANGGoStruct() {
}

// GetOrCreateInternalTags retrieves the value of the InternalTags field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Evpn_Advertise) GetOrCreateInternalTags() *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Evpn_Advertise_InternalTags {
	if t.InternalTags != nil {
		return t.InternalTags
	}
	t.InternalTags = &SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Evpn_Advertise_InternalTags{}
	return t.InternalTags
}

// GetInternalTags returns the value of the InternalTags struct pointer
// from SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Evpn_Advertise. If the receiver or the field InternalTags is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Evpn_Advertise) GetInternalTags() *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Evpn_Advertise_InternalTags {
	if t != nil && t.InternalTags != nil {
		return t.InternalTags
	}
	return nil
}

// GetRouteType retrieves the value of the leaf RouteType from the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Evpn_Advertise
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RouteType is set, it can
// safely use t.GetRouteType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RouteType == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Evpn_Advertise) GetRouteType() E_SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn_Advertise_RouteType {
	if t == nil || t.RouteType == 0 {
		return 0
	}
	return t.RouteType
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Evpn_Advertise
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Evpn_Advertise) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.InternalTags.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Evpn_Advertise struct, which is a YANG list entry.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Evpn_Advertise) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"route-type": t.RouteType,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Evpn_Advertise) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Evpn_Advertise"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Evpn_Advertise) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Evpn_Advertise) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Evpn_Advertise.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Evpn_Advertise) ΛBelongingModule() string {
	return "srl_nokia-interfaces-nbr-evpn"
}

// SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Evpn_Advertise_InternalTags represents the /srl_nokia-interfaces/interface/subinterface/ipv6/neighbor-discovery/evpn/advertise/internal-tags YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Evpn_Advertise_InternalTags struct {
	TagSet []string `path:"tag-set" module:"srl_nokia-interfaces-nbr-evpn"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Evpn_Advertise_InternalTags implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Evpn_Advertise_InternalTags) IsYANGGoStruct() {
}

// GetTagSet retrieves the value of the leaf TagSet from the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Evpn_Advertise_InternalTags
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TagSet is set, it can
// safely use t.GetTagSet() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TagSet == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Evpn_Advertise_InternalTags) GetTagSet() []string {
	if t == nil || t.TagSet == nil {
		return nil
	}
	return t.TagSet
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Evpn_Advertise_InternalTags
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Evpn_Advertise_InternalTags) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Evpn_Advertise_InternalTags) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Evpn_Advertise_InternalTags"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Evpn_Advertise_InternalTags) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Evpn_Advertise_InternalTags) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Evpn_Advertise_InternalTags.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Evpn_Advertise_InternalTags) ΛBelongingModule() string {
	return "srl_nokia-interfaces-nbr-evpn"
}

// SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_HostRoute represents the /srl_nokia-interfaces/interface/subinterface/ipv6/neighbor-discovery/host-route YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_HostRoute struct {
	Populate map[E_SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate_RouteType]*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_HostRoute_Populate `path:"populate" module:"srl_nokia-interfaces-nbr"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_HostRoute implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_HostRoute) IsYANGGoStruct() {}

// NewPopulate creates a new entry in the Populate list of the
// SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_HostRoute struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_HostRoute) NewPopulate(
	RouteType E_SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate_RouteType,
) (*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_HostRoute_Populate, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Populate == nil {
		t.Populate = make(map[E_SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate_RouteType]*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_HostRoute_Populate)
	}

	key := RouteType

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Populate[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Populate", key)
	}

	t.Populate[key] = &SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_HostRoute_Populate{
		RouteType: RouteType,
	}

	return t.Populate[key], nil
}

// RenamePopulate renames an entry in the list Populate within
// the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_HostRoute struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_HostRoute) RenamePopulate(
	oldK, newK E_SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate_RouteType,
) error {
	if _, ok := t.Populate[newK]; ok {
		return fmt.Errorf("key %v already exists in Populate", newK)
	}

	e, ok := t.Populate[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Populate", oldK)
	}
	e.RouteType = newK

	t.Populate[newK] = e
	delete(t.Populate, oldK)
	return nil
}

// GetOrCreatePopulate retrieves the value with the specified keys from
// the receiver SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_HostRoute. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_HostRoute) GetOrCreatePopulate(
	RouteType E_SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate_RouteType,
) *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_HostRoute_Populate {
	key := RouteType

	if v, ok := t.Populate[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPopulate(RouteType)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePopulate got unexpected error: %v", err))
	}
	return v
}

// GetPopulate retrieves the value with the specified key from
// the Populate map field of SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_HostRoute. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_HostRoute) GetPopulate(
	RouteType E_SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate_RouteType,
) *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_HostRoute_Populate {
	if t == nil {
		return nil
	}

	key := RouteType

	if lm, ok := t.Populate[key]; ok {
		return lm
	}
	return nil
}

// DeletePopulate deletes the value with the specified keys from
// the receiver SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_HostRoute. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_HostRoute) DeletePopulate(
	RouteType E_SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate_RouteType,
) {
	key := RouteType

	delete(t.Populate, key)
}

// AppendPopulate appends the supplied SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_HostRoute_Populate struct to the
// list Populate of SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_HostRoute. If the key value(s) specified in
// the supplied SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_HostRoute_Populate already exist in the list, an error is
// returned.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_HostRoute) AppendPopulate(
	v *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_HostRoute_Populate,
) error {
	key := v.RouteType

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Populate == nil {
		t.Populate = make(map[E_SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate_RouteType]*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_HostRoute_Populate)
	}

	if _, ok := t.Populate[key]; ok {
		return fmt.Errorf("duplicate key for list Populate %v", key)
	}

	t.Populate[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_HostRoute
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_HostRoute) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Populate {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_HostRoute) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_HostRoute"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_HostRoute) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_HostRoute) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_HostRoute.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_HostRoute) ΛBelongingModule() string {
	return "srl_nokia-interfaces-nbr"
}

// SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_HostRoute_Populate represents the /srl_nokia-interfaces/interface/subinterface/ipv6/neighbor-discovery/host-route/populate YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_HostRoute_Populate struct {
	DatapathProgramming *bool                                                                                             `path:"datapath-programming" module:"srl_nokia-interfaces-nbr"`
	InternalTags        *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_HostRoute_Populate_InternalTags `path:"internal-tags" module:"srl_nokia-interfaces-nbr"`
	RouteType           E_SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate_RouteType                 `path:"route-type" module:"srl_nokia-interfaces-nbr"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_HostRoute_Populate implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_HostRoute_Populate) IsYANGGoStruct() {
}

// GetOrCreateInternalTags retrieves the value of the InternalTags field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_HostRoute_Populate) GetOrCreateInternalTags() *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_HostRoute_Populate_InternalTags {
	if t.InternalTags != nil {
		return t.InternalTags
	}
	t.InternalTags = &SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_HostRoute_Populate_InternalTags{}
	return t.InternalTags
}

// GetInternalTags returns the value of the InternalTags struct pointer
// from SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_HostRoute_Populate. If the receiver or the field InternalTags is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_HostRoute_Populate) GetInternalTags() *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_HostRoute_Populate_InternalTags {
	if t != nil && t.InternalTags != nil {
		return t.InternalTags
	}
	return nil
}

// GetDatapathProgramming retrieves the value of the leaf DatapathProgramming from the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_HostRoute_Populate
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DatapathProgramming is set, it can
// safely use t.GetDatapathProgramming() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DatapathProgramming == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_HostRoute_Populate) GetDatapathProgramming() bool {
	if t == nil || t.DatapathProgramming == nil {
		return false
	}
	return *t.DatapathProgramming
}

// GetRouteType retrieves the value of the leaf RouteType from the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_HostRoute_Populate
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RouteType is set, it can
// safely use t.GetRouteType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RouteType == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_HostRoute_Populate) GetRouteType() E_SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate_RouteType {
	if t == nil || t.RouteType == 0 {
		return 0
	}
	return t.RouteType
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_HostRoute_Populate
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_HostRoute_Populate) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.InternalTags.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_HostRoute_Populate struct, which is a YANG list entry.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_HostRoute_Populate) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"route-type": t.RouteType,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_HostRoute_Populate) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_HostRoute_Populate"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_HostRoute_Populate) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_HostRoute_Populate) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_HostRoute_Populate.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_HostRoute_Populate) ΛBelongingModule() string {
	return "srl_nokia-interfaces-nbr"
}

// SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_HostRoute_Populate_InternalTags represents the /srl_nokia-interfaces/interface/subinterface/ipv6/neighbor-discovery/host-route/populate/internal-tags YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_HostRoute_Populate_InternalTags struct {
	TagSet *string `path:"tag-set" module:"srl_nokia-interfaces-nbr"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_HostRoute_Populate_InternalTags implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_HostRoute_Populate_InternalTags) IsYANGGoStruct() {
}

// GetTagSet retrieves the value of the leaf TagSet from the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_HostRoute_Populate_InternalTags
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TagSet is set, it can
// safely use t.GetTagSet() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TagSet == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_HostRoute_Populate_InternalTags) GetTagSet() string {
	if t == nil || t.TagSet == nil {
		return ""
	}
	return *t.TagSet
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_HostRoute_Populate_InternalTags
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_HostRoute_Populate_InternalTags) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_HostRoute_Populate_InternalTags) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_HostRoute_Populate_InternalTags"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_HostRoute_Populate_InternalTags) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_HostRoute_Populate_InternalTags) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_HostRoute_Populate_InternalTags.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_HostRoute_Populate_InternalTags) ΛBelongingModule() string {
	return "srl_nokia-interfaces-nbr"
}

// SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Limit represents the /srl_nokia-interfaces/interface/subinterface/ipv6/neighbor-discovery/limit YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Limit struct {
	LogOnly             *bool   `path:"log-only" module:"srl_nokia-interfaces-nbr"`
	MaxEntries          *uint32 `path:"max-entries" module:"srl_nokia-interfaces-nbr"`
	WarningThresholdPct *uint32 `path:"warning-threshold-pct" module:"srl_nokia-interfaces-nbr"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Limit implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Limit) IsYANGGoStruct() {}

// GetLogOnly retrieves the value of the leaf LogOnly from the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Limit
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LogOnly is set, it can
// safely use t.GetLogOnly() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LogOnly == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Limit) GetLogOnly() bool {
	if t == nil || t.LogOnly == nil {
		return false
	}
	return *t.LogOnly
}

// GetMaxEntries retrieves the value of the leaf MaxEntries from the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Limit
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MaxEntries is set, it can
// safely use t.GetMaxEntries() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MaxEntries == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Limit) GetMaxEntries() uint32 {
	if t == nil || t.MaxEntries == nil {
		return 0
	}
	return *t.MaxEntries
}

// GetWarningThresholdPct retrieves the value of the leaf WarningThresholdPct from the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Limit
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if WarningThresholdPct is set, it can
// safely use t.GetWarningThresholdPct() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.WarningThresholdPct == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Limit) GetWarningThresholdPct() uint32 {
	if t == nil || t.WarningThresholdPct == nil {
		return 90
	}
	return *t.WarningThresholdPct
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Limit
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Limit) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.LogOnly == nil {
		var v bool = false
		t.LogOnly = &v
	}
	if t.WarningThresholdPct == nil {
		var v uint32 = 90
		t.WarningThresholdPct = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Limit) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Limit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Limit) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Limit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Limit.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Limit) ΛBelongingModule() string {
	return "srl_nokia-interfaces-nbr"
}

// SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Neighbor represents the /srl_nokia-interfaces/interface/subinterface/ipv6/neighbor-discovery/neighbor YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Neighbor struct {
	Ipv6Address      *string `path:"ipv6-address" module:"srl_nokia-interfaces-nbr"`
	LinkLayerAddress *string `path:"link-layer-address" module:"srl_nokia-interfaces-nbr"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Neighbor implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Neighbor) IsYANGGoStruct() {}

// GetIpv6Address retrieves the value of the leaf Ipv6Address from the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ipv6Address is set, it can
// safely use t.GetIpv6Address() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ipv6Address == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Neighbor) GetIpv6Address() string {
	if t == nil || t.Ipv6Address == nil {
		return ""
	}
	return *t.Ipv6Address
}

// GetLinkLayerAddress retrieves the value of the leaf LinkLayerAddress from the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LinkLayerAddress is set, it can
// safely use t.GetLinkLayerAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LinkLayerAddress == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Neighbor) GetLinkLayerAddress() string {
	if t == nil || t.LinkLayerAddress == nil {
		return ""
	}
	return *t.LinkLayerAddress
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Neighbor
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Neighbor) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Neighbor struct, which is a YANG list entry.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Neighbor) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Ipv6Address == nil {
		return nil, fmt.Errorf("nil value for key Ipv6Address")
	}

	return map[string]interface{}{
		"ipv6-address": *t.Ipv6Address,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Neighbor) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Neighbor"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Neighbor) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Neighbor) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Neighbor.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Neighbor) ΛBelongingModule() string {
	return "srl_nokia-interfaces-nbr"
}

// SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_VirtualIpv6Discovery represents the /srl_nokia-interfaces/interface/subinterface/ipv6/neighbor-discovery/virtual-ipv6-discovery YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_VirtualIpv6Discovery struct {
	Address map[string]*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_VirtualIpv6Discovery_Address `path:"address" module:"srl_nokia-interfaces-nbr-virtual-ip-discovery"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_VirtualIpv6Discovery implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_VirtualIpv6Discovery) IsYANGGoStruct() {
}

// NewAddress creates a new entry in the Address list of the
// SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_VirtualIpv6Discovery struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_VirtualIpv6Discovery) NewAddress(
	Ipv6Address string,
) (*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_VirtualIpv6Discovery_Address, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Address == nil {
		t.Address = make(map[string]*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_VirtualIpv6Discovery_Address)
	}

	key := Ipv6Address

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Address[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Address", key)
	}

	t.Address[key] = &SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_VirtualIpv6Discovery_Address{
		Ipv6Address: &Ipv6Address,
	}

	return t.Address[key], nil
}

// RenameAddress renames an entry in the list Address within
// the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_VirtualIpv6Discovery struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_VirtualIpv6Discovery) RenameAddress(oldK, newK string) error {
	if _, ok := t.Address[newK]; ok {
		return fmt.Errorf("key %v already exists in Address", newK)
	}

	e, ok := t.Address[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Address", oldK)
	}
	e.Ipv6Address = &newK

	t.Address[newK] = e
	delete(t.Address, oldK)
	return nil
}

// GetOrCreateAddress retrieves the value with the specified keys from
// the receiver SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_VirtualIpv6Discovery. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_VirtualIpv6Discovery) GetOrCreateAddress(
	Ipv6Address string,
) *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_VirtualIpv6Discovery_Address {
	key := Ipv6Address

	if v, ok := t.Address[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAddress(Ipv6Address)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAddress got unexpected error: %v", err))
	}
	return v
}

// GetAddress retrieves the value with the specified key from
// the Address map field of SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_VirtualIpv6Discovery. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_VirtualIpv6Discovery) GetAddress(
	Ipv6Address string,
) *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_VirtualIpv6Discovery_Address {
	if t == nil {
		return nil
	}

	key := Ipv6Address

	if lm, ok := t.Address[key]; ok {
		return lm
	}
	return nil
}

// DeleteAddress deletes the value with the specified keys from
// the receiver SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_VirtualIpv6Discovery. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_VirtualIpv6Discovery) DeleteAddress(Ipv6Address string) {
	key := Ipv6Address

	delete(t.Address, key)
}

// AppendAddress appends the supplied SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_VirtualIpv6Discovery_Address struct to the
// list Address of SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_VirtualIpv6Discovery. If the key value(s) specified in
// the supplied SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_VirtualIpv6Discovery_Address already exist in the list, an error is
// returned.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_VirtualIpv6Discovery) AppendAddress(
	v *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_VirtualIpv6Discovery_Address,
) error {
	if v.Ipv6Address == nil {
		return fmt.Errorf("invalid nil key received for Ipv6Address")
	}

	key := *v.Ipv6Address

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Address == nil {
		t.Address = make(map[string]*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_VirtualIpv6Discovery_Address)
	}

	if _, ok := t.Address[key]; ok {
		return fmt.Errorf("duplicate key for list Address %v", key)
	}

	t.Address[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_VirtualIpv6Discovery
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_VirtualIpv6Discovery) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Address {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_VirtualIpv6Discovery) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_VirtualIpv6Discovery"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_VirtualIpv6Discovery) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_VirtualIpv6Discovery) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_VirtualIpv6Discovery.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_VirtualIpv6Discovery) ΛBelongingModule() string {
	return "srl_nokia-interfaces-nbr-virtual-ip-discovery"
}

// SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_VirtualIpv6Discovery_Address represents the /srl_nokia-interfaces/interface/subinterface/ipv6/neighbor-discovery/virtual-ipv6-discovery/address YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_VirtualIpv6Discovery_Address struct {
	AllowedMacs               []string `path:"allowed-macs" module:"srl_nokia-interfaces-nbr-virtual-ip-discovery"`
	Ipv6Address               *string  `path:"ipv6-address" module:"srl_nokia-interfaces-nbr-virtual-ip-discovery"`
	ProbeBridgedSubinterfaces []string `path:"probe-bridged-subinterfaces" module:"srl_nokia-interfaces-nbr-virtual-ip-discovery"`
	ProbeInterval             *uint32  `path:"probe-interval" module:"srl_nokia-interfaces-nbr-virtual-ip-discovery"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_VirtualIpv6Discovery_Address implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_VirtualIpv6Discovery_Address) IsYANGGoStruct() {
}

// GetAllowedMacs retrieves the value of the leaf AllowedMacs from the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_VirtualIpv6Discovery_Address
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AllowedMacs is set, it can
// safely use t.GetAllowedMacs() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AllowedMacs == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_VirtualIpv6Discovery_Address) GetAllowedMacs() []string {
	if t == nil || t.AllowedMacs == nil {
		return nil
	}
	return t.AllowedMacs
}

// GetIpv6Address retrieves the value of the leaf Ipv6Address from the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_VirtualIpv6Discovery_Address
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ipv6Address is set, it can
// safely use t.GetIpv6Address() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ipv6Address == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_VirtualIpv6Discovery_Address) GetIpv6Address() string {
	if t == nil || t.Ipv6Address == nil {
		return ""
	}
	return *t.Ipv6Address
}

// GetProbeBridgedSubinterfaces retrieves the value of the leaf ProbeBridgedSubinterfaces from the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_VirtualIpv6Discovery_Address
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ProbeBridgedSubinterfaces is set, it can
// safely use t.GetProbeBridgedSubinterfaces() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ProbeBridgedSubinterfaces == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_VirtualIpv6Discovery_Address) GetProbeBridgedSubinterfaces() []string {
	if t == nil || t.ProbeBridgedSubinterfaces == nil {
		return nil
	}
	return t.ProbeBridgedSubinterfaces
}

// GetProbeInterval retrieves the value of the leaf ProbeInterval from the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_VirtualIpv6Discovery_Address
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ProbeInterval is set, it can
// safely use t.GetProbeInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ProbeInterval == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_VirtualIpv6Discovery_Address) GetProbeInterval() uint32 {
	if t == nil || t.ProbeInterval == nil {
		return 0
	}
	return *t.ProbeInterval
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_VirtualIpv6Discovery_Address
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_VirtualIpv6Discovery_Address) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.ProbeInterval == nil {
		var v uint32 = 0
		t.ProbeInterval = &v
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_VirtualIpv6Discovery_Address struct, which is a YANG list entry.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_VirtualIpv6Discovery_Address) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Ipv6Address == nil {
		return nil, fmt.Errorf("nil value for key Ipv6Address")
	}

	return map[string]interface{}{
		"ipv6-address": *t.Ipv6Address,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_VirtualIpv6Discovery_Address) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_VirtualIpv6Discovery_Address"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_VirtualIpv6Discovery_Address) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_VirtualIpv6Discovery_Address) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_VirtualIpv6Discovery_Address.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_VirtualIpv6Discovery_Address) ΛBelongingModule() string {
	return "srl_nokia-interfaces-nbr-virtual-ip-discovery"
}

// SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement represents the /srl_nokia-interfaces/interface/subinterface/ipv6/router-advertisement YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement struct {
	Debug      []E_SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement_Debug   `path:"debug" module:"srl_nokia-interfaces-router-adv"`
	RouterRole *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement_RouterRole `path:"router-role" module:"srl_nokia-interfaces-router-adv"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement) IsYANGGoStruct() {}

// GetOrCreateRouterRole retrieves the value of the RouterRole field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement) GetOrCreateRouterRole() *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement_RouterRole {
	if t.RouterRole != nil {
		return t.RouterRole
	}
	t.RouterRole = &SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement_RouterRole{}
	return t.RouterRole
}

// GetRouterRole returns the value of the RouterRole struct pointer
// from SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement. If the receiver or the field RouterRole is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement) GetRouterRole() *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement_RouterRole {
	if t != nil && t.RouterRole != nil {
		return t.RouterRole
	}
	return nil
}

// GetDebug retrieves the value of the leaf Debug from the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Debug is set, it can
// safely use t.GetDebug() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Debug == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement) GetDebug() []E_SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement_Debug {
	if t == nil || t.Debug == nil {
		return nil
	}
	return t.Debug
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.RouterRole.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement) ΛBelongingModule() string {
	return "srl_nokia-interfaces-router-adv"
}

// SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement_RouterRole represents the /srl_nokia-interfaces/interface/subinterface/ipv6/router-advertisement/router-role YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement_RouterRole struct {
	AdminState               E_SrlNokiaCommon_AdminState                                                                      `path:"admin-state" module:"srl_nokia-interfaces-router-adv"`
	CurrentHopLimit          *uint8                                                                                           `path:"current-hop-limit" module:"srl_nokia-interfaces-router-adv"`
	IpMtu                    *uint16                                                                                          `path:"ip-mtu" module:"srl_nokia-interfaces-router-adv"`
	ManagedConfigurationFlag *bool                                                                                            `path:"managed-configuration-flag" module:"srl_nokia-interfaces-router-adv"`
	MaxAdvertisementInterval *uint16                                                                                          `path:"max-advertisement-interval" module:"srl_nokia-interfaces-router-adv"`
	MinAdvertisementInterval *uint16                                                                                          `path:"min-advertisement-interval" module:"srl_nokia-interfaces-router-adv"`
	OtherConfigurationFlag   *bool                                                                                            `path:"other-configuration-flag" module:"srl_nokia-interfaces-router-adv"`
	Prefix                   map[string]*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement_RouterRole_Prefix `path:"prefix" module:"srl_nokia-interfaces-router-adv"`
	ReachableTime            *uint32                                                                                          `path:"reachable-time" module:"srl_nokia-interfaces-router-adv"`
	RetransmitTime           *uint32                                                                                          `path:"retransmit-time" module:"srl_nokia-interfaces-router-adv"`
	RouterLifetime           *uint16                                                                                          `path:"router-lifetime" module:"srl_nokia-interfaces-router-adv"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement_RouterRole implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement_RouterRole) IsYANGGoStruct() {
}

// NewPrefix creates a new entry in the Prefix list of the
// SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement_RouterRole struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement_RouterRole) NewPrefix(
	Ipv6Prefix string,
) (*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement_RouterRole_Prefix, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Prefix == nil {
		t.Prefix = make(map[string]*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement_RouterRole_Prefix)
	}

	key := Ipv6Prefix

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Prefix[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Prefix", key)
	}

	t.Prefix[key] = &SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement_RouterRole_Prefix{
		Ipv6Prefix: &Ipv6Prefix,
	}

	return t.Prefix[key], nil
}

// RenamePrefix renames an entry in the list Prefix within
// the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement_RouterRole struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement_RouterRole) RenamePrefix(oldK, newK string) error {
	if _, ok := t.Prefix[newK]; ok {
		return fmt.Errorf("key %v already exists in Prefix", newK)
	}

	e, ok := t.Prefix[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Prefix", oldK)
	}
	e.Ipv6Prefix = &newK

	t.Prefix[newK] = e
	delete(t.Prefix, oldK)
	return nil
}

// GetOrCreatePrefix retrieves the value with the specified keys from
// the receiver SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement_RouterRole. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement_RouterRole) GetOrCreatePrefix(
	Ipv6Prefix string,
) *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement_RouterRole_Prefix {
	key := Ipv6Prefix

	if v, ok := t.Prefix[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPrefix(Ipv6Prefix)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePrefix got unexpected error: %v", err))
	}
	return v
}

// GetPrefix retrieves the value with the specified key from
// the Prefix map field of SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement_RouterRole. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement_RouterRole) GetPrefix(
	Ipv6Prefix string,
) *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement_RouterRole_Prefix {
	if t == nil {
		return nil
	}

	key := Ipv6Prefix

	if lm, ok := t.Prefix[key]; ok {
		return lm
	}
	return nil
}

// DeletePrefix deletes the value with the specified keys from
// the receiver SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement_RouterRole. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement_RouterRole) DeletePrefix(Ipv6Prefix string) {
	key := Ipv6Prefix

	delete(t.Prefix, key)
}

// AppendPrefix appends the supplied SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement_RouterRole_Prefix struct to the
// list Prefix of SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement_RouterRole. If the key value(s) specified in
// the supplied SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement_RouterRole_Prefix already exist in the list, an error is
// returned.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement_RouterRole) AppendPrefix(
	v *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement_RouterRole_Prefix,
) error {
	if v.Ipv6Prefix == nil {
		return fmt.Errorf("invalid nil key received for Ipv6Prefix")
	}

	key := *v.Ipv6Prefix

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Prefix == nil {
		t.Prefix = make(map[string]*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement_RouterRole_Prefix)
	}

	if _, ok := t.Prefix[key]; ok {
		return fmt.Errorf("duplicate key for list Prefix %v", key)
	}

	t.Prefix[key] = v
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement_RouterRole
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement_RouterRole) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_disable
	}
	return t.AdminState
}

// GetCurrentHopLimit retrieves the value of the leaf CurrentHopLimit from the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement_RouterRole
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if CurrentHopLimit is set, it can
// safely use t.GetCurrentHopLimit() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.CurrentHopLimit == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement_RouterRole) GetCurrentHopLimit() uint8 {
	if t == nil || t.CurrentHopLimit == nil {
		return 64
	}
	return *t.CurrentHopLimit
}

// GetIpMtu retrieves the value of the leaf IpMtu from the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement_RouterRole
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IpMtu is set, it can
// safely use t.GetIpMtu() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IpMtu == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement_RouterRole) GetIpMtu() uint16 {
	if t == nil || t.IpMtu == nil {
		return 0
	}
	return *t.IpMtu
}

// GetManagedConfigurationFlag retrieves the value of the leaf ManagedConfigurationFlag from the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement_RouterRole
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ManagedConfigurationFlag is set, it can
// safely use t.GetManagedConfigurationFlag() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ManagedConfigurationFlag == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement_RouterRole) GetManagedConfigurationFlag() bool {
	if t == nil || t.ManagedConfigurationFlag == nil {
		return false
	}
	return *t.ManagedConfigurationFlag
}

// GetMaxAdvertisementInterval retrieves the value of the leaf MaxAdvertisementInterval from the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement_RouterRole
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MaxAdvertisementInterval is set, it can
// safely use t.GetMaxAdvertisementInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MaxAdvertisementInterval == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement_RouterRole) GetMaxAdvertisementInterval() uint16 {
	if t == nil || t.MaxAdvertisementInterval == nil {
		return 600
	}
	return *t.MaxAdvertisementInterval
}

// GetMinAdvertisementInterval retrieves the value of the leaf MinAdvertisementInterval from the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement_RouterRole
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MinAdvertisementInterval is set, it can
// safely use t.GetMinAdvertisementInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MinAdvertisementInterval == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement_RouterRole) GetMinAdvertisementInterval() uint16 {
	if t == nil || t.MinAdvertisementInterval == nil {
		return 200
	}
	return *t.MinAdvertisementInterval
}

// GetOtherConfigurationFlag retrieves the value of the leaf OtherConfigurationFlag from the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement_RouterRole
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OtherConfigurationFlag is set, it can
// safely use t.GetOtherConfigurationFlag() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OtherConfigurationFlag == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement_RouterRole) GetOtherConfigurationFlag() bool {
	if t == nil || t.OtherConfigurationFlag == nil {
		return false
	}
	return *t.OtherConfigurationFlag
}

// GetReachableTime retrieves the value of the leaf ReachableTime from the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement_RouterRole
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ReachableTime is set, it can
// safely use t.GetReachableTime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ReachableTime == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement_RouterRole) GetReachableTime() uint32 {
	if t == nil || t.ReachableTime == nil {
		return 0
	}
	return *t.ReachableTime
}

// GetRetransmitTime retrieves the value of the leaf RetransmitTime from the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement_RouterRole
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RetransmitTime is set, it can
// safely use t.GetRetransmitTime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RetransmitTime == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement_RouterRole) GetRetransmitTime() uint32 {
	if t == nil || t.RetransmitTime == nil {
		return 0
	}
	return *t.RetransmitTime
}

// GetRouterLifetime retrieves the value of the leaf RouterLifetime from the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement_RouterRole
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RouterLifetime is set, it can
// safely use t.GetRouterLifetime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RouterLifetime == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement_RouterRole) GetRouterLifetime() uint16 {
	if t == nil || t.RouterLifetime == nil {
		return 1800
	}
	return *t.RouterLifetime
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement_RouterRole
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement_RouterRole) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_disable
	}
	if t.CurrentHopLimit == nil {
		var v uint8 = 64
		t.CurrentHopLimit = &v
	}
	if t.ManagedConfigurationFlag == nil {
		var v bool = false
		t.ManagedConfigurationFlag = &v
	}
	if t.MaxAdvertisementInterval == nil {
		var v uint16 = 600
		t.MaxAdvertisementInterval = &v
	}
	if t.MinAdvertisementInterval == nil {
		var v uint16 = 200
		t.MinAdvertisementInterval = &v
	}
	if t.OtherConfigurationFlag == nil {
		var v bool = false
		t.OtherConfigurationFlag = &v
	}
	if t.ReachableTime == nil {
		var v uint32 = 0
		t.ReachableTime = &v
	}
	if t.RetransmitTime == nil {
		var v uint32 = 0
		t.RetransmitTime = &v
	}
	if t.RouterLifetime == nil {
		var v uint16 = 1800
		t.RouterLifetime = &v
	}
	for _, e := range t.Prefix {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement_RouterRole) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement_RouterRole"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement_RouterRole) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement_RouterRole) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement_RouterRole.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement_RouterRole) ΛBelongingModule() string {
	return "srl_nokia-interfaces-router-adv"
}

// SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement_RouterRole_Prefix represents the /srl_nokia-interfaces/interface/subinterface/ipv6/router-advertisement/router-role/prefix YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement_RouterRole_Prefix struct {
	AutonomousFlag    *bool                                                                                                        `path:"autonomous-flag" module:"srl_nokia-interfaces-router-adv"`
	Ipv6Prefix        *string                                                                                                      `path:"ipv6-prefix" module:"srl_nokia-interfaces-router-adv"`
	OnLinkFlag        *bool                                                                                                        `path:"on-link-flag" module:"srl_nokia-interfaces-router-adv"`
	PreferredLifetime SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement_RouterRole_Prefix_PreferredLifetime_Union `path:"preferred-lifetime" module:"srl_nokia-interfaces-router-adv"`
	ValidLifetime     SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement_RouterRole_Prefix_ValidLifetime_Union     `path:"valid-lifetime" module:"srl_nokia-interfaces-router-adv"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement_RouterRole_Prefix implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement_RouterRole_Prefix) IsYANGGoStruct() {
}

// GetAutonomousFlag retrieves the value of the leaf AutonomousFlag from the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement_RouterRole_Prefix
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AutonomousFlag is set, it can
// safely use t.GetAutonomousFlag() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AutonomousFlag == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement_RouterRole_Prefix) GetAutonomousFlag() bool {
	if t == nil || t.AutonomousFlag == nil {
		return true
	}
	return *t.AutonomousFlag
}

// GetIpv6Prefix retrieves the value of the leaf Ipv6Prefix from the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement_RouterRole_Prefix
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ipv6Prefix is set, it can
// safely use t.GetIpv6Prefix() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ipv6Prefix == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement_RouterRole_Prefix) GetIpv6Prefix() string {
	if t == nil || t.Ipv6Prefix == nil {
		return ""
	}
	return *t.Ipv6Prefix
}

// GetOnLinkFlag retrieves the value of the leaf OnLinkFlag from the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement_RouterRole_Prefix
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OnLinkFlag is set, it can
// safely use t.GetOnLinkFlag() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OnLinkFlag == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement_RouterRole_Prefix) GetOnLinkFlag() bool {
	if t == nil || t.OnLinkFlag == nil {
		return true
	}
	return *t.OnLinkFlag
}

// GetPreferredLifetime retrieves the value of the leaf PreferredLifetime from the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement_RouterRole_Prefix
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PreferredLifetime is set, it can
// safely use t.GetPreferredLifetime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PreferredLifetime == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement_RouterRole_Prefix) GetPreferredLifetime() SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement_RouterRole_Prefix_PreferredLifetime_Union {
	if t == nil || t.PreferredLifetime == nil {
		return UnionUint32(604800)
	}
	return t.PreferredLifetime
}

// GetValidLifetime retrieves the value of the leaf ValidLifetime from the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement_RouterRole_Prefix
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ValidLifetime is set, it can
// safely use t.GetValidLifetime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ValidLifetime == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement_RouterRole_Prefix) GetValidLifetime() SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement_RouterRole_Prefix_ValidLifetime_Union {
	if t == nil || t.ValidLifetime == nil {
		return UnionUint32(2592000)
	}
	return t.ValidLifetime
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement_RouterRole_Prefix
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement_RouterRole_Prefix) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AutonomousFlag == nil {
		var v bool = true
		t.AutonomousFlag = &v
	}
	if t.OnLinkFlag == nil {
		var v bool = true
		t.OnLinkFlag = &v
	}
	if t.PreferredLifetime == nil {
		t.PreferredLifetime = UnionUint32(604800)
	}
	if t.ValidLifetime == nil {
		t.ValidLifetime = UnionUint32(2592000)
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement_RouterRole_Prefix struct, which is a YANG list entry.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement_RouterRole_Prefix) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Ipv6Prefix == nil {
		return nil, fmt.Errorf("nil value for key Ipv6Prefix")
	}

	return map[string]interface{}{
		"ipv6-prefix": *t.Ipv6Prefix,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement_RouterRole_Prefix) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement_RouterRole_Prefix"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement_RouterRole_Prefix) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement_RouterRole_Prefix) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement_RouterRole_Prefix.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement_RouterRole_Prefix) ΛBelongingModule() string {
	return "srl_nokia-interfaces-router-adv"
}

// SrlNokiaInterfaces_Interface_Subinterface_LocalMirrorDestination represents the /srl_nokia-interfaces/interface/subinterface/local-mirror-destination YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_LocalMirrorDestination struct {
	AdminState E_SrlNokiaCommon_AdminState `path:"admin-state" module:"srl_nokia-interfaces-local-mirror-destination"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_LocalMirrorDestination implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_LocalMirrorDestination) IsYANGGoStruct() {}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaInterfaces_Interface_Subinterface_LocalMirrorDestination
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_LocalMirrorDestination) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_enable
	}
	return t.AdminState
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_LocalMirrorDestination
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_LocalMirrorDestination) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_enable
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_LocalMirrorDestination) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_LocalMirrorDestination"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_LocalMirrorDestination) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_LocalMirrorDestination) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_LocalMirrorDestination.
func (*SrlNokiaInterfaces_Interface_Subinterface_LocalMirrorDestination) ΛBelongingModule() string {
	return "srl_nokia-interfaces-local-mirror-destination"
}

// SrlNokiaInterfaces_Interface_Subinterface_Qos represents the /srl_nokia-interfaces/interface/subinterface/qos YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_Qos struct {
	Input  *SrlNokiaInterfaces_Interface_Subinterface_Qos_Input  `path:"input" module:"srl_nokia-qos"`
	Output *SrlNokiaInterfaces_Interface_Subinterface_Qos_Output `path:"output" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_Qos implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_Qos) IsYANGGoStruct() {}

// GetOrCreateInput retrieves the value of the Input field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Qos) GetOrCreateInput() *SrlNokiaInterfaces_Interface_Subinterface_Qos_Input {
	if t.Input != nil {
		return t.Input
	}
	t.Input = &SrlNokiaInterfaces_Interface_Subinterface_Qos_Input{}
	return t.Input
}

// GetOrCreateOutput retrieves the value of the Output field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Qos) GetOrCreateOutput() *SrlNokiaInterfaces_Interface_Subinterface_Qos_Output {
	if t.Output != nil {
		return t.Output
	}
	t.Output = &SrlNokiaInterfaces_Interface_Subinterface_Qos_Output{}
	return t.Output
}

// GetInput returns the value of the Input struct pointer
// from SrlNokiaInterfaces_Interface_Subinterface_Qos. If the receiver or the field Input is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Qos) GetInput() *SrlNokiaInterfaces_Interface_Subinterface_Qos_Input {
	if t != nil && t.Input != nil {
		return t.Input
	}
	return nil
}

// GetOutput returns the value of the Output struct pointer
// from SrlNokiaInterfaces_Interface_Subinterface_Qos. If the receiver or the field Output is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Qos) GetOutput() *SrlNokiaInterfaces_Interface_Subinterface_Qos_Output {
	if t != nil && t.Output != nil {
		return t.Output
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_Qos
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Qos) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Input.PopulateDefaults()
	t.Output.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Qos) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Qos"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Qos) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Qos) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_Qos.
func (*SrlNokiaInterfaces_Interface_Subinterface_Qos) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaInterfaces_Interface_Subinterface_Qos_Input represents the /srl_nokia-interfaces/interface/subinterface/qos/input YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_Qos_Input struct {
	Classifiers      *SrlNokiaInterfaces_Interface_Subinterface_Qos_Input_Classifiers      `path:"classifiers" module:"srl_nokia-qos"`
	PolicerTemplates *SrlNokiaInterfaces_Interface_Subinterface_Qos_Input_PolicerTemplates `path:"policer-templates" module:"srl_nokia-acl-policers"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_Qos_Input implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_Qos_Input) IsYANGGoStruct() {}

// GetOrCreateClassifiers retrieves the value of the Classifiers field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Qos_Input) GetOrCreateClassifiers() *SrlNokiaInterfaces_Interface_Subinterface_Qos_Input_Classifiers {
	if t.Classifiers != nil {
		return t.Classifiers
	}
	t.Classifiers = &SrlNokiaInterfaces_Interface_Subinterface_Qos_Input_Classifiers{}
	return t.Classifiers
}

// GetOrCreatePolicerTemplates retrieves the value of the PolicerTemplates field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Qos_Input) GetOrCreatePolicerTemplates() *SrlNokiaInterfaces_Interface_Subinterface_Qos_Input_PolicerTemplates {
	if t.PolicerTemplates != nil {
		return t.PolicerTemplates
	}
	t.PolicerTemplates = &SrlNokiaInterfaces_Interface_Subinterface_Qos_Input_PolicerTemplates{}
	return t.PolicerTemplates
}

// GetClassifiers returns the value of the Classifiers struct pointer
// from SrlNokiaInterfaces_Interface_Subinterface_Qos_Input. If the receiver or the field Classifiers is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Qos_Input) GetClassifiers() *SrlNokiaInterfaces_Interface_Subinterface_Qos_Input_Classifiers {
	if t != nil && t.Classifiers != nil {
		return t.Classifiers
	}
	return nil
}

// GetPolicerTemplates returns the value of the PolicerTemplates struct pointer
// from SrlNokiaInterfaces_Interface_Subinterface_Qos_Input. If the receiver or the field PolicerTemplates is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Qos_Input) GetPolicerTemplates() *SrlNokiaInterfaces_Interface_Subinterface_Qos_Input_PolicerTemplates {
	if t != nil && t.PolicerTemplates != nil {
		return t.PolicerTemplates
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_Qos_Input
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Qos_Input) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Classifiers.PopulateDefaults()
	t.PolicerTemplates.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Qos_Input) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Qos_Input"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Qos_Input) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Qos_Input) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_Qos_Input.
func (*SrlNokiaInterfaces_Interface_Subinterface_Qos_Input) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaInterfaces_Interface_Subinterface_Qos_Input_Classifiers represents the /srl_nokia-interfaces/interface/subinterface/qos/input/classifiers YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_Qos_Input_Classifiers struct {
	DefaultDropProbability E_SrlNokiaCommon_DropProbability                                                             `path:"default-drop-probability" module:"srl_nokia-qos"`
	DefaultForwardingClass SrlNokiaInterfaces_Interface_Subinterface_Qos_Input_Classifiers_DefaultForwardingClass_Union `path:"default-forwarding-class" module:"srl_nokia-qos"`
	Dot1PPolicy            *string                                                                                      `path:"dot1p-policy" module:"srl_nokia-qos"`
	DscpPolicy             *string                                                                                      `path:"dscp-policy" module:"srl_nokia-qos"`
	Ipv4DscpPolicy         *string                                                                                      `path:"ipv4-dscp-policy" module:"srl_nokia-qos"`
	Ipv6DscpPolicy         *string                                                                                      `path:"ipv6-dscp-policy" module:"srl_nokia-qos"`
	MplsTrafficClassPolicy *string                                                                                      `path:"mpls-traffic-class-policy" module:"srl_nokia-qos"`
	Multifield             *SrlNokiaInterfaces_Interface_Subinterface_Qos_Input_Classifiers_Multifield                  `path:"multifield" module:"srl_nokia-acl-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_Qos_Input_Classifiers implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_Qos_Input_Classifiers) IsYANGGoStruct() {}

// GetOrCreateMultifield retrieves the value of the Multifield field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Qos_Input_Classifiers) GetOrCreateMultifield() *SrlNokiaInterfaces_Interface_Subinterface_Qos_Input_Classifiers_Multifield {
	if t.Multifield != nil {
		return t.Multifield
	}
	t.Multifield = &SrlNokiaInterfaces_Interface_Subinterface_Qos_Input_Classifiers_Multifield{}
	return t.Multifield
}

// GetMultifield returns the value of the Multifield struct pointer
// from SrlNokiaInterfaces_Interface_Subinterface_Qos_Input_Classifiers. If the receiver or the field Multifield is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Qos_Input_Classifiers) GetMultifield() *SrlNokiaInterfaces_Interface_Subinterface_Qos_Input_Classifiers_Multifield {
	if t != nil && t.Multifield != nil {
		return t.Multifield
	}
	return nil
}

// GetDefaultDropProbability retrieves the value of the leaf DefaultDropProbability from the SrlNokiaInterfaces_Interface_Subinterface_Qos_Input_Classifiers
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DefaultDropProbability is set, it can
// safely use t.GetDefaultDropProbability() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DefaultDropProbability == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Qos_Input_Classifiers) GetDefaultDropProbability() E_SrlNokiaCommon_DropProbability {
	if t == nil || t.DefaultDropProbability == 0 {
		return 0
	}
	return t.DefaultDropProbability
}

// GetDefaultForwardingClass retrieves the value of the leaf DefaultForwardingClass from the SrlNokiaInterfaces_Interface_Subinterface_Qos_Input_Classifiers
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DefaultForwardingClass is set, it can
// safely use t.GetDefaultForwardingClass() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DefaultForwardingClass == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Qos_Input_Classifiers) GetDefaultForwardingClass() SrlNokiaInterfaces_Interface_Subinterface_Qos_Input_Classifiers_DefaultForwardingClass_Union {
	if t == nil || t.DefaultForwardingClass == nil {
		return nil
	}
	return t.DefaultForwardingClass
}

// GetDot1PPolicy retrieves the value of the leaf Dot1PPolicy from the SrlNokiaInterfaces_Interface_Subinterface_Qos_Input_Classifiers
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Dot1PPolicy is set, it can
// safely use t.GetDot1PPolicy() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Dot1PPolicy == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Qos_Input_Classifiers) GetDot1PPolicy() string {
	if t == nil || t.Dot1PPolicy == nil {
		return ""
	}
	return *t.Dot1PPolicy
}

// GetDscpPolicy retrieves the value of the leaf DscpPolicy from the SrlNokiaInterfaces_Interface_Subinterface_Qos_Input_Classifiers
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DscpPolicy is set, it can
// safely use t.GetDscpPolicy() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DscpPolicy == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Qos_Input_Classifiers) GetDscpPolicy() string {
	if t == nil || t.DscpPolicy == nil {
		return ""
	}
	return *t.DscpPolicy
}

// GetIpv4DscpPolicy retrieves the value of the leaf Ipv4DscpPolicy from the SrlNokiaInterfaces_Interface_Subinterface_Qos_Input_Classifiers
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ipv4DscpPolicy is set, it can
// safely use t.GetIpv4DscpPolicy() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ipv4DscpPolicy == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Qos_Input_Classifiers) GetIpv4DscpPolicy() string {
	if t == nil || t.Ipv4DscpPolicy == nil {
		return ""
	}
	return *t.Ipv4DscpPolicy
}

// GetIpv6DscpPolicy retrieves the value of the leaf Ipv6DscpPolicy from the SrlNokiaInterfaces_Interface_Subinterface_Qos_Input_Classifiers
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ipv6DscpPolicy is set, it can
// safely use t.GetIpv6DscpPolicy() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ipv6DscpPolicy == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Qos_Input_Classifiers) GetIpv6DscpPolicy() string {
	if t == nil || t.Ipv6DscpPolicy == nil {
		return ""
	}
	return *t.Ipv6DscpPolicy
}

// GetMplsTrafficClassPolicy retrieves the value of the leaf MplsTrafficClassPolicy from the SrlNokiaInterfaces_Interface_Subinterface_Qos_Input_Classifiers
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MplsTrafficClassPolicy is set, it can
// safely use t.GetMplsTrafficClassPolicy() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MplsTrafficClassPolicy == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Qos_Input_Classifiers) GetMplsTrafficClassPolicy() string {
	if t == nil || t.MplsTrafficClassPolicy == nil {
		return ""
	}
	return *t.MplsTrafficClassPolicy
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_Qos_Input_Classifiers
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Qos_Input_Classifiers) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Multifield.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Qos_Input_Classifiers) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Qos_Input_Classifiers"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Qos_Input_Classifiers) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Qos_Input_Classifiers) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_Qos_Input_Classifiers.
func (*SrlNokiaInterfaces_Interface_Subinterface_Qos_Input_Classifiers) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaInterfaces_Interface_Subinterface_Qos_Input_Classifiers_Multifield represents the /srl_nokia-interfaces/interface/subinterface/qos/input/classifiers/multifield YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_Qos_Input_Classifiers_Multifield struct {
	Ipv4Policy *string `path:"ipv4-policy" module:"srl_nokia-acl-qos"`
	Ipv6Policy *string `path:"ipv6-policy" module:"srl_nokia-acl-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_Qos_Input_Classifiers_Multifield implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_Qos_Input_Classifiers_Multifield) IsYANGGoStruct() {}

// GetIpv4Policy retrieves the value of the leaf Ipv4Policy from the SrlNokiaInterfaces_Interface_Subinterface_Qos_Input_Classifiers_Multifield
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ipv4Policy is set, it can
// safely use t.GetIpv4Policy() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ipv4Policy == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Qos_Input_Classifiers_Multifield) GetIpv4Policy() string {
	if t == nil || t.Ipv4Policy == nil {
		return ""
	}
	return *t.Ipv4Policy
}

// GetIpv6Policy retrieves the value of the leaf Ipv6Policy from the SrlNokiaInterfaces_Interface_Subinterface_Qos_Input_Classifiers_Multifield
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ipv6Policy is set, it can
// safely use t.GetIpv6Policy() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ipv6Policy == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Qos_Input_Classifiers_Multifield) GetIpv6Policy() string {
	if t == nil || t.Ipv6Policy == nil {
		return ""
	}
	return *t.Ipv6Policy
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_Qos_Input_Classifiers_Multifield
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Qos_Input_Classifiers_Multifield) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Qos_Input_Classifiers_Multifield) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Qos_Input_Classifiers_Multifield"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Qos_Input_Classifiers_Multifield) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Qos_Input_Classifiers_Multifield) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_Qos_Input_Classifiers_Multifield.
func (*SrlNokiaInterfaces_Interface_Subinterface_Qos_Input_Classifiers_Multifield) ΛBelongingModule() string {
	return "srl_nokia-acl-qos"
}

// SrlNokiaInterfaces_Interface_Subinterface_Qos_Input_PolicerTemplates represents the /srl_nokia-interfaces/interface/subinterface/qos/input/policer-templates YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_Qos_Input_PolicerTemplates struct {
	PolicerTemplate *string `path:"policer-template" module:"srl_nokia-acl-policers"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_Qos_Input_PolicerTemplates implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_Qos_Input_PolicerTemplates) IsYANGGoStruct() {}

// GetPolicerTemplate retrieves the value of the leaf PolicerTemplate from the SrlNokiaInterfaces_Interface_Subinterface_Qos_Input_PolicerTemplates
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PolicerTemplate is set, it can
// safely use t.GetPolicerTemplate() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PolicerTemplate == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Qos_Input_PolicerTemplates) GetPolicerTemplate() string {
	if t == nil || t.PolicerTemplate == nil {
		return ""
	}
	return *t.PolicerTemplate
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_Qos_Input_PolicerTemplates
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Qos_Input_PolicerTemplates) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Qos_Input_PolicerTemplates) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Qos_Input_PolicerTemplates"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Qos_Input_PolicerTemplates) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Qos_Input_PolicerTemplates) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_Qos_Input_PolicerTemplates.
func (*SrlNokiaInterfaces_Interface_Subinterface_Qos_Input_PolicerTemplates) ΛBelongingModule() string {
	return "srl_nokia-acl-policers"
}

// SrlNokiaInterfaces_Interface_Subinterface_Qos_Output represents the /srl_nokia-interfaces/interface/subinterface/qos/output YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_Qos_Output struct {
	RewriteRules *SrlNokiaInterfaces_Interface_Subinterface_Qos_Output_RewriteRules `path:"rewrite-rules" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_Qos_Output implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_Qos_Output) IsYANGGoStruct() {}

// GetOrCreateRewriteRules retrieves the value of the RewriteRules field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Qos_Output) GetOrCreateRewriteRules() *SrlNokiaInterfaces_Interface_Subinterface_Qos_Output_RewriteRules {
	if t.RewriteRules != nil {
		return t.RewriteRules
	}
	t.RewriteRules = &SrlNokiaInterfaces_Interface_Subinterface_Qos_Output_RewriteRules{}
	return t.RewriteRules
}

// GetRewriteRules returns the value of the RewriteRules struct pointer
// from SrlNokiaInterfaces_Interface_Subinterface_Qos_Output. If the receiver or the field RewriteRules is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Qos_Output) GetRewriteRules() *SrlNokiaInterfaces_Interface_Subinterface_Qos_Output_RewriteRules {
	if t != nil && t.RewriteRules != nil {
		return t.RewriteRules
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_Qos_Output
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Qos_Output) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.RewriteRules.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Qos_Output) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Qos_Output"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Qos_Output) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Qos_Output) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_Qos_Output.
func (*SrlNokiaInterfaces_Interface_Subinterface_Qos_Output) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaInterfaces_Interface_Subinterface_Qos_Output_RewriteRules represents the /srl_nokia-interfaces/interface/subinterface/qos/output/rewrite-rules YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_Qos_Output_RewriteRules struct {
	Dot1PPolicy            *string `path:"dot1p-policy" module:"srl_nokia-qos"`
	DscpPolicy             *string `path:"dscp-policy" module:"srl_nokia-qos"`
	Ipv4DscpPolicy         *string `path:"ipv4-dscp-policy" module:"srl_nokia-qos"`
	Ipv6DscpPolicy         *string `path:"ipv6-dscp-policy" module:"srl_nokia-qos"`
	MplsTrafficClassPolicy *string `path:"mpls-traffic-class-policy" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_Qos_Output_RewriteRules implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_Qos_Output_RewriteRules) IsYANGGoStruct() {}

// GetDot1PPolicy retrieves the value of the leaf Dot1PPolicy from the SrlNokiaInterfaces_Interface_Subinterface_Qos_Output_RewriteRules
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Dot1PPolicy is set, it can
// safely use t.GetDot1PPolicy() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Dot1PPolicy == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Qos_Output_RewriteRules) GetDot1PPolicy() string {
	if t == nil || t.Dot1PPolicy == nil {
		return ""
	}
	return *t.Dot1PPolicy
}

// GetDscpPolicy retrieves the value of the leaf DscpPolicy from the SrlNokiaInterfaces_Interface_Subinterface_Qos_Output_RewriteRules
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DscpPolicy is set, it can
// safely use t.GetDscpPolicy() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DscpPolicy == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Qos_Output_RewriteRules) GetDscpPolicy() string {
	if t == nil || t.DscpPolicy == nil {
		return ""
	}
	return *t.DscpPolicy
}

// GetIpv4DscpPolicy retrieves the value of the leaf Ipv4DscpPolicy from the SrlNokiaInterfaces_Interface_Subinterface_Qos_Output_RewriteRules
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ipv4DscpPolicy is set, it can
// safely use t.GetIpv4DscpPolicy() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ipv4DscpPolicy == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Qos_Output_RewriteRules) GetIpv4DscpPolicy() string {
	if t == nil || t.Ipv4DscpPolicy == nil {
		return ""
	}
	return *t.Ipv4DscpPolicy
}

// GetIpv6DscpPolicy retrieves the value of the leaf Ipv6DscpPolicy from the SrlNokiaInterfaces_Interface_Subinterface_Qos_Output_RewriteRules
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ipv6DscpPolicy is set, it can
// safely use t.GetIpv6DscpPolicy() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ipv6DscpPolicy == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Qos_Output_RewriteRules) GetIpv6DscpPolicy() string {
	if t == nil || t.Ipv6DscpPolicy == nil {
		return ""
	}
	return *t.Ipv6DscpPolicy
}

// GetMplsTrafficClassPolicy retrieves the value of the leaf MplsTrafficClassPolicy from the SrlNokiaInterfaces_Interface_Subinterface_Qos_Output_RewriteRules
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MplsTrafficClassPolicy is set, it can
// safely use t.GetMplsTrafficClassPolicy() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MplsTrafficClassPolicy == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Qos_Output_RewriteRules) GetMplsTrafficClassPolicy() string {
	if t == nil || t.MplsTrafficClassPolicy == nil {
		return ""
	}
	return *t.MplsTrafficClassPolicy
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_Qos_Output_RewriteRules
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Qos_Output_RewriteRules) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Qos_Output_RewriteRules) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Qos_Output_RewriteRules"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Qos_Output_RewriteRules) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Qos_Output_RewriteRules) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_Qos_Output_RewriteRules.
func (*SrlNokiaInterfaces_Interface_Subinterface_Qos_Output_RewriteRules) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaInterfaces_Interface_Subinterface_RaGuard represents the /srl_nokia-interfaces/interface/subinterface/ra-guard YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_RaGuard struct {
	Policy   *string                                                                `path:"policy" module:"srl_nokia-ra_guard"`
	VlanList map[uint16]*SrlNokiaInterfaces_Interface_Subinterface_RaGuard_VlanList `path:"vlan-list" module:"srl_nokia-ra_guard"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_RaGuard implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_RaGuard) IsYANGGoStruct() {}

// NewVlanList creates a new entry in the VlanList list of the
// SrlNokiaInterfaces_Interface_Subinterface_RaGuard struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaInterfaces_Interface_Subinterface_RaGuard) NewVlanList(VlanId uint16) (*SrlNokiaInterfaces_Interface_Subinterface_RaGuard_VlanList, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.VlanList == nil {
		t.VlanList = make(map[uint16]*SrlNokiaInterfaces_Interface_Subinterface_RaGuard_VlanList)
	}

	key := VlanId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.VlanList[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list VlanList", key)
	}

	t.VlanList[key] = &SrlNokiaInterfaces_Interface_Subinterface_RaGuard_VlanList{
		VlanId: &VlanId,
	}

	return t.VlanList[key], nil
}

// RenameVlanList renames an entry in the list VlanList within
// the SrlNokiaInterfaces_Interface_Subinterface_RaGuard struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_RaGuard) RenameVlanList(oldK, newK uint16) error {
	if _, ok := t.VlanList[newK]; ok {
		return fmt.Errorf("key %v already exists in VlanList", newK)
	}

	e, ok := t.VlanList[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in VlanList", oldK)
	}
	e.VlanId = &newK

	t.VlanList[newK] = e
	delete(t.VlanList, oldK)
	return nil
}

// GetOrCreateVlanList retrieves the value with the specified keys from
// the receiver SrlNokiaInterfaces_Interface_Subinterface_RaGuard. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaInterfaces_Interface_Subinterface_RaGuard) GetOrCreateVlanList(VlanId uint16) *SrlNokiaInterfaces_Interface_Subinterface_RaGuard_VlanList {
	key := VlanId

	if v, ok := t.VlanList[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewVlanList(VlanId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateVlanList got unexpected error: %v", err))
	}
	return v
}

// GetVlanList retrieves the value with the specified key from
// the VlanList map field of SrlNokiaInterfaces_Interface_Subinterface_RaGuard. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_RaGuard) GetVlanList(VlanId uint16) *SrlNokiaInterfaces_Interface_Subinterface_RaGuard_VlanList {
	if t == nil {
		return nil
	}

	key := VlanId

	if lm, ok := t.VlanList[key]; ok {
		return lm
	}
	return nil
}

// DeleteVlanList deletes the value with the specified keys from
// the receiver SrlNokiaInterfaces_Interface_Subinterface_RaGuard. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaInterfaces_Interface_Subinterface_RaGuard) DeleteVlanList(VlanId uint16) {
	key := VlanId

	delete(t.VlanList, key)
}

// AppendVlanList appends the supplied SrlNokiaInterfaces_Interface_Subinterface_RaGuard_VlanList struct to the
// list VlanList of SrlNokiaInterfaces_Interface_Subinterface_RaGuard. If the key value(s) specified in
// the supplied SrlNokiaInterfaces_Interface_Subinterface_RaGuard_VlanList already exist in the list, an error is
// returned.
func (t *SrlNokiaInterfaces_Interface_Subinterface_RaGuard) AppendVlanList(
	v *SrlNokiaInterfaces_Interface_Subinterface_RaGuard_VlanList,
) error {
	if v.VlanId == nil {
		return fmt.Errorf("invalid nil key received for VlanId")
	}

	key := *v.VlanId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.VlanList == nil {
		t.VlanList = make(map[uint16]*SrlNokiaInterfaces_Interface_Subinterface_RaGuard_VlanList)
	}

	if _, ok := t.VlanList[key]; ok {
		return fmt.Errorf("duplicate key for list VlanList %v", key)
	}

	t.VlanList[key] = v
	return nil
}

// GetPolicy retrieves the value of the leaf Policy from the SrlNokiaInterfaces_Interface_Subinterface_RaGuard
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Policy is set, it can
// safely use t.GetPolicy() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Policy == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_RaGuard) GetPolicy() string {
	if t == nil || t.Policy == nil {
		return ""
	}
	return *t.Policy
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_RaGuard
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_RaGuard) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.VlanList {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_RaGuard) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_RaGuard"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_RaGuard) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_RaGuard) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_RaGuard.
func (*SrlNokiaInterfaces_Interface_Subinterface_RaGuard) ΛBelongingModule() string {
	return "srl_nokia-ra_guard"
}

// SrlNokiaInterfaces_Interface_Subinterface_RaGuard_VlanList represents the /srl_nokia-interfaces/interface/subinterface/ra-guard/vlan-list YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_RaGuard_VlanList struct {
	VlanId *uint16 `path:"vlan-id" module:"srl_nokia-ra_guard"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_RaGuard_VlanList implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_RaGuard_VlanList) IsYANGGoStruct() {}

// GetVlanId retrieves the value of the leaf VlanId from the SrlNokiaInterfaces_Interface_Subinterface_RaGuard_VlanList
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VlanId is set, it can
// safely use t.GetVlanId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VlanId == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_RaGuard_VlanList) GetVlanId() uint16 {
	if t == nil || t.VlanId == nil {
		return 0
	}
	return *t.VlanId
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_RaGuard_VlanList
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_RaGuard_VlanList) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the SrlNokiaInterfaces_Interface_Subinterface_RaGuard_VlanList struct, which is a YANG list entry.
func (t *SrlNokiaInterfaces_Interface_Subinterface_RaGuard_VlanList) ΛListKeyMap() (map[string]interface{}, error) {
	if t.VlanId == nil {
		return nil, fmt.Errorf("nil value for key VlanId")
	}

	return map[string]interface{}{
		"vlan-id": *t.VlanId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_RaGuard_VlanList) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_RaGuard_VlanList"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_RaGuard_VlanList) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_RaGuard_VlanList) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_RaGuard_VlanList.
func (*SrlNokiaInterfaces_Interface_Subinterface_RaGuard_VlanList) ΛBelongingModule() string {
	return "srl_nokia-ra_guard"
}

// SrlNokiaInterfaces_Interface_Subinterface_Vlan represents the /srl_nokia-interfaces/interface/subinterface/vlan YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_Vlan struct {
	Encap         *SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap         `path:"encap" module:"srl_nokia-interfaces-vlans"`
	VlanDiscovery *SrlNokiaInterfaces_Interface_Subinterface_Vlan_VlanDiscovery `path:"vlan-discovery" module:"srl_nokia-interfaces-vlans" yangPresence:"true"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_Vlan implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_Vlan) IsYANGGoStruct() {}

// GetOrCreateEncap retrieves the value of the Encap field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Vlan) GetOrCreateEncap() *SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap {
	if t.Encap != nil {
		return t.Encap
	}
	t.Encap = &SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap{}
	return t.Encap
}

// GetOrCreateVlanDiscovery retrieves the value of the VlanDiscovery field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Vlan) GetOrCreateVlanDiscovery() *SrlNokiaInterfaces_Interface_Subinterface_Vlan_VlanDiscovery {
	if t.VlanDiscovery != nil {
		return t.VlanDiscovery
	}
	t.VlanDiscovery = &SrlNokiaInterfaces_Interface_Subinterface_Vlan_VlanDiscovery{}
	return t.VlanDiscovery
}

// GetEncap returns the value of the Encap struct pointer
// from SrlNokiaInterfaces_Interface_Subinterface_Vlan. If the receiver or the field Encap is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Vlan) GetEncap() *SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap {
	if t != nil && t.Encap != nil {
		return t.Encap
	}
	return nil
}

// GetVlanDiscovery returns the value of the VlanDiscovery struct pointer
// from SrlNokiaInterfaces_Interface_Subinterface_Vlan. If the receiver or the field VlanDiscovery is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Vlan) GetVlanDiscovery() *SrlNokiaInterfaces_Interface_Subinterface_Vlan_VlanDiscovery {
	if t != nil && t.VlanDiscovery != nil {
		return t.VlanDiscovery
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_Vlan
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Vlan) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Encap.PopulateDefaults()
	t.VlanDiscovery.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Vlan) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Vlan"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Vlan) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Vlan) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_Vlan.
func (*SrlNokiaInterfaces_Interface_Subinterface_Vlan) ΛBelongingModule() string {
	return "srl_nokia-interfaces-vlans"
}

// SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap represents the /srl_nokia-interfaces/interface/subinterface/vlan/encap YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap struct {
	DoubleTagged      *SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_DoubleTagged      `path:"double-tagged" module:"srl_nokia-interfaces-vlans" yangPresence:"true"`
	SingleTagged      *SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_SingleTagged      `path:"single-tagged" module:"srl_nokia-interfaces-vlans" yangPresence:"true"`
	SingleTaggedRange *SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_SingleTaggedRange `path:"single-tagged-range" module:"srl_nokia-interfaces-vlans" yangPresence:"true"`
	Untagged          *SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_Untagged          `path:"untagged" module:"srl_nokia-interfaces-vlans" yangPresence:"true"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap) IsYANGGoStruct() {}

// GetOrCreateDoubleTagged retrieves the value of the DoubleTagged field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap) GetOrCreateDoubleTagged() *SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_DoubleTagged {
	if t.DoubleTagged != nil {
		return t.DoubleTagged
	}
	t.DoubleTagged = &SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_DoubleTagged{}
	return t.DoubleTagged
}

// GetOrCreateSingleTagged retrieves the value of the SingleTagged field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap) GetOrCreateSingleTagged() *SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_SingleTagged {
	if t.SingleTagged != nil {
		return t.SingleTagged
	}
	t.SingleTagged = &SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_SingleTagged{}
	return t.SingleTagged
}

// GetOrCreateSingleTaggedRange retrieves the value of the SingleTaggedRange field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap) GetOrCreateSingleTaggedRange() *SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_SingleTaggedRange {
	if t.SingleTaggedRange != nil {
		return t.SingleTaggedRange
	}
	t.SingleTaggedRange = &SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_SingleTaggedRange{}
	return t.SingleTaggedRange
}

// GetOrCreateUntagged retrieves the value of the Untagged field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap) GetOrCreateUntagged() *SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_Untagged {
	if t.Untagged != nil {
		return t.Untagged
	}
	t.Untagged = &SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_Untagged{}
	return t.Untagged
}

// GetDoubleTagged returns the value of the DoubleTagged struct pointer
// from SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap. If the receiver or the field DoubleTagged is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap) GetDoubleTagged() *SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_DoubleTagged {
	if t != nil && t.DoubleTagged != nil {
		return t.DoubleTagged
	}
	return nil
}

// GetSingleTagged returns the value of the SingleTagged struct pointer
// from SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap. If the receiver or the field SingleTagged is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap) GetSingleTagged() *SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_SingleTagged {
	if t != nil && t.SingleTagged != nil {
		return t.SingleTagged
	}
	return nil
}

// GetSingleTaggedRange returns the value of the SingleTaggedRange struct pointer
// from SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap. If the receiver or the field SingleTaggedRange is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap) GetSingleTaggedRange() *SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_SingleTaggedRange {
	if t != nil && t.SingleTaggedRange != nil {
		return t.SingleTaggedRange
	}
	return nil
}

// GetUntagged returns the value of the Untagged struct pointer
// from SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap. If the receiver or the field Untagged is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap) GetUntagged() *SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_Untagged {
	if t != nil && t.Untagged != nil {
		return t.Untagged
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.DoubleTagged.PopulateDefaults()
	t.SingleTagged.PopulateDefaults()
	t.SingleTaggedRange.PopulateDefaults()
	t.Untagged.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap.
func (*SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap) ΛBelongingModule() string {
	return "srl_nokia-interfaces-vlans"
}

// SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_DoubleTagged represents the /srl_nokia-interfaces/interface/subinterface/vlan/encap/double-tagged YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_DoubleTagged struct {
	InnerVlanId SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_DoubleTagged_InnerVlanId_Union `path:"inner-vlan-id" module:"srl_nokia-interfaces-vlans"`
	OuterVlanId SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_DoubleTagged_OuterVlanId_Union `path:"outer-vlan-id" module:"srl_nokia-interfaces-vlans"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_DoubleTagged implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_DoubleTagged) IsYANGGoStruct() {}

// GetInnerVlanId retrieves the value of the leaf InnerVlanId from the SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_DoubleTagged
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InnerVlanId is set, it can
// safely use t.GetInnerVlanId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InnerVlanId == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_DoubleTagged) GetInnerVlanId() SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_DoubleTagged_InnerVlanId_Union {
	if t == nil || t.InnerVlanId == nil {
		return nil
	}
	return t.InnerVlanId
}

// GetOuterVlanId retrieves the value of the leaf OuterVlanId from the SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_DoubleTagged
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OuterVlanId is set, it can
// safely use t.GetOuterVlanId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OuterVlanId == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_DoubleTagged) GetOuterVlanId() SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_DoubleTagged_OuterVlanId_Union {
	if t == nil || t.OuterVlanId == nil {
		return nil
	}
	return t.OuterVlanId
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_DoubleTagged
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_DoubleTagged) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_DoubleTagged) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_DoubleTagged"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_DoubleTagged) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_DoubleTagged) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_DoubleTagged.
func (*SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_DoubleTagged) ΛBelongingModule() string {
	return "srl_nokia-interfaces-vlans"
}

// SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_SingleTagged represents the /srl_nokia-interfaces/interface/subinterface/vlan/encap/single-tagged YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_SingleTagged struct {
	VlanId SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_SingleTagged_VlanId_Union `path:"vlan-id" module:"srl_nokia-interfaces-vlans"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_SingleTagged implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_SingleTagged) IsYANGGoStruct() {}

// GetVlanId retrieves the value of the leaf VlanId from the SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_SingleTagged
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VlanId is set, it can
// safely use t.GetVlanId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VlanId == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_SingleTagged) GetVlanId() SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_SingleTagged_VlanId_Union {
	if t == nil || t.VlanId == nil {
		return nil
	}
	return t.VlanId
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_SingleTagged
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_SingleTagged) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_SingleTagged) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_SingleTagged"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_SingleTagged) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_SingleTagged) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_SingleTagged.
func (*SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_SingleTagged) ΛBelongingModule() string {
	return "srl_nokia-interfaces-vlans"
}

// SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_SingleTaggedRange represents the /srl_nokia-interfaces/interface/subinterface/vlan/encap/single-tagged-range YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_SingleTaggedRange struct {
	LowVlanId map[uint16]*SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_SingleTaggedRange_LowVlanId `path:"low-vlan-id" module:"srl_nokia-interfaces-vlans"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_SingleTaggedRange implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_SingleTaggedRange) IsYANGGoStruct() {}

// NewLowVlanId creates a new entry in the LowVlanId list of the
// SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_SingleTaggedRange struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_SingleTaggedRange) NewLowVlanId(
	RangeLowVlanId uint16,
) (*SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_SingleTaggedRange_LowVlanId, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.LowVlanId == nil {
		t.LowVlanId = make(map[uint16]*SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_SingleTaggedRange_LowVlanId)
	}

	key := RangeLowVlanId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.LowVlanId[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list LowVlanId", key)
	}

	t.LowVlanId[key] = &SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_SingleTaggedRange_LowVlanId{
		RangeLowVlanId: &RangeLowVlanId,
	}

	return t.LowVlanId[key], nil
}

// RenameLowVlanId renames an entry in the list LowVlanId within
// the SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_SingleTaggedRange struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_SingleTaggedRange) RenameLowVlanId(oldK, newK uint16) error {
	if _, ok := t.LowVlanId[newK]; ok {
		return fmt.Errorf("key %v already exists in LowVlanId", newK)
	}

	e, ok := t.LowVlanId[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in LowVlanId", oldK)
	}
	e.RangeLowVlanId = &newK

	t.LowVlanId[newK] = e
	delete(t.LowVlanId, oldK)
	return nil
}

// GetOrCreateLowVlanId retrieves the value with the specified keys from
// the receiver SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_SingleTaggedRange. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_SingleTaggedRange) GetOrCreateLowVlanId(
	RangeLowVlanId uint16,
) *SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_SingleTaggedRange_LowVlanId {
	key := RangeLowVlanId

	if v, ok := t.LowVlanId[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewLowVlanId(RangeLowVlanId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateLowVlanId got unexpected error: %v", err))
	}
	return v
}

// GetLowVlanId retrieves the value with the specified key from
// the LowVlanId map field of SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_SingleTaggedRange. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_SingleTaggedRange) GetLowVlanId(
	RangeLowVlanId uint16,
) *SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_SingleTaggedRange_LowVlanId {
	if t == nil {
		return nil
	}

	key := RangeLowVlanId

	if lm, ok := t.LowVlanId[key]; ok {
		return lm
	}
	return nil
}

// DeleteLowVlanId deletes the value with the specified keys from
// the receiver SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_SingleTaggedRange. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_SingleTaggedRange) DeleteLowVlanId(RangeLowVlanId uint16) {
	key := RangeLowVlanId

	delete(t.LowVlanId, key)
}

// AppendLowVlanId appends the supplied SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_SingleTaggedRange_LowVlanId struct to the
// list LowVlanId of SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_SingleTaggedRange. If the key value(s) specified in
// the supplied SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_SingleTaggedRange_LowVlanId already exist in the list, an error is
// returned.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_SingleTaggedRange) AppendLowVlanId(
	v *SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_SingleTaggedRange_LowVlanId,
) error {
	if v.RangeLowVlanId == nil {
		return fmt.Errorf("invalid nil key received for RangeLowVlanId")
	}

	key := *v.RangeLowVlanId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.LowVlanId == nil {
		t.LowVlanId = make(map[uint16]*SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_SingleTaggedRange_LowVlanId)
	}

	if _, ok := t.LowVlanId[key]; ok {
		return fmt.Errorf("duplicate key for list LowVlanId %v", key)
	}

	t.LowVlanId[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_SingleTaggedRange
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_SingleTaggedRange) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.LowVlanId {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_SingleTaggedRange) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_SingleTaggedRange"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_SingleTaggedRange) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_SingleTaggedRange) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_SingleTaggedRange.
func (*SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_SingleTaggedRange) ΛBelongingModule() string {
	return "srl_nokia-interfaces-vlans"
}

// SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_SingleTaggedRange_LowVlanId represents the /srl_nokia-interfaces/interface/subinterface/vlan/encap/single-tagged-range/low-vlan-id YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_SingleTaggedRange_LowVlanId struct {
	HighVlanId     *uint16 `path:"high-vlan-id" module:"srl_nokia-interfaces-vlans"`
	RangeLowVlanId *uint16 `path:"range-low-vlan-id" module:"srl_nokia-interfaces-vlans"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_SingleTaggedRange_LowVlanId implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_SingleTaggedRange_LowVlanId) IsYANGGoStruct() {
}

// GetHighVlanId retrieves the value of the leaf HighVlanId from the SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_SingleTaggedRange_LowVlanId
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if HighVlanId is set, it can
// safely use t.GetHighVlanId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.HighVlanId == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_SingleTaggedRange_LowVlanId) GetHighVlanId() uint16 {
	if t == nil || t.HighVlanId == nil {
		return 0
	}
	return *t.HighVlanId
}

// GetRangeLowVlanId retrieves the value of the leaf RangeLowVlanId from the SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_SingleTaggedRange_LowVlanId
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RangeLowVlanId is set, it can
// safely use t.GetRangeLowVlanId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RangeLowVlanId == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_SingleTaggedRange_LowVlanId) GetRangeLowVlanId() uint16 {
	if t == nil || t.RangeLowVlanId == nil {
		return 0
	}
	return *t.RangeLowVlanId
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_SingleTaggedRange_LowVlanId
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_SingleTaggedRange_LowVlanId) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_SingleTaggedRange_LowVlanId struct, which is a YANG list entry.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_SingleTaggedRange_LowVlanId) ΛListKeyMap() (map[string]interface{}, error) {
	if t.RangeLowVlanId == nil {
		return nil, fmt.Errorf("nil value for key RangeLowVlanId")
	}

	return map[string]interface{}{
		"range-low-vlan-id": *t.RangeLowVlanId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_SingleTaggedRange_LowVlanId) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_SingleTaggedRange_LowVlanId"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_SingleTaggedRange_LowVlanId) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_SingleTaggedRange_LowVlanId) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_SingleTaggedRange_LowVlanId.
func (*SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_SingleTaggedRange_LowVlanId) ΛBelongingModule() string {
	return "srl_nokia-interfaces-vlans"
}

// SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_Untagged represents the /srl_nokia-interfaces/interface/subinterface/vlan/encap/untagged YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_Untagged struct{}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_Untagged implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_Untagged) IsYANGGoStruct() {}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_Untagged
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_Untagged) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_Untagged) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_Untagged"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_Untagged) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_Untagged) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_Untagged.
func (*SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_Untagged) ΛBelongingModule() string {
	return "srl_nokia-interfaces-vlans"
}

// SrlNokiaInterfaces_Interface_Subinterface_Vlan_VlanDiscovery represents the /srl_nokia-interfaces/interface/subinterface/vlan/vlan-discovery YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_Vlan_VlanDiscovery struct {
	Type E_SrlNokiaInterfacesVlans_VlanDiscoveryAddressType `path:"type" module:"srl_nokia-interfaces-vlans"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_Vlan_VlanDiscovery implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_Vlan_VlanDiscovery) IsYANGGoStruct() {}

// GetType retrieves the value of the leaf Type from the SrlNokiaInterfaces_Interface_Subinterface_Vlan_VlanDiscovery
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Type is set, it can
// safely use t.GetType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Type == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Vlan_VlanDiscovery) GetType() E_SrlNokiaInterfacesVlans_VlanDiscoveryAddressType {
	if t == nil || t.Type == 0 {
		return SrlNokiaInterfacesVlans_VlanDiscoveryAddressType_IPv4v6
	}
	return t.Type
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_Vlan_VlanDiscovery
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Vlan_VlanDiscovery) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Type == 0 {
		t.Type = SrlNokiaInterfacesVlans_VlanDiscoveryAddressType_IPv4v6
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Vlan_VlanDiscovery) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Vlan_VlanDiscovery"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Vlan_VlanDiscovery) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Vlan_VlanDiscovery) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_Vlan_VlanDiscovery.
func (*SrlNokiaInterfaces_Interface_Subinterface_Vlan_VlanDiscovery) ΛBelongingModule() string {
	return "srl_nokia-interfaces-vlans"
}

// SrlNokiaInterfaces_Interface_Transceiver represents the /srl_nokia-interfaces/interface/transceiver YANG schema element.
type SrlNokiaInterfaces_Interface_Transceiver struct {
	DdmEvents              *bool                                                             `path:"ddm-events" module:"srl_nokia-interfaces"`
	ForwardErrorCorrection E_SrlNokiaInterfaces_Interface_Transceiver_ForwardErrorCorrection `path:"forward-error-correction" module:"srl_nokia-interfaces"`
	FunctionalType         E_SrlNokiaInterfaces_TransceiverFunctionalType                    `path:"functional-type" module:"srl_nokia-interfaces"`
	TxLaser                *bool                                                             `path:"tx-laser" module:"srl_nokia-interfaces"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Transceiver implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Transceiver) IsYANGGoStruct() {}

// GetDdmEvents retrieves the value of the leaf DdmEvents from the SrlNokiaInterfaces_Interface_Transceiver
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DdmEvents is set, it can
// safely use t.GetDdmEvents() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DdmEvents == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Transceiver) GetDdmEvents() bool {
	if t == nil || t.DdmEvents == nil {
		return false
	}
	return *t.DdmEvents
}

// GetForwardErrorCorrection retrieves the value of the leaf ForwardErrorCorrection from the SrlNokiaInterfaces_Interface_Transceiver
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ForwardErrorCorrection is set, it can
// safely use t.GetForwardErrorCorrection() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ForwardErrorCorrection == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Transceiver) GetForwardErrorCorrection() E_SrlNokiaInterfaces_Interface_Transceiver_ForwardErrorCorrection {
	if t == nil || t.ForwardErrorCorrection == 0 {
		return 0
	}
	return t.ForwardErrorCorrection
}

// GetFunctionalType retrieves the value of the leaf FunctionalType from the SrlNokiaInterfaces_Interface_Transceiver
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FunctionalType is set, it can
// safely use t.GetFunctionalType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FunctionalType == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Transceiver) GetFunctionalType() E_SrlNokiaInterfaces_TransceiverFunctionalType {
	if t == nil || t.FunctionalType == 0 {
		return 0
	}
	return t.FunctionalType
}

// GetTxLaser retrieves the value of the leaf TxLaser from the SrlNokiaInterfaces_Interface_Transceiver
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TxLaser is set, it can
// safely use t.GetTxLaser() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TxLaser == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Transceiver) GetTxLaser() bool {
	if t == nil || t.TxLaser == nil {
		return false
	}
	return *t.TxLaser
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Transceiver
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Transceiver) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Transceiver) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Transceiver"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Transceiver) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Transceiver) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Transceiver.
func (*SrlNokiaInterfaces_Interface_Transceiver) ΛBelongingModule() string {
	return "srl_nokia-interfaces"
}

// SrlNokiaInterfaces_Interface_Vhost represents the /srl_nokia-interfaces/interface/vhost YANG schema element.
type SrlNokiaInterfaces_Interface_Vhost struct {
	VhostSocketMode   E_SrlNokiaInterfaces_Interface_Vhost_VhostSocketMode `path:"vhost-socket-mode" module:"srl_nokia-interfaces-vxdp"`
	VhostSocketPath   *string                                              `path:"vhost-socket-path" module:"srl_nokia-interfaces-vxdp"`
	VhostSocketQueues *uint16                                              `path:"vhost-socket-queues" module:"srl_nokia-interfaces-vxdp"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Vhost implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Vhost) IsYANGGoStruct() {}

// GetVhostSocketMode retrieves the value of the leaf VhostSocketMode from the SrlNokiaInterfaces_Interface_Vhost
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VhostSocketMode is set, it can
// safely use t.GetVhostSocketMode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VhostSocketMode == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Vhost) GetVhostSocketMode() E_SrlNokiaInterfaces_Interface_Vhost_VhostSocketMode {
	if t == nil || t.VhostSocketMode == 0 {
		return SrlNokiaInterfaces_Interface_Vhost_VhostSocketMode_client
	}
	return t.VhostSocketMode
}

// GetVhostSocketPath retrieves the value of the leaf VhostSocketPath from the SrlNokiaInterfaces_Interface_Vhost
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VhostSocketPath is set, it can
// safely use t.GetVhostSocketPath() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VhostSocketPath == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Vhost) GetVhostSocketPath() string {
	if t == nil || t.VhostSocketPath == nil {
		return ""
	}
	return *t.VhostSocketPath
}

// GetVhostSocketQueues retrieves the value of the leaf VhostSocketQueues from the SrlNokiaInterfaces_Interface_Vhost
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VhostSocketQueues is set, it can
// safely use t.GetVhostSocketQueues() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VhostSocketQueues == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Vhost) GetVhostSocketQueues() uint16 {
	if t == nil || t.VhostSocketQueues == nil {
		return 0
	}
	return *t.VhostSocketQueues
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Vhost
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Vhost) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.VhostSocketMode == 0 {
		t.VhostSocketMode = SrlNokiaInterfaces_Interface_Vhost_VhostSocketMode_client
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Vhost) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Vhost"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Vhost) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Vhost) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Vhost.
func (*SrlNokiaInterfaces_Interface_Vhost) ΛBelongingModule() string {
	return "srl_nokia-interfaces-vxdp"
}

// SrlNokiaNetworkInstance_NetworkInstance represents the /srl_nokia-network-instance/network-instance YANG schema element.
type SrlNokiaNetworkInstance_NetworkInstance struct {
	AdminState                 E_SrlNokiaCommon_AdminState                                         `path:"admin-state" module:"srl_nokia-network-instance"`
	AggregateRoutes            *SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes            `path:"aggregate-routes" module:"srl_nokia-aggregate-routes" yangPresence:"true"`
	BridgeTable                *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable                `path:"bridge-table" module:"srl_nokia-network-instance" yangPresence:"true"`
	ConnectionPoint            map[string]*SrlNokiaNetworkInstance_NetworkInstance_ConnectionPoint `path:"connection-point" module:"srl_nokia-network-instance"`
	Description                *string                                                             `path:"description" module:"srl_nokia-network-instance"`
	InterInstancePolicies      *SrlNokiaNetworkInstance_NetworkInstance_InterInstancePolicies      `path:"inter-instance-policies" module:"srl_nokia-network-instance"`
	Interface                  map[string]*SrlNokiaNetworkInstance_NetworkInstance_Interface       `path:"interface" module:"srl_nokia-network-instance"`
	IpForwarding               *SrlNokiaNetworkInstance_NetworkInstance_IpForwarding               `path:"ip-forwarding" module:"srl_nokia-network-instance" yangPresence:"true"`
	IpLoadBalancing            *SrlNokiaNetworkInstance_NetworkInstance_IpLoadBalancing            `path:"ip-load-balancing" module:"srl_nokia-network-instance"`
	MaintenancePolicies        *SrlNokiaNetworkInstance_NetworkInstance_MaintenancePolicies        `path:"maintenance-policies" module:"srl_nokia-maintenance-policies" yangPresence:"true"`
	Mpls                       *SrlNokiaNetworkInstance_NetworkInstance_Mpls                       `path:"mpls" module:"srl_nokia-mpls" yangPresence:"true"`
	MplsForwarding             *SrlNokiaNetworkInstance_NetworkInstance_MplsForwarding             `path:"mpls-forwarding" module:"srl_nokia-network-instance"`
	Mtu                        *SrlNokiaNetworkInstance_NetworkInstance_Mtu                        `path:"mtu" module:"srl_nokia-network-instance-mtu" yangPresence:"true"`
	MulticastL3Vpn             *SrlNokiaNetworkInstance_NetworkInstance_MulticastL3Vpn             `path:"multicast-l3-vpn" module:"srl_nokia-mvpn-l3" yangPresence:"true"`
	Name                       *string                                                             `path:"name" module:"srl_nokia-network-instance"`
	NextHopGroups              *SrlNokiaNetworkInstance_NetworkInstance_NextHopGroups              `path:"next-hop-groups" module:"srl_nokia-next-hop-groups" yangPresence:"true"`
	PolicyForwarding           *SrlNokiaNetworkInstance_NetworkInstance_PolicyForwarding           `path:"policy-forwarding" module:"srl_nokia-policy-forwarding" yangPresence:"true"`
	Protocols                  *SrlNokiaNetworkInstance_NetworkInstance_Protocols                  `path:"protocols" module:"srl_nokia-network-instance"`
	RouterId                   *string                                                             `path:"router-id" module:"srl_nokia-network-instance"`
	SegmentRouting             *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting             `path:"segment-routing" module:"srl_nokia-segment-routing"`
	StaticRoutes               *SrlNokiaNetworkInstance_NetworkInstance_StaticRoutes               `path:"static-routes" module:"srl_nokia-static-routes" yangPresence:"true"`
	TrafficEngineering         *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering         `path:"traffic-engineering" module:"srl_nokia-traffic-engineering" yangPresence:"true"`
	TrafficEngineeringPolicies *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineeringPolicies `path:"traffic-engineering-policies" module:"srl_nokia-te-policies" yangPresence:"true"`
	Type                       E_SrlNokiaNetworkInstance_NiType                                    `path:"type" module:"srl_nokia-network-instance"`
	VxlanInterface             map[string]*SrlNokiaNetworkInstance_NetworkInstance_VxlanInterface  `path:"vxlan-interface" module:"srl_nokia-network-instance"`
}

// IsYANGGoStruct ensures that SrlNokiaNetworkInstance_NetworkInstance implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaNetworkInstance_NetworkInstance) IsYANGGoStruct() {}

// NewConnectionPoint creates a new entry in the ConnectionPoint list of the
// SrlNokiaNetworkInstance_NetworkInstance struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaNetworkInstance_NetworkInstance) NewConnectionPoint(Name string) (*SrlNokiaNetworkInstance_NetworkInstance_ConnectionPoint, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ConnectionPoint == nil {
		t.ConnectionPoint = make(map[string]*SrlNokiaNetworkInstance_NetworkInstance_ConnectionPoint)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.ConnectionPoint[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list ConnectionPoint", key)
	}

	t.ConnectionPoint[key] = &SrlNokiaNetworkInstance_NetworkInstance_ConnectionPoint{
		Name: &Name,
	}

	return t.ConnectionPoint[key], nil
}

// RenameConnectionPoint renames an entry in the list ConnectionPoint within
// the SrlNokiaNetworkInstance_NetworkInstance struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaNetworkInstance_NetworkInstance) RenameConnectionPoint(oldK, newK string) error {
	if _, ok := t.ConnectionPoint[newK]; ok {
		return fmt.Errorf("key %v already exists in ConnectionPoint", newK)
	}

	e, ok := t.ConnectionPoint[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in ConnectionPoint", oldK)
	}
	e.Name = &newK

	t.ConnectionPoint[newK] = e
	delete(t.ConnectionPoint, oldK)
	return nil
}

// GetOrCreateConnectionPoint retrieves the value with the specified keys from
// the receiver SrlNokiaNetworkInstance_NetworkInstance. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaNetworkInstance_NetworkInstance) GetOrCreateConnectionPoint(Name string) *SrlNokiaNetworkInstance_NetworkInstance_ConnectionPoint {
	key := Name

	if v, ok := t.ConnectionPoint[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewConnectionPoint(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateConnectionPoint got unexpected error: %v", err))
	}
	return v
}

// GetConnectionPoint retrieves the value with the specified key from
// the ConnectionPoint map field of SrlNokiaNetworkInstance_NetworkInstance. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaNetworkInstance_NetworkInstance) GetConnectionPoint(Name string) *SrlNokiaNetworkInstance_NetworkInstance_ConnectionPoint {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.ConnectionPoint[key]; ok {
		return lm
	}
	return nil
}

// DeleteConnectionPoint deletes the value with the specified keys from
// the receiver SrlNokiaNetworkInstance_NetworkInstance. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaNetworkInstance_NetworkInstance) DeleteConnectionPoint(Name string) {
	key := Name

	delete(t.ConnectionPoint, key)
}

// AppendConnectionPoint appends the supplied SrlNokiaNetworkInstance_NetworkInstance_ConnectionPoint struct to the
// list ConnectionPoint of SrlNokiaNetworkInstance_NetworkInstance. If the key value(s) specified in
// the supplied SrlNokiaNetworkInstance_NetworkInstance_ConnectionPoint already exist in the list, an error is
// returned.
func (t *SrlNokiaNetworkInstance_NetworkInstance) AppendConnectionPoint(
	v *SrlNokiaNetworkInstance_NetworkInstance_ConnectionPoint,
) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ConnectionPoint == nil {
		t.ConnectionPoint = make(map[string]*SrlNokiaNetworkInstance_NetworkInstance_ConnectionPoint)
	}

	if _, ok := t.ConnectionPoint[key]; ok {
		return fmt.Errorf("duplicate key for list ConnectionPoint %v", key)
	}

	t.ConnectionPoint[key] = v
	return nil
}

// NewInterface creates a new entry in the Interface list of the
// SrlNokiaNetworkInstance_NetworkInstance struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaNetworkInstance_NetworkInstance) NewInterface(Name string) (*SrlNokiaNetworkInstance_NetworkInstance_Interface, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*SrlNokiaNetworkInstance_NetworkInstance_Interface)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Interface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Interface", key)
	}

	t.Interface[key] = &SrlNokiaNetworkInstance_NetworkInstance_Interface{
		Name: &Name,
	}

	return t.Interface[key], nil
}

// RenameInterface renames an entry in the list Interface within
// the SrlNokiaNetworkInstance_NetworkInstance struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaNetworkInstance_NetworkInstance) RenameInterface(oldK, newK string) error {
	if _, ok := t.Interface[newK]; ok {
		return fmt.Errorf("key %v already exists in Interface", newK)
	}

	e, ok := t.Interface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Interface", oldK)
	}
	e.Name = &newK

	t.Interface[newK] = e
	delete(t.Interface, oldK)
	return nil
}

// GetOrCreateInterface retrieves the value with the specified keys from
// the receiver SrlNokiaNetworkInstance_NetworkInstance. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaNetworkInstance_NetworkInstance) GetOrCreateInterface(Name string) *SrlNokiaNetworkInstance_NetworkInstance_Interface {
	key := Name

	if v, ok := t.Interface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInterface(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInterface got unexpected error: %v", err))
	}
	return v
}

// GetInterface retrieves the value with the specified key from
// the Interface map field of SrlNokiaNetworkInstance_NetworkInstance. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaNetworkInstance_NetworkInstance) GetInterface(Name string) *SrlNokiaNetworkInstance_NetworkInstance_Interface {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Interface[key]; ok {
		return lm
	}
	return nil
}

// DeleteInterface deletes the value with the specified keys from
// the receiver SrlNokiaNetworkInstance_NetworkInstance. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaNetworkInstance_NetworkInstance) DeleteInterface(Name string) {
	key := Name

	delete(t.Interface, key)
}

// AppendInterface appends the supplied SrlNokiaNetworkInstance_NetworkInstance_Interface struct to the
// list Interface of SrlNokiaNetworkInstance_NetworkInstance. If the key value(s) specified in
// the supplied SrlNokiaNetworkInstance_NetworkInstance_Interface already exist in the list, an error is
// returned.
func (t *SrlNokiaNetworkInstance_NetworkInstance) AppendInterface(
	v *SrlNokiaNetworkInstance_NetworkInstance_Interface,
) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*SrlNokiaNetworkInstance_NetworkInstance_Interface)
	}

	if _, ok := t.Interface[key]; ok {
		return fmt.Errorf("duplicate key for list Interface %v", key)
	}

	t.Interface[key] = v
	return nil
}

// NewVxlanInterface creates a new entry in the VxlanInterface list of the
// SrlNokiaNetworkInstance_NetworkInstance struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaNetworkInstance_NetworkInstance) NewVxlanInterface(Name string) (*SrlNokiaNetworkInstance_NetworkInstance_VxlanInterface, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.VxlanInterface == nil {
		t.VxlanInterface = make(map[string]*SrlNokiaNetworkInstance_NetworkInstance_VxlanInterface)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.VxlanInterface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list VxlanInterface", key)
	}

	t.VxlanInterface[key] = &SrlNokiaNetworkInstance_NetworkInstance_VxlanInterface{
		Name: &Name,
	}

	return t.VxlanInterface[key], nil
}

// RenameVxlanInterface renames an entry in the list VxlanInterface within
// the SrlNokiaNetworkInstance_NetworkInstance struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaNetworkInstance_NetworkInstance) RenameVxlanInterface(oldK, newK string) error {
	if _, ok := t.VxlanInterface[newK]; ok {
		return fmt.Errorf("key %v already exists in VxlanInterface", newK)
	}

	e, ok := t.VxlanInterface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in VxlanInterface", oldK)
	}
	e.Name = &newK

	t.VxlanInterface[newK] = e
	delete(t.VxlanInterface, oldK)
	return nil
}

// GetOrCreateVxlanInterface retrieves the value with the specified keys from
// the receiver SrlNokiaNetworkInstance_NetworkInstance. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaNetworkInstance_NetworkInstance) GetOrCreateVxlanInterface(Name string) *SrlNokiaNetworkInstance_NetworkInstance_VxlanInterface {
	key := Name

	if v, ok := t.VxlanInterface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewVxlanInterface(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateVxlanInterface got unexpected error: %v", err))
	}
	return v
}

// GetVxlanInterface retrieves the value with the specified key from
// the VxlanInterface map field of SrlNokiaNetworkInstance_NetworkInstance. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaNetworkInstance_NetworkInstance) GetVxlanInterface(Name string) *SrlNokiaNetworkInstance_NetworkInstance_VxlanInterface {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.VxlanInterface[key]; ok {
		return lm
	}
	return nil
}

// DeleteVxlanInterface deletes the value with the specified keys from
// the receiver SrlNokiaNetworkInstance_NetworkInstance. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaNetworkInstance_NetworkInstance) DeleteVxlanInterface(Name string) {
	key := Name

	delete(t.VxlanInterface, key)
}

// AppendVxlanInterface appends the supplied SrlNokiaNetworkInstance_NetworkInstance_VxlanInterface struct to the
// list VxlanInterface of SrlNokiaNetworkInstance_NetworkInstance. If the key value(s) specified in
// the supplied SrlNokiaNetworkInstance_NetworkInstance_VxlanInterface already exist in the list, an error is
// returned.
func (t *SrlNokiaNetworkInstance_NetworkInstance) AppendVxlanInterface(
	v *SrlNokiaNetworkInstance_NetworkInstance_VxlanInterface,
) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.VxlanInterface == nil {
		t.VxlanInterface = make(map[string]*SrlNokiaNetworkInstance_NetworkInstance_VxlanInterface)
	}

	if _, ok := t.VxlanInterface[key]; ok {
		return fmt.Errorf("duplicate key for list VxlanInterface %v", key)
	}

	t.VxlanInterface[key] = v
	return nil
}

// GetOrCreateAggregateRoutes retrieves the value of the AggregateRoutes field
// or returns the existing field if it already exists.
func (t *SrlNokiaNetworkInstance_NetworkInstance) GetOrCreateAggregateRoutes() *SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes {
	if t.AggregateRoutes != nil {
		return t.AggregateRoutes
	}
	t.AggregateRoutes = &SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes{}
	return t.AggregateRoutes
}

// GetOrCreateBridgeTable retrieves the value of the BridgeTable field
// or returns the existing field if it already exists.
func (t *SrlNokiaNetworkInstance_NetworkInstance) GetOrCreateBridgeTable() *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable {
	if t.BridgeTable != nil {
		return t.BridgeTable
	}
	t.BridgeTable = &SrlNokiaNetworkInstance_NetworkInstance_BridgeTable{}
	return t.BridgeTable
}

// GetOrCreateInterInstancePolicies retrieves the value of the InterInstancePolicies field
// or returns the existing field if it already exists.
func (t *SrlNokiaNetworkInstance_NetworkInstance) GetOrCreateInterInstancePolicies() *SrlNokiaNetworkInstance_NetworkInstance_InterInstancePolicies {
	if t.InterInstancePolicies != nil {
		return t.InterInstancePolicies
	}
	t.InterInstancePolicies = &SrlNokiaNetworkInstance_NetworkInstance_InterInstancePolicies{}
	return t.InterInstancePolicies
}

// GetOrCreateIpForwarding retrieves the value of the IpForwarding field
// or returns the existing field if it already exists.
func (t *SrlNokiaNetworkInstance_NetworkInstance) GetOrCreateIpForwarding() *SrlNokiaNetworkInstance_NetworkInstance_IpForwarding {
	if t.IpForwarding != nil {
		return t.IpForwarding
	}
	t.IpForwarding = &SrlNokiaNetworkInstance_NetworkInstance_IpForwarding{}
	return t.IpForwarding
}

// GetOrCreateIpLoadBalancing retrieves the value of the IpLoadBalancing field
// or returns the existing field if it already exists.
func (t *SrlNokiaNetworkInstance_NetworkInstance) GetOrCreateIpLoadBalancing() *SrlNokiaNetworkInstance_NetworkInstance_IpLoadBalancing {
	if t.IpLoadBalancing != nil {
		return t.IpLoadBalancing
	}
	t.IpLoadBalancing = &SrlNokiaNetworkInstance_NetworkInstance_IpLoadBalancing{}
	return t.IpLoadBalancing
}

// GetOrCreateMaintenancePolicies retrieves the value of the MaintenancePolicies field
// or returns the existing field if it already exists.
func (t *SrlNokiaNetworkInstance_NetworkInstance) GetOrCreateMaintenancePolicies() *SrlNokiaNetworkInstance_NetworkInstance_MaintenancePolicies {
	if t.MaintenancePolicies != nil {
		return t.MaintenancePolicies
	}
	t.MaintenancePolicies = &SrlNokiaNetworkInstance_NetworkInstance_MaintenancePolicies{}
	return t.MaintenancePolicies
}

// GetOrCreateMpls retrieves the value of the Mpls field
// or returns the existing field if it already exists.
func (t *SrlNokiaNetworkInstance_NetworkInstance) GetOrCreateMpls() *SrlNokiaNetworkInstance_NetworkInstance_Mpls {
	if t.Mpls != nil {
		return t.Mpls
	}
	t.Mpls = &SrlNokiaNetworkInstance_NetworkInstance_Mpls{}
	return t.Mpls
}

// GetOrCreateMplsForwarding retrieves the value of the MplsForwarding field
// or returns the existing field if it already exists.
func (t *SrlNokiaNetworkInstance_NetworkInstance) GetOrCreateMplsForwarding() *SrlNokiaNetworkInstance_NetworkInstance_MplsForwarding {
	if t.MplsForwarding != nil {
		return t.MplsForwarding
	}
	t.MplsForwarding = &SrlNokiaNetworkInstance_NetworkInstance_MplsForwarding{}
	return t.MplsForwarding
}

// GetOrCreateMtu retrieves the value of the Mtu field
// or returns the existing field if it already exists.
func (t *SrlNokiaNetworkInstance_NetworkInstance) GetOrCreateMtu() *SrlNokiaNetworkInstance_NetworkInstance_Mtu {
	if t.Mtu != nil {
		return t.Mtu
	}
	t.Mtu = &SrlNokiaNetworkInstance_NetworkInstance_Mtu{}
	return t.Mtu
}

// GetOrCreateMulticastL3Vpn retrieves the value of the MulticastL3Vpn field
// or returns the existing field if it already exists.
func (t *SrlNokiaNetworkInstance_NetworkInstance) GetOrCreateMulticastL3Vpn() *SrlNokiaNetworkInstance_NetworkInstance_MulticastL3Vpn {
	if t.MulticastL3Vpn != nil {
		return t.MulticastL3Vpn
	}
	t.MulticastL3Vpn = &SrlNokiaNetworkInstance_NetworkInstance_MulticastL3Vpn{}
	return t.MulticastL3Vpn
}

// GetOrCreateNextHopGroups retrieves the value of the NextHopGroups field
// or returns the existing field if it already exists.
func (t *SrlNokiaNetworkInstance_NetworkInstance) GetOrCreateNextHopGroups() *SrlNokiaNetworkInstance_NetworkInstance_NextHopGroups {
	if t.NextHopGroups != nil {
		return t.NextHopGroups
	}
	t.NextHopGroups = &SrlNokiaNetworkInstance_NetworkInstance_NextHopGroups{}
	return t.NextHopGroups
}

// GetOrCreatePolicyForwarding retrieves the value of the PolicyForwarding field
// or returns the existing field if it already exists.
func (t *SrlNokiaNetworkInstance_NetworkInstance) GetOrCreatePolicyForwarding() *SrlNokiaNetworkInstance_NetworkInstance_PolicyForwarding {
	if t.PolicyForwarding != nil {
		return t.PolicyForwarding
	}
	t.PolicyForwarding = &SrlNokiaNetworkInstance_NetworkInstance_PolicyForwarding{}
	return t.PolicyForwarding
}

// GetOrCreateProtocols retrieves the value of the Protocols field
// or returns the existing field if it already exists.
func (t *SrlNokiaNetworkInstance_NetworkInstance) GetOrCreateProtocols() *SrlNokiaNetworkInstance_NetworkInstance_Protocols {
	if t.Protocols != nil {
		return t.Protocols
	}
	t.Protocols = &SrlNokiaNetworkInstance_NetworkInstance_Protocols{}
	return t.Protocols
}

// GetOrCreateSegmentRouting retrieves the value of the SegmentRouting field
// or returns the existing field if it already exists.
func (t *SrlNokiaNetworkInstance_NetworkInstance) GetOrCreateSegmentRouting() *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting {
	if t.SegmentRouting != nil {
		return t.SegmentRouting
	}
	t.SegmentRouting = &SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting{}
	return t.SegmentRouting
}

// GetOrCreateStaticRoutes retrieves the value of the StaticRoutes field
// or returns the existing field if it already exists.
func (t *SrlNokiaNetworkInstance_NetworkInstance) GetOrCreateStaticRoutes() *SrlNokiaNetworkInstance_NetworkInstance_StaticRoutes {
	if t.StaticRoutes != nil {
		return t.StaticRoutes
	}
	t.StaticRoutes = &SrlNokiaNetworkInstance_NetworkInstance_StaticRoutes{}
	return t.StaticRoutes
}

// GetOrCreateTrafficEngineering retrieves the value of the TrafficEngineering field
// or returns the existing field if it already exists.
func (t *SrlNokiaNetworkInstance_NetworkInstance) GetOrCreateTrafficEngineering() *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering {
	if t.TrafficEngineering != nil {
		return t.TrafficEngineering
	}
	t.TrafficEngineering = &SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering{}
	return t.TrafficEngineering
}

// GetOrCreateTrafficEngineeringPolicies retrieves the value of the TrafficEngineeringPolicies field
// or returns the existing field if it already exists.
func (t *SrlNokiaNetworkInstance_NetworkInstance) GetOrCreateTrafficEngineeringPolicies() *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineeringPolicies {
	if t.TrafficEngineeringPolicies != nil {
		return t.TrafficEngineeringPolicies
	}
	t.TrafficEngineeringPolicies = &SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineeringPolicies{}
	return t.TrafficEngineeringPolicies
}

// GetAggregateRoutes returns the value of the AggregateRoutes struct pointer
// from SrlNokiaNetworkInstance_NetworkInstance. If the receiver or the field AggregateRoutes is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaNetworkInstance_NetworkInstance) GetAggregateRoutes() *SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes {
	if t != nil && t.AggregateRoutes != nil {
		return t.AggregateRoutes
	}
	return nil
}

// GetBridgeTable returns the value of the BridgeTable struct pointer
// from SrlNokiaNetworkInstance_NetworkInstance. If the receiver or the field BridgeTable is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaNetworkInstance_NetworkInstance) GetBridgeTable() *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable {
	if t != nil && t.BridgeTable != nil {
		return t.BridgeTable
	}
	return nil
}

// GetInterInstancePolicies returns the value of the InterInstancePolicies struct pointer
// from SrlNokiaNetworkInstance_NetworkInstance. If the receiver or the field InterInstancePolicies is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaNetworkInstance_NetworkInstance) GetInterInstancePolicies() *SrlNokiaNetworkInstance_NetworkInstance_InterInstancePolicies {
	if t != nil && t.InterInstancePolicies != nil {
		return t.InterInstancePolicies
	}
	return nil
}

// GetIpForwarding returns the value of the IpForwarding struct pointer
// from SrlNokiaNetworkInstance_NetworkInstance. If the receiver or the field IpForwarding is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaNetworkInstance_NetworkInstance) GetIpForwarding() *SrlNokiaNetworkInstance_NetworkInstance_IpForwarding {
	if t != nil && t.IpForwarding != nil {
		return t.IpForwarding
	}
	return nil
}

// GetIpLoadBalancing returns the value of the IpLoadBalancing struct pointer
// from SrlNokiaNetworkInstance_NetworkInstance. If the receiver or the field IpLoadBalancing is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaNetworkInstance_NetworkInstance) GetIpLoadBalancing() *SrlNokiaNetworkInstance_NetworkInstance_IpLoadBalancing {
	if t != nil && t.IpLoadBalancing != nil {
		return t.IpLoadBalancing
	}
	return nil
}

// GetMaintenancePolicies returns the value of the MaintenancePolicies struct pointer
// from SrlNokiaNetworkInstance_NetworkInstance. If the receiver or the field MaintenancePolicies is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaNetworkInstance_NetworkInstance) GetMaintenancePolicies() *SrlNokiaNetworkInstance_NetworkInstance_MaintenancePolicies {
	if t != nil && t.MaintenancePolicies != nil {
		return t.MaintenancePolicies
	}
	return nil
}

// GetMpls returns the value of the Mpls struct pointer
// from SrlNokiaNetworkInstance_NetworkInstance. If the receiver or the field Mpls is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaNetworkInstance_NetworkInstance) GetMpls() *SrlNokiaNetworkInstance_NetworkInstance_Mpls {
	if t != nil && t.Mpls != nil {
		return t.Mpls
	}
	return nil
}

// GetMplsForwarding returns the value of the MplsForwarding struct pointer
// from SrlNokiaNetworkInstance_NetworkInstance. If the receiver or the field MplsForwarding is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaNetworkInstance_NetworkInstance) GetMplsForwarding() *SrlNokiaNetworkInstance_NetworkInstance_MplsForwarding {
	if t != nil && t.MplsForwarding != nil {
		return t.MplsForwarding
	}
	return nil
}

// GetMtu returns the value of the Mtu struct pointer
// from SrlNokiaNetworkInstance_NetworkInstance. If the receiver or the field Mtu is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaNetworkInstance_NetworkInstance) GetMtu() *SrlNokiaNetworkInstance_NetworkInstance_Mtu {
	if t != nil && t.Mtu != nil {
		return t.Mtu
	}
	return nil
}

// GetMulticastL3Vpn returns the value of the MulticastL3Vpn struct pointer
// from SrlNokiaNetworkInstance_NetworkInstance. If the receiver or the field MulticastL3Vpn is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaNetworkInstance_NetworkInstance) GetMulticastL3Vpn() *SrlNokiaNetworkInstance_NetworkInstance_MulticastL3Vpn {
	if t != nil && t.MulticastL3Vpn != nil {
		return t.MulticastL3Vpn
	}
	return nil
}

// GetNextHopGroups returns the value of the NextHopGroups struct pointer
// from SrlNokiaNetworkInstance_NetworkInstance. If the receiver or the field NextHopGroups is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaNetworkInstance_NetworkInstance) GetNextHopGroups() *SrlNokiaNetworkInstance_NetworkInstance_NextHopGroups {
	if t != nil && t.NextHopGroups != nil {
		return t.NextHopGroups
	}
	return nil
}

// GetPolicyForwarding returns the value of the PolicyForwarding struct pointer
// from SrlNokiaNetworkInstance_NetworkInstance. If the receiver or the field PolicyForwarding is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaNetworkInstance_NetworkInstance) GetPolicyForwarding() *SrlNokiaNetworkInstance_NetworkInstance_PolicyForwarding {
	if t != nil && t.PolicyForwarding != nil {
		return t.PolicyForwarding
	}
	return nil
}

// GetProtocols returns the value of the Protocols struct pointer
// from SrlNokiaNetworkInstance_NetworkInstance. If the receiver or the field Protocols is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaNetworkInstance_NetworkInstance) GetProtocols() *SrlNokiaNetworkInstance_NetworkInstance_Protocols {
	if t != nil && t.Protocols != nil {
		return t.Protocols
	}
	return nil
}

// GetSegmentRouting returns the value of the SegmentRouting struct pointer
// from SrlNokiaNetworkInstance_NetworkInstance. If the receiver or the field SegmentRouting is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaNetworkInstance_NetworkInstance) GetSegmentRouting() *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting {
	if t != nil && t.SegmentRouting != nil {
		return t.SegmentRouting
	}
	return nil
}

// GetStaticRoutes returns the value of the StaticRoutes struct pointer
// from SrlNokiaNetworkInstance_NetworkInstance. If the receiver or the field StaticRoutes is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaNetworkInstance_NetworkInstance) GetStaticRoutes() *SrlNokiaNetworkInstance_NetworkInstance_StaticRoutes {
	if t != nil && t.StaticRoutes != nil {
		return t.StaticRoutes
	}
	return nil
}

// GetTrafficEngineering returns the value of the TrafficEngineering struct pointer
// from SrlNokiaNetworkInstance_NetworkInstance. If the receiver or the field TrafficEngineering is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaNetworkInstance_NetworkInstance) GetTrafficEngineering() *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering {
	if t != nil && t.TrafficEngineering != nil {
		return t.TrafficEngineering
	}
	return nil
}

// GetTrafficEngineeringPolicies returns the value of the TrafficEngineeringPolicies struct pointer
// from SrlNokiaNetworkInstance_NetworkInstance. If the receiver or the field TrafficEngineeringPolicies is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaNetworkInstance_NetworkInstance) GetTrafficEngineeringPolicies() *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineeringPolicies {
	if t != nil && t.TrafficEngineeringPolicies != nil {
		return t.TrafficEngineeringPolicies
	}
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaNetworkInstance_NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaNetworkInstance_NetworkInstance) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_enable
	}
	return t.AdminState
}

// GetDescription retrieves the value of the leaf Description from the SrlNokiaNetworkInstance_NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *SrlNokiaNetworkInstance_NetworkInstance) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetName retrieves the value of the leaf Name from the SrlNokiaNetworkInstance_NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaNetworkInstance_NetworkInstance) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetRouterId retrieves the value of the leaf RouterId from the SrlNokiaNetworkInstance_NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RouterId is set, it can
// safely use t.GetRouterId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RouterId == nil' before retrieving the leaf's value.
func (t *SrlNokiaNetworkInstance_NetworkInstance) GetRouterId() string {
	if t == nil || t.RouterId == nil {
		return ""
	}
	return *t.RouterId
}

// GetType retrieves the value of the leaf Type from the SrlNokiaNetworkInstance_NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Type is set, it can
// safely use t.GetType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Type == nil' before retrieving the leaf's value.
func (t *SrlNokiaNetworkInstance_NetworkInstance) GetType() E_SrlNokiaNetworkInstance_NiType {
	if t == nil || t.Type == 0 {
		return SrlNokiaNetworkInstance_NiType_default
	}
	return t.Type
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaNetworkInstance_NetworkInstance
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaNetworkInstance_NetworkInstance) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_enable
	}
	if t.Type == 0 {
		t.Type = SrlNokiaNetworkInstance_NiType_default
	}
	t.AggregateRoutes.PopulateDefaults()
	t.BridgeTable.PopulateDefaults()
	t.InterInstancePolicies.PopulateDefaults()
	t.IpForwarding.PopulateDefaults()
	t.IpLoadBalancing.PopulateDefaults()
	t.MaintenancePolicies.PopulateDefaults()
	t.Mpls.PopulateDefaults()
	t.MplsForwarding.PopulateDefaults()
	t.Mtu.PopulateDefaults()
	t.MulticastL3Vpn.PopulateDefaults()
	t.NextHopGroups.PopulateDefaults()
	t.PolicyForwarding.PopulateDefaults()
	t.Protocols.PopulateDefaults()
	t.SegmentRouting.PopulateDefaults()
	t.StaticRoutes.PopulateDefaults()
	t.TrafficEngineering.PopulateDefaults()
	t.TrafficEngineeringPolicies.PopulateDefaults()
	for _, e := range t.ConnectionPoint {
		e.PopulateDefaults()
	}
	for _, e := range t.Interface {
		e.PopulateDefaults()
	}
	for _, e := range t.VxlanInterface {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaNetworkInstance_NetworkInstance struct, which is a YANG list entry.
func (t *SrlNokiaNetworkInstance_NetworkInstance) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaNetworkInstance_NetworkInstance.
func (*SrlNokiaNetworkInstance_NetworkInstance) ΛBelongingModule() string {
	return "srl_nokia-network-instance"
}

// SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes represents the /srl_nokia-network-instance/network-instance/aggregate-routes YANG schema element.
type SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes struct {
	Route map[string]*SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes_Route `path:"route" module:"srl_nokia-aggregate-routes"`
}

// IsYANGGoStruct ensures that SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes) IsYANGGoStruct() {}

// NewRoute creates a new entry in the Route list of the
// SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes) NewRoute(Prefix string) (*SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes_Route, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Route == nil {
		t.Route = make(map[string]*SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes_Route)
	}

	key := Prefix

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Route[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Route", key)
	}

	t.Route[key] = &SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes_Route{
		Prefix: &Prefix,
	}

	return t.Route[key], nil
}

// RenameRoute renames an entry in the list Route within
// the SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes) RenameRoute(oldK, newK string) error {
	if _, ok := t.Route[newK]; ok {
		return fmt.Errorf("key %v already exists in Route", newK)
	}

	e, ok := t.Route[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Route", oldK)
	}
	e.Prefix = &newK

	t.Route[newK] = e
	delete(t.Route, oldK)
	return nil
}

// GetOrCreateRoute retrieves the value with the specified keys from
// the receiver SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes) GetOrCreateRoute(Prefix string) *SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes_Route {
	key := Prefix

	if v, ok := t.Route[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewRoute(Prefix)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateRoute got unexpected error: %v", err))
	}
	return v
}

// GetRoute retrieves the value with the specified key from
// the Route map field of SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes) GetRoute(Prefix string) *SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes_Route {
	if t == nil {
		return nil
	}

	key := Prefix

	if lm, ok := t.Route[key]; ok {
		return lm
	}
	return nil
}

// DeleteRoute deletes the value with the specified keys from
// the receiver SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes) DeleteRoute(Prefix string) {
	key := Prefix

	delete(t.Route, key)
}

// AppendRoute appends the supplied SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes_Route struct to the
// list Route of SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes. If the key value(s) specified in
// the supplied SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes_Route already exist in the list, an error is
// returned.
func (t *SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes) AppendRoute(
	v *SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes_Route,
) error {
	if v.Prefix == nil {
		return fmt.Errorf("invalid nil key received for Prefix")
	}

	key := *v.Prefix

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Route == nil {
		t.Route = make(map[string]*SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes_Route)
	}

	if _, ok := t.Route[key]; ok {
		return fmt.Errorf("duplicate key for list Route %v", key)
	}

	t.Route[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Route {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes.
func (*SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes) ΛBelongingModule() string {
	return "srl_nokia-aggregate-routes"
}

// SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes_Route represents the /srl_nokia-network-instance/network-instance/aggregate-routes/route YANG schema element.
type SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes_Route struct {
	AdminState   E_SrlNokiaCommon_AdminState                                                `path:"admin-state" module:"srl_nokia-aggregate-routes"`
	Aggregator   *SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes_Route_Aggregator  `path:"aggregator" module:"srl_nokia-aggregate-routes"`
	Communities  *SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes_Route_Communities `path:"communities" module:"srl_nokia-aggregate-routes"`
	GenerateIcmp *bool                                                                      `path:"generate-icmp" module:"srl_nokia-aggregate-routes"`
	Prefix       *string                                                                    `path:"prefix" module:"srl_nokia-aggregate-routes"`
	SummaryOnly  *bool                                                                      `path:"summary-only" module:"srl_nokia-aggregate-routes"`
}

// IsYANGGoStruct ensures that SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes_Route implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes_Route) IsYANGGoStruct() {}

// GetOrCreateAggregator retrieves the value of the Aggregator field
// or returns the existing field if it already exists.
func (t *SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes_Route) GetOrCreateAggregator() *SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes_Route_Aggregator {
	if t.Aggregator != nil {
		return t.Aggregator
	}
	t.Aggregator = &SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes_Route_Aggregator{}
	return t.Aggregator
}

// GetOrCreateCommunities retrieves the value of the Communities field
// or returns the existing field if it already exists.
func (t *SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes_Route) GetOrCreateCommunities() *SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes_Route_Communities {
	if t.Communities != nil {
		return t.Communities
	}
	t.Communities = &SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes_Route_Communities{}
	return t.Communities
}

// GetAggregator returns the value of the Aggregator struct pointer
// from SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes_Route. If the receiver or the field Aggregator is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes_Route) GetAggregator() *SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes_Route_Aggregator {
	if t != nil && t.Aggregator != nil {
		return t.Aggregator
	}
	return nil
}

// GetCommunities returns the value of the Communities struct pointer
// from SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes_Route. If the receiver or the field Communities is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes_Route) GetCommunities() *SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes_Route_Communities {
	if t != nil && t.Communities != nil {
		return t.Communities
	}
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes_Route
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes_Route) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_enable
	}
	return t.AdminState
}

// GetGenerateIcmp retrieves the value of the leaf GenerateIcmp from the SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes_Route
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if GenerateIcmp is set, it can
// safely use t.GetGenerateIcmp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.GenerateIcmp == nil' before retrieving the leaf's value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes_Route) GetGenerateIcmp() bool {
	if t == nil || t.GenerateIcmp == nil {
		return false
	}
	return *t.GenerateIcmp
}

// GetPrefix retrieves the value of the leaf Prefix from the SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes_Route
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Prefix is set, it can
// safely use t.GetPrefix() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Prefix == nil' before retrieving the leaf's value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes_Route) GetPrefix() string {
	if t == nil || t.Prefix == nil {
		return ""
	}
	return *t.Prefix
}

// GetSummaryOnly retrieves the value of the leaf SummaryOnly from the SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes_Route
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SummaryOnly is set, it can
// safely use t.GetSummaryOnly() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SummaryOnly == nil' before retrieving the leaf's value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes_Route) GetSummaryOnly() bool {
	if t == nil || t.SummaryOnly == nil {
		return false
	}
	return *t.SummaryOnly
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes_Route
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes_Route) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_enable
	}
	if t.SummaryOnly == nil {
		var v bool = false
		t.SummaryOnly = &v
	}
	t.Aggregator.PopulateDefaults()
	t.Communities.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes_Route struct, which is a YANG list entry.
func (t *SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes_Route) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Prefix == nil {
		return nil, fmt.Errorf("nil value for key Prefix")
	}

	return map[string]interface{}{
		"prefix": *t.Prefix,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes_Route) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes_Route"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes_Route) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes_Route) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes_Route.
func (*SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes_Route) ΛBelongingModule() string {
	return "srl_nokia-aggregate-routes"
}

// SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes_Route_Aggregator represents the /srl_nokia-network-instance/network-instance/aggregate-routes/route/aggregator YANG schema element.
type SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes_Route_Aggregator struct {
	Address  *string `path:"address" module:"srl_nokia-aggregate-routes"`
	AsNumber *uint32 `path:"as-number" module:"srl_nokia-aggregate-routes"`
}

// IsYANGGoStruct ensures that SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes_Route_Aggregator implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes_Route_Aggregator) IsYANGGoStruct() {}

// GetAddress retrieves the value of the leaf Address from the SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes_Route_Aggregator
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Address is set, it can
// safely use t.GetAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Address == nil' before retrieving the leaf's value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes_Route_Aggregator) GetAddress() string {
	if t == nil || t.Address == nil {
		return ""
	}
	return *t.Address
}

// GetAsNumber retrieves the value of the leaf AsNumber from the SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes_Route_Aggregator
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AsNumber is set, it can
// safely use t.GetAsNumber() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AsNumber == nil' before retrieving the leaf's value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes_Route_Aggregator) GetAsNumber() uint32 {
	if t == nil || t.AsNumber == nil {
		return 0
	}
	return *t.AsNumber
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes_Route_Aggregator
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes_Route_Aggregator) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes_Route_Aggregator) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes_Route_Aggregator"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes_Route_Aggregator) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes_Route_Aggregator) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes_Route_Aggregator.
func (*SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes_Route_Aggregator) ΛBelongingModule() string {
	return "srl_nokia-aggregate-routes"
}

// SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes_Route_Communities represents the /srl_nokia-network-instance/network-instance/aggregate-routes/route/communities YANG schema element.
type SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes_Route_Communities struct {
	Add []SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes_Route_Communities_Add_Union `path:"add" module:"srl_nokia-aggregate-routes"`
}

// IsYANGGoStruct ensures that SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes_Route_Communities implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes_Route_Communities) IsYANGGoStruct() {}

// GetAdd retrieves the value of the leaf Add from the SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes_Route_Communities
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Add is set, it can
// safely use t.GetAdd() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Add == nil' before retrieving the leaf's value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes_Route_Communities) GetAdd() []SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes_Route_Communities_Add_Union {
	if t == nil || t.Add == nil {
		return nil
	}
	return t.Add
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes_Route_Communities
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes_Route_Communities) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes_Route_Communities) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes_Route_Communities"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes_Route_Communities) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes_Route_Communities) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes_Route_Communities.
func (*SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes_Route_Communities) ΛBelongingModule() string {
	return "srl_nokia-aggregate-routes"
}

// SrlNokiaNetworkInstance_NetworkInstance_BridgeTable represents the /srl_nokia-network-instance/network-instance/bridge-table YANG schema element.
type SrlNokiaNetworkInstance_NetworkInstance_BridgeTable struct {
	DiscardUnknownDestMac *bool                                                                             `path:"discard-unknown-dest-mac" module:"srl_nokia-network-instance"`
	MacDuplication        *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_MacDuplication               `path:"mac-duplication" module:"srl_nokia-network-instance"`
	MacLearning           *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_MacLearning                  `path:"mac-learning" module:"srl_nokia-network-instance"`
	MacLimit              *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_MacLimit                     `path:"mac-limit" module:"srl_nokia-network-instance"`
	ProtectAnycastGwMac   *bool                                                                             `path:"protect-anycast-gw-mac" module:"srl_nokia-network-instance"`
	ProxyArp              *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_ProxyArp                     `path:"proxy-arp" module:"srl_nokia-bridge-table-proxy-arp-nd" yangPresence:"true"`
	ProxyNd               *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_ProxyNd                      `path:"proxy-nd" module:"srl_nokia-bridge-table-proxy-arp-nd" yangPresence:"true"`
	SplitHorizonGroup     map[string]*SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_SplitHorizonGroup `path:"split-horizon-group" module:"srl_nokia-network-instance"`
	StaticMac             *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_StaticMac                    `path:"static-mac" module:"srl_nokia-bridge-table-static-mac"`
}

// IsYANGGoStruct ensures that SrlNokiaNetworkInstance_NetworkInstance_BridgeTable implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaNetworkInstance_NetworkInstance_BridgeTable) IsYANGGoStruct() {}

// NewSplitHorizonGroup creates a new entry in the SplitHorizonGroup list of the
// SrlNokiaNetworkInstance_NetworkInstance_BridgeTable struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable) NewSplitHorizonGroup(Name string) (*SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_SplitHorizonGroup, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.SplitHorizonGroup == nil {
		t.SplitHorizonGroup = make(map[string]*SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_SplitHorizonGroup)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.SplitHorizonGroup[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list SplitHorizonGroup", key)
	}

	t.SplitHorizonGroup[key] = &SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_SplitHorizonGroup{
		Name: &Name,
	}

	return t.SplitHorizonGroup[key], nil
}

// RenameSplitHorizonGroup renames an entry in the list SplitHorizonGroup within
// the SrlNokiaNetworkInstance_NetworkInstance_BridgeTable struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable) RenameSplitHorizonGroup(oldK, newK string) error {
	if _, ok := t.SplitHorizonGroup[newK]; ok {
		return fmt.Errorf("key %v already exists in SplitHorizonGroup", newK)
	}

	e, ok := t.SplitHorizonGroup[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in SplitHorizonGroup", oldK)
	}
	e.Name = &newK

	t.SplitHorizonGroup[newK] = e
	delete(t.SplitHorizonGroup, oldK)
	return nil
}

// GetOrCreateSplitHorizonGroup retrieves the value with the specified keys from
// the receiver SrlNokiaNetworkInstance_NetworkInstance_BridgeTable. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable) GetOrCreateSplitHorizonGroup(
	Name string,
) *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_SplitHorizonGroup {
	key := Name

	if v, ok := t.SplitHorizonGroup[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewSplitHorizonGroup(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateSplitHorizonGroup got unexpected error: %v", err))
	}
	return v
}

// GetSplitHorizonGroup retrieves the value with the specified key from
// the SplitHorizonGroup map field of SrlNokiaNetworkInstance_NetworkInstance_BridgeTable. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable) GetSplitHorizonGroup(Name string) *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_SplitHorizonGroup {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.SplitHorizonGroup[key]; ok {
		return lm
	}
	return nil
}

// DeleteSplitHorizonGroup deletes the value with the specified keys from
// the receiver SrlNokiaNetworkInstance_NetworkInstance_BridgeTable. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable) DeleteSplitHorizonGroup(Name string) {
	key := Name

	delete(t.SplitHorizonGroup, key)
}

// AppendSplitHorizonGroup appends the supplied SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_SplitHorizonGroup struct to the
// list SplitHorizonGroup of SrlNokiaNetworkInstance_NetworkInstance_BridgeTable. If the key value(s) specified in
// the supplied SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_SplitHorizonGroup already exist in the list, an error is
// returned.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable) AppendSplitHorizonGroup(
	v *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_SplitHorizonGroup,
) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.SplitHorizonGroup == nil {
		t.SplitHorizonGroup = make(map[string]*SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_SplitHorizonGroup)
	}

	if _, ok := t.SplitHorizonGroup[key]; ok {
		return fmt.Errorf("duplicate key for list SplitHorizonGroup %v", key)
	}

	t.SplitHorizonGroup[key] = v
	return nil
}

// GetOrCreateMacDuplication retrieves the value of the MacDuplication field
// or returns the existing field if it already exists.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable) GetOrCreateMacDuplication() *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_MacDuplication {
	if t.MacDuplication != nil {
		return t.MacDuplication
	}
	t.MacDuplication = &SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_MacDuplication{}
	return t.MacDuplication
}

// GetOrCreateMacLearning retrieves the value of the MacLearning field
// or returns the existing field if it already exists.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable) GetOrCreateMacLearning() *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_MacLearning {
	if t.MacLearning != nil {
		return t.MacLearning
	}
	t.MacLearning = &SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_MacLearning{}
	return t.MacLearning
}

// GetOrCreateMacLimit retrieves the value of the MacLimit field
// or returns the existing field if it already exists.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable) GetOrCreateMacLimit() *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_MacLimit {
	if t.MacLimit != nil {
		return t.MacLimit
	}
	t.MacLimit = &SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_MacLimit{}
	return t.MacLimit
}

// GetOrCreateProxyArp retrieves the value of the ProxyArp field
// or returns the existing field if it already exists.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable) GetOrCreateProxyArp() *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_ProxyArp {
	if t.ProxyArp != nil {
		return t.ProxyArp
	}
	t.ProxyArp = &SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_ProxyArp{}
	return t.ProxyArp
}

// GetOrCreateProxyNd retrieves the value of the ProxyNd field
// or returns the existing field if it already exists.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable) GetOrCreateProxyNd() *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_ProxyNd {
	if t.ProxyNd != nil {
		return t.ProxyNd
	}
	t.ProxyNd = &SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_ProxyNd{}
	return t.ProxyNd
}

// GetOrCreateStaticMac retrieves the value of the StaticMac field
// or returns the existing field if it already exists.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable) GetOrCreateStaticMac() *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_StaticMac {
	if t.StaticMac != nil {
		return t.StaticMac
	}
	t.StaticMac = &SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_StaticMac{}
	return t.StaticMac
}

// GetMacDuplication returns the value of the MacDuplication struct pointer
// from SrlNokiaNetworkInstance_NetworkInstance_BridgeTable. If the receiver or the field MacDuplication is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable) GetMacDuplication() *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_MacDuplication {
	if t != nil && t.MacDuplication != nil {
		return t.MacDuplication
	}
	return nil
}

// GetMacLearning returns the value of the MacLearning struct pointer
// from SrlNokiaNetworkInstance_NetworkInstance_BridgeTable. If the receiver or the field MacLearning is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable) GetMacLearning() *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_MacLearning {
	if t != nil && t.MacLearning != nil {
		return t.MacLearning
	}
	return nil
}

// GetMacLimit returns the value of the MacLimit struct pointer
// from SrlNokiaNetworkInstance_NetworkInstance_BridgeTable. If the receiver or the field MacLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable) GetMacLimit() *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_MacLimit {
	if t != nil && t.MacLimit != nil {
		return t.MacLimit
	}
	return nil
}

// GetProxyArp returns the value of the ProxyArp struct pointer
// from SrlNokiaNetworkInstance_NetworkInstance_BridgeTable. If the receiver or the field ProxyArp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable) GetProxyArp() *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_ProxyArp {
	if t != nil && t.ProxyArp != nil {
		return t.ProxyArp
	}
	return nil
}

// GetProxyNd returns the value of the ProxyNd struct pointer
// from SrlNokiaNetworkInstance_NetworkInstance_BridgeTable. If the receiver or the field ProxyNd is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable) GetProxyNd() *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_ProxyNd {
	if t != nil && t.ProxyNd != nil {
		return t.ProxyNd
	}
	return nil
}

// GetStaticMac returns the value of the StaticMac struct pointer
// from SrlNokiaNetworkInstance_NetworkInstance_BridgeTable. If the receiver or the field StaticMac is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable) GetStaticMac() *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_StaticMac {
	if t != nil && t.StaticMac != nil {
		return t.StaticMac
	}
	return nil
}

// GetDiscardUnknownDestMac retrieves the value of the leaf DiscardUnknownDestMac from the SrlNokiaNetworkInstance_NetworkInstance_BridgeTable
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DiscardUnknownDestMac is set, it can
// safely use t.GetDiscardUnknownDestMac() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DiscardUnknownDestMac == nil' before retrieving the leaf's value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable) GetDiscardUnknownDestMac() bool {
	if t == nil || t.DiscardUnknownDestMac == nil {
		return false
	}
	return *t.DiscardUnknownDestMac
}

// GetProtectAnycastGwMac retrieves the value of the leaf ProtectAnycastGwMac from the SrlNokiaNetworkInstance_NetworkInstance_BridgeTable
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ProtectAnycastGwMac is set, it can
// safely use t.GetProtectAnycastGwMac() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ProtectAnycastGwMac == nil' before retrieving the leaf's value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable) GetProtectAnycastGwMac() bool {
	if t == nil || t.ProtectAnycastGwMac == nil {
		return false
	}
	return *t.ProtectAnycastGwMac
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaNetworkInstance_NetworkInstance_BridgeTable
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.DiscardUnknownDestMac == nil {
		var v bool = false
		t.DiscardUnknownDestMac = &v
	}
	if t.ProtectAnycastGwMac == nil {
		var v bool = false
		t.ProtectAnycastGwMac = &v
	}
	t.MacDuplication.PopulateDefaults()
	t.MacLearning.PopulateDefaults()
	t.MacLimit.PopulateDefaults()
	t.ProxyArp.PopulateDefaults()
	t.ProxyNd.PopulateDefaults()
	t.StaticMac.PopulateDefaults()
	for _, e := range t.SplitHorizonGroup {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_BridgeTable"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaNetworkInstance_NetworkInstance_BridgeTable.
func (*SrlNokiaNetworkInstance_NetworkInstance_BridgeTable) ΛBelongingModule() string {
	return "srl_nokia-network-instance"
}

// SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_MacDuplication represents the /srl_nokia-network-instance/network-instance/bridge-table/mac-duplication YANG schema element.
type SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_MacDuplication struct {
	Action           E_SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_MacDuplication_Action           `path:"action" module:"srl_nokia-network-instance"`
	AdminState       E_SrlNokiaCommon_AdminState                                                           `path:"admin-state" module:"srl_nokia-network-instance"`
	HoldDownTime     SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_MacDuplication_HoldDownTime_Union `path:"hold-down-time" module:"srl_nokia-network-instance"`
	MonitoringWindow *uint32                                                                               `path:"monitoring-window" module:"srl_nokia-network-instance"`
	NumMoves         *uint32                                                                               `path:"num-moves" module:"srl_nokia-network-instance"`
}

// IsYANGGoStruct ensures that SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_MacDuplication implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_MacDuplication) IsYANGGoStruct() {}

// GetAction retrieves the value of the leaf Action from the SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_MacDuplication
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Action is set, it can
// safely use t.GetAction() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Action == nil' before retrieving the leaf's value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_MacDuplication) GetAction() E_SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_MacDuplication_Action {
	if t == nil || t.Action == 0 {
		return SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_MacDuplication_Action_stop_learning
	}
	return t.Action
}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_MacDuplication
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_MacDuplication) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_enable
	}
	return t.AdminState
}

// GetHoldDownTime retrieves the value of the leaf HoldDownTime from the SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_MacDuplication
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if HoldDownTime is set, it can
// safely use t.GetHoldDownTime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.HoldDownTime == nil' before retrieving the leaf's value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_MacDuplication) GetHoldDownTime() SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_MacDuplication_HoldDownTime_Union {
	if t == nil || t.HoldDownTime == nil {
		return UnionUint32(9)
	}
	return t.HoldDownTime
}

// GetMonitoringWindow retrieves the value of the leaf MonitoringWindow from the SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_MacDuplication
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MonitoringWindow is set, it can
// safely use t.GetMonitoringWindow() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MonitoringWindow == nil' before retrieving the leaf's value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_MacDuplication) GetMonitoringWindow() uint32 {
	if t == nil || t.MonitoringWindow == nil {
		return 3
	}
	return *t.MonitoringWindow
}

// GetNumMoves retrieves the value of the leaf NumMoves from the SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_MacDuplication
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NumMoves is set, it can
// safely use t.GetNumMoves() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NumMoves == nil' before retrieving the leaf's value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_MacDuplication) GetNumMoves() uint32 {
	if t == nil || t.NumMoves == nil {
		return 5
	}
	return *t.NumMoves
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_MacDuplication
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_MacDuplication) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Action == 0 {
		t.Action = SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_MacDuplication_Action_stop_learning
	}
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_enable
	}
	if t.HoldDownTime == nil {
		t.HoldDownTime = UnionUint32(9)
	}
	if t.MonitoringWindow == nil {
		var v uint32 = 3
		t.MonitoringWindow = &v
	}
	if t.NumMoves == nil {
		var v uint32 = 5
		t.NumMoves = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_MacDuplication) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_MacDuplication"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_MacDuplication) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_MacDuplication) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_MacDuplication.
func (*SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_MacDuplication) ΛBelongingModule() string {
	return "srl_nokia-network-instance"
}

// SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_MacLearning represents the /srl_nokia-network-instance/network-instance/bridge-table/mac-learning YANG schema element.
type SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_MacLearning struct {
	AdminState E_SrlNokiaCommon_AdminState                                            `path:"admin-state" module:"srl_nokia-network-instance"`
	Aging      *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_MacLearning_Aging `path:"aging" module:"srl_nokia-network-instance"`
}

// IsYANGGoStruct ensures that SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_MacLearning implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_MacLearning) IsYANGGoStruct() {}

// GetOrCreateAging retrieves the value of the Aging field
// or returns the existing field if it already exists.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_MacLearning) GetOrCreateAging() *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_MacLearning_Aging {
	if t.Aging != nil {
		return t.Aging
	}
	t.Aging = &SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_MacLearning_Aging{}
	return t.Aging
}

// GetAging returns the value of the Aging struct pointer
// from SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_MacLearning. If the receiver or the field Aging is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_MacLearning) GetAging() *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_MacLearning_Aging {
	if t != nil && t.Aging != nil {
		return t.Aging
	}
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_MacLearning
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_MacLearning) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_enable
	}
	return t.AdminState
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_MacLearning
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_MacLearning) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_enable
	}
	t.Aging.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_MacLearning) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_MacLearning"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_MacLearning) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_MacLearning) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_MacLearning.
func (*SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_MacLearning) ΛBelongingModule() string {
	return "srl_nokia-network-instance"
}

// SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_MacLearning_Aging represents the /srl_nokia-network-instance/network-instance/bridge-table/mac-learning/aging YANG schema element.
type SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_MacLearning_Aging struct {
	AdminState E_SrlNokiaCommon_AdminState `path:"admin-state" module:"srl_nokia-network-instance"`
	AgeTime    *int32                      `path:"age-time" module:"srl_nokia-network-instance"`
}

// IsYANGGoStruct ensures that SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_MacLearning_Aging implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_MacLearning_Aging) IsYANGGoStruct() {}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_MacLearning_Aging
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_MacLearning_Aging) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_enable
	}
	return t.AdminState
}

// GetAgeTime retrieves the value of the leaf AgeTime from the SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_MacLearning_Aging
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AgeTime is set, it can
// safely use t.GetAgeTime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AgeTime == nil' before retrieving the leaf's value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_MacLearning_Aging) GetAgeTime() int32 {
	if t == nil || t.AgeTime == nil {
		return 300
	}
	return *t.AgeTime
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_MacLearning_Aging
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_MacLearning_Aging) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_enable
	}
	if t.AgeTime == nil {
		var v int32 = 300
		t.AgeTime = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_MacLearning_Aging) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_MacLearning_Aging"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_MacLearning_Aging) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_MacLearning_Aging) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_MacLearning_Aging.
func (*SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_MacLearning_Aging) ΛBelongingModule() string {
	return "srl_nokia-network-instance"
}

// SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_MacLimit represents the /srl_nokia-network-instance/network-instance/bridge-table/mac-limit YANG schema element.
type SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_MacLimit struct {
	MaximumEntries      *int32 `path:"maximum-entries" module:"srl_nokia-network-instance"`
	WarningThresholdPct *int32 `path:"warning-threshold-pct" module:"srl_nokia-network-instance"`
}

// IsYANGGoStruct ensures that SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_MacLimit implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_MacLimit) IsYANGGoStruct() {}

// GetMaximumEntries retrieves the value of the leaf MaximumEntries from the SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_MacLimit
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MaximumEntries is set, it can
// safely use t.GetMaximumEntries() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MaximumEntries == nil' before retrieving the leaf's value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_MacLimit) GetMaximumEntries() int32 {
	if t == nil || t.MaximumEntries == nil {
		return 250
	}
	return *t.MaximumEntries
}

// GetWarningThresholdPct retrieves the value of the leaf WarningThresholdPct from the SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_MacLimit
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if WarningThresholdPct is set, it can
// safely use t.GetWarningThresholdPct() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.WarningThresholdPct == nil' before retrieving the leaf's value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_MacLimit) GetWarningThresholdPct() int32 {
	if t == nil || t.WarningThresholdPct == nil {
		return 95
	}
	return *t.WarningThresholdPct
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_MacLimit
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_MacLimit) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.MaximumEntries == nil {
		var v int32 = 250
		t.MaximumEntries = &v
	}
	if t.WarningThresholdPct == nil {
		var v int32 = 95
		t.WarningThresholdPct = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_MacLimit) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_MacLimit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_MacLimit) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_MacLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_MacLimit.
func (*SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_MacLimit) ΛBelongingModule() string {
	return "srl_nokia-network-instance"
}

// SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_ProxyArp represents the /srl_nokia-network-instance/network-instance/bridge-table/proxy-arp YANG schema element.
type SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_ProxyArp struct {
	AdminState       E_SrlNokiaCommon_AdminState                                                   `path:"admin-state" module:"srl_nokia-bridge-table-proxy-arp-nd"`
	DynamicLearning  *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_ProxyArp_DynamicLearning `path:"dynamic-learning" module:"srl_nokia-bridge-table-proxy-arp-nd"`
	Evpn             *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_ProxyArp_Evpn            `path:"evpn" module:"srl_nokia-bridge-table-proxy-arp-nd"`
	IpDuplication    *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_ProxyArp_IpDuplication   `path:"ip-duplication" module:"srl_nokia-bridge-table-proxy-arp-nd"`
	ProcessArpProbes *bool                                                                         `path:"process-arp-probes" module:"srl_nokia-bridge-table-proxy-arp-nd"`
	StaticEntries    *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_ProxyArp_StaticEntries   `path:"static-entries" module:"srl_nokia-bridge-table-proxy-arp-nd"`
	TableSize        *uint32                                                                       `path:"table-size" module:"srl_nokia-bridge-table-proxy-arp-nd"`
	TraceOptions     *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_ProxyArp_TraceOptions    `path:"trace-options" module:"srl_nokia-bridge-table-proxy-arp-nd"`
}

// IsYANGGoStruct ensures that SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_ProxyArp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_ProxyArp) IsYANGGoStruct() {}

// GetOrCreateDynamicLearning retrieves the value of the DynamicLearning field
// or returns the existing field if it already exists.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_ProxyArp) GetOrCreateDynamicLearning() *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_ProxyArp_DynamicLearning {
	if t.DynamicLearning != nil {
		return t.DynamicLearning
	}
	t.DynamicLearning = &SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_ProxyArp_DynamicLearning{}
	return t.DynamicLearning
}

// GetOrCreateEvpn retrieves the value of the Evpn field
// or returns the existing field if it already exists.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_ProxyArp) GetOrCreateEvpn() *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_ProxyArp_Evpn {
	if t.Evpn != nil {
		return t.Evpn
	}
	t.Evpn = &SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_ProxyArp_Evpn{}
	return t.Evpn
}

// GetOrCreateIpDuplication retrieves the value of the IpDuplication field
// or returns the existing field if it already exists.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_ProxyArp) GetOrCreateIpDuplication() *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_ProxyArp_IpDuplication {
	if t.IpDuplication != nil {
		return t.IpDuplication
	}
	t.IpDuplication = &SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_ProxyArp_IpDuplication{}
	return t.IpDuplication
}

// GetOrCreateStaticEntries retrieves the value of the StaticEntries field
// or returns the existing field if it already exists.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_ProxyArp) GetOrCreateStaticEntries() *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_ProxyArp_StaticEntries {
	if t.StaticEntries != nil {
		return t.StaticEntries
	}
	t.StaticEntries = &SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_ProxyArp_StaticEntries{}
	return t.StaticEntries
}

// GetOrCreateTraceOptions retrieves the value of the TraceOptions field
// or returns the existing field if it already exists.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_ProxyArp) GetOrCreateTraceOptions() *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_ProxyArp_TraceOptions {
	if t.TraceOptions != nil {
		return t.TraceOptions
	}
	t.TraceOptions = &SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_ProxyArp_TraceOptions{}
	return t.TraceOptions
}

// GetDynamicLearning returns the value of the DynamicLearning struct pointer
// from SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_ProxyArp. If the receiver or the field DynamicLearning is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_ProxyArp) GetDynamicLearning() *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_ProxyArp_DynamicLearning {
	if t != nil && t.DynamicLearning != nil {
		return t.DynamicLearning
	}
	return nil
}

// GetEvpn returns the value of the Evpn struct pointer
// from SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_ProxyArp. If the receiver or the field Evpn is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_ProxyArp) GetEvpn() *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_ProxyArp_Evpn {
	if t != nil && t.Evpn != nil {
		return t.Evpn
	}
	return nil
}

// GetIpDuplication returns the value of the IpDuplication struct pointer
// from SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_ProxyArp. If the receiver or the field IpDuplication is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_ProxyArp) GetIpDuplication() *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_ProxyArp_IpDuplication {
	if t != nil && t.IpDuplication != nil {
		return t.IpDuplication
	}
	return nil
}

// GetStaticEntries returns the value of the StaticEntries struct pointer
// from SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_ProxyArp. If the receiver or the field StaticEntries is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_ProxyArp) GetStaticEntries() *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_ProxyArp_StaticEntries {
	if t != nil && t.StaticEntries != nil {
		return t.StaticEntries
	}
	return nil
}

// GetTraceOptions returns the value of the TraceOptions struct pointer
// from SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_ProxyArp. If the receiver or the field TraceOptions is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_ProxyArp) GetTraceOptions() *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_ProxyArp_TraceOptions {
	if t != nil && t.TraceOptions != nil {
		return t.TraceOptions
	}
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_ProxyArp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_ProxyArp) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_enable
	}
	return t.AdminState
}

// GetProcessArpProbes retrieves the value of the leaf ProcessArpProbes from the SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_ProxyArp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ProcessArpProbes is set, it can
// safely use t.GetProcessArpProbes() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ProcessArpProbes == nil' before retrieving the leaf's value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_ProxyArp) GetProcessArpProbes() bool {
	if t == nil || t.ProcessArpProbes == nil {
		return true
	}
	return *t.ProcessArpProbes
}

// GetTableSize retrieves the value of the leaf TableSize from the SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_ProxyArp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TableSize is set, it can
// safely use t.GetTableSize() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TableSize == nil' before retrieving the leaf's value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_ProxyArp) GetTableSize() uint32 {
	if t == nil || t.TableSize == nil {
		return 250
	}
	return *t.TableSize
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_ProxyArp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_ProxyArp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_enable
	}
	if t.ProcessArpProbes == nil {
		var v bool = true
		t.ProcessArpProbes = &v
	}
	if t.TableSize == nil {
		var v uint32 = 250
		t.TableSize = &v
	}
	t.DynamicLearning.PopulateDefaults()
	t.Evpn.PopulateDefaults()
	t.IpDuplication.PopulateDefaults()
	t.StaticEntries.PopulateDefaults()
	t.TraceOptions.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_ProxyArp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_ProxyArp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_ProxyArp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_ProxyArp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_ProxyArp.
func (*SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_ProxyArp) ΛBelongingModule() string {
	return "srl_nokia-bridge-table-proxy-arp-nd"
}

// SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_ProxyArp_DynamicLearning represents the /srl_nokia-network-instance/network-instance/bridge-table/proxy-arp/dynamic-learning YANG schema element.
type SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_ProxyArp_DynamicLearning struct {
	AdminState  E_SrlNokiaCommon_AdminState                                                                    `path:"admin-state" module:"srl_nokia-bridge-table-proxy-arp-nd"`
	AgeTime     SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_ProxyArp_DynamicLearning_AgeTime_Union     `path:"age-time" module:"srl_nokia-bridge-table-proxy-arp-nd"`
	SendRefresh SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_ProxyArp_DynamicLearning_SendRefresh_Union `path:"send-refresh" module:"srl_nokia-bridge-table-proxy-arp-nd"`
}

// IsYANGGoStruct ensures that SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_ProxyArp_DynamicLearning implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_ProxyArp_DynamicLearning) IsYANGGoStruct() {
}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_ProxyArp_DynamicLearning
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_ProxyArp_DynamicLearning) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_disable
	}
	return t.AdminState
}

// GetAgeTime retrieves the value of the leaf AgeTime from the SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_ProxyArp_DynamicLearning
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AgeTime is set, it can
// safely use t.GetAgeTime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AgeTime == nil' before retrieving the leaf's value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_ProxyArp_DynamicLearning) GetAgeTime() SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_ProxyArp_DynamicLearning_AgeTime_Union {
	if t == nil || t.AgeTime == nil {
		return SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_ProxyArp_DynamicLearning_AgeTime_Enum_never
	}
	return t.AgeTime
}

// GetSendRefresh retrieves the value of the leaf SendRefresh from the SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_ProxyArp_DynamicLearning
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SendRefresh is set, it can
// safely use t.GetSendRefresh() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SendRefresh == nil' before retrieving the leaf's value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_ProxyArp_DynamicLearning) GetSendRefresh() SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_ProxyArp_DynamicLearning_SendRefresh_Union {
	if t == nil || t.SendRefresh == nil {
		return SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_ProxyArp_DynamicLearning_SendRefresh_Enum_never
	}
	return t.SendRefresh
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_ProxyArp_DynamicLearning
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_ProxyArp_DynamicLearning) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_disable
	}
	if t.AgeTime == nil {
		t.AgeTime = SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_ProxyArp_DynamicLearning_AgeTime_Enum_never
	}
	if t.SendRefresh == nil {
		t.SendRefresh = SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_ProxyArp_DynamicLearning_SendRefresh_Enum_never
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_ProxyArp_DynamicLearning) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_ProxyArp_DynamicLearning"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_ProxyArp_DynamicLearning) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_ProxyArp_DynamicLearning) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_ProxyArp_DynamicLearning.
func (*SrlNokiaNetworkInstance_NetworkInstance_BridgeTable_ProxyArp_DynamicLearning) ΛBelongingModule() string {
	return "srl_nokia-bridge-table-proxy-arp-nd"
}
