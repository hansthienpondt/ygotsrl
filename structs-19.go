/*
Package ygotsrl is a generated package which contains definitions
of structs which represent a YANG schema. The generated schema can be
compressed by a series of transformations (compression was false
in this case).

This package was generated by /home/hans/go/pkg/mod/github.com/openconfig/ygot@v0.29.17/genutil/names.go
using the following YANG input files:
	- work/srlinux-yang-models/srl_nokia/models/acl/srl_nokia-acl-policers.yang
	- work/srlinux-yang-models/srl_nokia/models/acl/srl_nokia-acl-qos.yang
	- work/srlinux-yang-models/srl_nokia/models/acl/srl_nokia-acl.yang
	- work/srlinux-yang-models/srl_nokia/models/acl/srl_nokia-packet-match-types.yang
	- work/srlinux-yang-models/srl_nokia/models/bfd/srl_nokia-bfd.yang
	- work/srlinux-yang-models/srl_nokia/models/bfd/srl_nokia-micro-bfd.yang
	- work/srlinux-yang-models/srl_nokia/models/common/srl_nokia-common.yang
	- work/srlinux-yang-models/srl_nokia/models/common/srl_nokia-extensions.yang
	- work/srlinux-yang-models/srl_nokia/models/common/srl_nokia-features.yang
	- work/srlinux-yang-models/srl_nokia/models/ethcfm/srl_nokia-ethcfm-types.yang
	- work/srlinux-yang-models/srl_nokia/models/ethcfm/srl_nokia-ethcfm.yang
	- work/srlinux-yang-models/srl_nokia/models/ethcfm/srl_nokia-oam-pm-ethcfm.yang
	- work/srlinux-yang-models/srl_nokia/models/grpc/srl_nokia-gnsi-authz.yang
	- work/srlinux-yang-models/srl_nokia/models/grpc/srl_nokia-gnsi-certz.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-if-ip.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-if-mpls.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-bridge-table-mac-duplication-entries.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-bridge-table-mac-learning-entries.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-bridge-table-mac-table.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-bridge-table-statistics.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-bridge-table.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-ethernet-segment-association.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-ip-dhcp-relay.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-ip-dhcp-server.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-ip-dhcp.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-ip-vrrp.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-l2cp.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-lag.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-local-mirror-destination.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-nbr-evpn.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-nbr-virtual-ip-discovery.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-nbr.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-p4rt.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-router-adv.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-vlans.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-vxdp.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-lacp.yang
	- work/srlinux-yang-models/srl_nokia/models/ipamps/srl_nokia-ippm-source-udp-pool.yang
	- work/srlinux-yang-models/srl_nokia/models/ipamps/srl_nokia-link-measurement.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-aggregate-routes.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bgp-evpn-bgp-instance-mpls-bridge-table-multicast-destinations.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bgp-evpn-bgp-instance-mpls-bridge-table-statistics.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bgp-evpn-bgp-instance-mpls-bridge-table-unicast-destinations.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bgp-evpn-bgp-instance-mpls-vpws-destinations.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bgp-evpn.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bgp-ipvpn.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bgp-vpn.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bgp.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table-mac-duplication-entries.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table-mac-duplication.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table-mac-learning-entries.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table-mac-learning.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table-mac-limit.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table-mac-table.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table-proxy-arp-nd.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table-reserved-macs.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table-shg.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table-static-mac.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-connection-point.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-icmp.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-igmp-snooping.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-igmp-types.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-igmp.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-ip-route-tables.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-isis-lsdb-types.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-isis-lsdb.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-isis.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-ldp.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-linux.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-maintenance-policies.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-mld-snooping.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-mld.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-mpls-route-tables.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-mpls.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-multicast-mfib-tables.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-mvpn-l3.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-network-instance-mtu.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-network-instance.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-next-hop-groups.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-ospf-lsdb.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-ospf-types.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-ospf.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-ospfv3-lsas.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-pcep.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-pim.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-policy-forwarding.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-rib-bgp.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-segment-routing.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-static-routes.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-tcp-udp.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-te-policies.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-traffic-engineering.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-tunnel-tables.yang
	- work/srlinux-yang-models/srl_nokia/models/oam/srl_nokia-lsp-ping-trace.yang
	- work/srlinux-yang-models/srl_nokia/models/oam/srl_nokia-oam-pm-ip.yang
	- work/srlinux-yang-models/srl_nokia/models/oam/srl_nokia-oam-pm-types.yang
	- work/srlinux-yang-models/srl_nokia/models/oam/srl_nokia-oam-pm.yang
	- work/srlinux-yang-models/srl_nokia/models/oam/srl_nokia-oam.yang
	- work/srlinux-yang-models/srl_nokia/models/oam/srl_nokia-stamp.yang
	- work/srlinux-yang-models/srl_nokia/models/oam/srl_nokia-twamp.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-acl.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-cgroup.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-chassis.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-control.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-cpu.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-datapath-resources.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-disk.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-fabric.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-fan.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-healthz.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-lc.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-linecard-fib.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-memory.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-mtu.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-p4rt.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-pipeline-counters.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-psu.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-qos.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-redundancy.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-resource-mgmt.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-resource-monitoring.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-secure-boot.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-tcam.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-tpm.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-vxdp.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform.yang
	- work/srlinux-yang-models/srl_nokia/models/qos/srl_nokia-qos-policers.yang
	- work/srlinux-yang-models/srl_nokia/models/qos/srl_nokia-qos.yang
	- work/srlinux-yang-models/srl_nokia/models/routing-policy/srl_nokia-policy-types.yang
	- work/srlinux-yang-models/srl_nokia/models/routing-policy/srl_nokia-routing-policy.yang
	- work/srlinux-yang-models/srl_nokia/models/sync/srl_nokia-sync-freq.yang
	- work/srlinux-yang-models/srl_nokia/models/sync/srl_nokia-sync-interfaces.yang
	- work/srlinux-yang-models/srl_nokia/models/sync/srl_nokia-sync-ptp.yang
	- work/srlinux-yang-models/srl_nokia/models/sync/srl_nokia-sync-types.yang
	- work/srlinux-yang-models/srl_nokia/models/sync/srl_nokia-sync.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-aaa-password.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-aaa-radius.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-aaa-tacacs.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-aaa-types.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-aaa.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-app-mgmt.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-boot.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-configuration-role.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-configuration.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-dhcp-server.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-dns.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-event-handler.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-ftp.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-gnmi-server.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-gribi-server.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-json-rpc.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-keychains.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-license.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-lldp-types.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-lldp.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-load-balancing.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-logging.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-maintenance-mode.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-mirroring.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-mpls-label-management.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-mpls-services-evpn-label-management.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-mpls-services-network-instance-label-management.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-mtu.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-ntp.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-openconfig.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-p4rt-server.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-packet-link-qual.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-ra_guard.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-sflow.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-snmp-trace.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-snmp.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-ssh.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system-banner.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system-bridge-table-proxy-arp.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system-bridge-table.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system-info.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system-multicast-mfib-table.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system-multicast.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system-name.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system-network-instance-bgp-evpn-ethernet-segments.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system-network-instance-bgp-vpn.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system-network-instance.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system-protocols.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-timezone.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-tls.yang
	- work/srlinux-yang-models/srl_nokia/models/transport-security/srl_nokia-macsec.yang
	- work/srlinux-yang-models/srl_nokia/models/transport-security/srl_nokia-transport-security.yang
	- work/srlinux-yang-models/srl_nokia/models/tunnel/srl_nokia-tunnel-interfaces-vxlan-interface-bridge-table-multicast-destinations.yang
	- work/srlinux-yang-models/srl_nokia/models/tunnel/srl_nokia-tunnel-interfaces-vxlan-interface-bridge-table-unicast-destinations.yang
	- work/srlinux-yang-models/srl_nokia/models/tunnel/srl_nokia-tunnel-interfaces-vxlan-interface-bridge-table-unicast-es-destination-vteps.yang
	- work/srlinux-yang-models/srl_nokia/models/tunnel/srl_nokia-tunnel-interfaces-vxlan-interface-bridge-table.yang
	- work/srlinux-yang-models/srl_nokia/models/tunnel/srl_nokia-tunnel-interfaces.yang
	- work/srlinux-yang-models/srl_nokia/models/tunnel/srl_nokia-tunnel.yang
	- work/srlinux-yang-models/srl_nokia/models/tunnel/srl_nokia-vxlan-tunnel-vtep.yang
Imported modules were sourced from:
	- work/srlinux-yang-models/...
*/
package ygotsrl

import (
	"fmt"
	"reflect"

	"github.com/openconfig/ygot/ygot"
	"github.com/openconfig/ygot/ytypes"
)

// SrlNokiaSystem_System_RaGuardPolicy represents the /srl_nokia-system/system/ra-guard-policy YANG schema element.
type SrlNokiaSystem_System_RaGuardPolicy struct {
	Action             E_SrlNokiaSystem_System_RaGuardPolicy_Action           `path:"action" module:"srl_nokia-ra_guard"`
	AdvertisePrefixSet *string                                                `path:"advertise-prefix-set" module:"srl_nokia-ra_guard"`
	HopLimit           *uint8                                                 `path:"hop-limit" module:"srl_nokia-ra_guard"`
	ManagedConfigFlag  *bool                                                  `path:"managed-config-flag" module:"srl_nokia-ra_guard"`
	Name               *string                                                `path:"name" module:"srl_nokia-ra_guard"`
	OtherConfigFlag    *bool                                                  `path:"other-config-flag" module:"srl_nokia-ra_guard"`
	RouterPreference   E_SrlNokiaSystem_System_RaGuardPolicy_RouterPreference `path:"router-preference" module:"srl_nokia-ra_guard"`
	SourcePrefixSet    *string                                                `path:"source-prefix-set" module:"srl_nokia-ra_guard"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_RaGuardPolicy implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_RaGuardPolicy) IsYANGGoStruct() {}

// GetAction retrieves the value of the leaf Action from the SrlNokiaSystem_System_RaGuardPolicy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Action is set, it can
// safely use t.GetAction() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Action == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_RaGuardPolicy) GetAction() E_SrlNokiaSystem_System_RaGuardPolicy_Action {
	if t == nil || t.Action == 0 {
		return SrlNokiaSystem_System_RaGuardPolicy_Action_discard
	}
	return t.Action
}

// GetAdvertisePrefixSet retrieves the value of the leaf AdvertisePrefixSet from the SrlNokiaSystem_System_RaGuardPolicy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdvertisePrefixSet is set, it can
// safely use t.GetAdvertisePrefixSet() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdvertisePrefixSet == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_RaGuardPolicy) GetAdvertisePrefixSet() string {
	if t == nil || t.AdvertisePrefixSet == nil {
		return ""
	}
	return *t.AdvertisePrefixSet
}

// GetHopLimit retrieves the value of the leaf HopLimit from the SrlNokiaSystem_System_RaGuardPolicy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if HopLimit is set, it can
// safely use t.GetHopLimit() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.HopLimit == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_RaGuardPolicy) GetHopLimit() uint8 {
	if t == nil || t.HopLimit == nil {
		return 0
	}
	return *t.HopLimit
}

// GetManagedConfigFlag retrieves the value of the leaf ManagedConfigFlag from the SrlNokiaSystem_System_RaGuardPolicy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ManagedConfigFlag is set, it can
// safely use t.GetManagedConfigFlag() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ManagedConfigFlag == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_RaGuardPolicy) GetManagedConfigFlag() bool {
	if t == nil || t.ManagedConfigFlag == nil {
		return false
	}
	return *t.ManagedConfigFlag
}

// GetName retrieves the value of the leaf Name from the SrlNokiaSystem_System_RaGuardPolicy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_RaGuardPolicy) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetOtherConfigFlag retrieves the value of the leaf OtherConfigFlag from the SrlNokiaSystem_System_RaGuardPolicy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OtherConfigFlag is set, it can
// safely use t.GetOtherConfigFlag() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OtherConfigFlag == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_RaGuardPolicy) GetOtherConfigFlag() bool {
	if t == nil || t.OtherConfigFlag == nil {
		return false
	}
	return *t.OtherConfigFlag
}

// GetRouterPreference retrieves the value of the leaf RouterPreference from the SrlNokiaSystem_System_RaGuardPolicy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RouterPreference is set, it can
// safely use t.GetRouterPreference() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RouterPreference == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_RaGuardPolicy) GetRouterPreference() E_SrlNokiaSystem_System_RaGuardPolicy_RouterPreference {
	if t == nil || t.RouterPreference == 0 {
		return 0
	}
	return t.RouterPreference
}

// GetSourcePrefixSet retrieves the value of the leaf SourcePrefixSet from the SrlNokiaSystem_System_RaGuardPolicy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SourcePrefixSet is set, it can
// safely use t.GetSourcePrefixSet() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SourcePrefixSet == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_RaGuardPolicy) GetSourcePrefixSet() string {
	if t == nil || t.SourcePrefixSet == nil {
		return ""
	}
	return *t.SourcePrefixSet
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_RaGuardPolicy
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_RaGuardPolicy) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Action == 0 {
		t.Action = SrlNokiaSystem_System_RaGuardPolicy_Action_discard
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_RaGuardPolicy struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_RaGuardPolicy) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_RaGuardPolicy) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_RaGuardPolicy"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_RaGuardPolicy) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_RaGuardPolicy) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_RaGuardPolicy.
func (*SrlNokiaSystem_System_RaGuardPolicy) ΛBelongingModule() string {
	return "srl_nokia-ra_guard"
}

// SrlNokiaSystem_System_Sflow represents the /srl_nokia-system/system/sflow YANG schema element.
type SrlNokiaSystem_System_Sflow struct {
	AdminState    E_SrlNokiaCommon_AdminState                       `path:"admin-state" module:"srl_nokia-sflow"`
	Collector     map[uint16]*SrlNokiaSystem_System_Sflow_Collector `path:"collector" module:"srl_nokia-sflow"`
	Dscp          *uint8                                            `path:"dscp" module:"srl_nokia-sflow"`
	SampleRate    *uint32                                           `path:"sample-rate" module:"srl_nokia-sflow"`
	SampleSize    *uint16                                           `path:"sample-size" module:"srl_nokia-sflow"`
	SourceAddress *string                                           `path:"source-address" module:"srl_nokia-sflow"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Sflow implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Sflow) IsYANGGoStruct() {}

// NewCollector creates a new entry in the Collector list of the
// SrlNokiaSystem_System_Sflow struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_Sflow) NewCollector(CollectorId uint16) (*SrlNokiaSystem_System_Sflow_Collector, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Collector == nil {
		t.Collector = make(map[uint16]*SrlNokiaSystem_System_Sflow_Collector)
	}

	key := CollectorId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Collector[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Collector", key)
	}

	t.Collector[key] = &SrlNokiaSystem_System_Sflow_Collector{
		CollectorId: &CollectorId,
	}

	return t.Collector[key], nil
}

// RenameCollector renames an entry in the list Collector within
// the SrlNokiaSystem_System_Sflow struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaSystem_System_Sflow) RenameCollector(oldK, newK uint16) error {
	if _, ok := t.Collector[newK]; ok {
		return fmt.Errorf("key %v already exists in Collector", newK)
	}

	e, ok := t.Collector[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Collector", oldK)
	}
	e.CollectorId = &newK

	t.Collector[newK] = e
	delete(t.Collector, oldK)
	return nil
}

// GetOrCreateCollector retrieves the value with the specified keys from
// the receiver SrlNokiaSystem_System_Sflow. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaSystem_System_Sflow) GetOrCreateCollector(CollectorId uint16) *SrlNokiaSystem_System_Sflow_Collector {
	key := CollectorId

	if v, ok := t.Collector[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewCollector(CollectorId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateCollector got unexpected error: %v", err))
	}
	return v
}

// GetCollector retrieves the value with the specified key from
// the Collector map field of SrlNokiaSystem_System_Sflow. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaSystem_System_Sflow) GetCollector(CollectorId uint16) *SrlNokiaSystem_System_Sflow_Collector {
	if t == nil {
		return nil
	}

	key := CollectorId

	if lm, ok := t.Collector[key]; ok {
		return lm
	}
	return nil
}

// DeleteCollector deletes the value with the specified keys from
// the receiver SrlNokiaSystem_System_Sflow. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaSystem_System_Sflow) DeleteCollector(CollectorId uint16) {
	key := CollectorId

	delete(t.Collector, key)
}

// AppendCollector appends the supplied SrlNokiaSystem_System_Sflow_Collector struct to the
// list Collector of SrlNokiaSystem_System_Sflow. If the key value(s) specified in
// the supplied SrlNokiaSystem_System_Sflow_Collector already exist in the list, an error is
// returned.
func (t *SrlNokiaSystem_System_Sflow) AppendCollector(v *SrlNokiaSystem_System_Sflow_Collector) error {
	if v.CollectorId == nil {
		return fmt.Errorf("invalid nil key received for CollectorId")
	}

	key := *v.CollectorId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Collector == nil {
		t.Collector = make(map[uint16]*SrlNokiaSystem_System_Sflow_Collector)
	}

	if _, ok := t.Collector[key]; ok {
		return fmt.Errorf("duplicate key for list Collector %v", key)
	}

	t.Collector[key] = v
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaSystem_System_Sflow
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Sflow) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_disable
	}
	return t.AdminState
}

// GetDscp retrieves the value of the leaf Dscp from the SrlNokiaSystem_System_Sflow
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Dscp is set, it can
// safely use t.GetDscp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Dscp == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Sflow) GetDscp() uint8 {
	if t == nil || t.Dscp == nil {
		return 0
	}
	return *t.Dscp
}

// GetSampleRate retrieves the value of the leaf SampleRate from the SrlNokiaSystem_System_Sflow
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SampleRate is set, it can
// safely use t.GetSampleRate() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SampleRate == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Sflow) GetSampleRate() uint32 {
	if t == nil || t.SampleRate == nil {
		return 10000
	}
	return *t.SampleRate
}

// GetSampleSize retrieves the value of the leaf SampleSize from the SrlNokiaSystem_System_Sflow
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SampleSize is set, it can
// safely use t.GetSampleSize() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SampleSize == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Sflow) GetSampleSize() uint16 {
	if t == nil || t.SampleSize == nil {
		return 256
	}
	return *t.SampleSize
}

// GetSourceAddress retrieves the value of the leaf SourceAddress from the SrlNokiaSystem_System_Sflow
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SourceAddress is set, it can
// safely use t.GetSourceAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SourceAddress == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Sflow) GetSourceAddress() string {
	if t == nil || t.SourceAddress == nil {
		return ""
	}
	return *t.SourceAddress
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Sflow
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Sflow) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_disable
	}
	if t.Dscp == nil {
		var v uint8 = 0
		t.Dscp = &v
	}
	if t.SampleRate == nil {
		var v uint32 = 10000
		t.SampleRate = &v
	}
	if t.SampleSize == nil {
		var v uint16 = 256
		t.SampleSize = &v
	}
	for _, e := range t.Collector {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Sflow) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Sflow"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Sflow) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Sflow) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Sflow.
func (*SrlNokiaSystem_System_Sflow) ΛBelongingModule() string {
	return "srl_nokia-sflow"
}

// SrlNokiaSystem_System_Sflow_Collector represents the /srl_nokia-system/system/sflow/collector YANG schema element.
type SrlNokiaSystem_System_Sflow_Collector struct {
	CollectorAddress *string `path:"collector-address" module:"srl_nokia-sflow"`
	CollectorId      *uint16 `path:"collector-id" module:"srl_nokia-sflow"`
	NetworkInstance  *string `path:"network-instance" module:"srl_nokia-sflow"`
	Port             *uint16 `path:"port" module:"srl_nokia-sflow"`
	SourceAddress    *string `path:"source-address" module:"srl_nokia-sflow"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Sflow_Collector implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Sflow_Collector) IsYANGGoStruct() {}

// GetCollectorAddress retrieves the value of the leaf CollectorAddress from the SrlNokiaSystem_System_Sflow_Collector
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if CollectorAddress is set, it can
// safely use t.GetCollectorAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.CollectorAddress == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Sflow_Collector) GetCollectorAddress() string {
	if t == nil || t.CollectorAddress == nil {
		return ""
	}
	return *t.CollectorAddress
}

// GetCollectorId retrieves the value of the leaf CollectorId from the SrlNokiaSystem_System_Sflow_Collector
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if CollectorId is set, it can
// safely use t.GetCollectorId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.CollectorId == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Sflow_Collector) GetCollectorId() uint16 {
	if t == nil || t.CollectorId == nil {
		return 0
	}
	return *t.CollectorId
}

// GetNetworkInstance retrieves the value of the leaf NetworkInstance from the SrlNokiaSystem_System_Sflow_Collector
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NetworkInstance is set, it can
// safely use t.GetNetworkInstance() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NetworkInstance == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Sflow_Collector) GetNetworkInstance() string {
	if t == nil || t.NetworkInstance == nil {
		return ""
	}
	return *t.NetworkInstance
}

// GetPort retrieves the value of the leaf Port from the SrlNokiaSystem_System_Sflow_Collector
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Port is set, it can
// safely use t.GetPort() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Port == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Sflow_Collector) GetPort() uint16 {
	if t == nil || t.Port == nil {
		return 6343
	}
	return *t.Port
}

// GetSourceAddress retrieves the value of the leaf SourceAddress from the SrlNokiaSystem_System_Sflow_Collector
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SourceAddress is set, it can
// safely use t.GetSourceAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SourceAddress == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Sflow_Collector) GetSourceAddress() string {
	if t == nil || t.SourceAddress == nil {
		return ""
	}
	return *t.SourceAddress
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Sflow_Collector
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Sflow_Collector) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Port == nil {
		var v uint16 = 6343
		t.Port = &v
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_Sflow_Collector struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_Sflow_Collector) ΛListKeyMap() (map[string]interface{}, error) {
	if t.CollectorId == nil {
		return nil, fmt.Errorf("nil value for key CollectorId")
	}

	return map[string]interface{}{
		"collector-id": *t.CollectorId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Sflow_Collector) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Sflow_Collector"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Sflow_Collector) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Sflow_Collector) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Sflow_Collector.
func (*SrlNokiaSystem_System_Sflow_Collector) ΛBelongingModule() string {
	return "srl_nokia-sflow"
}

// SrlNokiaSystem_System_Snmp represents the /srl_nokia-system/system/snmp YANG schema element.
type SrlNokiaSystem_System_Snmp struct {
	AccessGroup     map[string]*SrlNokiaSystem_System_Snmp_AccessGroup     `path:"access-group" module:"srl_nokia-snmp"`
	Community       *string                                                `path:"community" module:"srl_nokia-snmp"`
	NetworkInstance map[string]*SrlNokiaSystem_System_Snmp_NetworkInstance `path:"network-instance" module:"srl_nokia-snmp"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Snmp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Snmp) IsYANGGoStruct() {}

// NewAccessGroup creates a new entry in the AccessGroup list of the
// SrlNokiaSystem_System_Snmp struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_Snmp) NewAccessGroup(Name string) (*SrlNokiaSystem_System_Snmp_AccessGroup, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AccessGroup == nil {
		t.AccessGroup = make(map[string]*SrlNokiaSystem_System_Snmp_AccessGroup)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.AccessGroup[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list AccessGroup", key)
	}

	t.AccessGroup[key] = &SrlNokiaSystem_System_Snmp_AccessGroup{
		Name: &Name,
	}

	return t.AccessGroup[key], nil
}

// RenameAccessGroup renames an entry in the list AccessGroup within
// the SrlNokiaSystem_System_Snmp struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaSystem_System_Snmp) RenameAccessGroup(oldK, newK string) error {
	if _, ok := t.AccessGroup[newK]; ok {
		return fmt.Errorf("key %v already exists in AccessGroup", newK)
	}

	e, ok := t.AccessGroup[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in AccessGroup", oldK)
	}
	e.Name = &newK

	t.AccessGroup[newK] = e
	delete(t.AccessGroup, oldK)
	return nil
}

// GetOrCreateAccessGroup retrieves the value with the specified keys from
// the receiver SrlNokiaSystem_System_Snmp. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaSystem_System_Snmp) GetOrCreateAccessGroup(Name string) *SrlNokiaSystem_System_Snmp_AccessGroup {
	key := Name

	if v, ok := t.AccessGroup[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAccessGroup(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAccessGroup got unexpected error: %v", err))
	}
	return v
}

// GetAccessGroup retrieves the value with the specified key from
// the AccessGroup map field of SrlNokiaSystem_System_Snmp. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaSystem_System_Snmp) GetAccessGroup(Name string) *SrlNokiaSystem_System_Snmp_AccessGroup {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.AccessGroup[key]; ok {
		return lm
	}
	return nil
}

// DeleteAccessGroup deletes the value with the specified keys from
// the receiver SrlNokiaSystem_System_Snmp. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaSystem_System_Snmp) DeleteAccessGroup(Name string) {
	key := Name

	delete(t.AccessGroup, key)
}

// AppendAccessGroup appends the supplied SrlNokiaSystem_System_Snmp_AccessGroup struct to the
// list AccessGroup of SrlNokiaSystem_System_Snmp. If the key value(s) specified in
// the supplied SrlNokiaSystem_System_Snmp_AccessGroup already exist in the list, an error is
// returned.
func (t *SrlNokiaSystem_System_Snmp) AppendAccessGroup(v *SrlNokiaSystem_System_Snmp_AccessGroup) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AccessGroup == nil {
		t.AccessGroup = make(map[string]*SrlNokiaSystem_System_Snmp_AccessGroup)
	}

	if _, ok := t.AccessGroup[key]; ok {
		return fmt.Errorf("duplicate key for list AccessGroup %v", key)
	}

	t.AccessGroup[key] = v
	return nil
}

// NewNetworkInstance creates a new entry in the NetworkInstance list of the
// SrlNokiaSystem_System_Snmp struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_Snmp) NewNetworkInstance(Name string) (*SrlNokiaSystem_System_Snmp_NetworkInstance, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NetworkInstance == nil {
		t.NetworkInstance = make(map[string]*SrlNokiaSystem_System_Snmp_NetworkInstance)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.NetworkInstance[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list NetworkInstance", key)
	}

	t.NetworkInstance[key] = &SrlNokiaSystem_System_Snmp_NetworkInstance{
		Name: &Name,
	}

	return t.NetworkInstance[key], nil
}

// RenameNetworkInstance renames an entry in the list NetworkInstance within
// the SrlNokiaSystem_System_Snmp struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaSystem_System_Snmp) RenameNetworkInstance(oldK, newK string) error {
	if _, ok := t.NetworkInstance[newK]; ok {
		return fmt.Errorf("key %v already exists in NetworkInstance", newK)
	}

	e, ok := t.NetworkInstance[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in NetworkInstance", oldK)
	}
	e.Name = &newK

	t.NetworkInstance[newK] = e
	delete(t.NetworkInstance, oldK)
	return nil
}

// GetOrCreateNetworkInstance retrieves the value with the specified keys from
// the receiver SrlNokiaSystem_System_Snmp. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaSystem_System_Snmp) GetOrCreateNetworkInstance(Name string) *SrlNokiaSystem_System_Snmp_NetworkInstance {
	key := Name

	if v, ok := t.NetworkInstance[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNetworkInstance(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNetworkInstance got unexpected error: %v", err))
	}
	return v
}

// GetNetworkInstance retrieves the value with the specified key from
// the NetworkInstance map field of SrlNokiaSystem_System_Snmp. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaSystem_System_Snmp) GetNetworkInstance(Name string) *SrlNokiaSystem_System_Snmp_NetworkInstance {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.NetworkInstance[key]; ok {
		return lm
	}
	return nil
}

// DeleteNetworkInstance deletes the value with the specified keys from
// the receiver SrlNokiaSystem_System_Snmp. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaSystem_System_Snmp) DeleteNetworkInstance(Name string) {
	key := Name

	delete(t.NetworkInstance, key)
}

// AppendNetworkInstance appends the supplied SrlNokiaSystem_System_Snmp_NetworkInstance struct to the
// list NetworkInstance of SrlNokiaSystem_System_Snmp. If the key value(s) specified in
// the supplied SrlNokiaSystem_System_Snmp_NetworkInstance already exist in the list, an error is
// returned.
func (t *SrlNokiaSystem_System_Snmp) AppendNetworkInstance(v *SrlNokiaSystem_System_Snmp_NetworkInstance) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NetworkInstance == nil {
		t.NetworkInstance = make(map[string]*SrlNokiaSystem_System_Snmp_NetworkInstance)
	}

	if _, ok := t.NetworkInstance[key]; ok {
		return fmt.Errorf("duplicate key for list NetworkInstance %v", key)
	}

	t.NetworkInstance[key] = v
	return nil
}

// GetCommunity retrieves the value of the leaf Community from the SrlNokiaSystem_System_Snmp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Community is set, it can
// safely use t.GetCommunity() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Community == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Snmp) GetCommunity() string {
	if t == nil || t.Community == nil {
		return ""
	}
	return *t.Community
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Snmp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Snmp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.AccessGroup {
		e.PopulateDefaults()
	}
	for _, e := range t.NetworkInstance {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Snmp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Snmp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Snmp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Snmp) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Snmp.
func (*SrlNokiaSystem_System_Snmp) ΛBelongingModule() string {
	return "srl_nokia-snmp"
}

// SrlNokiaSystem_System_Snmp_AccessGroup represents the /srl_nokia-system/system/snmp/access-group YANG schema element.
type SrlNokiaSystem_System_Snmp_AccessGroup struct {
	AdminState     E_SrlNokiaCommon_AdminState                                       `path:"admin-state" module:"srl_nokia-snmp"`
	CommunityEntry map[string]*SrlNokiaSystem_System_Snmp_AccessGroup_CommunityEntry `path:"community-entry" module:"srl_nokia-snmp"`
	Description    *string                                                           `path:"description" module:"srl_nokia-snmp"`
	Name           *string                                                           `path:"name" module:"srl_nokia-snmp"`
	SecurityEntry  map[string]*SrlNokiaSystem_System_Snmp_AccessGroup_SecurityEntry  `path:"security-entry" module:"srl_nokia-snmp"`
	SecurityLevel  E_SrlNokiaSnmp_SecurityLevel                                      `path:"security-level" module:"srl_nokia-snmp"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Snmp_AccessGroup implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Snmp_AccessGroup) IsYANGGoStruct() {}

// NewCommunityEntry creates a new entry in the CommunityEntry list of the
// SrlNokiaSystem_System_Snmp_AccessGroup struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_Snmp_AccessGroup) NewCommunityEntry(Name string) (*SrlNokiaSystem_System_Snmp_AccessGroup_CommunityEntry, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.CommunityEntry == nil {
		t.CommunityEntry = make(map[string]*SrlNokiaSystem_System_Snmp_AccessGroup_CommunityEntry)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.CommunityEntry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list CommunityEntry", key)
	}

	t.CommunityEntry[key] = &SrlNokiaSystem_System_Snmp_AccessGroup_CommunityEntry{
		Name: &Name,
	}

	return t.CommunityEntry[key], nil
}

// RenameCommunityEntry renames an entry in the list CommunityEntry within
// the SrlNokiaSystem_System_Snmp_AccessGroup struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaSystem_System_Snmp_AccessGroup) RenameCommunityEntry(oldK, newK string) error {
	if _, ok := t.CommunityEntry[newK]; ok {
		return fmt.Errorf("key %v already exists in CommunityEntry", newK)
	}

	e, ok := t.CommunityEntry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in CommunityEntry", oldK)
	}
	e.Name = &newK

	t.CommunityEntry[newK] = e
	delete(t.CommunityEntry, oldK)
	return nil
}

// GetOrCreateCommunityEntry retrieves the value with the specified keys from
// the receiver SrlNokiaSystem_System_Snmp_AccessGroup. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaSystem_System_Snmp_AccessGroup) GetOrCreateCommunityEntry(Name string) *SrlNokiaSystem_System_Snmp_AccessGroup_CommunityEntry {
	key := Name

	if v, ok := t.CommunityEntry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewCommunityEntry(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateCommunityEntry got unexpected error: %v", err))
	}
	return v
}

// GetCommunityEntry retrieves the value with the specified key from
// the CommunityEntry map field of SrlNokiaSystem_System_Snmp_AccessGroup. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaSystem_System_Snmp_AccessGroup) GetCommunityEntry(Name string) *SrlNokiaSystem_System_Snmp_AccessGroup_CommunityEntry {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.CommunityEntry[key]; ok {
		return lm
	}
	return nil
}

// DeleteCommunityEntry deletes the value with the specified keys from
// the receiver SrlNokiaSystem_System_Snmp_AccessGroup. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaSystem_System_Snmp_AccessGroup) DeleteCommunityEntry(Name string) {
	key := Name

	delete(t.CommunityEntry, key)
}

// AppendCommunityEntry appends the supplied SrlNokiaSystem_System_Snmp_AccessGroup_CommunityEntry struct to the
// list CommunityEntry of SrlNokiaSystem_System_Snmp_AccessGroup. If the key value(s) specified in
// the supplied SrlNokiaSystem_System_Snmp_AccessGroup_CommunityEntry already exist in the list, an error is
// returned.
func (t *SrlNokiaSystem_System_Snmp_AccessGroup) AppendCommunityEntry(
	v *SrlNokiaSystem_System_Snmp_AccessGroup_CommunityEntry,
) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.CommunityEntry == nil {
		t.CommunityEntry = make(map[string]*SrlNokiaSystem_System_Snmp_AccessGroup_CommunityEntry)
	}

	if _, ok := t.CommunityEntry[key]; ok {
		return fmt.Errorf("duplicate key for list CommunityEntry %v", key)
	}

	t.CommunityEntry[key] = v
	return nil
}

// NewSecurityEntry creates a new entry in the SecurityEntry list of the
// SrlNokiaSystem_System_Snmp_AccessGroup struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_Snmp_AccessGroup) NewSecurityEntry(Name string) (*SrlNokiaSystem_System_Snmp_AccessGroup_SecurityEntry, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.SecurityEntry == nil {
		t.SecurityEntry = make(map[string]*SrlNokiaSystem_System_Snmp_AccessGroup_SecurityEntry)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.SecurityEntry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list SecurityEntry", key)
	}

	t.SecurityEntry[key] = &SrlNokiaSystem_System_Snmp_AccessGroup_SecurityEntry{
		Name: &Name,
	}

	return t.SecurityEntry[key], nil
}

// RenameSecurityEntry renames an entry in the list SecurityEntry within
// the SrlNokiaSystem_System_Snmp_AccessGroup struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaSystem_System_Snmp_AccessGroup) RenameSecurityEntry(oldK, newK string) error {
	if _, ok := t.SecurityEntry[newK]; ok {
		return fmt.Errorf("key %v already exists in SecurityEntry", newK)
	}

	e, ok := t.SecurityEntry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in SecurityEntry", oldK)
	}
	e.Name = &newK

	t.SecurityEntry[newK] = e
	delete(t.SecurityEntry, oldK)
	return nil
}

// GetOrCreateSecurityEntry retrieves the value with the specified keys from
// the receiver SrlNokiaSystem_System_Snmp_AccessGroup. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaSystem_System_Snmp_AccessGroup) GetOrCreateSecurityEntry(Name string) *SrlNokiaSystem_System_Snmp_AccessGroup_SecurityEntry {
	key := Name

	if v, ok := t.SecurityEntry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewSecurityEntry(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateSecurityEntry got unexpected error: %v", err))
	}
	return v
}

// GetSecurityEntry retrieves the value with the specified key from
// the SecurityEntry map field of SrlNokiaSystem_System_Snmp_AccessGroup. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaSystem_System_Snmp_AccessGroup) GetSecurityEntry(Name string) *SrlNokiaSystem_System_Snmp_AccessGroup_SecurityEntry {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.SecurityEntry[key]; ok {
		return lm
	}
	return nil
}

// DeleteSecurityEntry deletes the value with the specified keys from
// the receiver SrlNokiaSystem_System_Snmp_AccessGroup. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaSystem_System_Snmp_AccessGroup) DeleteSecurityEntry(Name string) {
	key := Name

	delete(t.SecurityEntry, key)
}

// AppendSecurityEntry appends the supplied SrlNokiaSystem_System_Snmp_AccessGroup_SecurityEntry struct to the
// list SecurityEntry of SrlNokiaSystem_System_Snmp_AccessGroup. If the key value(s) specified in
// the supplied SrlNokiaSystem_System_Snmp_AccessGroup_SecurityEntry already exist in the list, an error is
// returned.
func (t *SrlNokiaSystem_System_Snmp_AccessGroup) AppendSecurityEntry(
	v *SrlNokiaSystem_System_Snmp_AccessGroup_SecurityEntry,
) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.SecurityEntry == nil {
		t.SecurityEntry = make(map[string]*SrlNokiaSystem_System_Snmp_AccessGroup_SecurityEntry)
	}

	if _, ok := t.SecurityEntry[key]; ok {
		return fmt.Errorf("duplicate key for list SecurityEntry %v", key)
	}

	t.SecurityEntry[key] = v
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaSystem_System_Snmp_AccessGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Snmp_AccessGroup) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_enable
	}
	return t.AdminState
}

// GetDescription retrieves the value of the leaf Description from the SrlNokiaSystem_System_Snmp_AccessGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Snmp_AccessGroup) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetName retrieves the value of the leaf Name from the SrlNokiaSystem_System_Snmp_AccessGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Snmp_AccessGroup) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetSecurityLevel retrieves the value of the leaf SecurityLevel from the SrlNokiaSystem_System_Snmp_AccessGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SecurityLevel is set, it can
// safely use t.GetSecurityLevel() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SecurityLevel == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Snmp_AccessGroup) GetSecurityLevel() E_SrlNokiaSnmp_SecurityLevel {
	if t == nil || t.SecurityLevel == 0 {
		return 0
	}
	return t.SecurityLevel
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Snmp_AccessGroup
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Snmp_AccessGroup) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_enable
	}
	for _, e := range t.CommunityEntry {
		e.PopulateDefaults()
	}
	for _, e := range t.SecurityEntry {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_Snmp_AccessGroup struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_Snmp_AccessGroup) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Snmp_AccessGroup) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Snmp_AccessGroup"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Snmp_AccessGroup) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Snmp_AccessGroup) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Snmp_AccessGroup.
func (*SrlNokiaSystem_System_Snmp_AccessGroup) ΛBelongingModule() string {
	return "srl_nokia-snmp"
}

// SrlNokiaSystem_System_Snmp_AccessGroup_CommunityEntry represents the /srl_nokia-system/system/snmp/access-group/community-entry YANG schema element.
type SrlNokiaSystem_System_Snmp_AccessGroup_CommunityEntry struct {
	Community   *string  `path:"community" module:"srl_nokia-snmp"`
	Description *string  `path:"description" module:"srl_nokia-snmp"`
	Name        *string  `path:"name" module:"srl_nokia-snmp"`
	PrefixList  []string `path:"prefix-list" module:"srl_nokia-snmp"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Snmp_AccessGroup_CommunityEntry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Snmp_AccessGroup_CommunityEntry) IsYANGGoStruct() {}

// GetCommunity retrieves the value of the leaf Community from the SrlNokiaSystem_System_Snmp_AccessGroup_CommunityEntry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Community is set, it can
// safely use t.GetCommunity() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Community == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Snmp_AccessGroup_CommunityEntry) GetCommunity() string {
	if t == nil || t.Community == nil {
		return ""
	}
	return *t.Community
}

// GetDescription retrieves the value of the leaf Description from the SrlNokiaSystem_System_Snmp_AccessGroup_CommunityEntry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Snmp_AccessGroup_CommunityEntry) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetName retrieves the value of the leaf Name from the SrlNokiaSystem_System_Snmp_AccessGroup_CommunityEntry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Snmp_AccessGroup_CommunityEntry) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetPrefixList retrieves the value of the leaf PrefixList from the SrlNokiaSystem_System_Snmp_AccessGroup_CommunityEntry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PrefixList is set, it can
// safely use t.GetPrefixList() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PrefixList == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Snmp_AccessGroup_CommunityEntry) GetPrefixList() []string {
	if t == nil || t.PrefixList == nil {
		return nil
	}
	return t.PrefixList
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Snmp_AccessGroup_CommunityEntry
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Snmp_AccessGroup_CommunityEntry) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_Snmp_AccessGroup_CommunityEntry struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_Snmp_AccessGroup_CommunityEntry) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Snmp_AccessGroup_CommunityEntry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Snmp_AccessGroup_CommunityEntry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Snmp_AccessGroup_CommunityEntry) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Snmp_AccessGroup_CommunityEntry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Snmp_AccessGroup_CommunityEntry.
func (*SrlNokiaSystem_System_Snmp_AccessGroup_CommunityEntry) ΛBelongingModule() string {
	return "srl_nokia-snmp"
}

// SrlNokiaSystem_System_Snmp_AccessGroup_SecurityEntry represents the /srl_nokia-system/system/snmp/access-group/security-entry YANG schema element.
type SrlNokiaSystem_System_Snmp_AccessGroup_SecurityEntry struct {
	Authentication *SrlNokiaSystem_System_Snmp_AccessGroup_SecurityEntry_Authentication `path:"authentication" module:"srl_nokia-snmp"`
	Description    *string                                                              `path:"description" module:"srl_nokia-snmp"`
	Name           *string                                                              `path:"name" module:"srl_nokia-snmp"`
	Privacy        *SrlNokiaSystem_System_Snmp_AccessGroup_SecurityEntry_Privacy        `path:"privacy" module:"srl_nokia-snmp"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Snmp_AccessGroup_SecurityEntry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Snmp_AccessGroup_SecurityEntry) IsYANGGoStruct() {}

// GetOrCreateAuthentication retrieves the value of the Authentication field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_Snmp_AccessGroup_SecurityEntry) GetOrCreateAuthentication() *SrlNokiaSystem_System_Snmp_AccessGroup_SecurityEntry_Authentication {
	if t.Authentication != nil {
		return t.Authentication
	}
	t.Authentication = &SrlNokiaSystem_System_Snmp_AccessGroup_SecurityEntry_Authentication{}
	return t.Authentication
}

// GetOrCreatePrivacy retrieves the value of the Privacy field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_Snmp_AccessGroup_SecurityEntry) GetOrCreatePrivacy() *SrlNokiaSystem_System_Snmp_AccessGroup_SecurityEntry_Privacy {
	if t.Privacy != nil {
		return t.Privacy
	}
	t.Privacy = &SrlNokiaSystem_System_Snmp_AccessGroup_SecurityEntry_Privacy{}
	return t.Privacy
}

// GetAuthentication returns the value of the Authentication struct pointer
// from SrlNokiaSystem_System_Snmp_AccessGroup_SecurityEntry. If the receiver or the field Authentication is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_Snmp_AccessGroup_SecurityEntry) GetAuthentication() *SrlNokiaSystem_System_Snmp_AccessGroup_SecurityEntry_Authentication {
	if t != nil && t.Authentication != nil {
		return t.Authentication
	}
	return nil
}

// GetPrivacy returns the value of the Privacy struct pointer
// from SrlNokiaSystem_System_Snmp_AccessGroup_SecurityEntry. If the receiver or the field Privacy is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_Snmp_AccessGroup_SecurityEntry) GetPrivacy() *SrlNokiaSystem_System_Snmp_AccessGroup_SecurityEntry_Privacy {
	if t != nil && t.Privacy != nil {
		return t.Privacy
	}
	return nil
}

// GetDescription retrieves the value of the leaf Description from the SrlNokiaSystem_System_Snmp_AccessGroup_SecurityEntry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Snmp_AccessGroup_SecurityEntry) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetName retrieves the value of the leaf Name from the SrlNokiaSystem_System_Snmp_AccessGroup_SecurityEntry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Snmp_AccessGroup_SecurityEntry) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Snmp_AccessGroup_SecurityEntry
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Snmp_AccessGroup_SecurityEntry) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Authentication.PopulateDefaults()
	t.Privacy.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_Snmp_AccessGroup_SecurityEntry struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_Snmp_AccessGroup_SecurityEntry) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Snmp_AccessGroup_SecurityEntry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Snmp_AccessGroup_SecurityEntry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Snmp_AccessGroup_SecurityEntry) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Snmp_AccessGroup_SecurityEntry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Snmp_AccessGroup_SecurityEntry.
func (*SrlNokiaSystem_System_Snmp_AccessGroup_SecurityEntry) ΛBelongingModule() string {
	return "srl_nokia-snmp"
}

// SrlNokiaSystem_System_Snmp_AccessGroup_SecurityEntry_Authentication represents the /srl_nokia-system/system/snmp/access-group/security-entry/authentication YANG schema element.
type SrlNokiaSystem_System_Snmp_AccessGroup_SecurityEntry_Authentication struct {
	Password *string                     `path:"password" module:"srl_nokia-snmp"`
	Protocol E_SrlNokiaSnmp_AuthProtocol `path:"protocol" module:"srl_nokia-snmp"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Snmp_AccessGroup_SecurityEntry_Authentication implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Snmp_AccessGroup_SecurityEntry_Authentication) IsYANGGoStruct() {}

// GetPassword retrieves the value of the leaf Password from the SrlNokiaSystem_System_Snmp_AccessGroup_SecurityEntry_Authentication
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Password is set, it can
// safely use t.GetPassword() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Password == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Snmp_AccessGroup_SecurityEntry_Authentication) GetPassword() string {
	if t == nil || t.Password == nil {
		return ""
	}
	return *t.Password
}

// GetProtocol retrieves the value of the leaf Protocol from the SrlNokiaSystem_System_Snmp_AccessGroup_SecurityEntry_Authentication
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Protocol is set, it can
// safely use t.GetProtocol() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Protocol == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Snmp_AccessGroup_SecurityEntry_Authentication) GetProtocol() E_SrlNokiaSnmp_AuthProtocol {
	if t == nil || t.Protocol == 0 {
		return SrlNokiaSnmp_AuthProtocol_hmac_md5_96
	}
	return t.Protocol
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Snmp_AccessGroup_SecurityEntry_Authentication
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Snmp_AccessGroup_SecurityEntry_Authentication) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Protocol == 0 {
		t.Protocol = SrlNokiaSnmp_AuthProtocol_hmac_md5_96
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Snmp_AccessGroup_SecurityEntry_Authentication) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Snmp_AccessGroup_SecurityEntry_Authentication"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Snmp_AccessGroup_SecurityEntry_Authentication) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Snmp_AccessGroup_SecurityEntry_Authentication) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Snmp_AccessGroup_SecurityEntry_Authentication.
func (*SrlNokiaSystem_System_Snmp_AccessGroup_SecurityEntry_Authentication) ΛBelongingModule() string {
	return "srl_nokia-snmp"
}

// SrlNokiaSystem_System_Snmp_AccessGroup_SecurityEntry_Privacy represents the /srl_nokia-system/system/snmp/access-group/security-entry/privacy YANG schema element.
type SrlNokiaSystem_System_Snmp_AccessGroup_SecurityEntry_Privacy struct {
	Password *string                     `path:"password" module:"srl_nokia-snmp"`
	Protocol E_SrlNokiaSnmp_PrivProtocol `path:"protocol" module:"srl_nokia-snmp"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Snmp_AccessGroup_SecurityEntry_Privacy implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Snmp_AccessGroup_SecurityEntry_Privacy) IsYANGGoStruct() {}

// GetPassword retrieves the value of the leaf Password from the SrlNokiaSystem_System_Snmp_AccessGroup_SecurityEntry_Privacy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Password is set, it can
// safely use t.GetPassword() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Password == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Snmp_AccessGroup_SecurityEntry_Privacy) GetPassword() string {
	if t == nil || t.Password == nil {
		return ""
	}
	return *t.Password
}

// GetProtocol retrieves the value of the leaf Protocol from the SrlNokiaSystem_System_Snmp_AccessGroup_SecurityEntry_Privacy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Protocol is set, it can
// safely use t.GetProtocol() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Protocol == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Snmp_AccessGroup_SecurityEntry_Privacy) GetProtocol() E_SrlNokiaSnmp_PrivProtocol {
	if t == nil || t.Protocol == 0 {
		return SrlNokiaSnmp_PrivProtocol_cbc_des
	}
	return t.Protocol
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Snmp_AccessGroup_SecurityEntry_Privacy
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Snmp_AccessGroup_SecurityEntry_Privacy) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Protocol == 0 {
		t.Protocol = SrlNokiaSnmp_PrivProtocol_cbc_des
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Snmp_AccessGroup_SecurityEntry_Privacy) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Snmp_AccessGroup_SecurityEntry_Privacy"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Snmp_AccessGroup_SecurityEntry_Privacy) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Snmp_AccessGroup_SecurityEntry_Privacy) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Snmp_AccessGroup_SecurityEntry_Privacy.
func (*SrlNokiaSystem_System_Snmp_AccessGroup_SecurityEntry_Privacy) ΛBelongingModule() string {
	return "srl_nokia-snmp"
}

// SrlNokiaSystem_System_Snmp_NetworkInstance represents the /srl_nokia-system/system/snmp/network-instance YANG schema element.
type SrlNokiaSystem_System_Snmp_NetworkInstance struct {
	AdminState    E_SrlNokiaCommon_AdminState `path:"admin-state" module:"srl_nokia-snmp"`
	EngineId      *string                     `path:"engine-id" module:"srl_nokia-snmp"`
	Name          *string                     `path:"name" module:"srl_nokia-snmp"`
	SourceAddress []string                    `path:"source-address" module:"srl_nokia-snmp"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Snmp_NetworkInstance implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Snmp_NetworkInstance) IsYANGGoStruct() {}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaSystem_System_Snmp_NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Snmp_NetworkInstance) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return 0
	}
	return t.AdminState
}

// GetEngineId retrieves the value of the leaf EngineId from the SrlNokiaSystem_System_Snmp_NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EngineId is set, it can
// safely use t.GetEngineId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EngineId == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Snmp_NetworkInstance) GetEngineId() string {
	if t == nil || t.EngineId == nil {
		return ""
	}
	return *t.EngineId
}

// GetName retrieves the value of the leaf Name from the SrlNokiaSystem_System_Snmp_NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Snmp_NetworkInstance) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetSourceAddress retrieves the value of the leaf SourceAddress from the SrlNokiaSystem_System_Snmp_NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SourceAddress is set, it can
// safely use t.GetSourceAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SourceAddress == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Snmp_NetworkInstance) GetSourceAddress() []string {
	if t == nil || t.SourceAddress == nil {
		return []string{"::"}
	}
	return t.SourceAddress
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Snmp_NetworkInstance
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Snmp_NetworkInstance) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.SourceAddress == nil {
		t.SourceAddress = []string{"::"}
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_Snmp_NetworkInstance struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_Snmp_NetworkInstance) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Snmp_NetworkInstance) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Snmp_NetworkInstance"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Snmp_NetworkInstance) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Snmp_NetworkInstance) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Snmp_NetworkInstance.
func (*SrlNokiaSystem_System_Snmp_NetworkInstance) ΛBelongingModule() string {
	return "srl_nokia-snmp"
}

// SrlNokiaSystem_System_SshServer represents the /srl_nokia-system/system/ssh-server YANG schema element.
type SrlNokiaSystem_System_SshServer struct {
	HostKey         *SrlNokiaSystem_System_SshServer_HostKey                    `path:"host-key" module:"srl_nokia-ssh"`
	NetworkInstance map[string]*SrlNokiaSystem_System_SshServer_NetworkInstance `path:"network-instance" module:"srl_nokia-ssh"`
	RevokedKeys     []string                                                    `path:"revoked-keys" module:"srl_nokia-ssh"`
	TrustAnchors    []string                                                    `path:"trust-anchors" module:"srl_nokia-ssh"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_SshServer implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_SshServer) IsYANGGoStruct() {}

// NewNetworkInstance creates a new entry in the NetworkInstance list of the
// SrlNokiaSystem_System_SshServer struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_SshServer) NewNetworkInstance(Name string) (*SrlNokiaSystem_System_SshServer_NetworkInstance, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NetworkInstance == nil {
		t.NetworkInstance = make(map[string]*SrlNokiaSystem_System_SshServer_NetworkInstance)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.NetworkInstance[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list NetworkInstance", key)
	}

	t.NetworkInstance[key] = &SrlNokiaSystem_System_SshServer_NetworkInstance{
		Name: &Name,
	}

	return t.NetworkInstance[key], nil
}

// RenameNetworkInstance renames an entry in the list NetworkInstance within
// the SrlNokiaSystem_System_SshServer struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaSystem_System_SshServer) RenameNetworkInstance(oldK, newK string) error {
	if _, ok := t.NetworkInstance[newK]; ok {
		return fmt.Errorf("key %v already exists in NetworkInstance", newK)
	}

	e, ok := t.NetworkInstance[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in NetworkInstance", oldK)
	}
	e.Name = &newK

	t.NetworkInstance[newK] = e
	delete(t.NetworkInstance, oldK)
	return nil
}

// GetOrCreateNetworkInstance retrieves the value with the specified keys from
// the receiver SrlNokiaSystem_System_SshServer. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaSystem_System_SshServer) GetOrCreateNetworkInstance(Name string) *SrlNokiaSystem_System_SshServer_NetworkInstance {
	key := Name

	if v, ok := t.NetworkInstance[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNetworkInstance(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNetworkInstance got unexpected error: %v", err))
	}
	return v
}

// GetNetworkInstance retrieves the value with the specified key from
// the NetworkInstance map field of SrlNokiaSystem_System_SshServer. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaSystem_System_SshServer) GetNetworkInstance(Name string) *SrlNokiaSystem_System_SshServer_NetworkInstance {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.NetworkInstance[key]; ok {
		return lm
	}
	return nil
}

// DeleteNetworkInstance deletes the value with the specified keys from
// the receiver SrlNokiaSystem_System_SshServer. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaSystem_System_SshServer) DeleteNetworkInstance(Name string) {
	key := Name

	delete(t.NetworkInstance, key)
}

// AppendNetworkInstance appends the supplied SrlNokiaSystem_System_SshServer_NetworkInstance struct to the
// list NetworkInstance of SrlNokiaSystem_System_SshServer. If the key value(s) specified in
// the supplied SrlNokiaSystem_System_SshServer_NetworkInstance already exist in the list, an error is
// returned.
func (t *SrlNokiaSystem_System_SshServer) AppendNetworkInstance(v *SrlNokiaSystem_System_SshServer_NetworkInstance) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NetworkInstance == nil {
		t.NetworkInstance = make(map[string]*SrlNokiaSystem_System_SshServer_NetworkInstance)
	}

	if _, ok := t.NetworkInstance[key]; ok {
		return fmt.Errorf("duplicate key for list NetworkInstance %v", key)
	}

	t.NetworkInstance[key] = v
	return nil
}

// GetOrCreateHostKey retrieves the value of the HostKey field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_SshServer) GetOrCreateHostKey() *SrlNokiaSystem_System_SshServer_HostKey {
	if t.HostKey != nil {
		return t.HostKey
	}
	t.HostKey = &SrlNokiaSystem_System_SshServer_HostKey{}
	return t.HostKey
}

// GetHostKey returns the value of the HostKey struct pointer
// from SrlNokiaSystem_System_SshServer. If the receiver or the field HostKey is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_SshServer) GetHostKey() *SrlNokiaSystem_System_SshServer_HostKey {
	if t != nil && t.HostKey != nil {
		return t.HostKey
	}
	return nil
}

// GetRevokedKeys retrieves the value of the leaf RevokedKeys from the SrlNokiaSystem_System_SshServer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RevokedKeys is set, it can
// safely use t.GetRevokedKeys() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RevokedKeys == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_SshServer) GetRevokedKeys() []string {
	if t == nil || t.RevokedKeys == nil {
		return nil
	}
	return t.RevokedKeys
}

// GetTrustAnchors retrieves the value of the leaf TrustAnchors from the SrlNokiaSystem_System_SshServer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TrustAnchors is set, it can
// safely use t.GetTrustAnchors() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TrustAnchors == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_SshServer) GetTrustAnchors() []string {
	if t == nil || t.TrustAnchors == nil {
		return nil
	}
	return t.TrustAnchors
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_SshServer
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_SshServer) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.HostKey.PopulateDefaults()
	for _, e := range t.NetworkInstance {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_SshServer) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_SshServer"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_SshServer) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_SshServer) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_SshServer.
func (*SrlNokiaSystem_System_SshServer) ΛBelongingModule() string {
	return "srl_nokia-ssh"
}

// SrlNokiaSystem_System_SshServer_HostKey represents the /srl_nokia-system/system/ssh-server/host-key YANG schema element.
type SrlNokiaSystem_System_SshServer_HostKey struct {
	Certificate *string `path:"certificate" module:"srl_nokia-ssh"`
	Preserve    *bool   `path:"preserve" module:"srl_nokia-ssh"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_SshServer_HostKey implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_SshServer_HostKey) IsYANGGoStruct() {}

// GetCertificate retrieves the value of the leaf Certificate from the SrlNokiaSystem_System_SshServer_HostKey
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Certificate is set, it can
// safely use t.GetCertificate() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Certificate == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_SshServer_HostKey) GetCertificate() string {
	if t == nil || t.Certificate == nil {
		return ""
	}
	return *t.Certificate
}

// GetPreserve retrieves the value of the leaf Preserve from the SrlNokiaSystem_System_SshServer_HostKey
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Preserve is set, it can
// safely use t.GetPreserve() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Preserve == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_SshServer_HostKey) GetPreserve() bool {
	if t == nil || t.Preserve == nil {
		return true
	}
	return *t.Preserve
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_SshServer_HostKey
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_SshServer_HostKey) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Preserve == nil {
		var v bool = true
		t.Preserve = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_SshServer_HostKey) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_SshServer_HostKey"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_SshServer_HostKey) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_SshServer_HostKey) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_SshServer_HostKey.
func (*SrlNokiaSystem_System_SshServer_HostKey) ΛBelongingModule() string {
	return "srl_nokia-ssh"
}

// SrlNokiaSystem_System_SshServer_NetworkInstance represents the /srl_nokia-system/system/ssh-server/network-instance YANG schema element.
type SrlNokiaSystem_System_SshServer_NetworkInstance struct {
	AdminState    E_SrlNokiaCommon_AdminState `path:"admin-state" module:"srl_nokia-ssh"`
	Name          *string                     `path:"name" module:"srl_nokia-ssh"`
	RateLimit     *uint16                     `path:"rate-limit" module:"srl_nokia-ssh"`
	SourceAddress []string                    `path:"source-address" module:"srl_nokia-ssh"`
	Timeout       *uint16                     `path:"timeout" module:"srl_nokia-ssh"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_SshServer_NetworkInstance implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_SshServer_NetworkInstance) IsYANGGoStruct() {}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaSystem_System_SshServer_NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_SshServer_NetworkInstance) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return 0
	}
	return t.AdminState
}

// GetName retrieves the value of the leaf Name from the SrlNokiaSystem_System_SshServer_NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_SshServer_NetworkInstance) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetRateLimit retrieves the value of the leaf RateLimit from the SrlNokiaSystem_System_SshServer_NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RateLimit is set, it can
// safely use t.GetRateLimit() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RateLimit == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_SshServer_NetworkInstance) GetRateLimit() uint16 {
	if t == nil || t.RateLimit == nil {
		return 20
	}
	return *t.RateLimit
}

// GetSourceAddress retrieves the value of the leaf SourceAddress from the SrlNokiaSystem_System_SshServer_NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SourceAddress is set, it can
// safely use t.GetSourceAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SourceAddress == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_SshServer_NetworkInstance) GetSourceAddress() []string {
	if t == nil || t.SourceAddress == nil {
		return nil
	}
	return t.SourceAddress
}

// GetTimeout retrieves the value of the leaf Timeout from the SrlNokiaSystem_System_SshServer_NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Timeout is set, it can
// safely use t.GetTimeout() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Timeout == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_SshServer_NetworkInstance) GetTimeout() uint16 {
	if t == nil || t.Timeout == nil {
		return 0
	}
	return *t.Timeout
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_SshServer_NetworkInstance
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_SshServer_NetworkInstance) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.RateLimit == nil {
		var v uint16 = 20
		t.RateLimit = &v
	}
	if t.Timeout == nil {
		var v uint16 = 0
		t.Timeout = &v
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_SshServer_NetworkInstance struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_SshServer_NetworkInstance) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_SshServer_NetworkInstance) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_SshServer_NetworkInstance"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_SshServer_NetworkInstance) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_SshServer_NetworkInstance) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_SshServer_NetworkInstance.
func (*SrlNokiaSystem_System_SshServer_NetworkInstance) ΛBelongingModule() string {
	return "srl_nokia-ssh"
}

// SrlNokiaSystem_System_Sync represents the /srl_nokia-system/system/sync YANG schema element.
type SrlNokiaSystem_System_Sync struct {
	FreqClock      *SrlNokiaSystem_System_Sync_FreqClock      `path:"freq-clock" module:"srl_nokia-sync"`
	FreqReferences *SrlNokiaSystem_System_Sync_FreqReferences `path:"freq-references" module:"srl_nokia-sync"`
	Gnss           *SrlNokiaSystem_System_Sync_Gnss           `path:"gnss" module:"srl_nokia-sync"`
	OnePps         *SrlNokiaSystem_System_Sync_OnePps         `path:"one-pps" module:"srl_nokia-sync"`
	Ptp            *SrlNokiaSystem_System_Sync_Ptp            `path:"ptp" module:"srl_nokia-sync"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Sync implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Sync) IsYANGGoStruct() {}

// GetOrCreateFreqClock retrieves the value of the FreqClock field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_Sync) GetOrCreateFreqClock() *SrlNokiaSystem_System_Sync_FreqClock {
	if t.FreqClock != nil {
		return t.FreqClock
	}
	t.FreqClock = &SrlNokiaSystem_System_Sync_FreqClock{}
	return t.FreqClock
}

// GetOrCreateFreqReferences retrieves the value of the FreqReferences field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_Sync) GetOrCreateFreqReferences() *SrlNokiaSystem_System_Sync_FreqReferences {
	if t.FreqReferences != nil {
		return t.FreqReferences
	}
	t.FreqReferences = &SrlNokiaSystem_System_Sync_FreqReferences{}
	return t.FreqReferences
}

// GetOrCreateGnss retrieves the value of the Gnss field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_Sync) GetOrCreateGnss() *SrlNokiaSystem_System_Sync_Gnss {
	if t.Gnss != nil {
		return t.Gnss
	}
	t.Gnss = &SrlNokiaSystem_System_Sync_Gnss{}
	return t.Gnss
}

// GetOrCreateOnePps retrieves the value of the OnePps field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_Sync) GetOrCreateOnePps() *SrlNokiaSystem_System_Sync_OnePps {
	if t.OnePps != nil {
		return t.OnePps
	}
	t.OnePps = &SrlNokiaSystem_System_Sync_OnePps{}
	return t.OnePps
}

// GetOrCreatePtp retrieves the value of the Ptp field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_Sync) GetOrCreatePtp() *SrlNokiaSystem_System_Sync_Ptp {
	if t.Ptp != nil {
		return t.Ptp
	}
	t.Ptp = &SrlNokiaSystem_System_Sync_Ptp{}
	return t.Ptp
}

// GetFreqClock returns the value of the FreqClock struct pointer
// from SrlNokiaSystem_System_Sync. If the receiver or the field FreqClock is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_Sync) GetFreqClock() *SrlNokiaSystem_System_Sync_FreqClock {
	if t != nil && t.FreqClock != nil {
		return t.FreqClock
	}
	return nil
}

// GetFreqReferences returns the value of the FreqReferences struct pointer
// from SrlNokiaSystem_System_Sync. If the receiver or the field FreqReferences is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_Sync) GetFreqReferences() *SrlNokiaSystem_System_Sync_FreqReferences {
	if t != nil && t.FreqReferences != nil {
		return t.FreqReferences
	}
	return nil
}

// GetGnss returns the value of the Gnss struct pointer
// from SrlNokiaSystem_System_Sync. If the receiver or the field Gnss is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_Sync) GetGnss() *SrlNokiaSystem_System_Sync_Gnss {
	if t != nil && t.Gnss != nil {
		return t.Gnss
	}
	return nil
}

// GetOnePps returns the value of the OnePps struct pointer
// from SrlNokiaSystem_System_Sync. If the receiver or the field OnePps is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_Sync) GetOnePps() *SrlNokiaSystem_System_Sync_OnePps {
	if t != nil && t.OnePps != nil {
		return t.OnePps
	}
	return nil
}

// GetPtp returns the value of the Ptp struct pointer
// from SrlNokiaSystem_System_Sync. If the receiver or the field Ptp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_Sync) GetPtp() *SrlNokiaSystem_System_Sync_Ptp {
	if t != nil && t.Ptp != nil {
		return t.Ptp
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Sync
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Sync) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.FreqClock.PopulateDefaults()
	t.FreqReferences.PopulateDefaults()
	t.Gnss.PopulateDefaults()
	t.OnePps.PopulateDefaults()
	t.Ptp.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Sync) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Sync"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Sync) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Sync) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Sync.
func (*SrlNokiaSystem_System_Sync) ΛBelongingModule() string {
	return "srl_nokia-sync"
}

// SrlNokiaSystem_System_Sync_FreqClock represents the /srl_nokia-system/system/sync/freq-clock YANG schema element.
type SrlNokiaSystem_System_Sync_FreqClock struct {
	NetworkType      E_SrlNokiaSystem_System_Sync_FreqClock_NetworkType `path:"network-type" module:"srl_nokia-sync"`
	QlInputThreshold E_SrlNokiaSyncTypes_SettableQlValues               `path:"ql-input-threshold" module:"srl_nokia-sync"`
	QlSelection      *bool                                              `path:"ql-selection" module:"srl_nokia-sync"`
	Revert           *bool                                              `path:"revert" module:"srl_nokia-sync"`
	WaitToRestore    *int8                                              `path:"wait-to-restore" module:"srl_nokia-sync"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Sync_FreqClock implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Sync_FreqClock) IsYANGGoStruct() {}

// GetNetworkType retrieves the value of the leaf NetworkType from the SrlNokiaSystem_System_Sync_FreqClock
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NetworkType is set, it can
// safely use t.GetNetworkType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NetworkType == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Sync_FreqClock) GetNetworkType() E_SrlNokiaSystem_System_Sync_FreqClock_NetworkType {
	if t == nil || t.NetworkType == 0 {
		return SrlNokiaSystem_System_Sync_FreqClock_NetworkType_sonet
	}
	return t.NetworkType
}

// GetQlInputThreshold retrieves the value of the leaf QlInputThreshold from the SrlNokiaSystem_System_Sync_FreqClock
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if QlInputThreshold is set, it can
// safely use t.GetQlInputThreshold() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.QlInputThreshold == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Sync_FreqClock) GetQlInputThreshold() E_SrlNokiaSyncTypes_SettableQlValues {
	if t == nil || t.QlInputThreshold == 0 {
		return SrlNokiaSyncTypes_SettableQlValues_unused
	}
	return t.QlInputThreshold
}

// GetQlSelection retrieves the value of the leaf QlSelection from the SrlNokiaSystem_System_Sync_FreqClock
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if QlSelection is set, it can
// safely use t.GetQlSelection() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.QlSelection == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Sync_FreqClock) GetQlSelection() bool {
	if t == nil || t.QlSelection == nil {
		return false
	}
	return *t.QlSelection
}

// GetRevert retrieves the value of the leaf Revert from the SrlNokiaSystem_System_Sync_FreqClock
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Revert is set, it can
// safely use t.GetRevert() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Revert == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Sync_FreqClock) GetRevert() bool {
	if t == nil || t.Revert == nil {
		return false
	}
	return *t.Revert
}

// GetWaitToRestore retrieves the value of the leaf WaitToRestore from the SrlNokiaSystem_System_Sync_FreqClock
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if WaitToRestore is set, it can
// safely use t.GetWaitToRestore() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.WaitToRestore == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Sync_FreqClock) GetWaitToRestore() int8 {
	if t == nil || t.WaitToRestore == nil {
		return 5
	}
	return *t.WaitToRestore
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Sync_FreqClock
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Sync_FreqClock) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.NetworkType == 0 {
		t.NetworkType = SrlNokiaSystem_System_Sync_FreqClock_NetworkType_sonet
	}
	if t.QlInputThreshold == 0 {
		t.QlInputThreshold = SrlNokiaSyncTypes_SettableQlValues_unused
	}
	if t.QlSelection == nil {
		var v bool = false
		t.QlSelection = &v
	}
	if t.Revert == nil {
		var v bool = false
		t.Revert = &v
	}
	if t.WaitToRestore == nil {
		var v int8 = 5
		t.WaitToRestore = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Sync_FreqClock) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Sync_FreqClock"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Sync_FreqClock) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Sync_FreqClock) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Sync_FreqClock.
func (*SrlNokiaSystem_System_Sync_FreqClock) ΛBelongingModule() string {
	return "srl_nokia-sync"
}

// SrlNokiaSystem_System_Sync_FreqReferences represents the /srl_nokia-system/system/sync/freq-references YANG schema element.
type SrlNokiaSystem_System_Sync_FreqReferences struct {
	Instance map[uint8]*SrlNokiaSystem_System_Sync_FreqReferences_Instance `path:"instance" module:"srl_nokia-sync"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Sync_FreqReferences implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Sync_FreqReferences) IsYANGGoStruct() {}

// NewInstance creates a new entry in the Instance list of the
// SrlNokiaSystem_System_Sync_FreqReferences struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_Sync_FreqReferences) NewInstance(InstanceNumber uint8) (*SrlNokiaSystem_System_Sync_FreqReferences_Instance, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Instance == nil {
		t.Instance = make(map[uint8]*SrlNokiaSystem_System_Sync_FreqReferences_Instance)
	}

	key := InstanceNumber

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Instance[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Instance", key)
	}

	t.Instance[key] = &SrlNokiaSystem_System_Sync_FreqReferences_Instance{
		InstanceNumber: &InstanceNumber,
	}

	return t.Instance[key], nil
}

// RenameInstance renames an entry in the list Instance within
// the SrlNokiaSystem_System_Sync_FreqReferences struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaSystem_System_Sync_FreqReferences) RenameInstance(oldK, newK uint8) error {
	if _, ok := t.Instance[newK]; ok {
		return fmt.Errorf("key %v already exists in Instance", newK)
	}

	e, ok := t.Instance[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Instance", oldK)
	}
	e.InstanceNumber = &newK

	t.Instance[newK] = e
	delete(t.Instance, oldK)
	return nil
}

// GetOrCreateInstance retrieves the value with the specified keys from
// the receiver SrlNokiaSystem_System_Sync_FreqReferences. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaSystem_System_Sync_FreqReferences) GetOrCreateInstance(InstanceNumber uint8) *SrlNokiaSystem_System_Sync_FreqReferences_Instance {
	key := InstanceNumber

	if v, ok := t.Instance[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInstance(InstanceNumber)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInstance got unexpected error: %v", err))
	}
	return v
}

// GetInstance retrieves the value with the specified key from
// the Instance map field of SrlNokiaSystem_System_Sync_FreqReferences. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaSystem_System_Sync_FreqReferences) GetInstance(InstanceNumber uint8) *SrlNokiaSystem_System_Sync_FreqReferences_Instance {
	if t == nil {
		return nil
	}

	key := InstanceNumber

	if lm, ok := t.Instance[key]; ok {
		return lm
	}
	return nil
}

// DeleteInstance deletes the value with the specified keys from
// the receiver SrlNokiaSystem_System_Sync_FreqReferences. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaSystem_System_Sync_FreqReferences) DeleteInstance(InstanceNumber uint8) {
	key := InstanceNumber

	delete(t.Instance, key)
}

// AppendInstance appends the supplied SrlNokiaSystem_System_Sync_FreqReferences_Instance struct to the
// list Instance of SrlNokiaSystem_System_Sync_FreqReferences. If the key value(s) specified in
// the supplied SrlNokiaSystem_System_Sync_FreqReferences_Instance already exist in the list, an error is
// returned.
func (t *SrlNokiaSystem_System_Sync_FreqReferences) AppendInstance(
	v *SrlNokiaSystem_System_Sync_FreqReferences_Instance,
) error {
	if v.InstanceNumber == nil {
		return fmt.Errorf("invalid nil key received for InstanceNumber")
	}

	key := *v.InstanceNumber

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Instance == nil {
		t.Instance = make(map[uint8]*SrlNokiaSystem_System_Sync_FreqReferences_Instance)
	}

	if _, ok := t.Instance[key]; ok {
		return fmt.Errorf("duplicate key for list Instance %v", key)
	}

	t.Instance[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Sync_FreqReferences
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Sync_FreqReferences) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Instance {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Sync_FreqReferences) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Sync_FreqReferences"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Sync_FreqReferences) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Sync_FreqReferences) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Sync_FreqReferences.
func (*SrlNokiaSystem_System_Sync_FreqReferences) ΛBelongingModule() string {
	return "srl_nokia-sync"
}

// SrlNokiaSystem_System_Sync_FreqReferences_Instance represents the /srl_nokia-system/system/sync/freq-references/instance YANG schema element.
type SrlNokiaSystem_System_Sync_FreqReferences_Instance struct {
	AdminState     E_SrlNokiaCommon_AdminState                                `path:"admin-state" module:"srl_nokia-sync"`
	InstanceNumber *uint8                                                     `path:"instance-number" module:"srl_nokia-sync"`
	Priority       *uint8                                                     `path:"priority" module:"srl_nokia-sync"`
	QlOverride     E_SrlNokiaSyncTypes_SettableQlValues                       `path:"ql-override" module:"srl_nokia-sync"`
	Source         *SrlNokiaSystem_System_Sync_FreqReferences_Instance_Source `path:"source" module:"srl_nokia-sync"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Sync_FreqReferences_Instance implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Sync_FreqReferences_Instance) IsYANGGoStruct() {}

// GetOrCreateSource retrieves the value of the Source field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_Sync_FreqReferences_Instance) GetOrCreateSource() *SrlNokiaSystem_System_Sync_FreqReferences_Instance_Source {
	if t.Source != nil {
		return t.Source
	}
	t.Source = &SrlNokiaSystem_System_Sync_FreqReferences_Instance_Source{}
	return t.Source
}

// GetSource returns the value of the Source struct pointer
// from SrlNokiaSystem_System_Sync_FreqReferences_Instance. If the receiver or the field Source is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_Sync_FreqReferences_Instance) GetSource() *SrlNokiaSystem_System_Sync_FreqReferences_Instance_Source {
	if t != nil && t.Source != nil {
		return t.Source
	}
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaSystem_System_Sync_FreqReferences_Instance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Sync_FreqReferences_Instance) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_disable
	}
	return t.AdminState
}

// GetInstanceNumber retrieves the value of the leaf InstanceNumber from the SrlNokiaSystem_System_Sync_FreqReferences_Instance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InstanceNumber is set, it can
// safely use t.GetInstanceNumber() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InstanceNumber == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Sync_FreqReferences_Instance) GetInstanceNumber() uint8 {
	if t == nil || t.InstanceNumber == nil {
		return 0
	}
	return *t.InstanceNumber
}

// GetPriority retrieves the value of the leaf Priority from the SrlNokiaSystem_System_Sync_FreqReferences_Instance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Priority is set, it can
// safely use t.GetPriority() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Priority == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Sync_FreqReferences_Instance) GetPriority() uint8 {
	if t == nil || t.Priority == nil {
		return 3
	}
	return *t.Priority
}

// GetQlOverride retrieves the value of the leaf QlOverride from the SrlNokiaSystem_System_Sync_FreqReferences_Instance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if QlOverride is set, it can
// safely use t.GetQlOverride() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.QlOverride == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Sync_FreqReferences_Instance) GetQlOverride() E_SrlNokiaSyncTypes_SettableQlValues {
	if t == nil || t.QlOverride == 0 {
		return SrlNokiaSyncTypes_SettableQlValues_unused
	}
	return t.QlOverride
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Sync_FreqReferences_Instance
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Sync_FreqReferences_Instance) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_disable
	}
	if t.Priority == nil {
		var v uint8 = 3
		t.Priority = &v
	}
	if t.QlOverride == 0 {
		t.QlOverride = SrlNokiaSyncTypes_SettableQlValues_unused
	}
	t.Source.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_Sync_FreqReferences_Instance struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_Sync_FreqReferences_Instance) ΛListKeyMap() (map[string]interface{}, error) {
	if t.InstanceNumber == nil {
		return nil, fmt.Errorf("nil value for key InstanceNumber")
	}

	return map[string]interface{}{
		"instance-number": *t.InstanceNumber,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Sync_FreqReferences_Instance) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Sync_FreqReferences_Instance"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Sync_FreqReferences_Instance) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Sync_FreqReferences_Instance) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Sync_FreqReferences_Instance.
func (*SrlNokiaSystem_System_Sync_FreqReferences_Instance) ΛBelongingModule() string {
	return "srl_nokia-sync"
}

// SrlNokiaSystem_System_Sync_FreqReferences_Instance_Source represents the /srl_nokia-system/system/sync/freq-references/instance/source YANG schema element.
type SrlNokiaSystem_System_Sync_FreqReferences_Instance_Source struct {
	Interface *string `path:"interface" module:"srl_nokia-sync"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Sync_FreqReferences_Instance_Source implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Sync_FreqReferences_Instance_Source) IsYANGGoStruct() {}

// GetInterface retrieves the value of the leaf Interface from the SrlNokiaSystem_System_Sync_FreqReferences_Instance_Source
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interface is set, it can
// safely use t.GetInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interface == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Sync_FreqReferences_Instance_Source) GetInterface() string {
	if t == nil || t.Interface == nil {
		return ""
	}
	return *t.Interface
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Sync_FreqReferences_Instance_Source
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Sync_FreqReferences_Instance_Source) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Sync_FreqReferences_Instance_Source) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Sync_FreqReferences_Instance_Source"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Sync_FreqReferences_Instance_Source) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Sync_FreqReferences_Instance_Source) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Sync_FreqReferences_Instance_Source.
func (*SrlNokiaSystem_System_Sync_FreqReferences_Instance_Source) ΛBelongingModule() string {
	return "srl_nokia-sync"
}

// SrlNokiaSystem_System_Sync_Gnss represents the /srl_nokia-system/system/sync/gnss YANG schema element.
type SrlNokiaSystem_System_Sync_Gnss struct {
	AdminState    E_SrlNokiaCommon_AdminState                    `path:"admin-state" module:"srl_nokia-sync"`
	Constellation *SrlNokiaSystem_System_Sync_Gnss_Constellation `path:"constellation" module:"srl_nokia-sync"`
	GnssA         *SrlNokiaSystem_System_Sync_Gnss_GnssA         `path:"gnss-a" module:"srl_nokia-sync"`
	GnssB         *SrlNokiaSystem_System_Sync_Gnss_GnssB         `path:"gnss-b" module:"srl_nokia-sync"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Sync_Gnss implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Sync_Gnss) IsYANGGoStruct() {}

// GetOrCreateConstellation retrieves the value of the Constellation field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_Sync_Gnss) GetOrCreateConstellation() *SrlNokiaSystem_System_Sync_Gnss_Constellation {
	if t.Constellation != nil {
		return t.Constellation
	}
	t.Constellation = &SrlNokiaSystem_System_Sync_Gnss_Constellation{}
	return t.Constellation
}

// GetOrCreateGnssA retrieves the value of the GnssA field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_Sync_Gnss) GetOrCreateGnssA() *SrlNokiaSystem_System_Sync_Gnss_GnssA {
	if t.GnssA != nil {
		return t.GnssA
	}
	t.GnssA = &SrlNokiaSystem_System_Sync_Gnss_GnssA{}
	return t.GnssA
}

// GetOrCreateGnssB retrieves the value of the GnssB field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_Sync_Gnss) GetOrCreateGnssB() *SrlNokiaSystem_System_Sync_Gnss_GnssB {
	if t.GnssB != nil {
		return t.GnssB
	}
	t.GnssB = &SrlNokiaSystem_System_Sync_Gnss_GnssB{}
	return t.GnssB
}

// GetConstellation returns the value of the Constellation struct pointer
// from SrlNokiaSystem_System_Sync_Gnss. If the receiver or the field Constellation is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_Sync_Gnss) GetConstellation() *SrlNokiaSystem_System_Sync_Gnss_Constellation {
	if t != nil && t.Constellation != nil {
		return t.Constellation
	}
	return nil
}

// GetGnssA returns the value of the GnssA struct pointer
// from SrlNokiaSystem_System_Sync_Gnss. If the receiver or the field GnssA is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_Sync_Gnss) GetGnssA() *SrlNokiaSystem_System_Sync_Gnss_GnssA {
	if t != nil && t.GnssA != nil {
		return t.GnssA
	}
	return nil
}

// GetGnssB returns the value of the GnssB struct pointer
// from SrlNokiaSystem_System_Sync_Gnss. If the receiver or the field GnssB is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_Sync_Gnss) GetGnssB() *SrlNokiaSystem_System_Sync_Gnss_GnssB {
	if t != nil && t.GnssB != nil {
		return t.GnssB
	}
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaSystem_System_Sync_Gnss
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Sync_Gnss) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_disable
	}
	return t.AdminState
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Sync_Gnss
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Sync_Gnss) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_disable
	}
	t.Constellation.PopulateDefaults()
	t.GnssA.PopulateDefaults()
	t.GnssB.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Sync_Gnss) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Sync_Gnss"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Sync_Gnss) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Sync_Gnss) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Sync_Gnss.
func (*SrlNokiaSystem_System_Sync_Gnss) ΛBelongingModule() string {
	return "srl_nokia-sync"
}

// SrlNokiaSystem_System_Sync_Gnss_Constellation represents the /srl_nokia-system/system/sync/gnss/constellation YANG schema element.
type SrlNokiaSystem_System_Sync_Gnss_Constellation struct {
	Galileo *bool `path:"galileo" module:"srl_nokia-sync"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Sync_Gnss_Constellation implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Sync_Gnss_Constellation) IsYANGGoStruct() {}

// GetGalileo retrieves the value of the leaf Galileo from the SrlNokiaSystem_System_Sync_Gnss_Constellation
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Galileo is set, it can
// safely use t.GetGalileo() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Galileo == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Sync_Gnss_Constellation) GetGalileo() bool {
	if t == nil || t.Galileo == nil {
		return false
	}
	return *t.Galileo
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Sync_Gnss_Constellation
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Sync_Gnss_Constellation) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Galileo == nil {
		var v bool = false
		t.Galileo = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Sync_Gnss_Constellation) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Sync_Gnss_Constellation"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Sync_Gnss_Constellation) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Sync_Gnss_Constellation) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Sync_Gnss_Constellation.
func (*SrlNokiaSystem_System_Sync_Gnss_Constellation) ΛBelongingModule() string {
	return "srl_nokia-sync"
}

// SrlNokiaSystem_System_Sync_Gnss_GnssA represents the /srl_nokia-system/system/sync/gnss/gnss-a YANG schema element.
type SrlNokiaSystem_System_Sync_Gnss_GnssA struct {
	AntennaCableDelay  *uint16                                          `path:"antenna-cable-delay" module:"srl_nokia-sync"`
	ElevationMaskAngle *uint8                                           `path:"elevation-mask-angle" module:"srl_nokia-sync"`
	SatsInUse          *SrlNokiaSystem_System_Sync_Gnss_GnssA_SatsInUse `path:"sats-in-use" module:"srl_nokia-sync"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Sync_Gnss_GnssA implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Sync_Gnss_GnssA) IsYANGGoStruct() {}

// GetOrCreateSatsInUse retrieves the value of the SatsInUse field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_Sync_Gnss_GnssA) GetOrCreateSatsInUse() *SrlNokiaSystem_System_Sync_Gnss_GnssA_SatsInUse {
	if t.SatsInUse != nil {
		return t.SatsInUse
	}
	t.SatsInUse = &SrlNokiaSystem_System_Sync_Gnss_GnssA_SatsInUse{}
	return t.SatsInUse
}

// GetSatsInUse returns the value of the SatsInUse struct pointer
// from SrlNokiaSystem_System_Sync_Gnss_GnssA. If the receiver or the field SatsInUse is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_Sync_Gnss_GnssA) GetSatsInUse() *SrlNokiaSystem_System_Sync_Gnss_GnssA_SatsInUse {
	if t != nil && t.SatsInUse != nil {
		return t.SatsInUse
	}
	return nil
}

// GetAntennaCableDelay retrieves the value of the leaf AntennaCableDelay from the SrlNokiaSystem_System_Sync_Gnss_GnssA
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AntennaCableDelay is set, it can
// safely use t.GetAntennaCableDelay() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AntennaCableDelay == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Sync_Gnss_GnssA) GetAntennaCableDelay() uint16 {
	if t == nil || t.AntennaCableDelay == nil {
		return 0
	}
	return *t.AntennaCableDelay
}

// GetElevationMaskAngle retrieves the value of the leaf ElevationMaskAngle from the SrlNokiaSystem_System_Sync_Gnss_GnssA
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ElevationMaskAngle is set, it can
// safely use t.GetElevationMaskAngle() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ElevationMaskAngle == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Sync_Gnss_GnssA) GetElevationMaskAngle() uint8 {
	if t == nil || t.ElevationMaskAngle == nil {
		return 10
	}
	return *t.ElevationMaskAngle
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Sync_Gnss_GnssA
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Sync_Gnss_GnssA) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AntennaCableDelay == nil {
		var v uint16 = 0
		t.AntennaCableDelay = &v
	}
	if t.ElevationMaskAngle == nil {
		var v uint8 = 10
		t.ElevationMaskAngle = &v
	}
	t.SatsInUse.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Sync_Gnss_GnssA) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Sync_Gnss_GnssA"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Sync_Gnss_GnssA) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Sync_Gnss_GnssA) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Sync_Gnss_GnssA.
func (*SrlNokiaSystem_System_Sync_Gnss_GnssA) ΛBelongingModule() string {
	return "srl_nokia-sync"
}

// SrlNokiaSystem_System_Sync_Gnss_GnssA_SatsInUse represents the /srl_nokia-system/system/sync/gnss/gnss-a/sats-in-use YANG schema element.
type SrlNokiaSystem_System_Sync_Gnss_GnssA_SatsInUse struct{}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Sync_Gnss_GnssA_SatsInUse implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Sync_Gnss_GnssA_SatsInUse) IsYANGGoStruct() {}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Sync_Gnss_GnssA_SatsInUse
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Sync_Gnss_GnssA_SatsInUse) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Sync_Gnss_GnssA_SatsInUse) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Sync_Gnss_GnssA_SatsInUse"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Sync_Gnss_GnssA_SatsInUse) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Sync_Gnss_GnssA_SatsInUse) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Sync_Gnss_GnssA_SatsInUse.
func (*SrlNokiaSystem_System_Sync_Gnss_GnssA_SatsInUse) ΛBelongingModule() string {
	return "srl_nokia-sync"
}

// SrlNokiaSystem_System_Sync_Gnss_GnssB represents the /srl_nokia-system/system/sync/gnss/gnss-b YANG schema element.
type SrlNokiaSystem_System_Sync_Gnss_GnssB struct {
	AntennaCableDelay  *uint16                                          `path:"antenna-cable-delay" module:"srl_nokia-sync"`
	ElevationMaskAngle *uint8                                           `path:"elevation-mask-angle" module:"srl_nokia-sync"`
	SatsInUse          *SrlNokiaSystem_System_Sync_Gnss_GnssB_SatsInUse `path:"sats-in-use" module:"srl_nokia-sync"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Sync_Gnss_GnssB implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Sync_Gnss_GnssB) IsYANGGoStruct() {}

// GetOrCreateSatsInUse retrieves the value of the SatsInUse field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_Sync_Gnss_GnssB) GetOrCreateSatsInUse() *SrlNokiaSystem_System_Sync_Gnss_GnssB_SatsInUse {
	if t.SatsInUse != nil {
		return t.SatsInUse
	}
	t.SatsInUse = &SrlNokiaSystem_System_Sync_Gnss_GnssB_SatsInUse{}
	return t.SatsInUse
}

// GetSatsInUse returns the value of the SatsInUse struct pointer
// from SrlNokiaSystem_System_Sync_Gnss_GnssB. If the receiver or the field SatsInUse is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_Sync_Gnss_GnssB) GetSatsInUse() *SrlNokiaSystem_System_Sync_Gnss_GnssB_SatsInUse {
	if t != nil && t.SatsInUse != nil {
		return t.SatsInUse
	}
	return nil
}

// GetAntennaCableDelay retrieves the value of the leaf AntennaCableDelay from the SrlNokiaSystem_System_Sync_Gnss_GnssB
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AntennaCableDelay is set, it can
// safely use t.GetAntennaCableDelay() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AntennaCableDelay == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Sync_Gnss_GnssB) GetAntennaCableDelay() uint16 {
	if t == nil || t.AntennaCableDelay == nil {
		return 0
	}
	return *t.AntennaCableDelay
}

// GetElevationMaskAngle retrieves the value of the leaf ElevationMaskAngle from the SrlNokiaSystem_System_Sync_Gnss_GnssB
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ElevationMaskAngle is set, it can
// safely use t.GetElevationMaskAngle() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ElevationMaskAngle == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Sync_Gnss_GnssB) GetElevationMaskAngle() uint8 {
	if t == nil || t.ElevationMaskAngle == nil {
		return 10
	}
	return *t.ElevationMaskAngle
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Sync_Gnss_GnssB
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Sync_Gnss_GnssB) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AntennaCableDelay == nil {
		var v uint16 = 0
		t.AntennaCableDelay = &v
	}
	if t.ElevationMaskAngle == nil {
		var v uint8 = 10
		t.ElevationMaskAngle = &v
	}
	t.SatsInUse.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Sync_Gnss_GnssB) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Sync_Gnss_GnssB"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Sync_Gnss_GnssB) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Sync_Gnss_GnssB) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Sync_Gnss_GnssB.
func (*SrlNokiaSystem_System_Sync_Gnss_GnssB) ΛBelongingModule() string {
	return "srl_nokia-sync"
}

// SrlNokiaSystem_System_Sync_Gnss_GnssB_SatsInUse represents the /srl_nokia-system/system/sync/gnss/gnss-b/sats-in-use YANG schema element.
type SrlNokiaSystem_System_Sync_Gnss_GnssB_SatsInUse struct{}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Sync_Gnss_GnssB_SatsInUse implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Sync_Gnss_GnssB_SatsInUse) IsYANGGoStruct() {}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Sync_Gnss_GnssB_SatsInUse
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Sync_Gnss_GnssB_SatsInUse) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Sync_Gnss_GnssB_SatsInUse) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Sync_Gnss_GnssB_SatsInUse"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Sync_Gnss_GnssB_SatsInUse) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Sync_Gnss_GnssB_SatsInUse) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Sync_Gnss_GnssB_SatsInUse.
func (*SrlNokiaSystem_System_Sync_Gnss_GnssB_SatsInUse) ΛBelongingModule() string {
	return "srl_nokia-sync"
}

// SrlNokiaSystem_System_Sync_OnePps represents the /srl_nokia-system/system/sync/one-pps YANG schema element.
type SrlNokiaSystem_System_Sync_OnePps struct {
	AdminState E_SrlNokiaCommon_AdminState `path:"admin-state" module:"srl_nokia-sync"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Sync_OnePps implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Sync_OnePps) IsYANGGoStruct() {}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaSystem_System_Sync_OnePps
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Sync_OnePps) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_disable
	}
	return t.AdminState
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Sync_OnePps
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Sync_OnePps) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_disable
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Sync_OnePps) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Sync_OnePps"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Sync_OnePps) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Sync_OnePps) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Sync_OnePps.
func (*SrlNokiaSystem_System_Sync_OnePps) ΛBelongingModule() string {
	return "srl_nokia-sync"
}

// SrlNokiaSystem_System_Sync_Ptp represents the /srl_nokia-system/system/sync/ptp YANG schema element.
type SrlNokiaSystem_System_Sync_Ptp struct {
	Instance   map[uint32]*SrlNokiaSystem_System_Sync_Ptp_Instance `path:"instance" module:"srl_nokia-sync"`
	PtpProfile E_SrlNokiaSystem_System_Sync_Ptp_PtpProfile         `path:"ptp-profile" module:"srl_nokia-sync"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Sync_Ptp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Sync_Ptp) IsYANGGoStruct() {}

// NewInstance creates a new entry in the Instance list of the
// SrlNokiaSystem_System_Sync_Ptp struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_Sync_Ptp) NewInstance(InstanceIndex uint32) (*SrlNokiaSystem_System_Sync_Ptp_Instance, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Instance == nil {
		t.Instance = make(map[uint32]*SrlNokiaSystem_System_Sync_Ptp_Instance)
	}

	key := InstanceIndex

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Instance[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Instance", key)
	}

	t.Instance[key] = &SrlNokiaSystem_System_Sync_Ptp_Instance{
		InstanceIndex: &InstanceIndex,
	}

	return t.Instance[key], nil
}

// RenameInstance renames an entry in the list Instance within
// the SrlNokiaSystem_System_Sync_Ptp struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaSystem_System_Sync_Ptp) RenameInstance(oldK, newK uint32) error {
	if _, ok := t.Instance[newK]; ok {
		return fmt.Errorf("key %v already exists in Instance", newK)
	}

	e, ok := t.Instance[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Instance", oldK)
	}
	e.InstanceIndex = &newK

	t.Instance[newK] = e
	delete(t.Instance, oldK)
	return nil
}

// GetOrCreateInstance retrieves the value with the specified keys from
// the receiver SrlNokiaSystem_System_Sync_Ptp. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaSystem_System_Sync_Ptp) GetOrCreateInstance(InstanceIndex uint32) *SrlNokiaSystem_System_Sync_Ptp_Instance {
	key := InstanceIndex

	if v, ok := t.Instance[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInstance(InstanceIndex)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInstance got unexpected error: %v", err))
	}
	return v
}

// GetInstance retrieves the value with the specified key from
// the Instance map field of SrlNokiaSystem_System_Sync_Ptp. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaSystem_System_Sync_Ptp) GetInstance(InstanceIndex uint32) *SrlNokiaSystem_System_Sync_Ptp_Instance {
	if t == nil {
		return nil
	}

	key := InstanceIndex

	if lm, ok := t.Instance[key]; ok {
		return lm
	}
	return nil
}

// DeleteInstance deletes the value with the specified keys from
// the receiver SrlNokiaSystem_System_Sync_Ptp. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaSystem_System_Sync_Ptp) DeleteInstance(InstanceIndex uint32) {
	key := InstanceIndex

	delete(t.Instance, key)
}

// AppendInstance appends the supplied SrlNokiaSystem_System_Sync_Ptp_Instance struct to the
// list Instance of SrlNokiaSystem_System_Sync_Ptp. If the key value(s) specified in
// the supplied SrlNokiaSystem_System_Sync_Ptp_Instance already exist in the list, an error is
// returned.
func (t *SrlNokiaSystem_System_Sync_Ptp) AppendInstance(v *SrlNokiaSystem_System_Sync_Ptp_Instance) error {
	if v.InstanceIndex == nil {
		return fmt.Errorf("invalid nil key received for InstanceIndex")
	}

	key := *v.InstanceIndex

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Instance == nil {
		t.Instance = make(map[uint32]*SrlNokiaSystem_System_Sync_Ptp_Instance)
	}

	if _, ok := t.Instance[key]; ok {
		return fmt.Errorf("duplicate key for list Instance %v", key)
	}

	t.Instance[key] = v
	return nil
}

// GetPtpProfile retrieves the value of the leaf PtpProfile from the SrlNokiaSystem_System_Sync_Ptp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PtpProfile is set, it can
// safely use t.GetPtpProfile() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PtpProfile == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Sync_Ptp) GetPtpProfile() E_SrlNokiaSystem_System_Sync_Ptp_PtpProfile {
	if t == nil || t.PtpProfile == 0 {
		return SrlNokiaSystem_System_Sync_Ptp_PtpProfile_itug8275dot1
	}
	return t.PtpProfile
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Sync_Ptp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Sync_Ptp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.PtpProfile == 0 {
		t.PtpProfile = SrlNokiaSystem_System_Sync_Ptp_PtpProfile_itug8275dot1
	}
	for _, e := range t.Instance {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Sync_Ptp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Sync_Ptp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Sync_Ptp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Sync_Ptp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Sync_Ptp.
func (*SrlNokiaSystem_System_Sync_Ptp) ΛBelongingModule() string {
	return "srl_nokia-sync"
}

// SrlNokiaSystem_System_Sync_Ptp_Instance represents the /srl_nokia-system/system/sync/ptp/instance YANG schema element.
type SrlNokiaSystem_System_Sync_Ptp_Instance struct {
	DefaultDs        *SrlNokiaSystem_System_Sync_Ptp_Instance_DefaultDs                   `path:"default-ds" module:"srl_nokia-sync"`
	InstanceIndex    *uint32                                                              `path:"instance-index" module:"srl_nokia-sync"`
	NetworkInstances map[string]*SrlNokiaSystem_System_Sync_Ptp_Instance_NetworkInstances `path:"network-instances" module:"srl_nokia-sync"`
	PortDsList       map[uint16]*SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList       `path:"port-ds-list" module:"srl_nokia-sync"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Sync_Ptp_Instance implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Sync_Ptp_Instance) IsYANGGoStruct() {}

// NewNetworkInstances creates a new entry in the NetworkInstances list of the
// SrlNokiaSystem_System_Sync_Ptp_Instance struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance) NewNetworkInstances(NetworkInstance string) (*SrlNokiaSystem_System_Sync_Ptp_Instance_NetworkInstances, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NetworkInstances == nil {
		t.NetworkInstances = make(map[string]*SrlNokiaSystem_System_Sync_Ptp_Instance_NetworkInstances)
	}

	key := NetworkInstance

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.NetworkInstances[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list NetworkInstances", key)
	}

	t.NetworkInstances[key] = &SrlNokiaSystem_System_Sync_Ptp_Instance_NetworkInstances{
		NetworkInstance: &NetworkInstance,
	}

	return t.NetworkInstances[key], nil
}

// RenameNetworkInstances renames an entry in the list NetworkInstances within
// the SrlNokiaSystem_System_Sync_Ptp_Instance struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance) RenameNetworkInstances(oldK, newK string) error {
	if _, ok := t.NetworkInstances[newK]; ok {
		return fmt.Errorf("key %v already exists in NetworkInstances", newK)
	}

	e, ok := t.NetworkInstances[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in NetworkInstances", oldK)
	}
	e.NetworkInstance = &newK

	t.NetworkInstances[newK] = e
	delete(t.NetworkInstances, oldK)
	return nil
}

// GetOrCreateNetworkInstances retrieves the value with the specified keys from
// the receiver SrlNokiaSystem_System_Sync_Ptp_Instance. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance) GetOrCreateNetworkInstances(
	NetworkInstance string,
) *SrlNokiaSystem_System_Sync_Ptp_Instance_NetworkInstances {
	key := NetworkInstance

	if v, ok := t.NetworkInstances[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNetworkInstances(NetworkInstance)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNetworkInstances got unexpected error: %v", err))
	}
	return v
}

// GetNetworkInstances retrieves the value with the specified key from
// the NetworkInstances map field of SrlNokiaSystem_System_Sync_Ptp_Instance. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance) GetNetworkInstances(NetworkInstance string) *SrlNokiaSystem_System_Sync_Ptp_Instance_NetworkInstances {
	if t == nil {
		return nil
	}

	key := NetworkInstance

	if lm, ok := t.NetworkInstances[key]; ok {
		return lm
	}
	return nil
}

// DeleteNetworkInstances deletes the value with the specified keys from
// the receiver SrlNokiaSystem_System_Sync_Ptp_Instance. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance) DeleteNetworkInstances(NetworkInstance string) {
	key := NetworkInstance

	delete(t.NetworkInstances, key)
}

// AppendNetworkInstances appends the supplied SrlNokiaSystem_System_Sync_Ptp_Instance_NetworkInstances struct to the
// list NetworkInstances of SrlNokiaSystem_System_Sync_Ptp_Instance. If the key value(s) specified in
// the supplied SrlNokiaSystem_System_Sync_Ptp_Instance_NetworkInstances already exist in the list, an error is
// returned.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance) AppendNetworkInstances(
	v *SrlNokiaSystem_System_Sync_Ptp_Instance_NetworkInstances,
) error {
	if v.NetworkInstance == nil {
		return fmt.Errorf("invalid nil key received for NetworkInstance")
	}

	key := *v.NetworkInstance

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NetworkInstances == nil {
		t.NetworkInstances = make(map[string]*SrlNokiaSystem_System_Sync_Ptp_Instance_NetworkInstances)
	}

	if _, ok := t.NetworkInstances[key]; ok {
		return fmt.Errorf("duplicate key for list NetworkInstances %v", key)
	}

	t.NetworkInstances[key] = v
	return nil
}

// NewPortDsList creates a new entry in the PortDsList list of the
// SrlNokiaSystem_System_Sync_Ptp_Instance struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance) NewPortDsList(PortIndex uint16) (*SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PortDsList == nil {
		t.PortDsList = make(map[uint16]*SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList)
	}

	key := PortIndex

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.PortDsList[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list PortDsList", key)
	}

	t.PortDsList[key] = &SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList{
		PortIndex: &PortIndex,
	}

	return t.PortDsList[key], nil
}

// RenamePortDsList renames an entry in the list PortDsList within
// the SrlNokiaSystem_System_Sync_Ptp_Instance struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance) RenamePortDsList(oldK, newK uint16) error {
	if _, ok := t.PortDsList[newK]; ok {
		return fmt.Errorf("key %v already exists in PortDsList", newK)
	}

	e, ok := t.PortDsList[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in PortDsList", oldK)
	}
	e.PortIndex = &newK

	t.PortDsList[newK] = e
	delete(t.PortDsList, oldK)
	return nil
}

// GetOrCreatePortDsList retrieves the value with the specified keys from
// the receiver SrlNokiaSystem_System_Sync_Ptp_Instance. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance) GetOrCreatePortDsList(PortIndex uint16) *SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList {
	key := PortIndex

	if v, ok := t.PortDsList[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPortDsList(PortIndex)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePortDsList got unexpected error: %v", err))
	}
	return v
}

// GetPortDsList retrieves the value with the specified key from
// the PortDsList map field of SrlNokiaSystem_System_Sync_Ptp_Instance. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance) GetPortDsList(PortIndex uint16) *SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList {
	if t == nil {
		return nil
	}

	key := PortIndex

	if lm, ok := t.PortDsList[key]; ok {
		return lm
	}
	return nil
}

// DeletePortDsList deletes the value with the specified keys from
// the receiver SrlNokiaSystem_System_Sync_Ptp_Instance. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance) DeletePortDsList(PortIndex uint16) {
	key := PortIndex

	delete(t.PortDsList, key)
}

// AppendPortDsList appends the supplied SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList struct to the
// list PortDsList of SrlNokiaSystem_System_Sync_Ptp_Instance. If the key value(s) specified in
// the supplied SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList already exist in the list, an error is
// returned.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance) AppendPortDsList(
	v *SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList,
) error {
	if v.PortIndex == nil {
		return fmt.Errorf("invalid nil key received for PortIndex")
	}

	key := *v.PortIndex

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PortDsList == nil {
		t.PortDsList = make(map[uint16]*SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList)
	}

	if _, ok := t.PortDsList[key]; ok {
		return fmt.Errorf("duplicate key for list PortDsList %v", key)
	}

	t.PortDsList[key] = v
	return nil
}

// GetOrCreateDefaultDs retrieves the value of the DefaultDs field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance) GetOrCreateDefaultDs() *SrlNokiaSystem_System_Sync_Ptp_Instance_DefaultDs {
	if t.DefaultDs != nil {
		return t.DefaultDs
	}
	t.DefaultDs = &SrlNokiaSystem_System_Sync_Ptp_Instance_DefaultDs{}
	return t.DefaultDs
}

// GetDefaultDs returns the value of the DefaultDs struct pointer
// from SrlNokiaSystem_System_Sync_Ptp_Instance. If the receiver or the field DefaultDs is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance) GetDefaultDs() *SrlNokiaSystem_System_Sync_Ptp_Instance_DefaultDs {
	if t != nil && t.DefaultDs != nil {
		return t.DefaultDs
	}
	return nil
}

// GetInstanceIndex retrieves the value of the leaf InstanceIndex from the SrlNokiaSystem_System_Sync_Ptp_Instance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InstanceIndex is set, it can
// safely use t.GetInstanceIndex() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InstanceIndex == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance) GetInstanceIndex() uint32 {
	if t == nil || t.InstanceIndex == nil {
		return 0
	}
	return *t.InstanceIndex
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Sync_Ptp_Instance
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.DefaultDs.PopulateDefaults()
	for _, e := range t.NetworkInstances {
		e.PopulateDefaults()
	}
	for _, e := range t.PortDsList {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_Sync_Ptp_Instance struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance) ΛListKeyMap() (map[string]interface{}, error) {
	if t.InstanceIndex == nil {
		return nil, fmt.Errorf("nil value for key InstanceIndex")
	}

	return map[string]interface{}{
		"instance-index": *t.InstanceIndex,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Sync_Ptp_Instance"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Sync_Ptp_Instance.
func (*SrlNokiaSystem_System_Sync_Ptp_Instance) ΛBelongingModule() string {
	return "srl_nokia-sync"
}

// SrlNokiaSystem_System_Sync_Ptp_Instance_DefaultDs represents the /srl_nokia-system/system/sync/ptp/instance/default-ds YANG schema element.
type SrlNokiaSystem_System_Sync_Ptp_Instance_DefaultDs struct {
	AnnounceReceiptTimeout *uint8                                                           `path:"announce-receipt-timeout" module:"srl_nokia-sync"`
	DomainNumber           *uint8                                                           `path:"domain-number" module:"srl_nokia-sync"`
	InstanceEnable         *bool                                                            `path:"instance-enable" module:"srl_nokia-sync"`
	InstanceType           E_SrlNokiaSystem_System_Sync_Ptp_Instance_DefaultDs_InstanceType `path:"instance-type" module:"srl_nokia-sync"`
	LocalPriority          *uint8                                                           `path:"local-priority" module:"srl_nokia-sync"`
	LogAnnounceInterval    *int8                                                            `path:"log-announce-interval" module:"srl_nokia-sync"`
	Priority1              *uint8                                                           `path:"priority1" module:"srl_nokia-sync"`
	Priority2              *uint8                                                           `path:"priority2" module:"srl_nokia-sync"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Sync_Ptp_Instance_DefaultDs implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Sync_Ptp_Instance_DefaultDs) IsYANGGoStruct() {}

// GetAnnounceReceiptTimeout retrieves the value of the leaf AnnounceReceiptTimeout from the SrlNokiaSystem_System_Sync_Ptp_Instance_DefaultDs
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AnnounceReceiptTimeout is set, it can
// safely use t.GetAnnounceReceiptTimeout() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AnnounceReceiptTimeout == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance_DefaultDs) GetAnnounceReceiptTimeout() uint8 {
	if t == nil || t.AnnounceReceiptTimeout == nil {
		return 3
	}
	return *t.AnnounceReceiptTimeout
}

// GetDomainNumber retrieves the value of the leaf DomainNumber from the SrlNokiaSystem_System_Sync_Ptp_Instance_DefaultDs
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DomainNumber is set, it can
// safely use t.GetDomainNumber() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DomainNumber == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance_DefaultDs) GetDomainNumber() uint8 {
	if t == nil || t.DomainNumber == nil {
		return 0
	}
	return *t.DomainNumber
}

// GetInstanceEnable retrieves the value of the leaf InstanceEnable from the SrlNokiaSystem_System_Sync_Ptp_Instance_DefaultDs
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InstanceEnable is set, it can
// safely use t.GetInstanceEnable() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InstanceEnable == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance_DefaultDs) GetInstanceEnable() bool {
	if t == nil || t.InstanceEnable == nil {
		return false
	}
	return *t.InstanceEnable
}

// GetInstanceType retrieves the value of the leaf InstanceType from the SrlNokiaSystem_System_Sync_Ptp_Instance_DefaultDs
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InstanceType is set, it can
// safely use t.GetInstanceType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InstanceType == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance_DefaultDs) GetInstanceType() E_SrlNokiaSystem_System_Sync_Ptp_Instance_DefaultDs_InstanceType {
	if t == nil || t.InstanceType == 0 {
		return SrlNokiaSystem_System_Sync_Ptp_Instance_DefaultDs_InstanceType_bc
	}
	return t.InstanceType
}

// GetLocalPriority retrieves the value of the leaf LocalPriority from the SrlNokiaSystem_System_Sync_Ptp_Instance_DefaultDs
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LocalPriority is set, it can
// safely use t.GetLocalPriority() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LocalPriority == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance_DefaultDs) GetLocalPriority() uint8 {
	if t == nil || t.LocalPriority == nil {
		return 128
	}
	return *t.LocalPriority
}

// GetLogAnnounceInterval retrieves the value of the leaf LogAnnounceInterval from the SrlNokiaSystem_System_Sync_Ptp_Instance_DefaultDs
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LogAnnounceInterval is set, it can
// safely use t.GetLogAnnounceInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LogAnnounceInterval == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance_DefaultDs) GetLogAnnounceInterval() int8 {
	if t == nil || t.LogAnnounceInterval == nil {
		return 0
	}
	return *t.LogAnnounceInterval
}

// GetPriority1 retrieves the value of the leaf Priority1 from the SrlNokiaSystem_System_Sync_Ptp_Instance_DefaultDs
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Priority1 is set, it can
// safely use t.GetPriority1() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Priority1 == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance_DefaultDs) GetPriority1() uint8 {
	if t == nil || t.Priority1 == nil {
		return 128
	}
	return *t.Priority1
}

// GetPriority2 retrieves the value of the leaf Priority2 from the SrlNokiaSystem_System_Sync_Ptp_Instance_DefaultDs
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Priority2 is set, it can
// safely use t.GetPriority2() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Priority2 == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance_DefaultDs) GetPriority2() uint8 {
	if t == nil || t.Priority2 == nil {
		return 128
	}
	return *t.Priority2
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Sync_Ptp_Instance_DefaultDs
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance_DefaultDs) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AnnounceReceiptTimeout == nil {
		var v uint8 = 3
		t.AnnounceReceiptTimeout = &v
	}
	if t.InstanceEnable == nil {
		var v bool = false
		t.InstanceEnable = &v
	}
	if t.InstanceType == 0 {
		t.InstanceType = SrlNokiaSystem_System_Sync_Ptp_Instance_DefaultDs_InstanceType_bc
	}
	if t.LocalPriority == nil {
		var v uint8 = 128
		t.LocalPriority = &v
	}
	if t.Priority1 == nil {
		var v uint8 = 128
		t.Priority1 = &v
	}
	if t.Priority2 == nil {
		var v uint8 = 128
		t.Priority2 = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance_DefaultDs) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Sync_Ptp_Instance_DefaultDs"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance_DefaultDs) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance_DefaultDs) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Sync_Ptp_Instance_DefaultDs.
func (*SrlNokiaSystem_System_Sync_Ptp_Instance_DefaultDs) ΛBelongingModule() string {
	return "srl_nokia-sync"
}

// SrlNokiaSystem_System_Sync_Ptp_Instance_NetworkInstances represents the /srl_nokia-system/system/sync/ptp/instance/network-instances YANG schema element.
type SrlNokiaSystem_System_Sync_Ptp_Instance_NetworkInstances struct {
	AdminState      E_SrlNokiaCommon_AdminState `path:"admin-state" module:"srl_nokia-sync"`
	NetworkInstance *string                     `path:"network-instance" module:"srl_nokia-sync"`
	PeerLimit       *int32                      `path:"peer-limit" module:"srl_nokia-sync"`
	SourceAddress   *string                     `path:"source-address" module:"srl_nokia-sync"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Sync_Ptp_Instance_NetworkInstances implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Sync_Ptp_Instance_NetworkInstances) IsYANGGoStruct() {}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaSystem_System_Sync_Ptp_Instance_NetworkInstances
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance_NetworkInstances) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_enable
	}
	return t.AdminState
}

// GetNetworkInstance retrieves the value of the leaf NetworkInstance from the SrlNokiaSystem_System_Sync_Ptp_Instance_NetworkInstances
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NetworkInstance is set, it can
// safely use t.GetNetworkInstance() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NetworkInstance == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance_NetworkInstances) GetNetworkInstance() string {
	if t == nil || t.NetworkInstance == nil {
		return ""
	}
	return *t.NetworkInstance
}

// GetPeerLimit retrieves the value of the leaf PeerLimit from the SrlNokiaSystem_System_Sync_Ptp_Instance_NetworkInstances
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PeerLimit is set, it can
// safely use t.GetPeerLimit() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PeerLimit == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance_NetworkInstances) GetPeerLimit() int32 {
	if t == nil || t.PeerLimit == nil {
		return 0
	}
	return *t.PeerLimit
}

// GetSourceAddress retrieves the value of the leaf SourceAddress from the SrlNokiaSystem_System_Sync_Ptp_Instance_NetworkInstances
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SourceAddress is set, it can
// safely use t.GetSourceAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SourceAddress == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance_NetworkInstances) GetSourceAddress() string {
	if t == nil || t.SourceAddress == nil {
		return ""
	}
	return *t.SourceAddress
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Sync_Ptp_Instance_NetworkInstances
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance_NetworkInstances) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_enable
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_Sync_Ptp_Instance_NetworkInstances struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance_NetworkInstances) ΛListKeyMap() (map[string]interface{}, error) {
	if t.NetworkInstance == nil {
		return nil, fmt.Errorf("nil value for key NetworkInstance")
	}

	return map[string]interface{}{
		"network-instance": *t.NetworkInstance,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance_NetworkInstances) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Sync_Ptp_Instance_NetworkInstances"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance_NetworkInstances) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance_NetworkInstances) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Sync_Ptp_Instance_NetworkInstances.
func (*SrlNokiaSystem_System_Sync_Ptp_Instance_NetworkInstances) ΛBelongingModule() string {
	return "srl_nokia-sync"
}

// SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList represents the /srl_nokia-system/system/sync/ptp/instance/port-ds-list YANG schema element.
type SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList struct {
	AdminState             E_SrlNokiaCommon_AdminState                                  `path:"admin-state" module:"srl_nokia-sync"`
	DestMac                E_SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList_DestMac `path:"dest-mac" module:"srl_nokia-sync"`
	LocalPriority          *uint8                                                       `path:"local-priority" module:"srl_nokia-sync"`
	LogMinDelayReqInterval *int8                                                        `path:"log-min-delay-req-interval" module:"srl_nokia-sync"`
	LogSyncInterval        *int8                                                        `path:"log-sync-interval" module:"srl_nokia-sync"`
	MasterOnly             *bool                                                        `path:"master-only" module:"srl_nokia-sync"`
	PortIndex              *uint16                                                      `path:"port-index" module:"srl_nokia-sync"`
	Source                 *SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList_Source   `path:"source" module:"srl_nokia-sync"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList) IsYANGGoStruct() {}

// GetOrCreateSource retrieves the value of the Source field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList) GetOrCreateSource() *SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList_Source {
	if t.Source != nil {
		return t.Source
	}
	t.Source = &SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList_Source{}
	return t.Source
}

// GetSource returns the value of the Source struct pointer
// from SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList. If the receiver or the field Source is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList) GetSource() *SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList_Source {
	if t != nil && t.Source != nil {
		return t.Source
	}
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_disable
	}
	return t.AdminState
}

// GetDestMac retrieves the value of the leaf DestMac from the SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DestMac is set, it can
// safely use t.GetDestMac() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DestMac == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList) GetDestMac() E_SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList_DestMac {
	if t == nil || t.DestMac == 0 {
		return SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList_DestMac_forwardable
	}
	return t.DestMac
}

// GetLocalPriority retrieves the value of the leaf LocalPriority from the SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LocalPriority is set, it can
// safely use t.GetLocalPriority() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LocalPriority == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList) GetLocalPriority() uint8 {
	if t == nil || t.LocalPriority == nil {
		return 128
	}
	return *t.LocalPriority
}

// GetLogMinDelayReqInterval retrieves the value of the leaf LogMinDelayReqInterval from the SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LogMinDelayReqInterval is set, it can
// safely use t.GetLogMinDelayReqInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LogMinDelayReqInterval == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList) GetLogMinDelayReqInterval() int8 {
	if t == nil || t.LogMinDelayReqInterval == nil {
		return 0
	}
	return *t.LogMinDelayReqInterval
}

// GetLogSyncInterval retrieves the value of the leaf LogSyncInterval from the SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LogSyncInterval is set, it can
// safely use t.GetLogSyncInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LogSyncInterval == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList) GetLogSyncInterval() int8 {
	if t == nil || t.LogSyncInterval == nil {
		return 0
	}
	return *t.LogSyncInterval
}

// GetMasterOnly retrieves the value of the leaf MasterOnly from the SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MasterOnly is set, it can
// safely use t.GetMasterOnly() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MasterOnly == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList) GetMasterOnly() bool {
	if t == nil || t.MasterOnly == nil {
		return true
	}
	return *t.MasterOnly
}

// GetPortIndex retrieves the value of the leaf PortIndex from the SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PortIndex is set, it can
// safely use t.GetPortIndex() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PortIndex == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList) GetPortIndex() uint16 {
	if t == nil || t.PortIndex == nil {
		return 0
	}
	return *t.PortIndex
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_disable
	}
	if t.DestMac == 0 {
		t.DestMac = SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList_DestMac_forwardable
	}
	if t.LocalPriority == nil {
		var v uint8 = 128
		t.LocalPriority = &v
	}
	if t.MasterOnly == nil {
		var v bool = true
		t.MasterOnly = &v
	}
	t.Source.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList) ΛListKeyMap() (map[string]interface{}, error) {
	if t.PortIndex == nil {
		return nil, fmt.Errorf("nil value for key PortIndex")
	}

	return map[string]interface{}{
		"port-index": *t.PortIndex,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList.
func (*SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList) ΛBelongingModule() string {
	return "srl_nokia-sync"
}

// SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList_Source represents the /srl_nokia-system/system/sync/ptp/instance/port-ds-list/source YANG schema element.
type SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList_Source struct {
	Interface *string                                                         `path:"interface" module:"srl_nokia-sync"`
	Peer      *SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList_Source_Peer `path:"peer" module:"srl_nokia-sync"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList_Source implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList_Source) IsYANGGoStruct() {}

// GetOrCreatePeer retrieves the value of the Peer field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList_Source) GetOrCreatePeer() *SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList_Source_Peer {
	if t.Peer != nil {
		return t.Peer
	}
	t.Peer = &SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList_Source_Peer{}
	return t.Peer
}

// GetPeer returns the value of the Peer struct pointer
// from SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList_Source. If the receiver or the field Peer is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList_Source) GetPeer() *SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList_Source_Peer {
	if t != nil && t.Peer != nil {
		return t.Peer
	}
	return nil
}

// GetInterface retrieves the value of the leaf Interface from the SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList_Source
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interface is set, it can
// safely use t.GetInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interface == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList_Source) GetInterface() string {
	if t == nil || t.Interface == nil {
		return ""
	}
	return *t.Interface
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList_Source
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList_Source) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Peer.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList_Source) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList_Source"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList_Source) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList_Source) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList_Source.
func (*SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList_Source) ΛBelongingModule() string {
	return "srl_nokia-sync"
}

// SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList_Source_Peer represents the /srl_nokia-system/system/sync/ptp/instance/port-ds-list/source/peer YANG schema element.
type SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList_Source_Peer struct {
	IpAddress       *string `path:"ip-address" module:"srl_nokia-sync"`
	NetworkInstance *string `path:"network-instance" module:"srl_nokia-sync"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList_Source_Peer implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList_Source_Peer) IsYANGGoStruct() {}

// GetIpAddress retrieves the value of the leaf IpAddress from the SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList_Source_Peer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IpAddress is set, it can
// safely use t.GetIpAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IpAddress == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList_Source_Peer) GetIpAddress() string {
	if t == nil || t.IpAddress == nil {
		return ""
	}
	return *t.IpAddress
}

// GetNetworkInstance retrieves the value of the leaf NetworkInstance from the SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList_Source_Peer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NetworkInstance is set, it can
// safely use t.GetNetworkInstance() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NetworkInstance == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList_Source_Peer) GetNetworkInstance() string {
	if t == nil || t.NetworkInstance == nil {
		return ""
	}
	return *t.NetworkInstance
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList_Source_Peer
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList_Source_Peer) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList_Source_Peer) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList_Source_Peer"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList_Source_Peer) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList_Source_Peer) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList_Source_Peer.
func (*SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList_Source_Peer) ΛBelongingModule() string {
	return "srl_nokia-sync"
}

// SrlNokiaSystem_System_Tls represents the /srl_nokia-system/system/tls YANG schema element.
type SrlNokiaSystem_System_Tls struct {
	ServerProfile map[string]*SrlNokiaSystem_System_Tls_ServerProfile `path:"server-profile" module:"srl_nokia-tls"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Tls implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Tls) IsYANGGoStruct() {}

// NewServerProfile creates a new entry in the ServerProfile list of the
// SrlNokiaSystem_System_Tls struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_Tls) NewServerProfile(Name string) (*SrlNokiaSystem_System_Tls_ServerProfile, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ServerProfile == nil {
		t.ServerProfile = make(map[string]*SrlNokiaSystem_System_Tls_ServerProfile)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.ServerProfile[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list ServerProfile", key)
	}

	t.ServerProfile[key] = &SrlNokiaSystem_System_Tls_ServerProfile{
		Name: &Name,
	}

	return t.ServerProfile[key], nil
}

// RenameServerProfile renames an entry in the list ServerProfile within
// the SrlNokiaSystem_System_Tls struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaSystem_System_Tls) RenameServerProfile(oldK, newK string) error {
	if _, ok := t.ServerProfile[newK]; ok {
		return fmt.Errorf("key %v already exists in ServerProfile", newK)
	}

	e, ok := t.ServerProfile[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in ServerProfile", oldK)
	}
	e.Name = &newK

	t.ServerProfile[newK] = e
	delete(t.ServerProfile, oldK)
	return nil
}

// GetOrCreateServerProfile retrieves the value with the specified keys from
// the receiver SrlNokiaSystem_System_Tls. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaSystem_System_Tls) GetOrCreateServerProfile(Name string) *SrlNokiaSystem_System_Tls_ServerProfile {
	key := Name

	if v, ok := t.ServerProfile[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewServerProfile(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateServerProfile got unexpected error: %v", err))
	}
	return v
}

// GetServerProfile retrieves the value with the specified key from
// the ServerProfile map field of SrlNokiaSystem_System_Tls. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaSystem_System_Tls) GetServerProfile(Name string) *SrlNokiaSystem_System_Tls_ServerProfile {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.ServerProfile[key]; ok {
		return lm
	}
	return nil
}

// DeleteServerProfile deletes the value with the specified keys from
// the receiver SrlNokiaSystem_System_Tls. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaSystem_System_Tls) DeleteServerProfile(Name string) {
	key := Name

	delete(t.ServerProfile, key)
}

// AppendServerProfile appends the supplied SrlNokiaSystem_System_Tls_ServerProfile struct to the
// list ServerProfile of SrlNokiaSystem_System_Tls. If the key value(s) specified in
// the supplied SrlNokiaSystem_System_Tls_ServerProfile already exist in the list, an error is
// returned.
func (t *SrlNokiaSystem_System_Tls) AppendServerProfile(v *SrlNokiaSystem_System_Tls_ServerProfile) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ServerProfile == nil {
		t.ServerProfile = make(map[string]*SrlNokiaSystem_System_Tls_ServerProfile)
	}

	if _, ok := t.ServerProfile[key]; ok {
		return fmt.Errorf("duplicate key for list ServerProfile %v", key)
	}

	t.ServerProfile[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Tls
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Tls) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.ServerProfile {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Tls) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Tls"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Tls) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Tls) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Tls.
func (*SrlNokiaSystem_System_Tls) ΛBelongingModule() string {
	return "srl_nokia-tls"
}

// SrlNokiaSystem_System_Tls_ServerProfile represents the /srl_nokia-system/system/tls/server-profile YANG schema element.
type SrlNokiaSystem_System_Tls_ServerProfile struct {
	AuthenticateClient        *bool                      `path:"authenticate-client" module:"srl_nokia-tls"`
	Certificate               *string                    `path:"certificate" module:"srl_nokia-tls"`
	CertificateRevocationList *string                    `path:"certificate-revocation-list" module:"srl_nokia-tls"`
	CipherList                []E_SrlNokiaTls_CipherType `path:"cipher-list" module:"srl_nokia-tls"`
	Key                       *string                    `path:"key" module:"srl_nokia-tls"`
	Name                      *string                    `path:"name" module:"srl_nokia-tls"`
	TrustAnchor               *string                    `path:"trust-anchor" module:"srl_nokia-tls"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Tls_ServerProfile implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Tls_ServerProfile) IsYANGGoStruct() {}

// GetAuthenticateClient retrieves the value of the leaf AuthenticateClient from the SrlNokiaSystem_System_Tls_ServerProfile
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AuthenticateClient is set, it can
// safely use t.GetAuthenticateClient() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AuthenticateClient == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Tls_ServerProfile) GetAuthenticateClient() bool {
	if t == nil || t.AuthenticateClient == nil {
		return false
	}
	return *t.AuthenticateClient
}

// GetCertificate retrieves the value of the leaf Certificate from the SrlNokiaSystem_System_Tls_ServerProfile
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Certificate is set, it can
// safely use t.GetCertificate() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Certificate == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Tls_ServerProfile) GetCertificate() string {
	if t == nil || t.Certificate == nil {
		return ""
	}
	return *t.Certificate
}

// GetCertificateRevocationList retrieves the value of the leaf CertificateRevocationList from the SrlNokiaSystem_System_Tls_ServerProfile
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if CertificateRevocationList is set, it can
// safely use t.GetCertificateRevocationList() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.CertificateRevocationList == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Tls_ServerProfile) GetCertificateRevocationList() string {
	if t == nil || t.CertificateRevocationList == nil {
		return ""
	}
	return *t.CertificateRevocationList
}

// GetCipherList retrieves the value of the leaf CipherList from the SrlNokiaSystem_System_Tls_ServerProfile
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if CipherList is set, it can
// safely use t.GetCipherList() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.CipherList == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Tls_ServerProfile) GetCipherList() []E_SrlNokiaTls_CipherType {
	if t == nil || t.CipherList == nil {
		return []E_SrlNokiaTls_CipherType{
			SrlNokiaTls_CipherType_ecdhe_ecdsa_aes256_gcm_sha384,
			SrlNokiaTls_CipherType_ecdhe_ecdsa_aes128_gcm_sha256,
			SrlNokiaTls_CipherType_ecdhe_rsa_aes256_gcm_sha384,
			SrlNokiaTls_CipherType_ecdhe_rsa_aes128_gcm_sha256,
		}
	}
	return t.CipherList
}

// GetKey retrieves the value of the leaf Key from the SrlNokiaSystem_System_Tls_ServerProfile
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Key is set, it can
// safely use t.GetKey() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Key == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Tls_ServerProfile) GetKey() string {
	if t == nil || t.Key == nil {
		return ""
	}
	return *t.Key
}

// GetName retrieves the value of the leaf Name from the SrlNokiaSystem_System_Tls_ServerProfile
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Tls_ServerProfile) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetTrustAnchor retrieves the value of the leaf TrustAnchor from the SrlNokiaSystem_System_Tls_ServerProfile
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TrustAnchor is set, it can
// safely use t.GetTrustAnchor() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TrustAnchor == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Tls_ServerProfile) GetTrustAnchor() string {
	if t == nil || t.TrustAnchor == nil {
		return ""
	}
	return *t.TrustAnchor
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Tls_ServerProfile
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Tls_ServerProfile) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AuthenticateClient == nil {
		var v bool = false
		t.AuthenticateClient = &v
	}
	if t.CipherList == nil {
		t.CipherList = []E_SrlNokiaTls_CipherType{
			SrlNokiaTls_CipherType_ecdhe_ecdsa_aes256_gcm_sha384,
			SrlNokiaTls_CipherType_ecdhe_ecdsa_aes128_gcm_sha256,
			SrlNokiaTls_CipherType_ecdhe_rsa_aes256_gcm_sha384,
			SrlNokiaTls_CipherType_ecdhe_rsa_aes128_gcm_sha256,
		}
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_Tls_ServerProfile struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_Tls_ServerProfile) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Tls_ServerProfile) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Tls_ServerProfile"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Tls_ServerProfile) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Tls_ServerProfile) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Tls_ServerProfile.
func (*SrlNokiaSystem_System_Tls_ServerProfile) ΛBelongingModule() string {
	return "srl_nokia-tls"
}

// SrlNokiaTransportSecurity_TransportSecurity represents the /srl_nokia-transport-security/transport-security YANG schema element.
type SrlNokiaTransportSecurity_TransportSecurity struct {
	Macsec *SrlNokiaTransportSecurity_TransportSecurity_Macsec `path:"macsec" module:"srl_nokia-macsec"`
}

// IsYANGGoStruct ensures that SrlNokiaTransportSecurity_TransportSecurity implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaTransportSecurity_TransportSecurity) IsYANGGoStruct() {}

// GetOrCreateMacsec retrieves the value of the Macsec field
// or returns the existing field if it already exists.
func (t *SrlNokiaTransportSecurity_TransportSecurity) GetOrCreateMacsec() *SrlNokiaTransportSecurity_TransportSecurity_Macsec {
	if t.Macsec != nil {
		return t.Macsec
	}
	t.Macsec = &SrlNokiaTransportSecurity_TransportSecurity_Macsec{}
	return t.Macsec
}

// GetMacsec returns the value of the Macsec struct pointer
// from SrlNokiaTransportSecurity_TransportSecurity. If the receiver or the field Macsec is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaTransportSecurity_TransportSecurity) GetMacsec() *SrlNokiaTransportSecurity_TransportSecurity_Macsec {
	if t != nil && t.Macsec != nil {
		return t.Macsec
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaTransportSecurity_TransportSecurity
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaTransportSecurity_TransportSecurity) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Macsec.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaTransportSecurity_TransportSecurity) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaTransportSecurity_TransportSecurity"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaTransportSecurity_TransportSecurity) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaTransportSecurity_TransportSecurity) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaTransportSecurity_TransportSecurity.
func (*SrlNokiaTransportSecurity_TransportSecurity) ΛBelongingModule() string {
	return "srl_nokia-transport-security"
}

// SrlNokiaTransportSecurity_TransportSecurity_Macsec represents the /srl_nokia-transport-security/transport-security/macsec YANG schema element.
type SrlNokiaTransportSecurity_TransportSecurity_Macsec struct {
	Interface map[string]*SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface `path:"interface" module:"srl_nokia-macsec"`
	Mka       *SrlNokiaTransportSecurity_TransportSecurity_Macsec_Mka                  `path:"mka" module:"srl_nokia-macsec"`
}

// IsYANGGoStruct ensures that SrlNokiaTransportSecurity_TransportSecurity_Macsec implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaTransportSecurity_TransportSecurity_Macsec) IsYANGGoStruct() {}

// NewInterface creates a new entry in the Interface list of the
// SrlNokiaTransportSecurity_TransportSecurity_Macsec struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaTransportSecurity_TransportSecurity_Macsec) NewInterface(Name string) (*SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Interface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Interface", key)
	}

	t.Interface[key] = &SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface{
		Name: &Name,
	}

	return t.Interface[key], nil
}

// RenameInterface renames an entry in the list Interface within
// the SrlNokiaTransportSecurity_TransportSecurity_Macsec struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaTransportSecurity_TransportSecurity_Macsec) RenameInterface(oldK, newK string) error {
	if _, ok := t.Interface[newK]; ok {
		return fmt.Errorf("key %v already exists in Interface", newK)
	}

	e, ok := t.Interface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Interface", oldK)
	}
	e.Name = &newK

	t.Interface[newK] = e
	delete(t.Interface, oldK)
	return nil
}

// GetOrCreateInterface retrieves the value with the specified keys from
// the receiver SrlNokiaTransportSecurity_TransportSecurity_Macsec. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaTransportSecurity_TransportSecurity_Macsec) GetOrCreateInterface(Name string) *SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface {
	key := Name

	if v, ok := t.Interface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInterface(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInterface got unexpected error: %v", err))
	}
	return v
}

// GetInterface retrieves the value with the specified key from
// the Interface map field of SrlNokiaTransportSecurity_TransportSecurity_Macsec. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaTransportSecurity_TransportSecurity_Macsec) GetInterface(Name string) *SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Interface[key]; ok {
		return lm
	}
	return nil
}

// DeleteInterface deletes the value with the specified keys from
// the receiver SrlNokiaTransportSecurity_TransportSecurity_Macsec. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaTransportSecurity_TransportSecurity_Macsec) DeleteInterface(Name string) {
	key := Name

	delete(t.Interface, key)
}

// AppendInterface appends the supplied SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface struct to the
// list Interface of SrlNokiaTransportSecurity_TransportSecurity_Macsec. If the key value(s) specified in
// the supplied SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface already exist in the list, an error is
// returned.
func (t *SrlNokiaTransportSecurity_TransportSecurity_Macsec) AppendInterface(
	v *SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface,
) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface)
	}

	if _, ok := t.Interface[key]; ok {
		return fmt.Errorf("duplicate key for list Interface %v", key)
	}

	t.Interface[key] = v
	return nil
}

// GetOrCreateMka retrieves the value of the Mka field
// or returns the existing field if it already exists.
func (t *SrlNokiaTransportSecurity_TransportSecurity_Macsec) GetOrCreateMka() *SrlNokiaTransportSecurity_TransportSecurity_Macsec_Mka {
	if t.Mka != nil {
		return t.Mka
	}
	t.Mka = &SrlNokiaTransportSecurity_TransportSecurity_Macsec_Mka{}
	return t.Mka
}

// GetMka returns the value of the Mka struct pointer
// from SrlNokiaTransportSecurity_TransportSecurity_Macsec. If the receiver or the field Mka is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaTransportSecurity_TransportSecurity_Macsec) GetMka() *SrlNokiaTransportSecurity_TransportSecurity_Macsec_Mka {
	if t != nil && t.Mka != nil {
		return t.Mka
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaTransportSecurity_TransportSecurity_Macsec
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaTransportSecurity_TransportSecurity_Macsec) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Mka.PopulateDefaults()
	for _, e := range t.Interface {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaTransportSecurity_TransportSecurity_Macsec) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaTransportSecurity_TransportSecurity_Macsec"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaTransportSecurity_TransportSecurity_Macsec) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaTransportSecurity_TransportSecurity_Macsec) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaTransportSecurity_TransportSecurity_Macsec.
func (*SrlNokiaTransportSecurity_TransportSecurity_Macsec) ΛBelongingModule() string {
	return "srl_nokia-macsec"
}

// SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface represents the /srl_nokia-transport-security/transport-security/macsec/interface YANG schema element.
type SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface struct {
	AdminState        E_SrlNokiaCommon_AdminState                                                                                   `path:"admin-state" module:"srl_nokia-macsec"`
	ExcludeMac        map[string]*SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface_ExcludeMac                           `path:"exclude-mac" module:"srl_nokia-macsec"`
	ExcludeProtocols  map[E_SrlNokiaMacsec_Protocols]*SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface_ExcludeProtocols `path:"exclude-protocols" module:"srl_nokia-macsec"`
	InterfaceRef      *SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface_InterfaceRef                                    `path:"interface-ref" module:"srl_nokia-macsec"`
	Mka               *SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface_Mka                                             `path:"mka" module:"srl_nokia-macsec"`
	Name              *string                                                                                                       `path:"name" module:"srl_nokia-macsec"`
	ReplayProtection  *uint16                                                                                                       `path:"replay-protection" module:"srl_nokia-macsec"`
	RxMustBeEncrypted *bool                                                                                                         `path:"rx-must-be-encrypted" module:"srl_nokia-macsec"`
}

// IsYANGGoStruct ensures that SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface) IsYANGGoStruct() {}

// NewExcludeMac creates a new entry in the ExcludeMac list of the
// SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface) NewExcludeMac(
	DestinationMac string,
) (*SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface_ExcludeMac, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ExcludeMac == nil {
		t.ExcludeMac = make(map[string]*SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface_ExcludeMac)
	}

	key := DestinationMac

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.ExcludeMac[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list ExcludeMac", key)
	}

	t.ExcludeMac[key] = &SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface_ExcludeMac{
		DestinationMac: &DestinationMac,
	}

	return t.ExcludeMac[key], nil
}

// RenameExcludeMac renames an entry in the list ExcludeMac within
// the SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface) RenameExcludeMac(oldK, newK string) error {
	if _, ok := t.ExcludeMac[newK]; ok {
		return fmt.Errorf("key %v already exists in ExcludeMac", newK)
	}

	e, ok := t.ExcludeMac[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in ExcludeMac", oldK)
	}
	e.DestinationMac = &newK

	t.ExcludeMac[newK] = e
	delete(t.ExcludeMac, oldK)
	return nil
}

// GetOrCreateExcludeMac retrieves the value with the specified keys from
// the receiver SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface) GetOrCreateExcludeMac(
	DestinationMac string,
) *SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface_ExcludeMac {
	key := DestinationMac

	if v, ok := t.ExcludeMac[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewExcludeMac(DestinationMac)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateExcludeMac got unexpected error: %v", err))
	}
	return v
}

// GetExcludeMac retrieves the value with the specified key from
// the ExcludeMac map field of SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface) GetExcludeMac(
	DestinationMac string,
) *SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface_ExcludeMac {
	if t == nil {
		return nil
	}

	key := DestinationMac

	if lm, ok := t.ExcludeMac[key]; ok {
		return lm
	}
	return nil
}

// DeleteExcludeMac deletes the value with the specified keys from
// the receiver SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface) DeleteExcludeMac(DestinationMac string) {
	key := DestinationMac

	delete(t.ExcludeMac, key)
}

// AppendExcludeMac appends the supplied SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface_ExcludeMac struct to the
// list ExcludeMac of SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface. If the key value(s) specified in
// the supplied SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface_ExcludeMac already exist in the list, an error is
// returned.
func (t *SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface) AppendExcludeMac(
	v *SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface_ExcludeMac,
) error {
	if v.DestinationMac == nil {
		return fmt.Errorf("invalid nil key received for DestinationMac")
	}

	key := *v.DestinationMac

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ExcludeMac == nil {
		t.ExcludeMac = make(map[string]*SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface_ExcludeMac)
	}

	if _, ok := t.ExcludeMac[key]; ok {
		return fmt.Errorf("duplicate key for list ExcludeMac %v", key)
	}

	t.ExcludeMac[key] = v
	return nil
}

// NewExcludeProtocols creates a new entry in the ExcludeProtocols list of the
// SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface) NewExcludeProtocols(
	Protocol E_SrlNokiaMacsec_Protocols,
) (*SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface_ExcludeProtocols, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ExcludeProtocols == nil {
		t.ExcludeProtocols = make(map[E_SrlNokiaMacsec_Protocols]*SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface_ExcludeProtocols)
	}

	key := Protocol

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.ExcludeProtocols[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list ExcludeProtocols", key)
	}

	t.ExcludeProtocols[key] = &SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface_ExcludeProtocols{
		Protocol: Protocol,
	}

	return t.ExcludeProtocols[key], nil
}

// RenameExcludeProtocols renames an entry in the list ExcludeProtocols within
// the SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface) RenameExcludeProtocols(oldK, newK E_SrlNokiaMacsec_Protocols) error {
	if _, ok := t.ExcludeProtocols[newK]; ok {
		return fmt.Errorf("key %v already exists in ExcludeProtocols", newK)
	}

	e, ok := t.ExcludeProtocols[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in ExcludeProtocols", oldK)
	}
	e.Protocol = newK

	t.ExcludeProtocols[newK] = e
	delete(t.ExcludeProtocols, oldK)
	return nil
}

// GetOrCreateExcludeProtocols retrieves the value with the specified keys from
// the receiver SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface) GetOrCreateExcludeProtocols(
	Protocol E_SrlNokiaMacsec_Protocols,
) *SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface_ExcludeProtocols {
	key := Protocol

	if v, ok := t.ExcludeProtocols[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewExcludeProtocols(Protocol)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateExcludeProtocols got unexpected error: %v", err))
	}
	return v
}

// GetExcludeProtocols retrieves the value with the specified key from
// the ExcludeProtocols map field of SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface) GetExcludeProtocols(
	Protocol E_SrlNokiaMacsec_Protocols,
) *SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface_ExcludeProtocols {
	if t == nil {
		return nil
	}

	key := Protocol

	if lm, ok := t.ExcludeProtocols[key]; ok {
		return lm
	}
	return nil
}

// DeleteExcludeProtocols deletes the value with the specified keys from
// the receiver SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface) DeleteExcludeProtocols(Protocol E_SrlNokiaMacsec_Protocols) {
	key := Protocol

	delete(t.ExcludeProtocols, key)
}

// AppendExcludeProtocols appends the supplied SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface_ExcludeProtocols struct to the
// list ExcludeProtocols of SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface. If the key value(s) specified in
// the supplied SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface_ExcludeProtocols already exist in the list, an error is
// returned.
func (t *SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface) AppendExcludeProtocols(
	v *SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface_ExcludeProtocols,
) error {
	key := v.Protocol

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ExcludeProtocols == nil {
		t.ExcludeProtocols = make(map[E_SrlNokiaMacsec_Protocols]*SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface_ExcludeProtocols)
	}

	if _, ok := t.ExcludeProtocols[key]; ok {
		return fmt.Errorf("duplicate key for list ExcludeProtocols %v", key)
	}

	t.ExcludeProtocols[key] = v
	return nil
}

// GetOrCreateInterfaceRef retrieves the value of the InterfaceRef field
// or returns the existing field if it already exists.
func (t *SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface) GetOrCreateInterfaceRef() *SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface_InterfaceRef {
	if t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	t.InterfaceRef = &SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface_InterfaceRef{}
	return t.InterfaceRef
}

// GetOrCreateMka retrieves the value of the Mka field
// or returns the existing field if it already exists.
func (t *SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface) GetOrCreateMka() *SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface_Mka {
	if t.Mka != nil {
		return t.Mka
	}
	t.Mka = &SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface_Mka{}
	return t.Mka
}

// GetInterfaceRef returns the value of the InterfaceRef struct pointer
// from SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface. If the receiver or the field InterfaceRef is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface) GetInterfaceRef() *SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface_InterfaceRef {
	if t != nil && t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	return nil
}

// GetMka returns the value of the Mka struct pointer
// from SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface. If the receiver or the field Mka is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface) GetMka() *SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface_Mka {
	if t != nil && t.Mka != nil {
		return t.Mka
	}
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_disable
	}
	return t.AdminState
}

// GetName retrieves the value of the leaf Name from the SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetReplayProtection retrieves the value of the leaf ReplayProtection from the SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ReplayProtection is set, it can
// safely use t.GetReplayProtection() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ReplayProtection == nil' before retrieving the leaf's value.
func (t *SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface) GetReplayProtection() uint16 {
	if t == nil || t.ReplayProtection == nil {
		return 0
	}
	return *t.ReplayProtection
}

// GetRxMustBeEncrypted retrieves the value of the leaf RxMustBeEncrypted from the SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RxMustBeEncrypted is set, it can
// safely use t.GetRxMustBeEncrypted() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RxMustBeEncrypted == nil' before retrieving the leaf's value.
func (t *SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface) GetRxMustBeEncrypted() bool {
	if t == nil || t.RxMustBeEncrypted == nil {
		return true
	}
	return *t.RxMustBeEncrypted
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_disable
	}
	if t.ReplayProtection == nil {
		var v uint16 = 0
		t.ReplayProtection = &v
	}
	if t.RxMustBeEncrypted == nil {
		var v bool = true
		t.RxMustBeEncrypted = &v
	}
	t.InterfaceRef.PopulateDefaults()
	t.Mka.PopulateDefaults()
	for _, e := range t.ExcludeMac {
		e.PopulateDefaults()
	}
	for _, e := range t.ExcludeProtocols {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface struct, which is a YANG list entry.
func (t *SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface.
func (*SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface) ΛBelongingModule() string {
	return "srl_nokia-macsec"
}

// SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface_ExcludeMac represents the /srl_nokia-transport-security/transport-security/macsec/interface/exclude-mac YANG schema element.
type SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface_ExcludeMac struct {
	DestinationMac *string `path:"destination-mac" module:"srl_nokia-macsec"`
}

// IsYANGGoStruct ensures that SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface_ExcludeMac implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface_ExcludeMac) IsYANGGoStruct() {}

// GetDestinationMac retrieves the value of the leaf DestinationMac from the SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface_ExcludeMac
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DestinationMac is set, it can
// safely use t.GetDestinationMac() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DestinationMac == nil' before retrieving the leaf's value.
func (t *SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface_ExcludeMac) GetDestinationMac() string {
	if t == nil || t.DestinationMac == nil {
		return ""
	}
	return *t.DestinationMac
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface_ExcludeMac
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface_ExcludeMac) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface_ExcludeMac struct, which is a YANG list entry.
func (t *SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface_ExcludeMac) ΛListKeyMap() (map[string]interface{}, error) {
	if t.DestinationMac == nil {
		return nil, fmt.Errorf("nil value for key DestinationMac")
	}

	return map[string]interface{}{
		"destination-mac": *t.DestinationMac,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface_ExcludeMac) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface_ExcludeMac"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface_ExcludeMac) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface_ExcludeMac) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface_ExcludeMac.
func (*SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface_ExcludeMac) ΛBelongingModule() string {
	return "srl_nokia-macsec"
}

// SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface_ExcludeProtocols represents the /srl_nokia-transport-security/transport-security/macsec/interface/exclude-protocols YANG schema element.
type SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface_ExcludeProtocols struct {
	Protocol E_SrlNokiaMacsec_Protocols `path:"protocol" module:"srl_nokia-macsec"`
}

// IsYANGGoStruct ensures that SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface_ExcludeProtocols implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface_ExcludeProtocols) IsYANGGoStruct() {
}

// GetProtocol retrieves the value of the leaf Protocol from the SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface_ExcludeProtocols
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Protocol is set, it can
// safely use t.GetProtocol() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Protocol == nil' before retrieving the leaf's value.
func (t *SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface_ExcludeProtocols) GetProtocol() E_SrlNokiaMacsec_Protocols {
	if t == nil || t.Protocol == 0 {
		return 0
	}
	return t.Protocol
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface_ExcludeProtocols
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface_ExcludeProtocols) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface_ExcludeProtocols struct, which is a YANG list entry.
func (t *SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface_ExcludeProtocols) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"protocol": t.Protocol,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface_ExcludeProtocols) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface_ExcludeProtocols"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface_ExcludeProtocols) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface_ExcludeProtocols) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface_ExcludeProtocols.
func (*SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface_ExcludeProtocols) ΛBelongingModule() string {
	return "srl_nokia-macsec"
}

// SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface_InterfaceRef represents the /srl_nokia-transport-security/transport-security/macsec/interface/interface-ref YANG schema element.
type SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface_InterfaceRef struct {
	Interface    *string `path:"interface" module:"srl_nokia-macsec"`
	Subinterface *uint32 `path:"subinterface" module:"srl_nokia-macsec"`
}

// IsYANGGoStruct ensures that SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface_InterfaceRef implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface_InterfaceRef) IsYANGGoStruct() {}

// GetInterface retrieves the value of the leaf Interface from the SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface_InterfaceRef
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interface is set, it can
// safely use t.GetInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interface == nil' before retrieving the leaf's value.
func (t *SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface_InterfaceRef) GetInterface() string {
	if t == nil || t.Interface == nil {
		return ""
	}
	return *t.Interface
}

// GetSubinterface retrieves the value of the leaf Subinterface from the SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface_InterfaceRef
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Subinterface is set, it can
// safely use t.GetSubinterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Subinterface == nil' before retrieving the leaf's value.
func (t *SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface_InterfaceRef) GetSubinterface() uint32 {
	if t == nil || t.Subinterface == nil {
		return 0
	}
	return *t.Subinterface
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface_InterfaceRef
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface_InterfaceRef) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface_InterfaceRef) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface_InterfaceRef"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface_InterfaceRef) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface_InterfaceRef) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface_InterfaceRef.
func (*SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface_InterfaceRef) ΛBelongingModule() string {
	return "srl_nokia-macsec"
}

// SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface_Mka represents the /srl_nokia-transport-security/transport-security/macsec/interface/mka YANG schema element.
type SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface_Mka struct {
	KeyChain  *string `path:"key-chain" module:"srl_nokia-macsec"`
	MkaPolicy *string `path:"mka-policy" module:"srl_nokia-macsec"`
}

// IsYANGGoStruct ensures that SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface_Mka implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface_Mka) IsYANGGoStruct() {}

// GetKeyChain retrieves the value of the leaf KeyChain from the SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface_Mka
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if KeyChain is set, it can
// safely use t.GetKeyChain() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.KeyChain == nil' before retrieving the leaf's value.
func (t *SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface_Mka) GetKeyChain() string {
	if t == nil || t.KeyChain == nil {
		return ""
	}
	return *t.KeyChain
}

// GetMkaPolicy retrieves the value of the leaf MkaPolicy from the SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface_Mka
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MkaPolicy is set, it can
// safely use t.GetMkaPolicy() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MkaPolicy == nil' before retrieving the leaf's value.
func (t *SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface_Mka) GetMkaPolicy() string {
	if t == nil || t.MkaPolicy == nil {
		return ""
	}
	return *t.MkaPolicy
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface_Mka
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface_Mka) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface_Mka) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface_Mka"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface_Mka) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface_Mka) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface_Mka.
func (*SrlNokiaTransportSecurity_TransportSecurity_Macsec_Interface_Mka) ΛBelongingModule() string {
	return "srl_nokia-macsec"
}

// SrlNokiaTransportSecurity_TransportSecurity_Macsec_Mka represents the /srl_nokia-transport-security/transport-security/macsec/mka YANG schema element.
type SrlNokiaTransportSecurity_TransportSecurity_Macsec_Mka struct {
	Policy map[string]*SrlNokiaTransportSecurity_TransportSecurity_Macsec_Mka_Policy `path:"policy" module:"srl_nokia-macsec"`
}

// IsYANGGoStruct ensures that SrlNokiaTransportSecurity_TransportSecurity_Macsec_Mka implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaTransportSecurity_TransportSecurity_Macsec_Mka) IsYANGGoStruct() {}

// NewPolicy creates a new entry in the Policy list of the
// SrlNokiaTransportSecurity_TransportSecurity_Macsec_Mka struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaTransportSecurity_TransportSecurity_Macsec_Mka) NewPolicy(Name string) (*SrlNokiaTransportSecurity_TransportSecurity_Macsec_Mka_Policy, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Policy == nil {
		t.Policy = make(map[string]*SrlNokiaTransportSecurity_TransportSecurity_Macsec_Mka_Policy)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Policy[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Policy", key)
	}

	t.Policy[key] = &SrlNokiaTransportSecurity_TransportSecurity_Macsec_Mka_Policy{
		Name: &Name,
	}

	return t.Policy[key], nil
}

// RenamePolicy renames an entry in the list Policy within
// the SrlNokiaTransportSecurity_TransportSecurity_Macsec_Mka struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaTransportSecurity_TransportSecurity_Macsec_Mka) RenamePolicy(oldK, newK string) error {
	if _, ok := t.Policy[newK]; ok {
		return fmt.Errorf("key %v already exists in Policy", newK)
	}

	e, ok := t.Policy[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Policy", oldK)
	}
	e.Name = &newK

	t.Policy[newK] = e
	delete(t.Policy, oldK)
	return nil
}

// GetOrCreatePolicy retrieves the value with the specified keys from
// the receiver SrlNokiaTransportSecurity_TransportSecurity_Macsec_Mka. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaTransportSecurity_TransportSecurity_Macsec_Mka) GetOrCreatePolicy(Name string) *SrlNokiaTransportSecurity_TransportSecurity_Macsec_Mka_Policy {
	key := Name

	if v, ok := t.Policy[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPolicy(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePolicy got unexpected error: %v", err))
	}
	return v
}

// GetPolicy retrieves the value with the specified key from
// the Policy map field of SrlNokiaTransportSecurity_TransportSecurity_Macsec_Mka. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaTransportSecurity_TransportSecurity_Macsec_Mka) GetPolicy(Name string) *SrlNokiaTransportSecurity_TransportSecurity_Macsec_Mka_Policy {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Policy[key]; ok {
		return lm
	}
	return nil
}

// DeletePolicy deletes the value with the specified keys from
// the receiver SrlNokiaTransportSecurity_TransportSecurity_Macsec_Mka. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaTransportSecurity_TransportSecurity_Macsec_Mka) DeletePolicy(Name string) {
	key := Name

	delete(t.Policy, key)
}

// AppendPolicy appends the supplied SrlNokiaTransportSecurity_TransportSecurity_Macsec_Mka_Policy struct to the
// list Policy of SrlNokiaTransportSecurity_TransportSecurity_Macsec_Mka. If the key value(s) specified in
// the supplied SrlNokiaTransportSecurity_TransportSecurity_Macsec_Mka_Policy already exist in the list, an error is
// returned.
func (t *SrlNokiaTransportSecurity_TransportSecurity_Macsec_Mka) AppendPolicy(
	v *SrlNokiaTransportSecurity_TransportSecurity_Macsec_Mka_Policy,
) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Policy == nil {
		t.Policy = make(map[string]*SrlNokiaTransportSecurity_TransportSecurity_Macsec_Mka_Policy)
	}

	if _, ok := t.Policy[key]; ok {
		return fmt.Errorf("duplicate key for list Policy %v", key)
	}

	t.Policy[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaTransportSecurity_TransportSecurity_Macsec_Mka
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaTransportSecurity_TransportSecurity_Macsec_Mka) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Policy {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaTransportSecurity_TransportSecurity_Macsec_Mka) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaTransportSecurity_TransportSecurity_Macsec_Mka"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaTransportSecurity_TransportSecurity_Macsec_Mka) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaTransportSecurity_TransportSecurity_Macsec_Mka) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaTransportSecurity_TransportSecurity_Macsec_Mka.
func (*SrlNokiaTransportSecurity_TransportSecurity_Macsec_Mka) ΛBelongingModule() string {
	return "srl_nokia-macsec"
}

// SrlNokiaTransportSecurity_TransportSecurity_Macsec_Mka_Policy represents the /srl_nokia-transport-security/transport-security/macsec/mka/policy YANG schema element.
type SrlNokiaTransportSecurity_TransportSecurity_Macsec_Mka_Policy struct {
	ClearTagMode            E_SrlNokiaMacsec_TagMode               `path:"clear-tag-mode" module:"srl_nokia-macsec"`
	ConfidentialityOffset   E_SrlNokiaMacsec_ConfidentialityOffset `path:"confidentiality-offset" module:"srl_nokia-macsec"`
	DelayProtection         *bool                                  `path:"delay-protection" module:"srl_nokia-macsec"`
	EapolDestinationAddress *string                                `path:"eapol-destination-address" module:"srl_nokia-macsec"`
	Encrypt                 *bool                                  `path:"encrypt" module:"srl_nokia-macsec"`
	HelloInterval           *uint32                                `path:"hello-interval" module:"srl_nokia-macsec"`
	KeyServerPriority       *uint8                                 `path:"key-server-priority" module:"srl_nokia-macsec"`
	MacsecCipherSuite       []E_SrlNokiaMacsec_MacsecCipherSuite   `path:"macsec-cipher-suite" module:"srl_nokia-macsec"`
	MaximumNumberOfPeers    *uint32                                `path:"maximum-number-of-peers" module:"srl_nokia-macsec"`
	Name                    *string                                `path:"name" module:"srl_nokia-macsec"`
	SakRekeyOnLivePeerLoss  *bool                                  `path:"sak-rekey-on-live-peer-loss" module:"srl_nokia-macsec"`
}

// IsYANGGoStruct ensures that SrlNokiaTransportSecurity_TransportSecurity_Macsec_Mka_Policy implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaTransportSecurity_TransportSecurity_Macsec_Mka_Policy) IsYANGGoStruct() {}

// GetClearTagMode retrieves the value of the leaf ClearTagMode from the SrlNokiaTransportSecurity_TransportSecurity_Macsec_Mka_Policy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ClearTagMode is set, it can
// safely use t.GetClearTagMode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ClearTagMode == nil' before retrieving the leaf's value.
func (t *SrlNokiaTransportSecurity_TransportSecurity_Macsec_Mka_Policy) GetClearTagMode() E_SrlNokiaMacsec_TagMode {
	if t == nil || t.ClearTagMode == 0 {
		return SrlNokiaMacsec_TagMode_no_tag
	}
	return t.ClearTagMode
}

// GetConfidentialityOffset retrieves the value of the leaf ConfidentialityOffset from the SrlNokiaTransportSecurity_TransportSecurity_Macsec_Mka_Policy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ConfidentialityOffset is set, it can
// safely use t.GetConfidentialityOffset() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ConfidentialityOffset == nil' before retrieving the leaf's value.
func (t *SrlNokiaTransportSecurity_TransportSecurity_Macsec_Mka_Policy) GetConfidentialityOffset() E_SrlNokiaMacsec_ConfidentialityOffset {
	if t == nil || t.ConfidentialityOffset == 0 {
		return SrlNokiaMacsec_ConfidentialityOffset_0_bytes
	}
	return t.ConfidentialityOffset
}

// GetDelayProtection retrieves the value of the leaf DelayProtection from the SrlNokiaTransportSecurity_TransportSecurity_Macsec_Mka_Policy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DelayProtection is set, it can
// safely use t.GetDelayProtection() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DelayProtection == nil' before retrieving the leaf's value.
func (t *SrlNokiaTransportSecurity_TransportSecurity_Macsec_Mka_Policy) GetDelayProtection() bool {
	if t == nil || t.DelayProtection == nil {
		return false
	}
	return *t.DelayProtection
}

// GetEapolDestinationAddress retrieves the value of the leaf EapolDestinationAddress from the SrlNokiaTransportSecurity_TransportSecurity_Macsec_Mka_Policy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EapolDestinationAddress is set, it can
// safely use t.GetEapolDestinationAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EapolDestinationAddress == nil' before retrieving the leaf's value.
func (t *SrlNokiaTransportSecurity_TransportSecurity_Macsec_Mka_Policy) GetEapolDestinationAddress() string {
	if t == nil || t.EapolDestinationAddress == nil {
		return ""
	}
	return *t.EapolDestinationAddress
}

// GetEncrypt retrieves the value of the leaf Encrypt from the SrlNokiaTransportSecurity_TransportSecurity_Macsec_Mka_Policy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Encrypt is set, it can
// safely use t.GetEncrypt() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Encrypt == nil' before retrieving the leaf's value.
func (t *SrlNokiaTransportSecurity_TransportSecurity_Macsec_Mka_Policy) GetEncrypt() bool {
	if t == nil || t.Encrypt == nil {
		return true
	}
	return *t.Encrypt
}

// GetHelloInterval retrieves the value of the leaf HelloInterval from the SrlNokiaTransportSecurity_TransportSecurity_Macsec_Mka_Policy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if HelloInterval is set, it can
// safely use t.GetHelloInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.HelloInterval == nil' before retrieving the leaf's value.
func (t *SrlNokiaTransportSecurity_TransportSecurity_Macsec_Mka_Policy) GetHelloInterval() uint32 {
	if t == nil || t.HelloInterval == nil {
		return 2
	}
	return *t.HelloInterval
}

// GetKeyServerPriority retrieves the value of the leaf KeyServerPriority from the SrlNokiaTransportSecurity_TransportSecurity_Macsec_Mka_Policy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if KeyServerPriority is set, it can
// safely use t.GetKeyServerPriority() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.KeyServerPriority == nil' before retrieving the leaf's value.
func (t *SrlNokiaTransportSecurity_TransportSecurity_Macsec_Mka_Policy) GetKeyServerPriority() uint8 {
	if t == nil || t.KeyServerPriority == nil {
		return 16
	}
	return *t.KeyServerPriority
}

// GetMacsecCipherSuite retrieves the value of the leaf MacsecCipherSuite from the SrlNokiaTransportSecurity_TransportSecurity_Macsec_Mka_Policy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MacsecCipherSuite is set, it can
// safely use t.GetMacsecCipherSuite() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MacsecCipherSuite == nil' before retrieving the leaf's value.
func (t *SrlNokiaTransportSecurity_TransportSecurity_Macsec_Mka_Policy) GetMacsecCipherSuite() []E_SrlNokiaMacsec_MacsecCipherSuite {
	if t == nil || t.MacsecCipherSuite == nil {
		return nil
	}
	return t.MacsecCipherSuite
}

// GetMaximumNumberOfPeers retrieves the value of the leaf MaximumNumberOfPeers from the SrlNokiaTransportSecurity_TransportSecurity_Macsec_Mka_Policy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MaximumNumberOfPeers is set, it can
// safely use t.GetMaximumNumberOfPeers() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MaximumNumberOfPeers == nil' before retrieving the leaf's value.
func (t *SrlNokiaTransportSecurity_TransportSecurity_Macsec_Mka_Policy) GetMaximumNumberOfPeers() uint32 {
	if t == nil || t.MaximumNumberOfPeers == nil {
		return 0
	}
	return *t.MaximumNumberOfPeers
}

// GetName retrieves the value of the leaf Name from the SrlNokiaTransportSecurity_TransportSecurity_Macsec_Mka_Policy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaTransportSecurity_TransportSecurity_Macsec_Mka_Policy) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetSakRekeyOnLivePeerLoss retrieves the value of the leaf SakRekeyOnLivePeerLoss from the SrlNokiaTransportSecurity_TransportSecurity_Macsec_Mka_Policy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SakRekeyOnLivePeerLoss is set, it can
// safely use t.GetSakRekeyOnLivePeerLoss() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SakRekeyOnLivePeerLoss == nil' before retrieving the leaf's value.
func (t *SrlNokiaTransportSecurity_TransportSecurity_Macsec_Mka_Policy) GetSakRekeyOnLivePeerLoss() bool {
	if t == nil || t.SakRekeyOnLivePeerLoss == nil {
		return false
	}
	return *t.SakRekeyOnLivePeerLoss
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaTransportSecurity_TransportSecurity_Macsec_Mka_Policy
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaTransportSecurity_TransportSecurity_Macsec_Mka_Policy) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.ClearTagMode == 0 {
		t.ClearTagMode = SrlNokiaMacsec_TagMode_no_tag
	}
	if t.ConfidentialityOffset == 0 {
		t.ConfidentialityOffset = SrlNokiaMacsec_ConfidentialityOffset_0_bytes
	}
	if t.DelayProtection == nil {
		var v bool = false
		t.DelayProtection = &v
	}
	if t.Encrypt == nil {
		var v bool = true
		t.Encrypt = &v
	}
	if t.HelloInterval == nil {
		var v uint32 = 2
		t.HelloInterval = &v
	}
	if t.KeyServerPriority == nil {
		var v uint8 = 16
		t.KeyServerPriority = &v
	}
	if t.SakRekeyOnLivePeerLoss == nil {
		var v bool = false
		t.SakRekeyOnLivePeerLoss = &v
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaTransportSecurity_TransportSecurity_Macsec_Mka_Policy struct, which is a YANG list entry.
func (t *SrlNokiaTransportSecurity_TransportSecurity_Macsec_Mka_Policy) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaTransportSecurity_TransportSecurity_Macsec_Mka_Policy) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaTransportSecurity_TransportSecurity_Macsec_Mka_Policy"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaTransportSecurity_TransportSecurity_Macsec_Mka_Policy) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaTransportSecurity_TransportSecurity_Macsec_Mka_Policy) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaTransportSecurity_TransportSecurity_Macsec_Mka_Policy.
func (*SrlNokiaTransportSecurity_TransportSecurity_Macsec_Mka_Policy) ΛBelongingModule() string {
	return "srl_nokia-macsec"
}

// SrlNokiaTunnelInterfaces_TunnelInterface represents the /srl_nokia-tunnel-interfaces/tunnel-interface YANG schema element.
type SrlNokiaTunnelInterfaces_TunnelInterface struct {
	Name           *string                                                             `path:"name" module:"srl_nokia-tunnel-interfaces"`
	VxlanInterface map[uint32]*SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface `path:"vxlan-interface" module:"srl_nokia-tunnel-interfaces"`
}

// IsYANGGoStruct ensures that SrlNokiaTunnelInterfaces_TunnelInterface implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaTunnelInterfaces_TunnelInterface) IsYANGGoStruct() {}

// NewVxlanInterface creates a new entry in the VxlanInterface list of the
// SrlNokiaTunnelInterfaces_TunnelInterface struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface) NewVxlanInterface(Index uint32) (*SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.VxlanInterface == nil {
		t.VxlanInterface = make(map[uint32]*SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface)
	}

	key := Index

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.VxlanInterface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list VxlanInterface", key)
	}

	t.VxlanInterface[key] = &SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface{
		Index: &Index,
	}

	return t.VxlanInterface[key], nil
}

// RenameVxlanInterface renames an entry in the list VxlanInterface within
// the SrlNokiaTunnelInterfaces_TunnelInterface struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface) RenameVxlanInterface(oldK, newK uint32) error {
	if _, ok := t.VxlanInterface[newK]; ok {
		return fmt.Errorf("key %v already exists in VxlanInterface", newK)
	}

	e, ok := t.VxlanInterface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in VxlanInterface", oldK)
	}
	e.Index = &newK

	t.VxlanInterface[newK] = e
	delete(t.VxlanInterface, oldK)
	return nil
}

// GetOrCreateVxlanInterface retrieves the value with the specified keys from
// the receiver SrlNokiaTunnelInterfaces_TunnelInterface. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface) GetOrCreateVxlanInterface(Index uint32) *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface {
	key := Index

	if v, ok := t.VxlanInterface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewVxlanInterface(Index)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateVxlanInterface got unexpected error: %v", err))
	}
	return v
}

// GetVxlanInterface retrieves the value with the specified key from
// the VxlanInterface map field of SrlNokiaTunnelInterfaces_TunnelInterface. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface) GetVxlanInterface(Index uint32) *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface {
	if t == nil {
		return nil
	}

	key := Index

	if lm, ok := t.VxlanInterface[key]; ok {
		return lm
	}
	return nil
}

// DeleteVxlanInterface deletes the value with the specified keys from
// the receiver SrlNokiaTunnelInterfaces_TunnelInterface. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface) DeleteVxlanInterface(Index uint32) {
	key := Index

	delete(t.VxlanInterface, key)
}

// AppendVxlanInterface appends the supplied SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface struct to the
// list VxlanInterface of SrlNokiaTunnelInterfaces_TunnelInterface. If the key value(s) specified in
// the supplied SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface already exist in the list, an error is
// returned.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface) AppendVxlanInterface(
	v *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface,
) error {
	if v.Index == nil {
		return fmt.Errorf("invalid nil key received for Index")
	}

	key := *v.Index

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.VxlanInterface == nil {
		t.VxlanInterface = make(map[uint32]*SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface)
	}

	if _, ok := t.VxlanInterface[key]; ok {
		return fmt.Errorf("duplicate key for list VxlanInterface %v", key)
	}

	t.VxlanInterface[key] = v
	return nil
}

// GetName retrieves the value of the leaf Name from the SrlNokiaTunnelInterfaces_TunnelInterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaTunnelInterfaces_TunnelInterface
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.VxlanInterface {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaTunnelInterfaces_TunnelInterface struct, which is a YANG list entry.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaTunnelInterfaces_TunnelInterface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaTunnelInterfaces_TunnelInterface.
func (*SrlNokiaTunnelInterfaces_TunnelInterface) ΛBelongingModule() string {
	return "srl_nokia-tunnel-interfaces"
}

// SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface represents the /srl_nokia-tunnel-interfaces/tunnel-interface/vxlan-interface YANG schema element.
type SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface struct {
	BridgeTable *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_BridgeTable `path:"bridge-table" module:"srl_nokia-tunnel-interfaces" yangPresence:"true"`
	Egress      *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress      `path:"egress" module:"srl_nokia-tunnel-interfaces"`
	Index       *uint32                                                              `path:"index" module:"srl_nokia-tunnel-interfaces"`
	Ingress     *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Ingress     `path:"ingress" module:"srl_nokia-tunnel-interfaces"`
	Type        E_SrlNokiaInterfaces_SiType                                          `path:"type" module:"srl_nokia-tunnel-interfaces"`
}

// IsYANGGoStruct ensures that SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface) IsYANGGoStruct() {}

// GetOrCreateBridgeTable retrieves the value of the BridgeTable field
// or returns the existing field if it already exists.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface) GetOrCreateBridgeTable() *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_BridgeTable {
	if t.BridgeTable != nil {
		return t.BridgeTable
	}
	t.BridgeTable = &SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_BridgeTable{}
	return t.BridgeTable
}

// GetOrCreateEgress retrieves the value of the Egress field
// or returns the existing field if it already exists.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface) GetOrCreateEgress() *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress {
	if t.Egress != nil {
		return t.Egress
	}
	t.Egress = &SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress{}
	return t.Egress
}

// GetOrCreateIngress retrieves the value of the Ingress field
// or returns the existing field if it already exists.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface) GetOrCreateIngress() *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Ingress {
	if t.Ingress != nil {
		return t.Ingress
	}
	t.Ingress = &SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Ingress{}
	return t.Ingress
}

// GetBridgeTable returns the value of the BridgeTable struct pointer
// from SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface. If the receiver or the field BridgeTable is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface) GetBridgeTable() *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_BridgeTable {
	if t != nil && t.BridgeTable != nil {
		return t.BridgeTable
	}
	return nil
}

// GetEgress returns the value of the Egress struct pointer
// from SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface. If the receiver or the field Egress is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface) GetEgress() *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress {
	if t != nil && t.Egress != nil {
		return t.Egress
	}
	return nil
}

// GetIngress returns the value of the Ingress struct pointer
// from SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface. If the receiver or the field Ingress is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface) GetIngress() *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Ingress {
	if t != nil && t.Ingress != nil {
		return t.Ingress
	}
	return nil
}

// GetIndex retrieves the value of the leaf Index from the SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Index is set, it can
// safely use t.GetIndex() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Index == nil' before retrieving the leaf's value.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface) GetIndex() uint32 {
	if t == nil || t.Index == nil {
		return 0
	}
	return *t.Index
}

// GetType retrieves the value of the leaf Type from the SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Type is set, it can
// safely use t.GetType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Type == nil' before retrieving the leaf's value.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface) GetType() E_SrlNokiaInterfaces_SiType {
	if t == nil || t.Type == 0 {
		return 0
	}
	return t.Type
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.BridgeTable.PopulateDefaults()
	t.Egress.PopulateDefaults()
	t.Ingress.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface struct, which is a YANG list entry.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Index == nil {
		return nil, fmt.Errorf("nil value for key Index")
	}

	return map[string]interface{}{
		"index": *t.Index,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface.
func (*SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface) ΛBelongingModule() string {
	return "srl_nokia-tunnel-interfaces"
}

// SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_BridgeTable represents the /srl_nokia-tunnel-interfaces/tunnel-interface/vxlan-interface/bridge-table YANG schema element.
type SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_BridgeTable struct{}

// IsYANGGoStruct ensures that SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_BridgeTable implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_BridgeTable) IsYANGGoStruct() {}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_BridgeTable
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_BridgeTable) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_BridgeTable) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_BridgeTable"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_BridgeTable) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_BridgeTable) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_BridgeTable.
func (*SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_BridgeTable) ΛBelongingModule() string {
	return "srl_nokia-tunnel-interfaces"
}

// SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress represents the /srl_nokia-tunnel-interfaces/tunnel-interface/vxlan-interface/egress YANG schema element.
type SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress struct {
	DestinationGroups   *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups   `path:"destination-groups" module:"srl_nokia-tunnel-interfaces"`
	InnerEthernetHeader *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_InnerEthernetHeader `path:"inner-ethernet-header" module:"srl_nokia-tunnel-interfaces" yangPresence:"true"`
	SourceIp            E_SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_SourceIp_Enum      `path:"source-ip" module:"srl_nokia-tunnel-interfaces"`
}

// IsYANGGoStruct ensures that SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress) IsYANGGoStruct() {}

// GetOrCreateDestinationGroups retrieves the value of the DestinationGroups field
// or returns the existing field if it already exists.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress) GetOrCreateDestinationGroups() *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups {
	if t.DestinationGroups != nil {
		return t.DestinationGroups
	}
	t.DestinationGroups = &SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups{}
	return t.DestinationGroups
}

// GetOrCreateInnerEthernetHeader retrieves the value of the InnerEthernetHeader field
// or returns the existing field if it already exists.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress) GetOrCreateInnerEthernetHeader() *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_InnerEthernetHeader {
	if t.InnerEthernetHeader != nil {
		return t.InnerEthernetHeader
	}
	t.InnerEthernetHeader = &SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_InnerEthernetHeader{}
	return t.InnerEthernetHeader
}

// GetDestinationGroups returns the value of the DestinationGroups struct pointer
// from SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress. If the receiver or the field DestinationGroups is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress) GetDestinationGroups() *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups {
	if t != nil && t.DestinationGroups != nil {
		return t.DestinationGroups
	}
	return nil
}

// GetInnerEthernetHeader returns the value of the InnerEthernetHeader struct pointer
// from SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress. If the receiver or the field InnerEthernetHeader is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress) GetInnerEthernetHeader() *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_InnerEthernetHeader {
	if t != nil && t.InnerEthernetHeader != nil {
		return t.InnerEthernetHeader
	}
	return nil
}

// GetSourceIp retrieves the value of the leaf SourceIp from the SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SourceIp is set, it can
// safely use t.GetSourceIp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SourceIp == nil' before retrieving the leaf's value.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress) GetSourceIp() E_SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_SourceIp_Enum {
	if t == nil || t.SourceIp == 0 {
		return SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_SourceIp_Enum_use_system_ipv4_address
	}
	return t.SourceIp
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.SourceIp == 0 {
		t.SourceIp = SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_SourceIp_Enum_use_system_ipv4_address
	}
	t.DestinationGroups.PopulateDefaults()
	t.InnerEthernetHeader.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress.
func (*SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress) ΛBelongingModule() string {
	return "srl_nokia-tunnel-interfaces"
}

// SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups represents the /srl_nokia-tunnel-interfaces/tunnel-interface/vxlan-interface/egress/destination-groups YANG schema element.
type SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups struct {
	Group map[string]*SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group `path:"group" module:"srl_nokia-tunnel-interfaces"`
}

// IsYANGGoStruct ensures that SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups) IsYANGGoStruct() {
}

// NewGroup creates a new entry in the Group list of the
// SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups) NewGroup(
	Name string,
) (*SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Group == nil {
		t.Group = make(map[string]*SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Group[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Group", key)
	}

	t.Group[key] = &SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group{
		Name: &Name,
	}

	return t.Group[key], nil
}

// RenameGroup renames an entry in the list Group within
// the SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups) RenameGroup(oldK, newK string) error {
	if _, ok := t.Group[newK]; ok {
		return fmt.Errorf("key %v already exists in Group", newK)
	}

	e, ok := t.Group[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Group", oldK)
	}
	e.Name = &newK

	t.Group[newK] = e
	delete(t.Group, oldK)
	return nil
}

// GetOrCreateGroup retrieves the value with the specified keys from
// the receiver SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups) GetOrCreateGroup(
	Name string,
) *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group {
	key := Name

	if v, ok := t.Group[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewGroup(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateGroup got unexpected error: %v", err))
	}
	return v
}

// GetGroup retrieves the value with the specified key from
// the Group map field of SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups) GetGroup(
	Name string,
) *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Group[key]; ok {
		return lm
	}
	return nil
}

// DeleteGroup deletes the value with the specified keys from
// the receiver SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups) DeleteGroup(Name string) {
	key := Name

	delete(t.Group, key)
}

// AppendGroup appends the supplied SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group struct to the
// list Group of SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups. If the key value(s) specified in
// the supplied SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group already exist in the list, an error is
// returned.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups) AppendGroup(
	v *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group,
) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Group == nil {
		t.Group = make(map[string]*SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group)
	}

	if _, ok := t.Group[key]; ok {
		return fmt.Errorf("duplicate key for list Group %v", key)
	}

	t.Group[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Group {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups.
func (*SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups) ΛBelongingModule() string {
	return "srl_nokia-tunnel-interfaces"
}

// SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group represents the /srl_nokia-tunnel-interfaces/tunnel-interface/vxlan-interface/egress/destination-groups/group YANG schema element.
type SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group struct {
	AdminState  E_SrlNokiaCommon_AdminState                                                                                    `path:"admin-state" module:"srl_nokia-tunnel-interfaces"`
	Destination map[uint16]*SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group_Destination `path:"destination" module:"srl_nokia-tunnel-interfaces"`
	Esi         *string                                                                                                        `path:"esi" module:"srl_nokia-tunnel-interfaces"`
	Name        *string                                                                                                        `path:"name" module:"srl_nokia-tunnel-interfaces"`
}

// IsYANGGoStruct ensures that SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group) IsYANGGoStruct() {
}

// NewDestination creates a new entry in the Destination list of the
// SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group) NewDestination(
	Index uint16,
) (*SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group_Destination, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Destination == nil {
		t.Destination = make(map[uint16]*SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group_Destination)
	}

	key := Index

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Destination[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Destination", key)
	}

	t.Destination[key] = &SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group_Destination{
		Index: &Index,
	}

	return t.Destination[key], nil
}

// RenameDestination renames an entry in the list Destination within
// the SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group) RenameDestination(oldK, newK uint16) error {
	if _, ok := t.Destination[newK]; ok {
		return fmt.Errorf("key %v already exists in Destination", newK)
	}

	e, ok := t.Destination[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Destination", oldK)
	}
	e.Index = &newK

	t.Destination[newK] = e
	delete(t.Destination, oldK)
	return nil
}

// GetOrCreateDestination retrieves the value with the specified keys from
// the receiver SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group) GetOrCreateDestination(
	Index uint16,
) *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group_Destination {
	key := Index

	if v, ok := t.Destination[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewDestination(Index)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateDestination got unexpected error: %v", err))
	}
	return v
}

// GetDestination retrieves the value with the specified key from
// the Destination map field of SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group) GetDestination(
	Index uint16,
) *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group_Destination {
	if t == nil {
		return nil
	}

	key := Index

	if lm, ok := t.Destination[key]; ok {
		return lm
	}
	return nil
}

// DeleteDestination deletes the value with the specified keys from
// the receiver SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group) DeleteDestination(Index uint16) {
	key := Index

	delete(t.Destination, key)
}

// AppendDestination appends the supplied SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group_Destination struct to the
// list Destination of SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group. If the key value(s) specified in
// the supplied SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group_Destination already exist in the list, an error is
// returned.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group) AppendDestination(
	v *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group_Destination,
) error {
	if v.Index == nil {
		return fmt.Errorf("invalid nil key received for Index")
	}

	key := *v.Index

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Destination == nil {
		t.Destination = make(map[uint16]*SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group_Destination)
	}

	if _, ok := t.Destination[key]; ok {
		return fmt.Errorf("duplicate key for list Destination %v", key)
	}

	t.Destination[key] = v
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_enable
	}
	return t.AdminState
}

// GetEsi retrieves the value of the leaf Esi from the SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Esi is set, it can
// safely use t.GetEsi() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Esi == nil' before retrieving the leaf's value.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group) GetEsi() string {
	if t == nil || t.Esi == nil {
		return ""
	}
	return *t.Esi
}

// GetName retrieves the value of the leaf Name from the SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_enable
	}
	for _, e := range t.Destination {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group struct, which is a YANG list entry.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group.
func (*SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group) ΛBelongingModule() string {
	return "srl_nokia-tunnel-interfaces"
}

// SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group_Destination represents the /srl_nokia-tunnel-interfaces/tunnel-interface/vxlan-interface/egress/destination-groups/group/destination YANG schema element.
type SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group_Destination struct {
	AdminState          E_SrlNokiaCommon_AdminState                                                                                             `path:"admin-state" module:"srl_nokia-tunnel-interfaces"`
	Index               *uint16                                                                                                                 `path:"index" module:"srl_nokia-tunnel-interfaces"`
	InnerEthernetHeader *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group_Destination_InnerEthernetHeader `path:"inner-ethernet-header" module:"srl_nokia-tunnel-interfaces"`
	Vni                 *uint32                                                                                                                 `path:"vni" module:"srl_nokia-tunnel-interfaces"`
}

// IsYANGGoStruct ensures that SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group_Destination implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group_Destination) IsYANGGoStruct() {
}

// GetOrCreateInnerEthernetHeader retrieves the value of the InnerEthernetHeader field
// or returns the existing field if it already exists.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group_Destination) GetOrCreateInnerEthernetHeader() *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group_Destination_InnerEthernetHeader {
	if t.InnerEthernetHeader != nil {
		return t.InnerEthernetHeader
	}
	t.InnerEthernetHeader = &SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group_Destination_InnerEthernetHeader{}
	return t.InnerEthernetHeader
}

// GetInnerEthernetHeader returns the value of the InnerEthernetHeader struct pointer
// from SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group_Destination. If the receiver or the field InnerEthernetHeader is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group_Destination) GetInnerEthernetHeader() *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group_Destination_InnerEthernetHeader {
	if t != nil && t.InnerEthernetHeader != nil {
		return t.InnerEthernetHeader
	}
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group_Destination
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group_Destination) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_enable
	}
	return t.AdminState
}

// GetIndex retrieves the value of the leaf Index from the SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group_Destination
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Index is set, it can
// safely use t.GetIndex() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Index == nil' before retrieving the leaf's value.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group_Destination) GetIndex() uint16 {
	if t == nil || t.Index == nil {
		return 0
	}
	return *t.Index
}

// GetVni retrieves the value of the leaf Vni from the SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group_Destination
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Vni is set, it can
// safely use t.GetVni() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Vni == nil' before retrieving the leaf's value.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group_Destination) GetVni() uint32 {
	if t == nil || t.Vni == nil {
		return 0
	}
	return *t.Vni
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group_Destination
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group_Destination) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_enable
	}
	t.InnerEthernetHeader.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group_Destination struct, which is a YANG list entry.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group_Destination) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Index == nil {
		return nil, fmt.Errorf("nil value for key Index")
	}

	return map[string]interface{}{
		"index": *t.Index,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group_Destination) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group_Destination"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group_Destination) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group_Destination) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group_Destination.
func (*SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group_Destination) ΛBelongingModule() string {
	return "srl_nokia-tunnel-interfaces"
}

// SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group_Destination_InnerEthernetHeader represents the /srl_nokia-tunnel-interfaces/tunnel-interface/vxlan-interface/egress/destination-groups/group/destination/inner-ethernet-header YANG schema element.
type SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group_Destination_InnerEthernetHeader struct {
	DestinationMac *string `path:"destination-mac" module:"srl_nokia-tunnel-interfaces"`
}

// IsYANGGoStruct ensures that SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group_Destination_InnerEthernetHeader implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group_Destination_InnerEthernetHeader) IsYANGGoStruct() {
}

// GetDestinationMac retrieves the value of the leaf DestinationMac from the SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group_Destination_InnerEthernetHeader
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DestinationMac is set, it can
// safely use t.GetDestinationMac() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DestinationMac == nil' before retrieving the leaf's value.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group_Destination_InnerEthernetHeader) GetDestinationMac() string {
	if t == nil || t.DestinationMac == nil {
		return ""
	}
	return *t.DestinationMac
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group_Destination_InnerEthernetHeader
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group_Destination_InnerEthernetHeader) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group_Destination_InnerEthernetHeader) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group_Destination_InnerEthernetHeader"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group_Destination_InnerEthernetHeader) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group_Destination_InnerEthernetHeader) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group_Destination_InnerEthernetHeader.
func (*SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group_Destination_InnerEthernetHeader) ΛBelongingModule() string {
	return "srl_nokia-tunnel-interfaces"
}

// SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_InnerEthernetHeader represents the /srl_nokia-tunnel-interfaces/tunnel-interface/vxlan-interface/egress/inner-ethernet-header YANG schema element.
type SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_InnerEthernetHeader struct {
	SourceMac E_SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_InnerEthernetHeader_SourceMac_Enum `path:"source-mac" module:"srl_nokia-tunnel-interfaces"`
}

// IsYANGGoStruct ensures that SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_InnerEthernetHeader implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_InnerEthernetHeader) IsYANGGoStruct() {
}

// GetSourceMac retrieves the value of the leaf SourceMac from the SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_InnerEthernetHeader
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SourceMac is set, it can
// safely use t.GetSourceMac() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SourceMac == nil' before retrieving the leaf's value.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_InnerEthernetHeader) GetSourceMac() E_SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_InnerEthernetHeader_SourceMac_Enum {
	if t == nil || t.SourceMac == 0 {
		return SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_InnerEthernetHeader_SourceMac_Enum_use_system_mac
	}
	return t.SourceMac
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_InnerEthernetHeader
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_InnerEthernetHeader) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.SourceMac == 0 {
		t.SourceMac = SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_InnerEthernetHeader_SourceMac_Enum_use_system_mac
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_InnerEthernetHeader) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_InnerEthernetHeader"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_InnerEthernetHeader) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_InnerEthernetHeader) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_InnerEthernetHeader.
func (*SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_InnerEthernetHeader) ΛBelongingModule() string {
	return "srl_nokia-tunnel-interfaces"
}

// SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Ingress represents the /srl_nokia-tunnel-interfaces/tunnel-interface/vxlan-interface/ingress YANG schema element.
type SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Ingress struct {
	Vni *uint32 `path:"vni" module:"srl_nokia-tunnel-interfaces"`
}

// IsYANGGoStruct ensures that SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Ingress implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Ingress) IsYANGGoStruct() {}

// GetVni retrieves the value of the leaf Vni from the SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Ingress
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Vni is set, it can
// safely use t.GetVni() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Vni == nil' before retrieving the leaf's value.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Ingress) GetVni() uint32 {
	if t == nil || t.Vni == nil {
		return 0
	}
	return *t.Vni
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Ingress
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Ingress) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Ingress) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Ingress"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Ingress) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Ingress) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Ingress.
func (*SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Ingress) ΛBelongingModule() string {
	return "srl_nokia-tunnel-interfaces"
}

// SrlNokiaTunnel_Tunnel represents the /srl_nokia-tunnel/tunnel YANG schema element.
type SrlNokiaTunnel_Tunnel struct {
	VxlanTunnel *SrlNokiaTunnel_Tunnel_VxlanTunnel `path:"vxlan-tunnel" module:"srl_nokia-vxlan-tunnel-vtep"`
}

// IsYANGGoStruct ensures that SrlNokiaTunnel_Tunnel implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaTunnel_Tunnel) IsYANGGoStruct() {}

// GetOrCreateVxlanTunnel retrieves the value of the VxlanTunnel field
// or returns the existing field if it already exists.
func (t *SrlNokiaTunnel_Tunnel) GetOrCreateVxlanTunnel() *SrlNokiaTunnel_Tunnel_VxlanTunnel {
	if t.VxlanTunnel != nil {
		return t.VxlanTunnel
	}
	t.VxlanTunnel = &SrlNokiaTunnel_Tunnel_VxlanTunnel{}
	return t.VxlanTunnel
}

// GetVxlanTunnel returns the value of the VxlanTunnel struct pointer
// from SrlNokiaTunnel_Tunnel. If the receiver or the field VxlanTunnel is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaTunnel_Tunnel) GetVxlanTunnel() *SrlNokiaTunnel_Tunnel_VxlanTunnel {
	if t != nil && t.VxlanTunnel != nil {
		return t.VxlanTunnel
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaTunnel_Tunnel
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaTunnel_Tunnel) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.VxlanTunnel.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaTunnel_Tunnel) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaTunnel_Tunnel"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaTunnel_Tunnel) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaTunnel_Tunnel) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaTunnel_Tunnel.
func (*SrlNokiaTunnel_Tunnel) ΛBelongingModule() string {
	return "srl_nokia-tunnel"
}

// SrlNokiaTunnel_Tunnel_VxlanTunnel represents the /srl_nokia-tunnel/tunnel/vxlan-tunnel YANG schema element.
type SrlNokiaTunnel_Tunnel_VxlanTunnel struct {
	Statistics *SrlNokiaTunnel_Tunnel_VxlanTunnel_Statistics `path:"statistics" module:"srl_nokia-vxlan-tunnel-vtep"`
}

// IsYANGGoStruct ensures that SrlNokiaTunnel_Tunnel_VxlanTunnel implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaTunnel_Tunnel_VxlanTunnel) IsYANGGoStruct() {}

// GetOrCreateStatistics retrieves the value of the Statistics field
// or returns the existing field if it already exists.
func (t *SrlNokiaTunnel_Tunnel_VxlanTunnel) GetOrCreateStatistics() *SrlNokiaTunnel_Tunnel_VxlanTunnel_Statistics {
	if t.Statistics != nil {
		return t.Statistics
	}
	t.Statistics = &SrlNokiaTunnel_Tunnel_VxlanTunnel_Statistics{}
	return t.Statistics
}

// GetStatistics returns the value of the Statistics struct pointer
// from SrlNokiaTunnel_Tunnel_VxlanTunnel. If the receiver or the field Statistics is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaTunnel_Tunnel_VxlanTunnel) GetStatistics() *SrlNokiaTunnel_Tunnel_VxlanTunnel_Statistics {
	if t != nil && t.Statistics != nil {
		return t.Statistics
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaTunnel_Tunnel_VxlanTunnel
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaTunnel_Tunnel_VxlanTunnel) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Statistics.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaTunnel_Tunnel_VxlanTunnel) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaTunnel_Tunnel_VxlanTunnel"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaTunnel_Tunnel_VxlanTunnel) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaTunnel_Tunnel_VxlanTunnel) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaTunnel_Tunnel_VxlanTunnel.
func (*SrlNokiaTunnel_Tunnel_VxlanTunnel) ΛBelongingModule() string {
	return "srl_nokia-vxlan-tunnel-vtep"
}

// SrlNokiaTunnel_Tunnel_VxlanTunnel_Statistics represents the /srl_nokia-tunnel/tunnel/vxlan-tunnel/statistics YANG schema element.
type SrlNokiaTunnel_Tunnel_VxlanTunnel_Statistics struct {
	AdminState E_SrlNokiaCommon_AdminState `path:"admin-state" module:"srl_nokia-vxlan-tunnel-vtep"`
}

// IsYANGGoStruct ensures that SrlNokiaTunnel_Tunnel_VxlanTunnel_Statistics implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaTunnel_Tunnel_VxlanTunnel_Statistics) IsYANGGoStruct() {}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaTunnel_Tunnel_VxlanTunnel_Statistics
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaTunnel_Tunnel_VxlanTunnel_Statistics) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_disable
	}
	return t.AdminState
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaTunnel_Tunnel_VxlanTunnel_Statistics
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaTunnel_Tunnel_VxlanTunnel_Statistics) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_disable
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaTunnel_Tunnel_VxlanTunnel_Statistics) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaTunnel_Tunnel_VxlanTunnel_Statistics"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaTunnel_Tunnel_VxlanTunnel_Statistics) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaTunnel_Tunnel_VxlanTunnel_Statistics) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaTunnel_Tunnel_VxlanTunnel_Statistics.
func (*SrlNokiaTunnel_Tunnel_VxlanTunnel_Statistics) ΛBelongingModule() string {
	return "srl_nokia-vxlan-tunnel-vtep"
}
