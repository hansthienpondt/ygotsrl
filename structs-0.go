/*
Package ygotsrl is a generated package which contains definitions
of structs which represent a YANG schema. The generated schema can be
compressed by a series of transformations (compression was false
in this case).

This package was generated by /home/hans/go/pkg/mod/github.com/openconfig/ygot@v0.29.17/genutil/names.go
using the following YANG input files:
	- work/srlinux-yang-models/srl_nokia/models/acl/srl_nokia-acl-policers.yang
	- work/srlinux-yang-models/srl_nokia/models/acl/srl_nokia-acl-qos.yang
	- work/srlinux-yang-models/srl_nokia/models/acl/srl_nokia-acl.yang
	- work/srlinux-yang-models/srl_nokia/models/acl/srl_nokia-packet-match-types.yang
	- work/srlinux-yang-models/srl_nokia/models/bfd/srl_nokia-bfd.yang
	- work/srlinux-yang-models/srl_nokia/models/bfd/srl_nokia-micro-bfd.yang
	- work/srlinux-yang-models/srl_nokia/models/common/srl_nokia-common.yang
	- work/srlinux-yang-models/srl_nokia/models/common/srl_nokia-extensions.yang
	- work/srlinux-yang-models/srl_nokia/models/common/srl_nokia-features.yang
	- work/srlinux-yang-models/srl_nokia/models/ethcfm/srl_nokia-ethcfm-types.yang
	- work/srlinux-yang-models/srl_nokia/models/ethcfm/srl_nokia-ethcfm.yang
	- work/srlinux-yang-models/srl_nokia/models/ethcfm/srl_nokia-oam-pm-ethcfm.yang
	- work/srlinux-yang-models/srl_nokia/models/grpc/srl_nokia-gnsi-authz.yang
	- work/srlinux-yang-models/srl_nokia/models/grpc/srl_nokia-gnsi-certz.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-if-ip.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-if-mpls.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-bridge-table-mac-duplication-entries.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-bridge-table-mac-learning-entries.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-bridge-table-mac-table.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-bridge-table-statistics.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-bridge-table.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-ethernet-segment-association.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-ip-dhcp-relay.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-ip-dhcp-server.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-ip-dhcp.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-ip-vrrp.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-l2cp.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-lag.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-local-mirror-destination.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-nbr-evpn.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-nbr-virtual-ip-discovery.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-nbr.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-p4rt.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-router-adv.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-vlans.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-vxdp.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-lacp.yang
	- work/srlinux-yang-models/srl_nokia/models/ipamps/srl_nokia-ippm-source-udp-pool.yang
	- work/srlinux-yang-models/srl_nokia/models/ipamps/srl_nokia-link-measurement.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-aggregate-routes.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bgp-evpn-bgp-instance-mpls-bridge-table-multicast-destinations.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bgp-evpn-bgp-instance-mpls-bridge-table-statistics.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bgp-evpn-bgp-instance-mpls-bridge-table-unicast-destinations.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bgp-evpn-bgp-instance-mpls-vpws-destinations.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bgp-evpn.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bgp-ipvpn.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bgp-vpn.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bgp.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table-mac-duplication-entries.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table-mac-duplication.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table-mac-learning-entries.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table-mac-learning.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table-mac-limit.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table-mac-table.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table-proxy-arp-nd.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table-reserved-macs.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table-shg.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table-static-mac.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-connection-point.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-icmp.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-igmp-snooping.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-igmp-types.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-igmp.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-ip-route-tables.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-isis-lsdb-types.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-isis-lsdb.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-isis.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-ldp.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-linux.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-maintenance-policies.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-mld-snooping.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-mld.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-mpls-route-tables.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-mpls.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-multicast-mfib-tables.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-mvpn-l3.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-network-instance-mtu.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-network-instance.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-next-hop-groups.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-ospf-lsdb.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-ospf-types.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-ospf.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-ospfv3-lsas.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-pcep.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-pim.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-policy-forwarding.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-rib-bgp.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-segment-routing.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-static-routes.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-tcp-udp.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-te-policies.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-traffic-engineering.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-tunnel-tables.yang
	- work/srlinux-yang-models/srl_nokia/models/oam/srl_nokia-lsp-ping-trace.yang
	- work/srlinux-yang-models/srl_nokia/models/oam/srl_nokia-oam-pm-ip.yang
	- work/srlinux-yang-models/srl_nokia/models/oam/srl_nokia-oam-pm-types.yang
	- work/srlinux-yang-models/srl_nokia/models/oam/srl_nokia-oam-pm.yang
	- work/srlinux-yang-models/srl_nokia/models/oam/srl_nokia-oam.yang
	- work/srlinux-yang-models/srl_nokia/models/oam/srl_nokia-stamp.yang
	- work/srlinux-yang-models/srl_nokia/models/oam/srl_nokia-twamp.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-acl.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-cgroup.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-chassis.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-control.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-cpu.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-datapath-resources.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-disk.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-fabric.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-fan.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-healthz.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-lc.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-linecard-fib.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-memory.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-mtu.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-p4rt.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-pipeline-counters.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-psu.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-qos.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-redundancy.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-resource-mgmt.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-resource-monitoring.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-secure-boot.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-tcam.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-tpm.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-vxdp.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform.yang
	- work/srlinux-yang-models/srl_nokia/models/qos/srl_nokia-qos-policers.yang
	- work/srlinux-yang-models/srl_nokia/models/qos/srl_nokia-qos.yang
	- work/srlinux-yang-models/srl_nokia/models/routing-policy/srl_nokia-policy-types.yang
	- work/srlinux-yang-models/srl_nokia/models/routing-policy/srl_nokia-routing-policy.yang
	- work/srlinux-yang-models/srl_nokia/models/sync/srl_nokia-sync-freq.yang
	- work/srlinux-yang-models/srl_nokia/models/sync/srl_nokia-sync-interfaces.yang
	- work/srlinux-yang-models/srl_nokia/models/sync/srl_nokia-sync-ptp.yang
	- work/srlinux-yang-models/srl_nokia/models/sync/srl_nokia-sync-types.yang
	- work/srlinux-yang-models/srl_nokia/models/sync/srl_nokia-sync.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-aaa-password.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-aaa-radius.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-aaa-tacacs.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-aaa-types.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-aaa.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-app-mgmt.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-boot.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-configuration-role.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-configuration.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-dhcp-server.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-dns.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-event-handler.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-ftp.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-gnmi-server.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-gribi-server.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-json-rpc.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-keychains.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-license.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-lldp-types.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-lldp.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-load-balancing.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-logging.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-maintenance-mode.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-mirroring.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-mpls-label-management.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-mpls-services-evpn-label-management.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-mpls-services-network-instance-label-management.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-mtu.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-ntp.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-openconfig.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-p4rt-server.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-packet-link-qual.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-ra_guard.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-sflow.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-snmp-trace.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-snmp.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-ssh.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system-banner.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system-bridge-table-proxy-arp.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system-bridge-table.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system-info.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system-multicast-mfib-table.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system-multicast.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system-name.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system-network-instance-bgp-evpn-ethernet-segments.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system-network-instance-bgp-vpn.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system-network-instance.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system-protocols.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-timezone.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-tls.yang
	- work/srlinux-yang-models/srl_nokia/models/transport-security/srl_nokia-macsec.yang
	- work/srlinux-yang-models/srl_nokia/models/transport-security/srl_nokia-transport-security.yang
	- work/srlinux-yang-models/srl_nokia/models/tunnel/srl_nokia-tunnel-interfaces-vxlan-interface-bridge-table-multicast-destinations.yang
	- work/srlinux-yang-models/srl_nokia/models/tunnel/srl_nokia-tunnel-interfaces-vxlan-interface-bridge-table-unicast-destinations.yang
	- work/srlinux-yang-models/srl_nokia/models/tunnel/srl_nokia-tunnel-interfaces-vxlan-interface-bridge-table-unicast-es-destination-vteps.yang
	- work/srlinux-yang-models/srl_nokia/models/tunnel/srl_nokia-tunnel-interfaces-vxlan-interface-bridge-table.yang
	- work/srlinux-yang-models/srl_nokia/models/tunnel/srl_nokia-tunnel-interfaces.yang
	- work/srlinux-yang-models/srl_nokia/models/tunnel/srl_nokia-tunnel.yang
	- work/srlinux-yang-models/srl_nokia/models/tunnel/srl_nokia-vxlan-tunnel-vtep.yang
Imported modules were sourced from:
	- work/srlinux-yang-models/...
*/
package ygotsrl

import (
	"encoding/json"
	"fmt"
	"reflect"

	gpb "github.com/openconfig/gnmi/proto/gnmi"
	"github.com/openconfig/goyang/pkg/yang"
	"github.com/openconfig/ygot/ygot"
	"github.com/openconfig/ygot/ytypes"
)

// Binary is a type that is used for fields that have a YANG type of
// binary. It is used such that binary fields can be distinguished from
// leaf-lists of uint8s (which are mapped to []uint8, equivalent to
// []byte in reflection).
type Binary []byte

// YANGEmpty is a type that is used for fields that have a YANG type of
// empty. It is used such that empty fields can be distinguished from boolean fields
// in the generated code.
type YANGEmpty bool

// UnionInt8 is an int8 type assignable to unions of which it is a subtype.
type UnionInt8 int8

// UnionInt16 is an int16 type assignable to unions of which it is a subtype.
type UnionInt16 int16

// UnionInt32 is an int32 type assignable to unions of which it is a subtype.
type UnionInt32 int32

// UnionInt64 is an int64 type assignable to unions of which it is a subtype.
type UnionInt64 int64

// UnionUint8 is a uint8 type assignable to unions of which it is a subtype.
type UnionUint8 uint8

// UnionUint16 is a uint16 type assignable to unions of which it is a subtype.
type UnionUint16 uint16

// UnionUint32 is a uint32 type assignable to unions of which it is a subtype.
type UnionUint32 uint32

// UnionUint64 is a uint64 type assignable to unions of which it is a subtype.
type UnionUint64 uint64

// UnionFloat64 is a float64 type assignable to unions of which it is a subtype.
type UnionFloat64 float64

// UnionString is a string type assignable to unions of which it is a subtype.
type UnionString string

// UnionBool is a bool type assignable to unions of which it is a subtype.
type UnionBool bool

// UnionUnsupported is an interface{} wrapper type for unsupported types. It is
// assignable to unions of which it is a subtype.
type UnionUnsupported struct {
	Value interface{}
}

var (
	SchemaTree map[string]*yang.Entry
	ΛEnumTypes map[string][]reflect.Type
)

func init() {
	var err error
	initΛEnumTypes()
	if SchemaTree, err = UnzipSchema(); err != nil {
		panic("schema error: " + err.Error())
	}
}

// Schema returns the details of the generated schema.
func Schema() (*ytypes.Schema, error) {
	uzp, err := UnzipSchema()
	if err != nil {
		return nil, fmt.Errorf("cannot unzip schema, %v", err)
	}

	return &ytypes.Schema{
		Root:       &Device{},
		SchemaTree: uzp,
		Unmarshal:  Unmarshal,
	}, nil
}

// UnzipSchema unzips the zipped schema and returns a map of yang.Entry nodes,
// keyed by the name of the struct that the yang.Entry describes the schema for.
func UnzipSchema() (map[string]*yang.Entry, error) {
	var schemaTree map[string]*yang.Entry
	var err error
	if schemaTree, err = ygot.GzipToSchema(ySchema); err != nil {
		return nil, fmt.Errorf("could not unzip the schema; %v", err)
	}
	return schemaTree, nil
}

// Unmarshal unmarshals data, which must be RFC7951 JSON format, into
// destStruct, which must be non-nil and the correct GoStruct type. It returns
// an error if the destStruct is not found in the schema or the data cannot be
// unmarshaled. The supplied options (opts) are used to control the behaviour
// of the unmarshal function - for example, determining whether errors are
// thrown for unknown fields in the input JSON.
func Unmarshal(data []byte, destStruct ygot.GoStruct, opts ...ytypes.UnmarshalOpt) error {
	tn := reflect.TypeOf(destStruct).Elem().Name()
	schema, ok := SchemaTree[tn]
	if !ok {
		return fmt.Errorf("could not find schema for type %s", tn)
	}
	var jsonTree interface{}
	if err := json.Unmarshal([]byte(data), &jsonTree); err != nil {
		return err
	}
	return ytypes.Unmarshal(schema, destStruct, jsonTree, opts...)
}

// ΓModelData contains the catalogue information corresponding to the modules for
// which Go code was generated.
var ΓModelData = []*gpb.ModelData{
	{
		Name:         "ietf-yang-metadata",
		Organization: "IETF NETMOD (NETCONF Data Modeling Language) Working Group",
	},
	{
		Name:         "ietf-yang-types",
		Organization: "IETF NETMOD (NETCONF Data Modeling Language) Working Group",
	},
	{
		Name:         "openconfig-extensions",
		Organization: "OpenConfig working group",
		Version:      "0.5.1",
	},
	{
		Name:         "openconfig-metadata",
		Organization: "OpenConfig working group",
		Version:      "0.1.0",
	},
	{
		Name:         "srl_nokia-aaa",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-aaa-password",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-aaa-radius",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-aaa-tacacs",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-aaa-types",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-acl",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-acl-policers",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-acl-qos",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-aggregate-routes",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-app-mgmt",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-bfd",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-bgp",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-bgp-evpn",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-bgp-evpn-bgp-instance-mpls-bridge-table-multicast-destinations",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-bgp-evpn-bgp-instance-mpls-bridge-table-statistics",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-bgp-evpn-bgp-instance-mpls-bridge-table-unicast-destinations",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-bgp-evpn-bgp-instance-mpls-vpws-destinations",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-bgp-ipvpn",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-bgp-vpn",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-boot",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-bridge-table",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-bridge-table-mac-duplication",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-bridge-table-mac-duplication-entries",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-bridge-table-mac-learning",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-bridge-table-mac-learning-entries",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-bridge-table-mac-limit",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-bridge-table-mac-table",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-bridge-table-proxy-arp-nd",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-bridge-table-reserved-macs",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-bridge-table-shg",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-bridge-table-static-mac",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-common",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-configuration",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-configuration-role",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-connection-point",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-dhcp-server",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-dns",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-ethcfm",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-ethcfm-types",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-event-handler",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-extensions",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-features",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-ftp",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-gnmi-server",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-gnsi-authz",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-gnsi-certz",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-gribi-server",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-icmp",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-if-ip",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-if-mpls",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-igmp",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-igmp-snooping",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-igmp-types",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-interfaces",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-interfaces-bridge-table",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-interfaces-bridge-table-mac-duplication-entries",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-interfaces-bridge-table-mac-learning-entries",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-interfaces-bridge-table-mac-table",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-interfaces-bridge-table-statistics",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-interfaces-ethernet-segment-association",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-interfaces-ip-dhcp",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-interfaces-ip-dhcp-relay",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-interfaces-ip-dhcp-server",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-interfaces-ip-vrrp",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-interfaces-l2cp",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-interfaces-lag",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-interfaces-local-mirror-destination",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-interfaces-nbr",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-interfaces-nbr-evpn",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-interfaces-nbr-virtual-ip-discovery",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-interfaces-p4rt",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-interfaces-router-adv",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-interfaces-vlans",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-interfaces-vxdp",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-ip-route-tables",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-ippm-source-udp-pool",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-isis",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-isis-lsdb",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-isis-lsdb-types",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-json-rpc",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-keychains",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-lacp",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-ldp",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-license",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-link-measurement",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-linux",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-lldp",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-lldp-types",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-load-balancing",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-logging",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-lsp-ping-trace",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-macsec",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-maintenance-mode",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-maintenance-policies",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-micro-bfd",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-mirroring",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-mld",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-mld-snooping",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-mpls",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-mpls-label-management",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-mpls-route-tables",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-mpls-services-evpn-label-management",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-mpls-services-network-instance-label-management",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-mtu",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-multicast-mfib-tables",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-mvpn-l3",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-network-instance",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-network-instance-mtu",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-next-hop-groups",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-ntp",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-oam",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-oam-pm",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-oam-pm-ethcfm",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-oam-pm-ip",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-oam-pm-types",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-openconfig",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-ospf",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-ospf-types",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-p4rt-server",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-packet-link-qual",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-packet-match-types",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-pcep",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-pim",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-platform",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-platform-acl",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-platform-cgroup",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-platform-chassis",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-platform-control",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-platform-cpu",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-platform-datapath-resources",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-platform-disk",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-platform-fabric",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-platform-fan",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-platform-healthz",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-platform-lc",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-platform-linecard-fib",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-platform-memory",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-platform-mtu",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-platform-p4rt",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-platform-pipeline-counters",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-platform-psu",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-platform-qos",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-platform-redundancy",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-platform-resource-mgmt",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-platform-resource-monitoring",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-platform-secure-boot",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-platform-tcam",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-platform-tpm",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-platform-vxdp",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-policy-forwarding",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-policy-types",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-qos",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-qos-policers",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-ra_guard",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-rib-bgp",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-routing-policy",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-segment-routing",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-sflow",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-snmp",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-snmp-trace",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-ssh",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-stamp",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-static-routes",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-sync",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-sync-freq",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-sync-interfaces",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-sync-ptp",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-sync-types",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-system",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-system-banner",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-system-bridge-table",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-system-bridge-table-proxy-arp",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-system-info",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-system-multicast",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-system-multicast-mfib-table",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-system-name",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-system-network-instance",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-system-network-instance-bgp-evpn-ethernet-segments",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-system-network-instance-bgp-vpn",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-system-protocols",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-tcp-udp",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-te-policies",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-timezone",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-tls",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-traffic-engineering",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-transport-security",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-tunnel",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-tunnel-interfaces",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-tunnel-interfaces-vxlan-interface-bridge-table",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-tunnel-interfaces-vxlan-interface-bridge-table-multicast-destinations",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-tunnel-interfaces-vxlan-interface-bridge-table-unicast-destinations",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-tunnel-interfaces-vxlan-interface-bridge-table-unicast-es-destination-vteps",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-tunnel-tables",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-twamp",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-vxlan-tunnel-vtep",
		Organization: "Nokia",
	},
}

// Device represents the /Device YANG schema element.
type Device struct {
	XAnnotation_      *OpenconfigMetadata_XAnnotation_                     `path:"_annotation_" module:"openconfig-metadata"`
	Acl               *SrlNokiaAcl_Acl                                     `path:"acl" module:"srl_nokia-acl"`
	Bfd               *SrlNokiaBfd_Bfd                                     `path:"bfd" module:"srl_nokia-bfd" yangPresence:"true"`
	Interface         map[string]*SrlNokiaInterfaces_Interface             `path:"interface" module:"srl_nokia-interfaces"`
	NetworkInstance   map[string]*SrlNokiaNetworkInstance_NetworkInstance  `path:"network-instance" module:"srl_nokia-network-instance"`
	Oam               *SrlNokiaOam_Oam                                     `path:"oam" module:"srl_nokia-oam"`
	Platform          *SrlNokiaPlatform_Platform                           `path:"platform" module:"srl_nokia-platform"`
	Qos               *SrlNokiaQos_Qos                                     `path:"qos" module:"srl_nokia-qos"`
	RoutingPolicy     *SrlNokiaRoutingPolicy_RoutingPolicy                 `path:"routing-policy" module:"srl_nokia-routing-policy"`
	System            *SrlNokiaSystem_System                               `path:"system" module:"srl_nokia-system"`
	TransportSecurity *SrlNokiaTransportSecurity_TransportSecurity         `path:"transport-security" module:"srl_nokia-transport-security"`
	Tunnel            *SrlNokiaTunnel_Tunnel                               `path:"tunnel" module:"srl_nokia-tunnel"`
	TunnelInterface   map[string]*SrlNokiaTunnelInterfaces_TunnelInterface `path:"tunnel-interface" module:"srl_nokia-tunnel-interfaces"`
}

// IsYANGGoStruct ensures that Device implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Device) IsYANGGoStruct() {}

// NewInterface creates a new entry in the Interface list of the
// Device struct. The keys of the list are populated from the input
// arguments.
func (t *Device) NewInterface(Name string) (*SrlNokiaInterfaces_Interface, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*SrlNokiaInterfaces_Interface)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Interface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Interface", key)
	}

	t.Interface[key] = &SrlNokiaInterfaces_Interface{
		Name: &Name,
	}

	return t.Interface[key], nil
}

// RenameInterface renames an entry in the list Interface within
// the Device struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Device) RenameInterface(oldK, newK string) error {
	if _, ok := t.Interface[newK]; ok {
		return fmt.Errorf("key %v already exists in Interface", newK)
	}

	e, ok := t.Interface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Interface", oldK)
	}
	e.Name = &newK

	t.Interface[newK] = e
	delete(t.Interface, oldK)
	return nil
}

// GetOrCreateInterface retrieves the value with the specified keys from
// the receiver Device. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Device) GetOrCreateInterface(Name string) *SrlNokiaInterfaces_Interface {
	key := Name

	if v, ok := t.Interface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInterface(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInterface got unexpected error: %v", err))
	}
	return v
}

// GetInterface retrieves the value with the specified key from
// the Interface map field of Device. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Device) GetInterface(Name string) *SrlNokiaInterfaces_Interface {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Interface[key]; ok {
		return lm
	}
	return nil
}

// DeleteInterface deletes the value with the specified keys from
// the receiver Device. If there is no such element, the function
// is a no-op.
func (t *Device) DeleteInterface(Name string) {
	key := Name

	delete(t.Interface, key)
}

// AppendInterface appends the supplied SrlNokiaInterfaces_Interface struct to the
// list Interface of Device. If the key value(s) specified in
// the supplied SrlNokiaInterfaces_Interface already exist in the list, an error is
// returned.
func (t *Device) AppendInterface(v *SrlNokiaInterfaces_Interface) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*SrlNokiaInterfaces_Interface)
	}

	if _, ok := t.Interface[key]; ok {
		return fmt.Errorf("duplicate key for list Interface %v", key)
	}

	t.Interface[key] = v
	return nil
}

// NewNetworkInstance creates a new entry in the NetworkInstance list of the
// Device struct. The keys of the list are populated from the input
// arguments.
func (t *Device) NewNetworkInstance(Name string) (*SrlNokiaNetworkInstance_NetworkInstance, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NetworkInstance == nil {
		t.NetworkInstance = make(map[string]*SrlNokiaNetworkInstance_NetworkInstance)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.NetworkInstance[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list NetworkInstance", key)
	}

	t.NetworkInstance[key] = &SrlNokiaNetworkInstance_NetworkInstance{
		Name: &Name,
	}

	return t.NetworkInstance[key], nil
}

// RenameNetworkInstance renames an entry in the list NetworkInstance within
// the Device struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Device) RenameNetworkInstance(oldK, newK string) error {
	if _, ok := t.NetworkInstance[newK]; ok {
		return fmt.Errorf("key %v already exists in NetworkInstance", newK)
	}

	e, ok := t.NetworkInstance[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in NetworkInstance", oldK)
	}
	e.Name = &newK

	t.NetworkInstance[newK] = e
	delete(t.NetworkInstance, oldK)
	return nil
}

// GetOrCreateNetworkInstance retrieves the value with the specified keys from
// the receiver Device. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Device) GetOrCreateNetworkInstance(Name string) *SrlNokiaNetworkInstance_NetworkInstance {
	key := Name

	if v, ok := t.NetworkInstance[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNetworkInstance(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNetworkInstance got unexpected error: %v", err))
	}
	return v
}

// GetNetworkInstance retrieves the value with the specified key from
// the NetworkInstance map field of Device. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Device) GetNetworkInstance(Name string) *SrlNokiaNetworkInstance_NetworkInstance {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.NetworkInstance[key]; ok {
		return lm
	}
	return nil
}

// DeleteNetworkInstance deletes the value with the specified keys from
// the receiver Device. If there is no such element, the function
// is a no-op.
func (t *Device) DeleteNetworkInstance(Name string) {
	key := Name

	delete(t.NetworkInstance, key)
}

// AppendNetworkInstance appends the supplied SrlNokiaNetworkInstance_NetworkInstance struct to the
// list NetworkInstance of Device. If the key value(s) specified in
// the supplied SrlNokiaNetworkInstance_NetworkInstance already exist in the list, an error is
// returned.
func (t *Device) AppendNetworkInstance(v *SrlNokiaNetworkInstance_NetworkInstance) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NetworkInstance == nil {
		t.NetworkInstance = make(map[string]*SrlNokiaNetworkInstance_NetworkInstance)
	}

	if _, ok := t.NetworkInstance[key]; ok {
		return fmt.Errorf("duplicate key for list NetworkInstance %v", key)
	}

	t.NetworkInstance[key] = v
	return nil
}

// NewTunnelInterface creates a new entry in the TunnelInterface list of the
// Device struct. The keys of the list are populated from the input
// arguments.
func (t *Device) NewTunnelInterface(Name string) (*SrlNokiaTunnelInterfaces_TunnelInterface, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.TunnelInterface == nil {
		t.TunnelInterface = make(map[string]*SrlNokiaTunnelInterfaces_TunnelInterface)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.TunnelInterface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list TunnelInterface", key)
	}

	t.TunnelInterface[key] = &SrlNokiaTunnelInterfaces_TunnelInterface{
		Name: &Name,
	}

	return t.TunnelInterface[key], nil
}

// RenameTunnelInterface renames an entry in the list TunnelInterface within
// the Device struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Device) RenameTunnelInterface(oldK, newK string) error {
	if _, ok := t.TunnelInterface[newK]; ok {
		return fmt.Errorf("key %v already exists in TunnelInterface", newK)
	}

	e, ok := t.TunnelInterface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in TunnelInterface", oldK)
	}
	e.Name = &newK

	t.TunnelInterface[newK] = e
	delete(t.TunnelInterface, oldK)
	return nil
}

// GetOrCreateTunnelInterface retrieves the value with the specified keys from
// the receiver Device. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Device) GetOrCreateTunnelInterface(Name string) *SrlNokiaTunnelInterfaces_TunnelInterface {
	key := Name

	if v, ok := t.TunnelInterface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewTunnelInterface(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateTunnelInterface got unexpected error: %v", err))
	}
	return v
}

// GetTunnelInterface retrieves the value with the specified key from
// the TunnelInterface map field of Device. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Device) GetTunnelInterface(Name string) *SrlNokiaTunnelInterfaces_TunnelInterface {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.TunnelInterface[key]; ok {
		return lm
	}
	return nil
}

// DeleteTunnelInterface deletes the value with the specified keys from
// the receiver Device. If there is no such element, the function
// is a no-op.
func (t *Device) DeleteTunnelInterface(Name string) {
	key := Name

	delete(t.TunnelInterface, key)
}

// AppendTunnelInterface appends the supplied SrlNokiaTunnelInterfaces_TunnelInterface struct to the
// list TunnelInterface of Device. If the key value(s) specified in
// the supplied SrlNokiaTunnelInterfaces_TunnelInterface already exist in the list, an error is
// returned.
func (t *Device) AppendTunnelInterface(v *SrlNokiaTunnelInterfaces_TunnelInterface) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.TunnelInterface == nil {
		t.TunnelInterface = make(map[string]*SrlNokiaTunnelInterfaces_TunnelInterface)
	}

	if _, ok := t.TunnelInterface[key]; ok {
		return fmt.Errorf("duplicate key for list TunnelInterface %v", key)
	}

	t.TunnelInterface[key] = v
	return nil
}

// GetOrCreateXAnnotation_ retrieves the value of the XAnnotation_ field
// or returns the existing field if it already exists.
func (t *Device) GetOrCreateXAnnotation_() *OpenconfigMetadata_XAnnotation_ {
	if t.XAnnotation_ != nil {
		return t.XAnnotation_
	}
	t.XAnnotation_ = &OpenconfigMetadata_XAnnotation_{}
	return t.XAnnotation_
}

// GetOrCreateAcl retrieves the value of the Acl field
// or returns the existing field if it already exists.
func (t *Device) GetOrCreateAcl() *SrlNokiaAcl_Acl {
	if t.Acl != nil {
		return t.Acl
	}
	t.Acl = &SrlNokiaAcl_Acl{}
	return t.Acl
}

// GetOrCreateBfd retrieves the value of the Bfd field
// or returns the existing field if it already exists.
func (t *Device) GetOrCreateBfd() *SrlNokiaBfd_Bfd {
	if t.Bfd != nil {
		return t.Bfd
	}
	t.Bfd = &SrlNokiaBfd_Bfd{}
	return t.Bfd
}

// GetOrCreateOam retrieves the value of the Oam field
// or returns the existing field if it already exists.
func (t *Device) GetOrCreateOam() *SrlNokiaOam_Oam {
	if t.Oam != nil {
		return t.Oam
	}
	t.Oam = &SrlNokiaOam_Oam{}
	return t.Oam
}

// GetOrCreatePlatform retrieves the value of the Platform field
// or returns the existing field if it already exists.
func (t *Device) GetOrCreatePlatform() *SrlNokiaPlatform_Platform {
	if t.Platform != nil {
		return t.Platform
	}
	t.Platform = &SrlNokiaPlatform_Platform{}
	return t.Platform
}

// GetOrCreateQos retrieves the value of the Qos field
// or returns the existing field if it already exists.
func (t *Device) GetOrCreateQos() *SrlNokiaQos_Qos {
	if t.Qos != nil {
		return t.Qos
	}
	t.Qos = &SrlNokiaQos_Qos{}
	return t.Qos
}

// GetOrCreateRoutingPolicy retrieves the value of the RoutingPolicy field
// or returns the existing field if it already exists.
func (t *Device) GetOrCreateRoutingPolicy() *SrlNokiaRoutingPolicy_RoutingPolicy {
	if t.RoutingPolicy != nil {
		return t.RoutingPolicy
	}
	t.RoutingPolicy = &SrlNokiaRoutingPolicy_RoutingPolicy{}
	return t.RoutingPolicy
}

// GetOrCreateSystem retrieves the value of the System field
// or returns the existing field if it already exists.
func (t *Device) GetOrCreateSystem() *SrlNokiaSystem_System {
	if t.System != nil {
		return t.System
	}
	t.System = &SrlNokiaSystem_System{}
	return t.System
}

// GetOrCreateTransportSecurity retrieves the value of the TransportSecurity field
// or returns the existing field if it already exists.
func (t *Device) GetOrCreateTransportSecurity() *SrlNokiaTransportSecurity_TransportSecurity {
	if t.TransportSecurity != nil {
		return t.TransportSecurity
	}
	t.TransportSecurity = &SrlNokiaTransportSecurity_TransportSecurity{}
	return t.TransportSecurity
}

// GetOrCreateTunnel retrieves the value of the Tunnel field
// or returns the existing field if it already exists.
func (t *Device) GetOrCreateTunnel() *SrlNokiaTunnel_Tunnel {
	if t.Tunnel != nil {
		return t.Tunnel
	}
	t.Tunnel = &SrlNokiaTunnel_Tunnel{}
	return t.Tunnel
}

// GetXAnnotation_ returns the value of the XAnnotation_ struct pointer
// from Device. If the receiver or the field XAnnotation_ is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Device) GetXAnnotation_() *OpenconfigMetadata_XAnnotation_ {
	if t != nil && t.XAnnotation_ != nil {
		return t.XAnnotation_
	}
	return nil
}

// GetAcl returns the value of the Acl struct pointer
// from Device. If the receiver or the field Acl is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Device) GetAcl() *SrlNokiaAcl_Acl {
	if t != nil && t.Acl != nil {
		return t.Acl
	}
	return nil
}

// GetBfd returns the value of the Bfd struct pointer
// from Device. If the receiver or the field Bfd is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Device) GetBfd() *SrlNokiaBfd_Bfd {
	if t != nil && t.Bfd != nil {
		return t.Bfd
	}
	return nil
}

// GetOam returns the value of the Oam struct pointer
// from Device. If the receiver or the field Oam is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Device) GetOam() *SrlNokiaOam_Oam {
	if t != nil && t.Oam != nil {
		return t.Oam
	}
	return nil
}

// GetPlatform returns the value of the Platform struct pointer
// from Device. If the receiver or the field Platform is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Device) GetPlatform() *SrlNokiaPlatform_Platform {
	if t != nil && t.Platform != nil {
		return t.Platform
	}
	return nil
}

// GetQos returns the value of the Qos struct pointer
// from Device. If the receiver or the field Qos is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Device) GetQos() *SrlNokiaQos_Qos {
	if t != nil && t.Qos != nil {
		return t.Qos
	}
	return nil
}

// GetRoutingPolicy returns the value of the RoutingPolicy struct pointer
// from Device. If the receiver or the field RoutingPolicy is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Device) GetRoutingPolicy() *SrlNokiaRoutingPolicy_RoutingPolicy {
	if t != nil && t.RoutingPolicy != nil {
		return t.RoutingPolicy
	}
	return nil
}

// GetSystem returns the value of the System struct pointer
// from Device. If the receiver or the field System is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Device) GetSystem() *SrlNokiaSystem_System {
	if t != nil && t.System != nil {
		return t.System
	}
	return nil
}

// GetTransportSecurity returns the value of the TransportSecurity struct pointer
// from Device. If the receiver or the field TransportSecurity is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Device) GetTransportSecurity() *SrlNokiaTransportSecurity_TransportSecurity {
	if t != nil && t.TransportSecurity != nil {
		return t.TransportSecurity
	}
	return nil
}

// GetTunnel returns the value of the Tunnel struct pointer
// from Device. If the receiver or the field Tunnel is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Device) GetTunnel() *SrlNokiaTunnel_Tunnel {
	if t != nil && t.Tunnel != nil {
		return t.Tunnel
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the Device
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Device) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.XAnnotation_.PopulateDefaults()
	t.Acl.PopulateDefaults()
	t.Bfd.PopulateDefaults()
	t.Oam.PopulateDefaults()
	t.Platform.PopulateDefaults()
	t.Qos.PopulateDefaults()
	t.RoutingPolicy.PopulateDefaults()
	t.System.PopulateDefaults()
	t.TransportSecurity.PopulateDefaults()
	t.Tunnel.PopulateDefaults()
	for _, e := range t.Interface {
		e.PopulateDefaults()
	}
	for _, e := range t.NetworkInstance {
		e.PopulateDefaults()
	}
	for _, e := range t.TunnelInterface {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Device) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Device"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Device) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Device) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Device.
func (*Device) ΛBelongingModule() string {
	return ""
}

// OpenconfigMetadata_XAnnotation_ represents the /openconfig-metadata/_annotation_ YANG schema element.
type OpenconfigMetadata_XAnnotation_ struct {
	ProtobufMetadata Binary `path:"protobuf-metadata" module:"openconfig-metadata"`
}

// IsYANGGoStruct ensures that OpenconfigMetadata_XAnnotation_ implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*OpenconfigMetadata_XAnnotation_) IsYANGGoStruct() {}

// GetProtobufMetadata retrieves the value of the leaf ProtobufMetadata from the OpenconfigMetadata_XAnnotation_
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ProtobufMetadata is set, it can
// safely use t.GetProtobufMetadata() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ProtobufMetadata == nil' before retrieving the leaf's value.
func (t *OpenconfigMetadata_XAnnotation_) GetProtobufMetadata() Binary {
	if t == nil || t.ProtobufMetadata == nil {
		return nil
	}
	return t.ProtobufMetadata
}

// PopulateDefaults recursively populates unset leaf fields in the OpenconfigMetadata_XAnnotation_
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *OpenconfigMetadata_XAnnotation_) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *OpenconfigMetadata_XAnnotation_) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["OpenconfigMetadata_XAnnotation_"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *OpenconfigMetadata_XAnnotation_) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *OpenconfigMetadata_XAnnotation_) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of OpenconfigMetadata_XAnnotation_.
func (*OpenconfigMetadata_XAnnotation_) ΛBelongingModule() string {
	return "openconfig-metadata"
}

// SrlNokiaAcl_Acl represents the /srl_nokia-acl/acl YANG schema element.
type SrlNokiaAcl_Acl struct {
	CaptureFilter      *SrlNokiaAcl_Acl_CaptureFilter         `path:"capture-filter" module:"srl_nokia-acl"`
	CpmFilter          *SrlNokiaAcl_Acl_CpmFilter             `path:"cpm-filter" module:"srl_nokia-acl"`
	EgressMacFiltering *bool                                  `path:"egress-mac-filtering" module:"srl_nokia-acl"`
	Ipv4Filter         map[string]*SrlNokiaAcl_Acl_Ipv4Filter `path:"ipv4-filter" module:"srl_nokia-acl"`
	Ipv6Filter         map[string]*SrlNokiaAcl_Acl_Ipv6Filter `path:"ipv6-filter" module:"srl_nokia-acl"`
	MacFilter          map[string]*SrlNokiaAcl_Acl_MacFilter  `path:"mac-filter" module:"srl_nokia-acl"`
	Policers           *SrlNokiaAcl_Acl_Policers              `path:"policers" module:"srl_nokia-acl"`
	SystemFilter       *SrlNokiaAcl_Acl_SystemFilter          `path:"system-filter" module:"srl_nokia-acl"`
	TcamProfile        E_SrlNokiaAcl_Acl_TcamProfile          `path:"tcam-profile" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl) IsYANGGoStruct() {}

// NewIpv4Filter creates a new entry in the Ipv4Filter list of the
// SrlNokiaAcl_Acl struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaAcl_Acl) NewIpv4Filter(Name string) (*SrlNokiaAcl_Acl_Ipv4Filter, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Ipv4Filter == nil {
		t.Ipv4Filter = make(map[string]*SrlNokiaAcl_Acl_Ipv4Filter)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Ipv4Filter[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Ipv4Filter", key)
	}

	t.Ipv4Filter[key] = &SrlNokiaAcl_Acl_Ipv4Filter{
		Name: &Name,
	}

	return t.Ipv4Filter[key], nil
}

// RenameIpv4Filter renames an entry in the list Ipv4Filter within
// the SrlNokiaAcl_Acl struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaAcl_Acl) RenameIpv4Filter(oldK, newK string) error {
	if _, ok := t.Ipv4Filter[newK]; ok {
		return fmt.Errorf("key %v already exists in Ipv4Filter", newK)
	}

	e, ok := t.Ipv4Filter[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Ipv4Filter", oldK)
	}
	e.Name = &newK

	t.Ipv4Filter[newK] = e
	delete(t.Ipv4Filter, oldK)
	return nil
}

// GetOrCreateIpv4Filter retrieves the value with the specified keys from
// the receiver SrlNokiaAcl_Acl. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaAcl_Acl) GetOrCreateIpv4Filter(Name string) *SrlNokiaAcl_Acl_Ipv4Filter {
	key := Name

	if v, ok := t.Ipv4Filter[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewIpv4Filter(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateIpv4Filter got unexpected error: %v", err))
	}
	return v
}

// GetIpv4Filter retrieves the value with the specified key from
// the Ipv4Filter map field of SrlNokiaAcl_Acl. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaAcl_Acl) GetIpv4Filter(Name string) *SrlNokiaAcl_Acl_Ipv4Filter {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Ipv4Filter[key]; ok {
		return lm
	}
	return nil
}

// DeleteIpv4Filter deletes the value with the specified keys from
// the receiver SrlNokiaAcl_Acl. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaAcl_Acl) DeleteIpv4Filter(Name string) {
	key := Name

	delete(t.Ipv4Filter, key)
}

// AppendIpv4Filter appends the supplied SrlNokiaAcl_Acl_Ipv4Filter struct to the
// list Ipv4Filter of SrlNokiaAcl_Acl. If the key value(s) specified in
// the supplied SrlNokiaAcl_Acl_Ipv4Filter already exist in the list, an error is
// returned.
func (t *SrlNokiaAcl_Acl) AppendIpv4Filter(v *SrlNokiaAcl_Acl_Ipv4Filter) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Ipv4Filter == nil {
		t.Ipv4Filter = make(map[string]*SrlNokiaAcl_Acl_Ipv4Filter)
	}

	if _, ok := t.Ipv4Filter[key]; ok {
		return fmt.Errorf("duplicate key for list Ipv4Filter %v", key)
	}

	t.Ipv4Filter[key] = v
	return nil
}

// NewIpv6Filter creates a new entry in the Ipv6Filter list of the
// SrlNokiaAcl_Acl struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaAcl_Acl) NewIpv6Filter(Name string) (*SrlNokiaAcl_Acl_Ipv6Filter, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Ipv6Filter == nil {
		t.Ipv6Filter = make(map[string]*SrlNokiaAcl_Acl_Ipv6Filter)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Ipv6Filter[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Ipv6Filter", key)
	}

	t.Ipv6Filter[key] = &SrlNokiaAcl_Acl_Ipv6Filter{
		Name: &Name,
	}

	return t.Ipv6Filter[key], nil
}

// RenameIpv6Filter renames an entry in the list Ipv6Filter within
// the SrlNokiaAcl_Acl struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaAcl_Acl) RenameIpv6Filter(oldK, newK string) error {
	if _, ok := t.Ipv6Filter[newK]; ok {
		return fmt.Errorf("key %v already exists in Ipv6Filter", newK)
	}

	e, ok := t.Ipv6Filter[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Ipv6Filter", oldK)
	}
	e.Name = &newK

	t.Ipv6Filter[newK] = e
	delete(t.Ipv6Filter, oldK)
	return nil
}

// GetOrCreateIpv6Filter retrieves the value with the specified keys from
// the receiver SrlNokiaAcl_Acl. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaAcl_Acl) GetOrCreateIpv6Filter(Name string) *SrlNokiaAcl_Acl_Ipv6Filter {
	key := Name

	if v, ok := t.Ipv6Filter[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewIpv6Filter(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateIpv6Filter got unexpected error: %v", err))
	}
	return v
}

// GetIpv6Filter retrieves the value with the specified key from
// the Ipv6Filter map field of SrlNokiaAcl_Acl. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaAcl_Acl) GetIpv6Filter(Name string) *SrlNokiaAcl_Acl_Ipv6Filter {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Ipv6Filter[key]; ok {
		return lm
	}
	return nil
}

// DeleteIpv6Filter deletes the value with the specified keys from
// the receiver SrlNokiaAcl_Acl. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaAcl_Acl) DeleteIpv6Filter(Name string) {
	key := Name

	delete(t.Ipv6Filter, key)
}

// AppendIpv6Filter appends the supplied SrlNokiaAcl_Acl_Ipv6Filter struct to the
// list Ipv6Filter of SrlNokiaAcl_Acl. If the key value(s) specified in
// the supplied SrlNokiaAcl_Acl_Ipv6Filter already exist in the list, an error is
// returned.
func (t *SrlNokiaAcl_Acl) AppendIpv6Filter(v *SrlNokiaAcl_Acl_Ipv6Filter) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Ipv6Filter == nil {
		t.Ipv6Filter = make(map[string]*SrlNokiaAcl_Acl_Ipv6Filter)
	}

	if _, ok := t.Ipv6Filter[key]; ok {
		return fmt.Errorf("duplicate key for list Ipv6Filter %v", key)
	}

	t.Ipv6Filter[key] = v
	return nil
}

// NewMacFilter creates a new entry in the MacFilter list of the
// SrlNokiaAcl_Acl struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaAcl_Acl) NewMacFilter(Name string) (*SrlNokiaAcl_Acl_MacFilter, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.MacFilter == nil {
		t.MacFilter = make(map[string]*SrlNokiaAcl_Acl_MacFilter)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.MacFilter[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list MacFilter", key)
	}

	t.MacFilter[key] = &SrlNokiaAcl_Acl_MacFilter{
		Name: &Name,
	}

	return t.MacFilter[key], nil
}

// RenameMacFilter renames an entry in the list MacFilter within
// the SrlNokiaAcl_Acl struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaAcl_Acl) RenameMacFilter(oldK, newK string) error {
	if _, ok := t.MacFilter[newK]; ok {
		return fmt.Errorf("key %v already exists in MacFilter", newK)
	}

	e, ok := t.MacFilter[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in MacFilter", oldK)
	}
	e.Name = &newK

	t.MacFilter[newK] = e
	delete(t.MacFilter, oldK)
	return nil
}

// GetOrCreateMacFilter retrieves the value with the specified keys from
// the receiver SrlNokiaAcl_Acl. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaAcl_Acl) GetOrCreateMacFilter(Name string) *SrlNokiaAcl_Acl_MacFilter {
	key := Name

	if v, ok := t.MacFilter[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewMacFilter(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateMacFilter got unexpected error: %v", err))
	}
	return v
}

// GetMacFilter retrieves the value with the specified key from
// the MacFilter map field of SrlNokiaAcl_Acl. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaAcl_Acl) GetMacFilter(Name string) *SrlNokiaAcl_Acl_MacFilter {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.MacFilter[key]; ok {
		return lm
	}
	return nil
}

// DeleteMacFilter deletes the value with the specified keys from
// the receiver SrlNokiaAcl_Acl. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaAcl_Acl) DeleteMacFilter(Name string) {
	key := Name

	delete(t.MacFilter, key)
}

// AppendMacFilter appends the supplied SrlNokiaAcl_Acl_MacFilter struct to the
// list MacFilter of SrlNokiaAcl_Acl. If the key value(s) specified in
// the supplied SrlNokiaAcl_Acl_MacFilter already exist in the list, an error is
// returned.
func (t *SrlNokiaAcl_Acl) AppendMacFilter(v *SrlNokiaAcl_Acl_MacFilter) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.MacFilter == nil {
		t.MacFilter = make(map[string]*SrlNokiaAcl_Acl_MacFilter)
	}

	if _, ok := t.MacFilter[key]; ok {
		return fmt.Errorf("duplicate key for list MacFilter %v", key)
	}

	t.MacFilter[key] = v
	return nil
}

// GetOrCreateCaptureFilter retrieves the value of the CaptureFilter field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl) GetOrCreateCaptureFilter() *SrlNokiaAcl_Acl_CaptureFilter {
	if t.CaptureFilter != nil {
		return t.CaptureFilter
	}
	t.CaptureFilter = &SrlNokiaAcl_Acl_CaptureFilter{}
	return t.CaptureFilter
}

// GetOrCreateCpmFilter retrieves the value of the CpmFilter field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl) GetOrCreateCpmFilter() *SrlNokiaAcl_Acl_CpmFilter {
	if t.CpmFilter != nil {
		return t.CpmFilter
	}
	t.CpmFilter = &SrlNokiaAcl_Acl_CpmFilter{}
	return t.CpmFilter
}

// GetOrCreatePolicers retrieves the value of the Policers field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl) GetOrCreatePolicers() *SrlNokiaAcl_Acl_Policers {
	if t.Policers != nil {
		return t.Policers
	}
	t.Policers = &SrlNokiaAcl_Acl_Policers{}
	return t.Policers
}

// GetOrCreateSystemFilter retrieves the value of the SystemFilter field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl) GetOrCreateSystemFilter() *SrlNokiaAcl_Acl_SystemFilter {
	if t.SystemFilter != nil {
		return t.SystemFilter
	}
	t.SystemFilter = &SrlNokiaAcl_Acl_SystemFilter{}
	return t.SystemFilter
}

// GetCaptureFilter returns the value of the CaptureFilter struct pointer
// from SrlNokiaAcl_Acl. If the receiver or the field CaptureFilter is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl) GetCaptureFilter() *SrlNokiaAcl_Acl_CaptureFilter {
	if t != nil && t.CaptureFilter != nil {
		return t.CaptureFilter
	}
	return nil
}

// GetCpmFilter returns the value of the CpmFilter struct pointer
// from SrlNokiaAcl_Acl. If the receiver or the field CpmFilter is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl) GetCpmFilter() *SrlNokiaAcl_Acl_CpmFilter {
	if t != nil && t.CpmFilter != nil {
		return t.CpmFilter
	}
	return nil
}

// GetPolicers returns the value of the Policers struct pointer
// from SrlNokiaAcl_Acl. If the receiver or the field Policers is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl) GetPolicers() *SrlNokiaAcl_Acl_Policers {
	if t != nil && t.Policers != nil {
		return t.Policers
	}
	return nil
}

// GetSystemFilter returns the value of the SystemFilter struct pointer
// from SrlNokiaAcl_Acl. If the receiver or the field SystemFilter is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl) GetSystemFilter() *SrlNokiaAcl_Acl_SystemFilter {
	if t != nil && t.SystemFilter != nil {
		return t.SystemFilter
	}
	return nil
}

// GetEgressMacFiltering retrieves the value of the leaf EgressMacFiltering from the SrlNokiaAcl_Acl
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EgressMacFiltering is set, it can
// safely use t.GetEgressMacFiltering() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EgressMacFiltering == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl) GetEgressMacFiltering() bool {
	if t == nil || t.EgressMacFiltering == nil {
		return false
	}
	return *t.EgressMacFiltering
}

// GetTcamProfile retrieves the value of the leaf TcamProfile from the SrlNokiaAcl_Acl
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TcamProfile is set, it can
// safely use t.GetTcamProfile() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TcamProfile == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl) GetTcamProfile() E_SrlNokiaAcl_Acl_TcamProfile {
	if t == nil || t.TcamProfile == 0 {
		return 0
	}
	return t.TcamProfile
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.EgressMacFiltering == nil {
		var v bool = false
		t.EgressMacFiltering = &v
	}
	t.CaptureFilter.PopulateDefaults()
	t.CpmFilter.PopulateDefaults()
	t.Policers.PopulateDefaults()
	t.SystemFilter.PopulateDefaults()
	for _, e := range t.Ipv4Filter {
		e.PopulateDefaults()
	}
	for _, e := range t.Ipv6Filter {
		e.PopulateDefaults()
	}
	for _, e := range t.MacFilter {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl.
func (*SrlNokiaAcl_Acl) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CaptureFilter represents the /srl_nokia-acl/acl/capture-filter YANG schema element.
type SrlNokiaAcl_Acl_CaptureFilter struct {
	Ipv4Filter *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter `path:"ipv4-filter" module:"srl_nokia-acl"`
	Ipv6Filter *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter `path:"ipv6-filter" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CaptureFilter implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CaptureFilter) IsYANGGoStruct() {}

// GetOrCreateIpv4Filter retrieves the value of the Ipv4Filter field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CaptureFilter) GetOrCreateIpv4Filter() *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter {
	if t.Ipv4Filter != nil {
		return t.Ipv4Filter
	}
	t.Ipv4Filter = &SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter{}
	return t.Ipv4Filter
}

// GetOrCreateIpv6Filter retrieves the value of the Ipv6Filter field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CaptureFilter) GetOrCreateIpv6Filter() *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter {
	if t.Ipv6Filter != nil {
		return t.Ipv6Filter
	}
	t.Ipv6Filter = &SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter{}
	return t.Ipv6Filter
}

// GetIpv4Filter returns the value of the Ipv4Filter struct pointer
// from SrlNokiaAcl_Acl_CaptureFilter. If the receiver or the field Ipv4Filter is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CaptureFilter) GetIpv4Filter() *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter {
	if t != nil && t.Ipv4Filter != nil {
		return t.Ipv4Filter
	}
	return nil
}

// GetIpv6Filter returns the value of the Ipv6Filter struct pointer
// from SrlNokiaAcl_Acl_CaptureFilter. If the receiver or the field Ipv6Filter is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CaptureFilter) GetIpv6Filter() *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter {
	if t != nil && t.Ipv6Filter != nil {
		return t.Ipv6Filter
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CaptureFilter
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CaptureFilter) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Ipv4Filter.PopulateDefaults()
	t.Ipv6Filter.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CaptureFilter"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CaptureFilter) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CaptureFilter.
func (*SrlNokiaAcl_Acl_CaptureFilter) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter represents the /srl_nokia-acl/acl/capture-filter/ipv4-filter YANG schema element.
type SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter struct {
	Entry map[uint32]*SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry `path:"entry" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter) IsYANGGoStruct() {}

// NewEntry creates a new entry in the Entry list of the
// SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter) NewEntry(SequenceId uint32) (*SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[uint32]*SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry)
	}

	key := SequenceId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Entry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Entry", key)
	}

	t.Entry[key] = &SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry{
		SequenceId: &SequenceId,
	}

	return t.Entry[key], nil
}

// RenameEntry renames an entry in the list Entry within
// the SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter) RenameEntry(oldK, newK uint32) error {
	if _, ok := t.Entry[newK]; ok {
		return fmt.Errorf("key %v already exists in Entry", newK)
	}

	e, ok := t.Entry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Entry", oldK)
	}
	e.SequenceId = &newK

	t.Entry[newK] = e
	delete(t.Entry, oldK)
	return nil
}

// GetOrCreateEntry retrieves the value with the specified keys from
// the receiver SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter) GetOrCreateEntry(SequenceId uint32) *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry {
	key := SequenceId

	if v, ok := t.Entry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEntry(SequenceId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEntry got unexpected error: %v", err))
	}
	return v
}

// GetEntry retrieves the value with the specified key from
// the Entry map field of SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter) GetEntry(SequenceId uint32) *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry {
	if t == nil {
		return nil
	}

	key := SequenceId

	if lm, ok := t.Entry[key]; ok {
		return lm
	}
	return nil
}

// DeleteEntry deletes the value with the specified keys from
// the receiver SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter) DeleteEntry(SequenceId uint32) {
	key := SequenceId

	delete(t.Entry, key)
}

// AppendEntry appends the supplied SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry struct to the
// list Entry of SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter. If the key value(s) specified in
// the supplied SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry already exist in the list, an error is
// returned.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter) AppendEntry(v *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry) error {
	if v.SequenceId == nil {
		return fmt.Errorf("invalid nil key received for SequenceId")
	}

	key := *v.SequenceId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[uint32]*SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry)
	}

	if _, ok := t.Entry[key]; ok {
		return fmt.Errorf("duplicate key for list Entry %v", key)
	}

	t.Entry[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Entry {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter.
func (*SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry represents the /srl_nokia-acl/acl/capture-filter/ipv4-filter/entry YANG schema element.
type SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry struct {
	Action      *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action `path:"action" module:"srl_nokia-acl"`
	Description *string                                                `path:"description" module:"srl_nokia-acl"`
	Match       *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match  `path:"match" module:"srl_nokia-acl"`
	SequenceId  *uint32                                                `path:"sequence-id" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry) IsYANGGoStruct() {}

// GetOrCreateAction retrieves the value of the Action field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry) GetOrCreateAction() *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action {
	if t.Action != nil {
		return t.Action
	}
	t.Action = &SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action{}
	return t.Action
}

// GetOrCreateMatch retrieves the value of the Match field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry) GetOrCreateMatch() *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match {
	if t.Match != nil {
		return t.Match
	}
	t.Match = &SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match{}
	return t.Match
}

// GetAction returns the value of the Action struct pointer
// from SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry. If the receiver or the field Action is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry) GetAction() *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action {
	if t != nil && t.Action != nil {
		return t.Action
	}
	return nil
}

// GetMatch returns the value of the Match struct pointer
// from SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry. If the receiver or the field Match is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry) GetMatch() *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match {
	if t != nil && t.Match != nil {
		return t.Match
	}
	return nil
}

// GetDescription retrieves the value of the leaf Description from the SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetSequenceId retrieves the value of the leaf SequenceId from the SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SequenceId is set, it can
// safely use t.GetSequenceId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SequenceId == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry) GetSequenceId() uint32 {
	if t == nil || t.SequenceId == nil {
		return 0
	}
	return *t.SequenceId
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Action.PopulateDefaults()
	t.Match.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry struct, which is a YANG list entry.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry) ΛListKeyMap() (map[string]interface{}, error) {
	if t.SequenceId == nil {
		return nil, fmt.Errorf("nil value for key SequenceId")
	}

	return map[string]interface{}{
		"sequence-id": *t.SequenceId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry.
func (*SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action represents the /srl_nokia-acl/acl/capture-filter/ipv4-filter/entry/action YANG schema element.
type SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action struct {
	Accept *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action_Accept `path:"accept" module:"srl_nokia-acl" yangPresence:"true"`
	Copy   *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action_Copy   `path:"copy" module:"srl_nokia-acl" yangPresence:"true"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action) IsYANGGoStruct() {}

// GetOrCreateAccept retrieves the value of the Accept field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action) GetOrCreateAccept() *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action_Accept {
	if t.Accept != nil {
		return t.Accept
	}
	t.Accept = &SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action_Accept{}
	return t.Accept
}

// GetOrCreateCopy retrieves the value of the Copy field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action) GetOrCreateCopy() *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action_Copy {
	if t.Copy != nil {
		return t.Copy
	}
	t.Copy = &SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action_Copy{}
	return t.Copy
}

// GetAccept returns the value of the Accept struct pointer
// from SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action. If the receiver or the field Accept is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action) GetAccept() *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action_Accept {
	if t != nil && t.Accept != nil {
		return t.Accept
	}
	return nil
}

// GetCopy returns the value of the Copy struct pointer
// from SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action. If the receiver or the field Copy is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action) GetCopy() *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action_Copy {
	if t != nil && t.Copy != nil {
		return t.Copy
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Accept.PopulateDefaults()
	t.Copy.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action.
func (*SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action_Accept represents the /srl_nokia-acl/acl/capture-filter/ipv4-filter/entry/action/accept YANG schema element.
type SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action_Accept struct{}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action_Accept implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action_Accept) IsYANGGoStruct() {}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action_Accept
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action_Accept) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action_Accept) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action_Accept"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action_Accept) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action_Accept) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action_Accept.
func (*SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action_Accept) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action_Copy represents the /srl_nokia-acl/acl/capture-filter/ipv4-filter/entry/action/copy YANG schema element.
type SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action_Copy struct{}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action_Copy implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action_Copy) IsYANGGoStruct() {}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action_Copy
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action_Copy) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action_Copy) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action_Copy"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action_Copy) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action_Copy) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action_Copy.
func (*SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action_Copy) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match represents the /srl_nokia-acl/acl/capture-filter/ipv4-filter/entry/match YANG schema element.
type SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match struct {
	DestinationIp   *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationIp   `path:"destination-ip" module:"srl_nokia-acl"`
	DestinationPort *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationPort `path:"destination-port" module:"srl_nokia-acl"`
	DscpSet         []SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DscpSet_Union  `path:"dscp-set" module:"srl_nokia-acl"`
	FirstFragment   *bool                                                                 `path:"first-fragment" module:"srl_nokia-acl"`
	Fragment        *bool                                                                 `path:"fragment" module:"srl_nokia-acl"`
	Icmp            *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_Icmp            `path:"icmp" module:"srl_nokia-acl"`
	Protocol        SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_Protocol_Union   `path:"protocol" module:"srl_nokia-acl"`
	SourceIp        *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourceIp        `path:"source-ip" module:"srl_nokia-acl"`
	SourcePort      *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourcePort      `path:"source-port" module:"srl_nokia-acl"`
	TcpFlags        *string                                                               `path:"tcp-flags" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match) IsYANGGoStruct() {}

// GetOrCreateDestinationIp retrieves the value of the DestinationIp field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match) GetOrCreateDestinationIp() *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationIp {
	if t.DestinationIp != nil {
		return t.DestinationIp
	}
	t.DestinationIp = &SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationIp{}
	return t.DestinationIp
}

// GetOrCreateDestinationPort retrieves the value of the DestinationPort field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match) GetOrCreateDestinationPort() *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationPort {
	if t.DestinationPort != nil {
		return t.DestinationPort
	}
	t.DestinationPort = &SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationPort{}
	return t.DestinationPort
}

// GetOrCreateIcmp retrieves the value of the Icmp field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match) GetOrCreateIcmp() *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_Icmp {
	if t.Icmp != nil {
		return t.Icmp
	}
	t.Icmp = &SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_Icmp{}
	return t.Icmp
}

// GetOrCreateSourceIp retrieves the value of the SourceIp field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match) GetOrCreateSourceIp() *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourceIp {
	if t.SourceIp != nil {
		return t.SourceIp
	}
	t.SourceIp = &SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourceIp{}
	return t.SourceIp
}

// GetOrCreateSourcePort retrieves the value of the SourcePort field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match) GetOrCreateSourcePort() *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourcePort {
	if t.SourcePort != nil {
		return t.SourcePort
	}
	t.SourcePort = &SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourcePort{}
	return t.SourcePort
}

// GetDestinationIp returns the value of the DestinationIp struct pointer
// from SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match. If the receiver or the field DestinationIp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match) GetDestinationIp() *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationIp {
	if t != nil && t.DestinationIp != nil {
		return t.DestinationIp
	}
	return nil
}

// GetDestinationPort returns the value of the DestinationPort struct pointer
// from SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match. If the receiver or the field DestinationPort is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match) GetDestinationPort() *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationPort {
	if t != nil && t.DestinationPort != nil {
		return t.DestinationPort
	}
	return nil
}

// GetIcmp returns the value of the Icmp struct pointer
// from SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match. If the receiver or the field Icmp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match) GetIcmp() *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_Icmp {
	if t != nil && t.Icmp != nil {
		return t.Icmp
	}
	return nil
}

// GetSourceIp returns the value of the SourceIp struct pointer
// from SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match. If the receiver or the field SourceIp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match) GetSourceIp() *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourceIp {
	if t != nil && t.SourceIp != nil {
		return t.SourceIp
	}
	return nil
}

// GetSourcePort returns the value of the SourcePort struct pointer
// from SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match. If the receiver or the field SourcePort is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match) GetSourcePort() *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourcePort {
	if t != nil && t.SourcePort != nil {
		return t.SourcePort
	}
	return nil
}

// GetDscpSet retrieves the value of the leaf DscpSet from the SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DscpSet is set, it can
// safely use t.GetDscpSet() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DscpSet == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match) GetDscpSet() []SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DscpSet_Union {
	if t == nil || t.DscpSet == nil {
		return nil
	}
	return t.DscpSet
}

// GetFirstFragment retrieves the value of the leaf FirstFragment from the SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FirstFragment is set, it can
// safely use t.GetFirstFragment() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FirstFragment == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match) GetFirstFragment() bool {
	if t == nil || t.FirstFragment == nil {
		return false
	}
	return *t.FirstFragment
}

// GetFragment retrieves the value of the leaf Fragment from the SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Fragment is set, it can
// safely use t.GetFragment() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Fragment == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match) GetFragment() bool {
	if t == nil || t.Fragment == nil {
		return false
	}
	return *t.Fragment
}

// GetProtocol retrieves the value of the leaf Protocol from the SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Protocol is set, it can
// safely use t.GetProtocol() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Protocol == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match) GetProtocol() SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_Protocol_Union {
	if t == nil || t.Protocol == nil {
		return nil
	}
	return t.Protocol
}

// GetTcpFlags retrieves the value of the leaf TcpFlags from the SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TcpFlags is set, it can
// safely use t.GetTcpFlags() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TcpFlags == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match) GetTcpFlags() string {
	if t == nil || t.TcpFlags == nil {
		return ""
	}
	return *t.TcpFlags
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.DestinationIp.PopulateDefaults()
	t.DestinationPort.PopulateDefaults()
	t.Icmp.PopulateDefaults()
	t.SourceIp.PopulateDefaults()
	t.SourcePort.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match.
func (*SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationIp represents the /srl_nokia-acl/acl/capture-filter/ipv4-filter/entry/match/destination-ip YANG schema element.
type SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationIp struct {
	Address *string `path:"address" module:"srl_nokia-acl"`
	Mask    *string `path:"mask" module:"srl_nokia-acl"`
	Prefix  *string `path:"prefix" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationIp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationIp) IsYANGGoStruct() {}

// GetAddress retrieves the value of the leaf Address from the SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Address is set, it can
// safely use t.GetAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Address == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationIp) GetAddress() string {
	if t == nil || t.Address == nil {
		return ""
	}
	return *t.Address
}

// GetMask retrieves the value of the leaf Mask from the SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Mask is set, it can
// safely use t.GetMask() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Mask == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationIp) GetMask() string {
	if t == nil || t.Mask == nil {
		return ""
	}
	return *t.Mask
}

// GetPrefix retrieves the value of the leaf Prefix from the SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Prefix is set, it can
// safely use t.GetPrefix() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Prefix == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationIp) GetPrefix() string {
	if t == nil || t.Prefix == nil {
		return ""
	}
	return *t.Prefix
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationIp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationIp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationIp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationIp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationIp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationIp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationIp.
func (*SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationIp) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationPort represents the /srl_nokia-acl/acl/capture-filter/ipv4-filter/entry/match/destination-port YANG schema element.
type SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationPort struct {
	Operator E_SrlNokiaPacketMatchTypes_Operator                                              `path:"operator" module:"srl_nokia-acl"`
	Range    *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationPort_Range      `path:"range" module:"srl_nokia-acl"`
	Value    SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationPort_Value_Union `path:"value" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationPort implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationPort) IsYANGGoStruct() {}

// GetOrCreateRange retrieves the value of the Range field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationPort) GetOrCreateRange() *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationPort_Range {
	if t.Range != nil {
		return t.Range
	}
	t.Range = &SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationPort_Range{}
	return t.Range
}

// GetRange returns the value of the Range struct pointer
// from SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationPort. If the receiver or the field Range is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationPort) GetRange() *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationPort_Range {
	if t != nil && t.Range != nil {
		return t.Range
	}
	return nil
}

// GetOperator retrieves the value of the leaf Operator from the SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationPort
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Operator is set, it can
// safely use t.GetOperator() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Operator == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationPort) GetOperator() E_SrlNokiaPacketMatchTypes_Operator {
	if t == nil || t.Operator == 0 {
		return 0
	}
	return t.Operator
}

// GetValue retrieves the value of the leaf Value from the SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationPort
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Value is set, it can
// safely use t.GetValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Value == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationPort) GetValue() SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationPort_Value_Union {
	if t == nil || t.Value == nil {
		return nil
	}
	return t.Value
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationPort
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationPort) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Range.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationPort) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationPort"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationPort) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationPort) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationPort.
func (*SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationPort) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationPort_Range represents the /srl_nokia-acl/acl/capture-filter/ipv4-filter/entry/match/destination-port/range YANG schema element.
type SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationPort_Range struct {
	End   SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationPort_Range_End_Union   `path:"end" module:"srl_nokia-acl"`
	Start SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationPort_Range_Start_Union `path:"start" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationPort_Range implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationPort_Range) IsYANGGoStruct() {}

// GetEnd retrieves the value of the leaf End from the SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationPort_Range
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if End is set, it can
// safely use t.GetEnd() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.End == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationPort_Range) GetEnd() SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationPort_Range_End_Union {
	if t == nil || t.End == nil {
		return nil
	}
	return t.End
}

// GetStart retrieves the value of the leaf Start from the SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationPort_Range
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Start is set, it can
// safely use t.GetStart() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Start == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationPort_Range) GetStart() SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationPort_Range_Start_Union {
	if t == nil || t.Start == nil {
		return nil
	}
	return t.Start
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationPort_Range
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationPort_Range) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationPort_Range) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationPort_Range"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationPort_Range) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationPort_Range) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationPort_Range.
func (*SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationPort_Range) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_Icmp represents the /srl_nokia-acl/acl/capture-filter/ipv4-filter/entry/match/icmp YANG schema element.
type SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_Icmp struct {
	Code []uint8                                                              `path:"code" module:"srl_nokia-acl"`
	Type SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_Icmp_Type_Union `path:"type" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_Icmp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_Icmp) IsYANGGoStruct() {}

// GetCode retrieves the value of the leaf Code from the SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_Icmp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Code is set, it can
// safely use t.GetCode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Code == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_Icmp) GetCode() []uint8 {
	if t == nil || t.Code == nil {
		return nil
	}
	return t.Code
}

// GetType retrieves the value of the leaf Type from the SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_Icmp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Type is set, it can
// safely use t.GetType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Type == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_Icmp) GetType() SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_Icmp_Type_Union {
	if t == nil || t.Type == nil {
		return nil
	}
	return t.Type
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_Icmp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_Icmp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_Icmp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_Icmp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_Icmp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_Icmp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_Icmp.
func (*SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_Icmp) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourceIp represents the /srl_nokia-acl/acl/capture-filter/ipv4-filter/entry/match/source-ip YANG schema element.
type SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourceIp struct {
	Address *string `path:"address" module:"srl_nokia-acl"`
	Mask    *string `path:"mask" module:"srl_nokia-acl"`
	Prefix  *string `path:"prefix" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourceIp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourceIp) IsYANGGoStruct() {}

// GetAddress retrieves the value of the leaf Address from the SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourceIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Address is set, it can
// safely use t.GetAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Address == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourceIp) GetAddress() string {
	if t == nil || t.Address == nil {
		return ""
	}
	return *t.Address
}

// GetMask retrieves the value of the leaf Mask from the SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourceIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Mask is set, it can
// safely use t.GetMask() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Mask == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourceIp) GetMask() string {
	if t == nil || t.Mask == nil {
		return ""
	}
	return *t.Mask
}

// GetPrefix retrieves the value of the leaf Prefix from the SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourceIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Prefix is set, it can
// safely use t.GetPrefix() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Prefix == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourceIp) GetPrefix() string {
	if t == nil || t.Prefix == nil {
		return ""
	}
	return *t.Prefix
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourceIp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourceIp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourceIp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourceIp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourceIp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourceIp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourceIp.
func (*SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourceIp) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourcePort represents the /srl_nokia-acl/acl/capture-filter/ipv4-filter/entry/match/source-port YANG schema element.
type SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourcePort struct {
	Operator E_SrlNokiaPacketMatchTypes_Operator                                         `path:"operator" module:"srl_nokia-acl"`
	Range    *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourcePort_Range      `path:"range" module:"srl_nokia-acl"`
	Value    SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourcePort_Value_Union `path:"value" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourcePort implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourcePort) IsYANGGoStruct() {}

// GetOrCreateRange retrieves the value of the Range field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourcePort) GetOrCreateRange() *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourcePort_Range {
	if t.Range != nil {
		return t.Range
	}
	t.Range = &SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourcePort_Range{}
	return t.Range
}

// GetRange returns the value of the Range struct pointer
// from SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourcePort. If the receiver or the field Range is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourcePort) GetRange() *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourcePort_Range {
	if t != nil && t.Range != nil {
		return t.Range
	}
	return nil
}

// GetOperator retrieves the value of the leaf Operator from the SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourcePort
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Operator is set, it can
// safely use t.GetOperator() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Operator == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourcePort) GetOperator() E_SrlNokiaPacketMatchTypes_Operator {
	if t == nil || t.Operator == 0 {
		return 0
	}
	return t.Operator
}

// GetValue retrieves the value of the leaf Value from the SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourcePort
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Value is set, it can
// safely use t.GetValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Value == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourcePort) GetValue() SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourcePort_Value_Union {
	if t == nil || t.Value == nil {
		return nil
	}
	return t.Value
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourcePort
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourcePort) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Range.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourcePort) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourcePort"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourcePort) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourcePort) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourcePort.
func (*SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourcePort) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourcePort_Range represents the /srl_nokia-acl/acl/capture-filter/ipv4-filter/entry/match/source-port/range YANG schema element.
type SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourcePort_Range struct {
	End   SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourcePort_Range_End_Union   `path:"end" module:"srl_nokia-acl"`
	Start SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourcePort_Range_Start_Union `path:"start" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourcePort_Range implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourcePort_Range) IsYANGGoStruct() {}

// GetEnd retrieves the value of the leaf End from the SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourcePort_Range
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if End is set, it can
// safely use t.GetEnd() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.End == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourcePort_Range) GetEnd() SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourcePort_Range_End_Union {
	if t == nil || t.End == nil {
		return nil
	}
	return t.End
}

// GetStart retrieves the value of the leaf Start from the SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourcePort_Range
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Start is set, it can
// safely use t.GetStart() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Start == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourcePort_Range) GetStart() SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourcePort_Range_Start_Union {
	if t == nil || t.Start == nil {
		return nil
	}
	return t.Start
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourcePort_Range
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourcePort_Range) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourcePort_Range) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourcePort_Range"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourcePort_Range) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourcePort_Range) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourcePort_Range.
func (*SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourcePort_Range) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter represents the /srl_nokia-acl/acl/capture-filter/ipv6-filter YANG schema element.
type SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter struct {
	Entry map[uint32]*SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry `path:"entry" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter) IsYANGGoStruct() {}

// NewEntry creates a new entry in the Entry list of the
// SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter) NewEntry(SequenceId uint32) (*SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[uint32]*SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry)
	}

	key := SequenceId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Entry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Entry", key)
	}

	t.Entry[key] = &SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry{
		SequenceId: &SequenceId,
	}

	return t.Entry[key], nil
}

// RenameEntry renames an entry in the list Entry within
// the SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter) RenameEntry(oldK, newK uint32) error {
	if _, ok := t.Entry[newK]; ok {
		return fmt.Errorf("key %v already exists in Entry", newK)
	}

	e, ok := t.Entry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Entry", oldK)
	}
	e.SequenceId = &newK

	t.Entry[newK] = e
	delete(t.Entry, oldK)
	return nil
}

// GetOrCreateEntry retrieves the value with the specified keys from
// the receiver SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter) GetOrCreateEntry(SequenceId uint32) *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry {
	key := SequenceId

	if v, ok := t.Entry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEntry(SequenceId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEntry got unexpected error: %v", err))
	}
	return v
}

// GetEntry retrieves the value with the specified key from
// the Entry map field of SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter) GetEntry(SequenceId uint32) *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry {
	if t == nil {
		return nil
	}

	key := SequenceId

	if lm, ok := t.Entry[key]; ok {
		return lm
	}
	return nil
}

// DeleteEntry deletes the value with the specified keys from
// the receiver SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter) DeleteEntry(SequenceId uint32) {
	key := SequenceId

	delete(t.Entry, key)
}

// AppendEntry appends the supplied SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry struct to the
// list Entry of SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter. If the key value(s) specified in
// the supplied SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry already exist in the list, an error is
// returned.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter) AppendEntry(v *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry) error {
	if v.SequenceId == nil {
		return fmt.Errorf("invalid nil key received for SequenceId")
	}

	key := *v.SequenceId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[uint32]*SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry)
	}

	if _, ok := t.Entry[key]; ok {
		return fmt.Errorf("duplicate key for list Entry %v", key)
	}

	t.Entry[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Entry {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter.
func (*SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry represents the /srl_nokia-acl/acl/capture-filter/ipv6-filter/entry YANG schema element.
type SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry struct {
	Action      *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action `path:"action" module:"srl_nokia-acl"`
	Description *string                                                `path:"description" module:"srl_nokia-acl"`
	Match       *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match  `path:"match" module:"srl_nokia-acl"`
	SequenceId  *uint32                                                `path:"sequence-id" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry) IsYANGGoStruct() {}

// GetOrCreateAction retrieves the value of the Action field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry) GetOrCreateAction() *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action {
	if t.Action != nil {
		return t.Action
	}
	t.Action = &SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action{}
	return t.Action
}

// GetOrCreateMatch retrieves the value of the Match field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry) GetOrCreateMatch() *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match {
	if t.Match != nil {
		return t.Match
	}
	t.Match = &SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match{}
	return t.Match
}

// GetAction returns the value of the Action struct pointer
// from SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry. If the receiver or the field Action is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry) GetAction() *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action {
	if t != nil && t.Action != nil {
		return t.Action
	}
	return nil
}

// GetMatch returns the value of the Match struct pointer
// from SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry. If the receiver or the field Match is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry) GetMatch() *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match {
	if t != nil && t.Match != nil {
		return t.Match
	}
	return nil
}

// GetDescription retrieves the value of the leaf Description from the SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetSequenceId retrieves the value of the leaf SequenceId from the SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SequenceId is set, it can
// safely use t.GetSequenceId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SequenceId == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry) GetSequenceId() uint32 {
	if t == nil || t.SequenceId == nil {
		return 0
	}
	return *t.SequenceId
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Action.PopulateDefaults()
	t.Match.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry struct, which is a YANG list entry.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry) ΛListKeyMap() (map[string]interface{}, error) {
	if t.SequenceId == nil {
		return nil, fmt.Errorf("nil value for key SequenceId")
	}

	return map[string]interface{}{
		"sequence-id": *t.SequenceId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry.
func (*SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action represents the /srl_nokia-acl/acl/capture-filter/ipv6-filter/entry/action YANG schema element.
type SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action struct {
	Accept *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action_Accept `path:"accept" module:"srl_nokia-acl" yangPresence:"true"`
	Copy   *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action_Copy   `path:"copy" module:"srl_nokia-acl" yangPresence:"true"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action) IsYANGGoStruct() {}

// GetOrCreateAccept retrieves the value of the Accept field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action) GetOrCreateAccept() *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action_Accept {
	if t.Accept != nil {
		return t.Accept
	}
	t.Accept = &SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action_Accept{}
	return t.Accept
}

// GetOrCreateCopy retrieves the value of the Copy field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action) GetOrCreateCopy() *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action_Copy {
	if t.Copy != nil {
		return t.Copy
	}
	t.Copy = &SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action_Copy{}
	return t.Copy
}

// GetAccept returns the value of the Accept struct pointer
// from SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action. If the receiver or the field Accept is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action) GetAccept() *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action_Accept {
	if t != nil && t.Accept != nil {
		return t.Accept
	}
	return nil
}

// GetCopy returns the value of the Copy struct pointer
// from SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action. If the receiver or the field Copy is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action) GetCopy() *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action_Copy {
	if t != nil && t.Copy != nil {
		return t.Copy
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Accept.PopulateDefaults()
	t.Copy.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action.
func (*SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action_Accept represents the /srl_nokia-acl/acl/capture-filter/ipv6-filter/entry/action/accept YANG schema element.
type SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action_Accept struct{}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action_Accept implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action_Accept) IsYANGGoStruct() {}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action_Accept
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action_Accept) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action_Accept) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action_Accept"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action_Accept) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action_Accept) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action_Accept.
func (*SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action_Accept) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action_Copy represents the /srl_nokia-acl/acl/capture-filter/ipv6-filter/entry/action/copy YANG schema element.
type SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action_Copy struct{}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action_Copy implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action_Copy) IsYANGGoStruct() {}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action_Copy
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action_Copy) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action_Copy) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action_Copy"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action_Copy) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action_Copy) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action_Copy.
func (*SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action_Copy) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match represents the /srl_nokia-acl/acl/capture-filter/ipv6-filter/entry/match YANG schema element.
type SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match struct {
	DestinationIp   *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationIp   `path:"destination-ip" module:"srl_nokia-acl"`
	DestinationPort *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationPort `path:"destination-port" module:"srl_nokia-acl"`
	DscpSet         []SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DscpSet_Union  `path:"dscp-set" module:"srl_nokia-acl"`
	Icmp6           *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_Icmp6           `path:"icmp6" module:"srl_nokia-acl"`
	NextHeader      SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_NextHeader_Union `path:"next-header" module:"srl_nokia-acl"`
	SourceIp        *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourceIp        `path:"source-ip" module:"srl_nokia-acl"`
	SourcePort      *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourcePort      `path:"source-port" module:"srl_nokia-acl"`
	TcpFlags        *string                                                               `path:"tcp-flags" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match) IsYANGGoStruct() {}

// GetOrCreateDestinationIp retrieves the value of the DestinationIp field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match) GetOrCreateDestinationIp() *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationIp {
	if t.DestinationIp != nil {
		return t.DestinationIp
	}
	t.DestinationIp = &SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationIp{}
	return t.DestinationIp
}

// GetOrCreateDestinationPort retrieves the value of the DestinationPort field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match) GetOrCreateDestinationPort() *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationPort {
	if t.DestinationPort != nil {
		return t.DestinationPort
	}
	t.DestinationPort = &SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationPort{}
	return t.DestinationPort
}

// GetOrCreateIcmp6 retrieves the value of the Icmp6 field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match) GetOrCreateIcmp6() *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_Icmp6 {
	if t.Icmp6 != nil {
		return t.Icmp6
	}
	t.Icmp6 = &SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_Icmp6{}
	return t.Icmp6
}

// GetOrCreateSourceIp retrieves the value of the SourceIp field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match) GetOrCreateSourceIp() *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourceIp {
	if t.SourceIp != nil {
		return t.SourceIp
	}
	t.SourceIp = &SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourceIp{}
	return t.SourceIp
}

// GetOrCreateSourcePort retrieves the value of the SourcePort field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match) GetOrCreateSourcePort() *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourcePort {
	if t.SourcePort != nil {
		return t.SourcePort
	}
	t.SourcePort = &SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourcePort{}
	return t.SourcePort
}

// GetDestinationIp returns the value of the DestinationIp struct pointer
// from SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match. If the receiver or the field DestinationIp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match) GetDestinationIp() *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationIp {
	if t != nil && t.DestinationIp != nil {
		return t.DestinationIp
	}
	return nil
}

// GetDestinationPort returns the value of the DestinationPort struct pointer
// from SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match. If the receiver or the field DestinationPort is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match) GetDestinationPort() *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationPort {
	if t != nil && t.DestinationPort != nil {
		return t.DestinationPort
	}
	return nil
}

// GetIcmp6 returns the value of the Icmp6 struct pointer
// from SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match. If the receiver or the field Icmp6 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match) GetIcmp6() *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_Icmp6 {
	if t != nil && t.Icmp6 != nil {
		return t.Icmp6
	}
	return nil
}

// GetSourceIp returns the value of the SourceIp struct pointer
// from SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match. If the receiver or the field SourceIp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match) GetSourceIp() *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourceIp {
	if t != nil && t.SourceIp != nil {
		return t.SourceIp
	}
	return nil
}

// GetSourcePort returns the value of the SourcePort struct pointer
// from SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match. If the receiver or the field SourcePort is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match) GetSourcePort() *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourcePort {
	if t != nil && t.SourcePort != nil {
		return t.SourcePort
	}
	return nil
}

// GetDscpSet retrieves the value of the leaf DscpSet from the SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DscpSet is set, it can
// safely use t.GetDscpSet() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DscpSet == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match) GetDscpSet() []SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DscpSet_Union {
	if t == nil || t.DscpSet == nil {
		return nil
	}
	return t.DscpSet
}

// GetNextHeader retrieves the value of the leaf NextHeader from the SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NextHeader is set, it can
// safely use t.GetNextHeader() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NextHeader == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match) GetNextHeader() SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_NextHeader_Union {
	if t == nil || t.NextHeader == nil {
		return nil
	}
	return t.NextHeader
}

// GetTcpFlags retrieves the value of the leaf TcpFlags from the SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TcpFlags is set, it can
// safely use t.GetTcpFlags() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TcpFlags == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match) GetTcpFlags() string {
	if t == nil || t.TcpFlags == nil {
		return ""
	}
	return *t.TcpFlags
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.DestinationIp.PopulateDefaults()
	t.DestinationPort.PopulateDefaults()
	t.Icmp6.PopulateDefaults()
	t.SourceIp.PopulateDefaults()
	t.SourcePort.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match.
func (*SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationIp represents the /srl_nokia-acl/acl/capture-filter/ipv6-filter/entry/match/destination-ip YANG schema element.
type SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationIp struct {
	Address *string `path:"address" module:"srl_nokia-acl"`
	Mask    *string `path:"mask" module:"srl_nokia-acl"`
	Prefix  *string `path:"prefix" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationIp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationIp) IsYANGGoStruct() {}

// GetAddress retrieves the value of the leaf Address from the SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Address is set, it can
// safely use t.GetAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Address == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationIp) GetAddress() string {
	if t == nil || t.Address == nil {
		return ""
	}
	return *t.Address
}

// GetMask retrieves the value of the leaf Mask from the SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Mask is set, it can
// safely use t.GetMask() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Mask == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationIp) GetMask() string {
	if t == nil || t.Mask == nil {
		return ""
	}
	return *t.Mask
}

// GetPrefix retrieves the value of the leaf Prefix from the SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Prefix is set, it can
// safely use t.GetPrefix() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Prefix == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationIp) GetPrefix() string {
	if t == nil || t.Prefix == nil {
		return ""
	}
	return *t.Prefix
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationIp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationIp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationIp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationIp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationIp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationIp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationIp.
func (*SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationIp) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationPort represents the /srl_nokia-acl/acl/capture-filter/ipv6-filter/entry/match/destination-port YANG schema element.
type SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationPort struct {
	Operator E_SrlNokiaPacketMatchTypes_Operator                                              `path:"operator" module:"srl_nokia-acl"`
	Range    *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationPort_Range      `path:"range" module:"srl_nokia-acl"`
	Value    SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationPort_Value_Union `path:"value" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationPort implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationPort) IsYANGGoStruct() {}

// GetOrCreateRange retrieves the value of the Range field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationPort) GetOrCreateRange() *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationPort_Range {
	if t.Range != nil {
		return t.Range
	}
	t.Range = &SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationPort_Range{}
	return t.Range
}

// GetRange returns the value of the Range struct pointer
// from SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationPort. If the receiver or the field Range is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationPort) GetRange() *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationPort_Range {
	if t != nil && t.Range != nil {
		return t.Range
	}
	return nil
}

// GetOperator retrieves the value of the leaf Operator from the SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationPort
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Operator is set, it can
// safely use t.GetOperator() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Operator == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationPort) GetOperator() E_SrlNokiaPacketMatchTypes_Operator {
	if t == nil || t.Operator == 0 {
		return 0
	}
	return t.Operator
}

// GetValue retrieves the value of the leaf Value from the SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationPort
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Value is set, it can
// safely use t.GetValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Value == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationPort) GetValue() SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationPort_Value_Union {
	if t == nil || t.Value == nil {
		return nil
	}
	return t.Value
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationPort
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationPort) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Range.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationPort) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationPort"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationPort) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationPort) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationPort.
func (*SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationPort) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationPort_Range represents the /srl_nokia-acl/acl/capture-filter/ipv6-filter/entry/match/destination-port/range YANG schema element.
type SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationPort_Range struct {
	End   SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationPort_Range_End_Union   `path:"end" module:"srl_nokia-acl"`
	Start SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationPort_Range_Start_Union `path:"start" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationPort_Range implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationPort_Range) IsYANGGoStruct() {}

// GetEnd retrieves the value of the leaf End from the SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationPort_Range
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if End is set, it can
// safely use t.GetEnd() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.End == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationPort_Range) GetEnd() SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationPort_Range_End_Union {
	if t == nil || t.End == nil {
		return nil
	}
	return t.End
}

// GetStart retrieves the value of the leaf Start from the SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationPort_Range
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Start is set, it can
// safely use t.GetStart() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Start == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationPort_Range) GetStart() SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationPort_Range_Start_Union {
	if t == nil || t.Start == nil {
		return nil
	}
	return t.Start
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationPort_Range
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationPort_Range) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationPort_Range) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationPort_Range"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationPort_Range) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationPort_Range) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationPort_Range.
func (*SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationPort_Range) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_Icmp6 represents the /srl_nokia-acl/acl/capture-filter/ipv6-filter/entry/match/icmp6 YANG schema element.
type SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_Icmp6 struct {
	Code []uint8                                                               `path:"code" module:"srl_nokia-acl"`
	Type SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_Icmp6_Type_Union `path:"type" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_Icmp6 implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_Icmp6) IsYANGGoStruct() {}

// GetCode retrieves the value of the leaf Code from the SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_Icmp6
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Code is set, it can
// safely use t.GetCode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Code == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_Icmp6) GetCode() []uint8 {
	if t == nil || t.Code == nil {
		return nil
	}
	return t.Code
}

// GetType retrieves the value of the leaf Type from the SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_Icmp6
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Type is set, it can
// safely use t.GetType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Type == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_Icmp6) GetType() SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_Icmp6_Type_Union {
	if t == nil || t.Type == nil {
		return nil
	}
	return t.Type
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_Icmp6
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_Icmp6) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_Icmp6) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_Icmp6"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_Icmp6) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_Icmp6) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_Icmp6.
func (*SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_Icmp6) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourceIp represents the /srl_nokia-acl/acl/capture-filter/ipv6-filter/entry/match/source-ip YANG schema element.
type SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourceIp struct {
	Address *string `path:"address" module:"srl_nokia-acl"`
	Mask    *string `path:"mask" module:"srl_nokia-acl"`
	Prefix  *string `path:"prefix" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourceIp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourceIp) IsYANGGoStruct() {}

// GetAddress retrieves the value of the leaf Address from the SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourceIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Address is set, it can
// safely use t.GetAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Address == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourceIp) GetAddress() string {
	if t == nil || t.Address == nil {
		return ""
	}
	return *t.Address
}

// GetMask retrieves the value of the leaf Mask from the SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourceIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Mask is set, it can
// safely use t.GetMask() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Mask == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourceIp) GetMask() string {
	if t == nil || t.Mask == nil {
		return ""
	}
	return *t.Mask
}

// GetPrefix retrieves the value of the leaf Prefix from the SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourceIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Prefix is set, it can
// safely use t.GetPrefix() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Prefix == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourceIp) GetPrefix() string {
	if t == nil || t.Prefix == nil {
		return ""
	}
	return *t.Prefix
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourceIp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourceIp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourceIp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourceIp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourceIp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourceIp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourceIp.
func (*SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourceIp) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourcePort represents the /srl_nokia-acl/acl/capture-filter/ipv6-filter/entry/match/source-port YANG schema element.
type SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourcePort struct {
	Operator E_SrlNokiaPacketMatchTypes_Operator                                         `path:"operator" module:"srl_nokia-acl"`
	Range    *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourcePort_Range      `path:"range" module:"srl_nokia-acl"`
	Value    SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourcePort_Value_Union `path:"value" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourcePort implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourcePort) IsYANGGoStruct() {}

// GetOrCreateRange retrieves the value of the Range field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourcePort) GetOrCreateRange() *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourcePort_Range {
	if t.Range != nil {
		return t.Range
	}
	t.Range = &SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourcePort_Range{}
	return t.Range
}

// GetRange returns the value of the Range struct pointer
// from SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourcePort. If the receiver or the field Range is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourcePort) GetRange() *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourcePort_Range {
	if t != nil && t.Range != nil {
		return t.Range
	}
	return nil
}

// GetOperator retrieves the value of the leaf Operator from the SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourcePort
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Operator is set, it can
// safely use t.GetOperator() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Operator == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourcePort) GetOperator() E_SrlNokiaPacketMatchTypes_Operator {
	if t == nil || t.Operator == 0 {
		return 0
	}
	return t.Operator
}

// GetValue retrieves the value of the leaf Value from the SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourcePort
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Value is set, it can
// safely use t.GetValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Value == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourcePort) GetValue() SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourcePort_Value_Union {
	if t == nil || t.Value == nil {
		return nil
	}
	return t.Value
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourcePort
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourcePort) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Range.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourcePort) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourcePort"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourcePort) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourcePort) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourcePort.
func (*SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourcePort) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourcePort_Range represents the /srl_nokia-acl/acl/capture-filter/ipv6-filter/entry/match/source-port/range YANG schema element.
type SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourcePort_Range struct {
	End   SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourcePort_Range_End_Union   `path:"end" module:"srl_nokia-acl"`
	Start SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourcePort_Range_Start_Union `path:"start" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourcePort_Range implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourcePort_Range) IsYANGGoStruct() {}

// GetEnd retrieves the value of the leaf End from the SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourcePort_Range
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if End is set, it can
// safely use t.GetEnd() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.End == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourcePort_Range) GetEnd() SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourcePort_Range_End_Union {
	if t == nil || t.End == nil {
		return nil
	}
	return t.End
}

// GetStart retrieves the value of the leaf Start from the SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourcePort_Range
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Start is set, it can
// safely use t.GetStart() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Start == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourcePort_Range) GetStart() SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourcePort_Range_Start_Union {
	if t == nil || t.Start == nil {
		return nil
	}
	return t.Start
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourcePort_Range
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourcePort_Range) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourcePort_Range) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourcePort_Range"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourcePort_Range) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourcePort_Range) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourcePort_Range.
func (*SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourcePort_Range) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CpmFilter represents the /srl_nokia-acl/acl/cpm-filter YANG schema element.
type SrlNokiaAcl_Acl_CpmFilter struct {
	Ipv4Filter *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter `path:"ipv4-filter" module:"srl_nokia-acl"`
	Ipv6Filter *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter `path:"ipv6-filter" module:"srl_nokia-acl"`
	MacFilter  *SrlNokiaAcl_Acl_CpmFilter_MacFilter  `path:"mac-filter" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CpmFilter implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CpmFilter) IsYANGGoStruct() {}

// GetOrCreateIpv4Filter retrieves the value of the Ipv4Filter field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CpmFilter) GetOrCreateIpv4Filter() *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter {
	if t.Ipv4Filter != nil {
		return t.Ipv4Filter
	}
	t.Ipv4Filter = &SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter{}
	return t.Ipv4Filter
}

// GetOrCreateIpv6Filter retrieves the value of the Ipv6Filter field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CpmFilter) GetOrCreateIpv6Filter() *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter {
	if t.Ipv6Filter != nil {
		return t.Ipv6Filter
	}
	t.Ipv6Filter = &SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter{}
	return t.Ipv6Filter
}

// GetOrCreateMacFilter retrieves the value of the MacFilter field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CpmFilter) GetOrCreateMacFilter() *SrlNokiaAcl_Acl_CpmFilter_MacFilter {
	if t.MacFilter != nil {
		return t.MacFilter
	}
	t.MacFilter = &SrlNokiaAcl_Acl_CpmFilter_MacFilter{}
	return t.MacFilter
}

// GetIpv4Filter returns the value of the Ipv4Filter struct pointer
// from SrlNokiaAcl_Acl_CpmFilter. If the receiver or the field Ipv4Filter is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CpmFilter) GetIpv4Filter() *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter {
	if t != nil && t.Ipv4Filter != nil {
		return t.Ipv4Filter
	}
	return nil
}

// GetIpv6Filter returns the value of the Ipv6Filter struct pointer
// from SrlNokiaAcl_Acl_CpmFilter. If the receiver or the field Ipv6Filter is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CpmFilter) GetIpv6Filter() *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter {
	if t != nil && t.Ipv6Filter != nil {
		return t.Ipv6Filter
	}
	return nil
}

// GetMacFilter returns the value of the MacFilter struct pointer
// from SrlNokiaAcl_Acl_CpmFilter. If the receiver or the field MacFilter is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CpmFilter) GetMacFilter() *SrlNokiaAcl_Acl_CpmFilter_MacFilter {
	if t != nil && t.MacFilter != nil {
		return t.MacFilter
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CpmFilter
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CpmFilter) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Ipv4Filter.PopulateDefaults()
	t.Ipv6Filter.PopulateDefaults()
	t.MacFilter.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CpmFilter"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CpmFilter) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CpmFilter.
func (*SrlNokiaAcl_Acl_CpmFilter) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter represents the /srl_nokia-acl/acl/cpm-filter/ipv4-filter YANG schema element.
type SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter struct {
	Entry              map[uint32]*SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry `path:"entry" module:"srl_nokia-acl"`
	StatisticsPerEntry *bool                                                  `path:"statistics-per-entry" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter) IsYANGGoStruct() {}

// NewEntry creates a new entry in the Entry list of the
// SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter) NewEntry(SequenceId uint32) (*SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[uint32]*SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry)
	}

	key := SequenceId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Entry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Entry", key)
	}

	t.Entry[key] = &SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry{
		SequenceId: &SequenceId,
	}

	return t.Entry[key], nil
}

// RenameEntry renames an entry in the list Entry within
// the SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter) RenameEntry(oldK, newK uint32) error {
	if _, ok := t.Entry[newK]; ok {
		return fmt.Errorf("key %v already exists in Entry", newK)
	}

	e, ok := t.Entry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Entry", oldK)
	}
	e.SequenceId = &newK

	t.Entry[newK] = e
	delete(t.Entry, oldK)
	return nil
}

// GetOrCreateEntry retrieves the value with the specified keys from
// the receiver SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter) GetOrCreateEntry(SequenceId uint32) *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry {
	key := SequenceId

	if v, ok := t.Entry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEntry(SequenceId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEntry got unexpected error: %v", err))
	}
	return v
}

// GetEntry retrieves the value with the specified key from
// the Entry map field of SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter) GetEntry(SequenceId uint32) *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry {
	if t == nil {
		return nil
	}

	key := SequenceId

	if lm, ok := t.Entry[key]; ok {
		return lm
	}
	return nil
}

// DeleteEntry deletes the value with the specified keys from
// the receiver SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter) DeleteEntry(SequenceId uint32) {
	key := SequenceId

	delete(t.Entry, key)
}

// AppendEntry appends the supplied SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry struct to the
// list Entry of SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter. If the key value(s) specified in
// the supplied SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry already exist in the list, an error is
// returned.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter) AppendEntry(v *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry) error {
	if v.SequenceId == nil {
		return fmt.Errorf("invalid nil key received for SequenceId")
	}

	key := *v.SequenceId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[uint32]*SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry)
	}

	if _, ok := t.Entry[key]; ok {
		return fmt.Errorf("duplicate key for list Entry %v", key)
	}

	t.Entry[key] = v
	return nil
}

// GetStatisticsPerEntry retrieves the value of the leaf StatisticsPerEntry from the SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if StatisticsPerEntry is set, it can
// safely use t.GetStatisticsPerEntry() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.StatisticsPerEntry == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter) GetStatisticsPerEntry() bool {
	if t == nil || t.StatisticsPerEntry == nil {
		return false
	}
	return *t.StatisticsPerEntry
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Entry {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry represents the /srl_nokia-acl/acl/cpm-filter/ipv4-filter/entry YANG schema element.
type SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry struct {
	Action      *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action `path:"action" module:"srl_nokia-acl"`
	Description *string                                            `path:"description" module:"srl_nokia-acl"`
	Match       *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match  `path:"match" module:"srl_nokia-acl"`
	SequenceId  *uint32                                            `path:"sequence-id" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry) IsYANGGoStruct() {}

// GetOrCreateAction retrieves the value of the Action field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry) GetOrCreateAction() *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action {
	if t.Action != nil {
		return t.Action
	}
	t.Action = &SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action{}
	return t.Action
}

// GetOrCreateMatch retrieves the value of the Match field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry) GetOrCreateMatch() *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match {
	if t.Match != nil {
		return t.Match
	}
	t.Match = &SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match{}
	return t.Match
}

// GetAction returns the value of the Action struct pointer
// from SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry. If the receiver or the field Action is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry) GetAction() *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action {
	if t != nil && t.Action != nil {
		return t.Action
	}
	return nil
}

// GetMatch returns the value of the Match struct pointer
// from SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry. If the receiver or the field Match is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry) GetMatch() *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match {
	if t != nil && t.Match != nil {
		return t.Match
	}
	return nil
}

// GetDescription retrieves the value of the leaf Description from the SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetSequenceId retrieves the value of the leaf SequenceId from the SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SequenceId is set, it can
// safely use t.GetSequenceId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SequenceId == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry) GetSequenceId() uint32 {
	if t == nil || t.SequenceId == nil {
		return 0
	}
	return *t.SequenceId
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Action.PopulateDefaults()
	t.Match.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry struct, which is a YANG list entry.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry) ΛListKeyMap() (map[string]interface{}, error) {
	if t.SequenceId == nil {
		return nil, fmt.Errorf("nil value for key SequenceId")
	}

	return map[string]interface{}{
		"sequence-id": *t.SequenceId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action represents the /srl_nokia-acl/acl/cpm-filter/ipv4-filter/entry/action YANG schema element.
type SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action struct {
	Accept       *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Accept `path:"accept" module:"srl_nokia-acl" yangPresence:"true"`
	CollectStats *bool                                                     `path:"collect-stats" module:"srl_nokia-acl"`
	Drop         *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Drop   `path:"drop" module:"srl_nokia-acl" yangPresence:"true"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action) IsYANGGoStruct() {}

// GetOrCreateAccept retrieves the value of the Accept field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action) GetOrCreateAccept() *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Accept {
	if t.Accept != nil {
		return t.Accept
	}
	t.Accept = &SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Accept{}
	return t.Accept
}

// GetOrCreateDrop retrieves the value of the Drop field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action) GetOrCreateDrop() *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Drop {
	if t.Drop != nil {
		return t.Drop
	}
	t.Drop = &SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Drop{}
	return t.Drop
}

// GetAccept returns the value of the Accept struct pointer
// from SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action. If the receiver or the field Accept is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action) GetAccept() *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Accept {
	if t != nil && t.Accept != nil {
		return t.Accept
	}
	return nil
}

// GetDrop returns the value of the Drop struct pointer
// from SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action. If the receiver or the field Drop is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action) GetDrop() *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Drop {
	if t != nil && t.Drop != nil {
		return t.Drop
	}
	return nil
}

// GetCollectStats retrieves the value of the leaf CollectStats from the SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if CollectStats is set, it can
// safely use t.GetCollectStats() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.CollectStats == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action) GetCollectStats() bool {
	if t == nil || t.CollectStats == nil {
		return false
	}
	return *t.CollectStats
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.CollectStats == nil {
		var v bool = false
		t.CollectStats = &v
	}
	t.Accept.PopulateDefaults()
	t.Drop.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Accept represents the /srl_nokia-acl/acl/cpm-filter/ipv4-filter/entry/action/accept YANG schema element.
type SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Accept struct {
	Log       *bool                                                               `path:"log" module:"srl_nokia-acl"`
	RateLimit *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Accept_RateLimit `path:"rate-limit" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Accept implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Accept) IsYANGGoStruct() {}

// GetOrCreateRateLimit retrieves the value of the RateLimit field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Accept) GetOrCreateRateLimit() *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Accept_RateLimit {
	if t.RateLimit != nil {
		return t.RateLimit
	}
	t.RateLimit = &SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Accept_RateLimit{}
	return t.RateLimit
}

// GetRateLimit returns the value of the RateLimit struct pointer
// from SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Accept. If the receiver or the field RateLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Accept) GetRateLimit() *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Accept_RateLimit {
	if t != nil && t.RateLimit != nil {
		return t.RateLimit
	}
	return nil
}

// GetLog retrieves the value of the leaf Log from the SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Accept
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Log is set, it can
// safely use t.GetLog() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Log == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Accept) GetLog() bool {
	if t == nil || t.Log == nil {
		return false
	}
	return *t.Log
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Accept
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Accept) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Log == nil {
		var v bool = false
		t.Log = &v
	}
	t.RateLimit.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Accept) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Accept"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Accept) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Accept) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Accept.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Accept) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Accept_RateLimit represents the /srl_nokia-acl/acl/cpm-filter/ipv4-filter/entry/action/accept/rate-limit YANG schema element.
type SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Accept_RateLimit struct {
	Policer          *string `path:"policer" module:"srl_nokia-acl"`
	SystemCpuPolicer *string `path:"system-cpu-policer" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Accept_RateLimit implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Accept_RateLimit) IsYANGGoStruct() {}

// GetPolicer retrieves the value of the leaf Policer from the SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Accept_RateLimit
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Policer is set, it can
// safely use t.GetPolicer() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Policer == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Accept_RateLimit) GetPolicer() string {
	if t == nil || t.Policer == nil {
		return ""
	}
	return *t.Policer
}

// GetSystemCpuPolicer retrieves the value of the leaf SystemCpuPolicer from the SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Accept_RateLimit
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SystemCpuPolicer is set, it can
// safely use t.GetSystemCpuPolicer() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SystemCpuPolicer == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Accept_RateLimit) GetSystemCpuPolicer() string {
	if t == nil || t.SystemCpuPolicer == nil {
		return ""
	}
	return *t.SystemCpuPolicer
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Accept_RateLimit
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Accept_RateLimit) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Accept_RateLimit) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Accept_RateLimit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Accept_RateLimit) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Accept_RateLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Accept_RateLimit.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Accept_RateLimit) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Drop represents the /srl_nokia-acl/acl/cpm-filter/ipv4-filter/entry/action/drop YANG schema element.
type SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Drop struct {
	Log *bool `path:"log" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Drop implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Drop) IsYANGGoStruct() {}

// GetLog retrieves the value of the leaf Log from the SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Drop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Log is set, it can
// safely use t.GetLog() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Log == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Drop) GetLog() bool {
	if t == nil || t.Log == nil {
		return false
	}
	return *t.Log
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Drop
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Drop) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Log == nil {
		var v bool = false
		t.Log = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Drop) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Drop"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Drop) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Drop) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Drop.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Drop) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match represents the /srl_nokia-acl/acl/cpm-filter/ipv4-filter/entry/match YANG schema element.
type SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match struct {
	DestinationIp   *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationIp   `path:"destination-ip" module:"srl_nokia-acl"`
	DestinationPort *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationPort `path:"destination-port" module:"srl_nokia-acl"`
	DscpSet         []SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DscpSet_Union  `path:"dscp-set" module:"srl_nokia-acl"`
	FirstFragment   *bool                                                             `path:"first-fragment" module:"srl_nokia-acl"`
	Fragment        *bool                                                             `path:"fragment" module:"srl_nokia-acl"`
	Icmp            *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_Icmp            `path:"icmp" module:"srl_nokia-acl"`
	NetworkInstance *string                                                           `path:"network-instance" module:"srl_nokia-acl"`
	Protocol        SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_Protocol_Union   `path:"protocol" module:"srl_nokia-acl"`
	SourceIp        *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourceIp        `path:"source-ip" module:"srl_nokia-acl"`
	SourcePort      *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourcePort      `path:"source-port" module:"srl_nokia-acl"`
	TcpFlags        *string                                                           `path:"tcp-flags" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match) IsYANGGoStruct() {}

// GetOrCreateDestinationIp retrieves the value of the DestinationIp field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match) GetOrCreateDestinationIp() *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationIp {
	if t.DestinationIp != nil {
		return t.DestinationIp
	}
	t.DestinationIp = &SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationIp{}
	return t.DestinationIp
}

// GetOrCreateDestinationPort retrieves the value of the DestinationPort field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match) GetOrCreateDestinationPort() *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationPort {
	if t.DestinationPort != nil {
		return t.DestinationPort
	}
	t.DestinationPort = &SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationPort{}
	return t.DestinationPort
}

// GetOrCreateIcmp retrieves the value of the Icmp field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match) GetOrCreateIcmp() *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_Icmp {
	if t.Icmp != nil {
		return t.Icmp
	}
	t.Icmp = &SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_Icmp{}
	return t.Icmp
}

// GetOrCreateSourceIp retrieves the value of the SourceIp field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match) GetOrCreateSourceIp() *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourceIp {
	if t.SourceIp != nil {
		return t.SourceIp
	}
	t.SourceIp = &SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourceIp{}
	return t.SourceIp
}

// GetOrCreateSourcePort retrieves the value of the SourcePort field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match) GetOrCreateSourcePort() *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourcePort {
	if t.SourcePort != nil {
		return t.SourcePort
	}
	t.SourcePort = &SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourcePort{}
	return t.SourcePort
}

// GetDestinationIp returns the value of the DestinationIp struct pointer
// from SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match. If the receiver or the field DestinationIp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match) GetDestinationIp() *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationIp {
	if t != nil && t.DestinationIp != nil {
		return t.DestinationIp
	}
	return nil
}

// GetDestinationPort returns the value of the DestinationPort struct pointer
// from SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match. If the receiver or the field DestinationPort is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match) GetDestinationPort() *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationPort {
	if t != nil && t.DestinationPort != nil {
		return t.DestinationPort
	}
	return nil
}

// GetIcmp returns the value of the Icmp struct pointer
// from SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match. If the receiver or the field Icmp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match) GetIcmp() *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_Icmp {
	if t != nil && t.Icmp != nil {
		return t.Icmp
	}
	return nil
}

// GetSourceIp returns the value of the SourceIp struct pointer
// from SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match. If the receiver or the field SourceIp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match) GetSourceIp() *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourceIp {
	if t != nil && t.SourceIp != nil {
		return t.SourceIp
	}
	return nil
}

// GetSourcePort returns the value of the SourcePort struct pointer
// from SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match. If the receiver or the field SourcePort is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match) GetSourcePort() *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourcePort {
	if t != nil && t.SourcePort != nil {
		return t.SourcePort
	}
	return nil
}

// GetDscpSet retrieves the value of the leaf DscpSet from the SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DscpSet is set, it can
// safely use t.GetDscpSet() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DscpSet == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match) GetDscpSet() []SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DscpSet_Union {
	if t == nil || t.DscpSet == nil {
		return nil
	}
	return t.DscpSet
}

// GetFirstFragment retrieves the value of the leaf FirstFragment from the SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FirstFragment is set, it can
// safely use t.GetFirstFragment() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FirstFragment == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match) GetFirstFragment() bool {
	if t == nil || t.FirstFragment == nil {
		return false
	}
	return *t.FirstFragment
}

// GetFragment retrieves the value of the leaf Fragment from the SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Fragment is set, it can
// safely use t.GetFragment() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Fragment == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match) GetFragment() bool {
	if t == nil || t.Fragment == nil {
		return false
	}
	return *t.Fragment
}

// GetNetworkInstance retrieves the value of the leaf NetworkInstance from the SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NetworkInstance is set, it can
// safely use t.GetNetworkInstance() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NetworkInstance == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match) GetNetworkInstance() string {
	if t == nil || t.NetworkInstance == nil {
		return ""
	}
	return *t.NetworkInstance
}

// GetProtocol retrieves the value of the leaf Protocol from the SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Protocol is set, it can
// safely use t.GetProtocol() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Protocol == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match) GetProtocol() SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_Protocol_Union {
	if t == nil || t.Protocol == nil {
		return nil
	}
	return t.Protocol
}

// GetTcpFlags retrieves the value of the leaf TcpFlags from the SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TcpFlags is set, it can
// safely use t.GetTcpFlags() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TcpFlags == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match) GetTcpFlags() string {
	if t == nil || t.TcpFlags == nil {
		return ""
	}
	return *t.TcpFlags
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.DestinationIp.PopulateDefaults()
	t.DestinationPort.PopulateDefaults()
	t.Icmp.PopulateDefaults()
	t.SourceIp.PopulateDefaults()
	t.SourcePort.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationIp represents the /srl_nokia-acl/acl/cpm-filter/ipv4-filter/entry/match/destination-ip YANG schema element.
type SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationIp struct {
	Address *string `path:"address" module:"srl_nokia-acl"`
	Mask    *string `path:"mask" module:"srl_nokia-acl"`
	Prefix  *string `path:"prefix" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationIp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationIp) IsYANGGoStruct() {}

// GetAddress retrieves the value of the leaf Address from the SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Address is set, it can
// safely use t.GetAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Address == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationIp) GetAddress() string {
	if t == nil || t.Address == nil {
		return ""
	}
	return *t.Address
}

// GetMask retrieves the value of the leaf Mask from the SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Mask is set, it can
// safely use t.GetMask() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Mask == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationIp) GetMask() string {
	if t == nil || t.Mask == nil {
		return ""
	}
	return *t.Mask
}

// GetPrefix retrieves the value of the leaf Prefix from the SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Prefix is set, it can
// safely use t.GetPrefix() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Prefix == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationIp) GetPrefix() string {
	if t == nil || t.Prefix == nil {
		return ""
	}
	return *t.Prefix
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationIp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationIp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationIp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationIp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationIp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationIp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationIp.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationIp) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationPort represents the /srl_nokia-acl/acl/cpm-filter/ipv4-filter/entry/match/destination-port YANG schema element.
type SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationPort struct {
	Operator E_SrlNokiaPacketMatchTypes_Operator                                          `path:"operator" module:"srl_nokia-acl"`
	Range    *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationPort_Range      `path:"range" module:"srl_nokia-acl"`
	Value    SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationPort_Value_Union `path:"value" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationPort implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationPort) IsYANGGoStruct() {}

// GetOrCreateRange retrieves the value of the Range field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationPort) GetOrCreateRange() *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationPort_Range {
	if t.Range != nil {
		return t.Range
	}
	t.Range = &SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationPort_Range{}
	return t.Range
}

// GetRange returns the value of the Range struct pointer
// from SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationPort. If the receiver or the field Range is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationPort) GetRange() *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationPort_Range {
	if t != nil && t.Range != nil {
		return t.Range
	}
	return nil
}

// GetOperator retrieves the value of the leaf Operator from the SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationPort
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Operator is set, it can
// safely use t.GetOperator() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Operator == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationPort) GetOperator() E_SrlNokiaPacketMatchTypes_Operator {
	if t == nil || t.Operator == 0 {
		return 0
	}
	return t.Operator
}

// GetValue retrieves the value of the leaf Value from the SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationPort
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Value is set, it can
// safely use t.GetValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Value == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationPort) GetValue() SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationPort_Value_Union {
	if t == nil || t.Value == nil {
		return nil
	}
	return t.Value
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationPort
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationPort) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Range.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationPort) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationPort"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationPort) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationPort) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationPort.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationPort) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationPort_Range represents the /srl_nokia-acl/acl/cpm-filter/ipv4-filter/entry/match/destination-port/range YANG schema element.
type SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationPort_Range struct {
	End   SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationPort_Range_End_Union   `path:"end" module:"srl_nokia-acl"`
	Start SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationPort_Range_Start_Union `path:"start" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationPort_Range implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationPort_Range) IsYANGGoStruct() {}

// GetEnd retrieves the value of the leaf End from the SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationPort_Range
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if End is set, it can
// safely use t.GetEnd() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.End == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationPort_Range) GetEnd() SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationPort_Range_End_Union {
	if t == nil || t.End == nil {
		return nil
	}
	return t.End
}

// GetStart retrieves the value of the leaf Start from the SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationPort_Range
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Start is set, it can
// safely use t.GetStart() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Start == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationPort_Range) GetStart() SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationPort_Range_Start_Union {
	if t == nil || t.Start == nil {
		return nil
	}
	return t.Start
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationPort_Range
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationPort_Range) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationPort_Range) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationPort_Range"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationPort_Range) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationPort_Range) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationPort_Range.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationPort_Range) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_Icmp represents the /srl_nokia-acl/acl/cpm-filter/ipv4-filter/entry/match/icmp YANG schema element.
type SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_Icmp struct {
	Code []uint8                                                          `path:"code" module:"srl_nokia-acl"`
	Type SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_Icmp_Type_Union `path:"type" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_Icmp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_Icmp) IsYANGGoStruct() {}

// GetCode retrieves the value of the leaf Code from the SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_Icmp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Code is set, it can
// safely use t.GetCode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Code == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_Icmp) GetCode() []uint8 {
	if t == nil || t.Code == nil {
		return nil
	}
	return t.Code
}

// GetType retrieves the value of the leaf Type from the SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_Icmp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Type is set, it can
// safely use t.GetType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Type == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_Icmp) GetType() SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_Icmp_Type_Union {
	if t == nil || t.Type == nil {
		return nil
	}
	return t.Type
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_Icmp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_Icmp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_Icmp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_Icmp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_Icmp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_Icmp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_Icmp.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_Icmp) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourceIp represents the /srl_nokia-acl/acl/cpm-filter/ipv4-filter/entry/match/source-ip YANG schema element.
type SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourceIp struct {
	Address *string `path:"address" module:"srl_nokia-acl"`
	Mask    *string `path:"mask" module:"srl_nokia-acl"`
	Prefix  *string `path:"prefix" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourceIp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourceIp) IsYANGGoStruct() {}

// GetAddress retrieves the value of the leaf Address from the SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourceIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Address is set, it can
// safely use t.GetAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Address == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourceIp) GetAddress() string {
	if t == nil || t.Address == nil {
		return ""
	}
	return *t.Address
}

// GetMask retrieves the value of the leaf Mask from the SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourceIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Mask is set, it can
// safely use t.GetMask() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Mask == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourceIp) GetMask() string {
	if t == nil || t.Mask == nil {
		return ""
	}
	return *t.Mask
}

// GetPrefix retrieves the value of the leaf Prefix from the SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourceIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Prefix is set, it can
// safely use t.GetPrefix() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Prefix == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourceIp) GetPrefix() string {
	if t == nil || t.Prefix == nil {
		return ""
	}
	return *t.Prefix
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourceIp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourceIp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourceIp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourceIp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourceIp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourceIp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourceIp.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourceIp) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourcePort represents the /srl_nokia-acl/acl/cpm-filter/ipv4-filter/entry/match/source-port YANG schema element.
type SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourcePort struct {
	Operator E_SrlNokiaPacketMatchTypes_Operator                                     `path:"operator" module:"srl_nokia-acl"`
	Range    *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourcePort_Range      `path:"range" module:"srl_nokia-acl"`
	Value    SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourcePort_Value_Union `path:"value" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourcePort implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourcePort) IsYANGGoStruct() {}

// GetOrCreateRange retrieves the value of the Range field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourcePort) GetOrCreateRange() *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourcePort_Range {
	if t.Range != nil {
		return t.Range
	}
	t.Range = &SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourcePort_Range{}
	return t.Range
}

// GetRange returns the value of the Range struct pointer
// from SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourcePort. If the receiver or the field Range is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourcePort) GetRange() *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourcePort_Range {
	if t != nil && t.Range != nil {
		return t.Range
	}
	return nil
}

// GetOperator retrieves the value of the leaf Operator from the SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourcePort
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Operator is set, it can
// safely use t.GetOperator() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Operator == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourcePort) GetOperator() E_SrlNokiaPacketMatchTypes_Operator {
	if t == nil || t.Operator == 0 {
		return 0
	}
	return t.Operator
}

// GetValue retrieves the value of the leaf Value from the SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourcePort
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Value is set, it can
// safely use t.GetValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Value == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourcePort) GetValue() SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourcePort_Value_Union {
	if t == nil || t.Value == nil {
		return nil
	}
	return t.Value
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourcePort
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourcePort) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Range.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourcePort) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourcePort"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourcePort) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourcePort) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourcePort.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourcePort) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourcePort_Range represents the /srl_nokia-acl/acl/cpm-filter/ipv4-filter/entry/match/source-port/range YANG schema element.
type SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourcePort_Range struct {
	End   SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourcePort_Range_End_Union   `path:"end" module:"srl_nokia-acl"`
	Start SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourcePort_Range_Start_Union `path:"start" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourcePort_Range implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourcePort_Range) IsYANGGoStruct() {}

// GetEnd retrieves the value of the leaf End from the SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourcePort_Range
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if End is set, it can
// safely use t.GetEnd() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.End == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourcePort_Range) GetEnd() SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourcePort_Range_End_Union {
	if t == nil || t.End == nil {
		return nil
	}
	return t.End
}

// GetStart retrieves the value of the leaf Start from the SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourcePort_Range
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Start is set, it can
// safely use t.GetStart() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Start == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourcePort_Range) GetStart() SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourcePort_Range_Start_Union {
	if t == nil || t.Start == nil {
		return nil
	}
	return t.Start
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourcePort_Range
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourcePort_Range) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourcePort_Range) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourcePort_Range"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourcePort_Range) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourcePort_Range) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourcePort_Range.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourcePort_Range) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter represents the /srl_nokia-acl/acl/cpm-filter/ipv6-filter YANG schema element.
type SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter struct {
	Entry              map[uint32]*SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry `path:"entry" module:"srl_nokia-acl"`
	StatisticsPerEntry *bool                                                  `path:"statistics-per-entry" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter) IsYANGGoStruct() {}

// NewEntry creates a new entry in the Entry list of the
// SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter) NewEntry(SequenceId uint32) (*SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[uint32]*SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry)
	}

	key := SequenceId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Entry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Entry", key)
	}

	t.Entry[key] = &SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry{
		SequenceId: &SequenceId,
	}

	return t.Entry[key], nil
}

// RenameEntry renames an entry in the list Entry within
// the SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter) RenameEntry(oldK, newK uint32) error {
	if _, ok := t.Entry[newK]; ok {
		return fmt.Errorf("key %v already exists in Entry", newK)
	}

	e, ok := t.Entry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Entry", oldK)
	}
	e.SequenceId = &newK

	t.Entry[newK] = e
	delete(t.Entry, oldK)
	return nil
}

// GetOrCreateEntry retrieves the value with the specified keys from
// the receiver SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter) GetOrCreateEntry(SequenceId uint32) *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry {
	key := SequenceId

	if v, ok := t.Entry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEntry(SequenceId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEntry got unexpected error: %v", err))
	}
	return v
}

// GetEntry retrieves the value with the specified key from
// the Entry map field of SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter) GetEntry(SequenceId uint32) *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry {
	if t == nil {
		return nil
	}

	key := SequenceId

	if lm, ok := t.Entry[key]; ok {
		return lm
	}
	return nil
}

// DeleteEntry deletes the value with the specified keys from
// the receiver SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter) DeleteEntry(SequenceId uint32) {
	key := SequenceId

	delete(t.Entry, key)
}

// AppendEntry appends the supplied SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry struct to the
// list Entry of SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter. If the key value(s) specified in
// the supplied SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry already exist in the list, an error is
// returned.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter) AppendEntry(v *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry) error {
	if v.SequenceId == nil {
		return fmt.Errorf("invalid nil key received for SequenceId")
	}

	key := *v.SequenceId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[uint32]*SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry)
	}

	if _, ok := t.Entry[key]; ok {
		return fmt.Errorf("duplicate key for list Entry %v", key)
	}

	t.Entry[key] = v
	return nil
}

// GetStatisticsPerEntry retrieves the value of the leaf StatisticsPerEntry from the SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if StatisticsPerEntry is set, it can
// safely use t.GetStatisticsPerEntry() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.StatisticsPerEntry == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter) GetStatisticsPerEntry() bool {
	if t == nil || t.StatisticsPerEntry == nil {
		return false
	}
	return *t.StatisticsPerEntry
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Entry {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry represents the /srl_nokia-acl/acl/cpm-filter/ipv6-filter/entry YANG schema element.
type SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry struct {
	Action      *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action `path:"action" module:"srl_nokia-acl"`
	Description *string                                            `path:"description" module:"srl_nokia-acl"`
	Match       *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match  `path:"match" module:"srl_nokia-acl"`
	SequenceId  *uint32                                            `path:"sequence-id" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry) IsYANGGoStruct() {}

// GetOrCreateAction retrieves the value of the Action field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry) GetOrCreateAction() *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action {
	if t.Action != nil {
		return t.Action
	}
	t.Action = &SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action{}
	return t.Action
}

// GetOrCreateMatch retrieves the value of the Match field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry) GetOrCreateMatch() *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match {
	if t.Match != nil {
		return t.Match
	}
	t.Match = &SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match{}
	return t.Match
}

// GetAction returns the value of the Action struct pointer
// from SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry. If the receiver or the field Action is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry) GetAction() *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action {
	if t != nil && t.Action != nil {
		return t.Action
	}
	return nil
}

// GetMatch returns the value of the Match struct pointer
// from SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry. If the receiver or the field Match is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry) GetMatch() *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match {
	if t != nil && t.Match != nil {
		return t.Match
	}
	return nil
}

// GetDescription retrieves the value of the leaf Description from the SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetSequenceId retrieves the value of the leaf SequenceId from the SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SequenceId is set, it can
// safely use t.GetSequenceId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SequenceId == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry) GetSequenceId() uint32 {
	if t == nil || t.SequenceId == nil {
		return 0
	}
	return *t.SequenceId
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Action.PopulateDefaults()
	t.Match.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry struct, which is a YANG list entry.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry) ΛListKeyMap() (map[string]interface{}, error) {
	if t.SequenceId == nil {
		return nil, fmt.Errorf("nil value for key SequenceId")
	}

	return map[string]interface{}{
		"sequence-id": *t.SequenceId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action represents the /srl_nokia-acl/acl/cpm-filter/ipv6-filter/entry/action YANG schema element.
type SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action struct {
	Accept       *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Accept `path:"accept" module:"srl_nokia-acl" yangPresence:"true"`
	CollectStats *bool                                                     `path:"collect-stats" module:"srl_nokia-acl"`
	Drop         *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Drop   `path:"drop" module:"srl_nokia-acl" yangPresence:"true"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action) IsYANGGoStruct() {}

// GetOrCreateAccept retrieves the value of the Accept field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action) GetOrCreateAccept() *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Accept {
	if t.Accept != nil {
		return t.Accept
	}
	t.Accept = &SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Accept{}
	return t.Accept
}

// GetOrCreateDrop retrieves the value of the Drop field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action) GetOrCreateDrop() *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Drop {
	if t.Drop != nil {
		return t.Drop
	}
	t.Drop = &SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Drop{}
	return t.Drop
}

// GetAccept returns the value of the Accept struct pointer
// from SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action. If the receiver or the field Accept is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action) GetAccept() *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Accept {
	if t != nil && t.Accept != nil {
		return t.Accept
	}
	return nil
}

// GetDrop returns the value of the Drop struct pointer
// from SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action. If the receiver or the field Drop is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action) GetDrop() *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Drop {
	if t != nil && t.Drop != nil {
		return t.Drop
	}
	return nil
}

// GetCollectStats retrieves the value of the leaf CollectStats from the SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if CollectStats is set, it can
// safely use t.GetCollectStats() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.CollectStats == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action) GetCollectStats() bool {
	if t == nil || t.CollectStats == nil {
		return false
	}
	return *t.CollectStats
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.CollectStats == nil {
		var v bool = false
		t.CollectStats = &v
	}
	t.Accept.PopulateDefaults()
	t.Drop.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Accept represents the /srl_nokia-acl/acl/cpm-filter/ipv6-filter/entry/action/accept YANG schema element.
type SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Accept struct {
	Log       *bool                                                               `path:"log" module:"srl_nokia-acl"`
	RateLimit *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Accept_RateLimit `path:"rate-limit" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Accept implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Accept) IsYANGGoStruct() {}

// GetOrCreateRateLimit retrieves the value of the RateLimit field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Accept) GetOrCreateRateLimit() *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Accept_RateLimit {
	if t.RateLimit != nil {
		return t.RateLimit
	}
	t.RateLimit = &SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Accept_RateLimit{}
	return t.RateLimit
}

// GetRateLimit returns the value of the RateLimit struct pointer
// from SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Accept. If the receiver or the field RateLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Accept) GetRateLimit() *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Accept_RateLimit {
	if t != nil && t.RateLimit != nil {
		return t.RateLimit
	}
	return nil
}

// GetLog retrieves the value of the leaf Log from the SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Accept
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Log is set, it can
// safely use t.GetLog() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Log == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Accept) GetLog() bool {
	if t == nil || t.Log == nil {
		return false
	}
	return *t.Log
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Accept
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Accept) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Log == nil {
		var v bool = false
		t.Log = &v
	}
	t.RateLimit.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Accept) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Accept"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Accept) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Accept) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Accept.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Accept) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Accept_RateLimit represents the /srl_nokia-acl/acl/cpm-filter/ipv6-filter/entry/action/accept/rate-limit YANG schema element.
type SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Accept_RateLimit struct {
	Policer          *string `path:"policer" module:"srl_nokia-acl"`
	SystemCpuPolicer *string `path:"system-cpu-policer" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Accept_RateLimit implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Accept_RateLimit) IsYANGGoStruct() {}

// GetPolicer retrieves the value of the leaf Policer from the SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Accept_RateLimit
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Policer is set, it can
// safely use t.GetPolicer() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Policer == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Accept_RateLimit) GetPolicer() string {
	if t == nil || t.Policer == nil {
		return ""
	}
	return *t.Policer
}

// GetSystemCpuPolicer retrieves the value of the leaf SystemCpuPolicer from the SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Accept_RateLimit
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SystemCpuPolicer is set, it can
// safely use t.GetSystemCpuPolicer() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SystemCpuPolicer == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Accept_RateLimit) GetSystemCpuPolicer() string {
	if t == nil || t.SystemCpuPolicer == nil {
		return ""
	}
	return *t.SystemCpuPolicer
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Accept_RateLimit
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Accept_RateLimit) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Accept_RateLimit) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Accept_RateLimit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Accept_RateLimit) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Accept_RateLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Accept_RateLimit.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Accept_RateLimit) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Drop represents the /srl_nokia-acl/acl/cpm-filter/ipv6-filter/entry/action/drop YANG schema element.
type SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Drop struct {
	Log *bool `path:"log" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Drop implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Drop) IsYANGGoStruct() {}

// GetLog retrieves the value of the leaf Log from the SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Drop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Log is set, it can
// safely use t.GetLog() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Log == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Drop) GetLog() bool {
	if t == nil || t.Log == nil {
		return false
	}
	return *t.Log
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Drop
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Drop) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Log == nil {
		var v bool = false
		t.Log = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Drop) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Drop"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Drop) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Drop) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Drop.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Drop) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match represents the /srl_nokia-acl/acl/cpm-filter/ipv6-filter/entry/match YANG schema element.
type SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match struct {
	DestinationIp   *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationIp   `path:"destination-ip" module:"srl_nokia-acl"`
	DestinationPort *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationPort `path:"destination-port" module:"srl_nokia-acl"`
	DscpSet         []SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DscpSet_Union  `path:"dscp-set" module:"srl_nokia-acl"`
	Icmp6           *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_Icmp6           `path:"icmp6" module:"srl_nokia-acl"`
	NetworkInstance *string                                                           `path:"network-instance" module:"srl_nokia-acl"`
	NextHeader      SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_NextHeader_Union `path:"next-header" module:"srl_nokia-acl"`
	SourceIp        *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourceIp        `path:"source-ip" module:"srl_nokia-acl"`
	SourcePort      *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourcePort      `path:"source-port" module:"srl_nokia-acl"`
	TcpFlags        *string                                                           `path:"tcp-flags" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match) IsYANGGoStruct() {}

// GetOrCreateDestinationIp retrieves the value of the DestinationIp field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match) GetOrCreateDestinationIp() *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationIp {
	if t.DestinationIp != nil {
		return t.DestinationIp
	}
	t.DestinationIp = &SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationIp{}
	return t.DestinationIp
}

// GetOrCreateDestinationPort retrieves the value of the DestinationPort field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match) GetOrCreateDestinationPort() *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationPort {
	if t.DestinationPort != nil {
		return t.DestinationPort
	}
	t.DestinationPort = &SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationPort{}
	return t.DestinationPort
}

// GetOrCreateIcmp6 retrieves the value of the Icmp6 field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match) GetOrCreateIcmp6() *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_Icmp6 {
	if t.Icmp6 != nil {
		return t.Icmp6
	}
	t.Icmp6 = &SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_Icmp6{}
	return t.Icmp6
}

// GetOrCreateSourceIp retrieves the value of the SourceIp field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match) GetOrCreateSourceIp() *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourceIp {
	if t.SourceIp != nil {
		return t.SourceIp
	}
	t.SourceIp = &SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourceIp{}
	return t.SourceIp
}

// GetOrCreateSourcePort retrieves the value of the SourcePort field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match) GetOrCreateSourcePort() *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourcePort {
	if t.SourcePort != nil {
		return t.SourcePort
	}
	t.SourcePort = &SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourcePort{}
	return t.SourcePort
}

// GetDestinationIp returns the value of the DestinationIp struct pointer
// from SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match. If the receiver or the field DestinationIp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match) GetDestinationIp() *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationIp {
	if t != nil && t.DestinationIp != nil {
		return t.DestinationIp
	}
	return nil
}

// GetDestinationPort returns the value of the DestinationPort struct pointer
// from SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match. If the receiver or the field DestinationPort is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match) GetDestinationPort() *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationPort {
	if t != nil && t.DestinationPort != nil {
		return t.DestinationPort
	}
	return nil
}

// GetIcmp6 returns the value of the Icmp6 struct pointer
// from SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match. If the receiver or the field Icmp6 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match) GetIcmp6() *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_Icmp6 {
	if t != nil && t.Icmp6 != nil {
		return t.Icmp6
	}
	return nil
}

// GetSourceIp returns the value of the SourceIp struct pointer
// from SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match. If the receiver or the field SourceIp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match) GetSourceIp() *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourceIp {
	if t != nil && t.SourceIp != nil {
		return t.SourceIp
	}
	return nil
}

// GetSourcePort returns the value of the SourcePort struct pointer
// from SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match. If the receiver or the field SourcePort is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match) GetSourcePort() *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourcePort {
	if t != nil && t.SourcePort != nil {
		return t.SourcePort
	}
	return nil
}

// GetDscpSet retrieves the value of the leaf DscpSet from the SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DscpSet is set, it can
// safely use t.GetDscpSet() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DscpSet == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match) GetDscpSet() []SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DscpSet_Union {
	if t == nil || t.DscpSet == nil {
		return nil
	}
	return t.DscpSet
}

// GetNetworkInstance retrieves the value of the leaf NetworkInstance from the SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NetworkInstance is set, it can
// safely use t.GetNetworkInstance() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NetworkInstance == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match) GetNetworkInstance() string {
	if t == nil || t.NetworkInstance == nil {
		return ""
	}
	return *t.NetworkInstance
}

// GetNextHeader retrieves the value of the leaf NextHeader from the SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NextHeader is set, it can
// safely use t.GetNextHeader() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NextHeader == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match) GetNextHeader() SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_NextHeader_Union {
	if t == nil || t.NextHeader == nil {
		return nil
	}
	return t.NextHeader
}

// GetTcpFlags retrieves the value of the leaf TcpFlags from the SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TcpFlags is set, it can
// safely use t.GetTcpFlags() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TcpFlags == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match) GetTcpFlags() string {
	if t == nil || t.TcpFlags == nil {
		return ""
	}
	return *t.TcpFlags
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.DestinationIp.PopulateDefaults()
	t.DestinationPort.PopulateDefaults()
	t.Icmp6.PopulateDefaults()
	t.SourceIp.PopulateDefaults()
	t.SourcePort.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationIp represents the /srl_nokia-acl/acl/cpm-filter/ipv6-filter/entry/match/destination-ip YANG schema element.
type SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationIp struct {
	Address *string `path:"address" module:"srl_nokia-acl"`
	Mask    *string `path:"mask" module:"srl_nokia-acl"`
	Prefix  *string `path:"prefix" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationIp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationIp) IsYANGGoStruct() {}

// GetAddress retrieves the value of the leaf Address from the SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Address is set, it can
// safely use t.GetAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Address == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationIp) GetAddress() string {
	if t == nil || t.Address == nil {
		return ""
	}
	return *t.Address
}

// GetMask retrieves the value of the leaf Mask from the SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Mask is set, it can
// safely use t.GetMask() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Mask == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationIp) GetMask() string {
	if t == nil || t.Mask == nil {
		return ""
	}
	return *t.Mask
}

// GetPrefix retrieves the value of the leaf Prefix from the SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Prefix is set, it can
// safely use t.GetPrefix() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Prefix == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationIp) GetPrefix() string {
	if t == nil || t.Prefix == nil {
		return ""
	}
	return *t.Prefix
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationIp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationIp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationIp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationIp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationIp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationIp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationIp.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationIp) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationPort represents the /srl_nokia-acl/acl/cpm-filter/ipv6-filter/entry/match/destination-port YANG schema element.
type SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationPort struct {
	Operator E_SrlNokiaPacketMatchTypes_Operator                                          `path:"operator" module:"srl_nokia-acl"`
	Range    *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationPort_Range      `path:"range" module:"srl_nokia-acl"`
	Value    SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationPort_Value_Union `path:"value" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationPort implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationPort) IsYANGGoStruct() {}

// GetOrCreateRange retrieves the value of the Range field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationPort) GetOrCreateRange() *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationPort_Range {
	if t.Range != nil {
		return t.Range
	}
	t.Range = &SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationPort_Range{}
	return t.Range
}

// GetRange returns the value of the Range struct pointer
// from SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationPort. If the receiver or the field Range is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationPort) GetRange() *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationPort_Range {
	if t != nil && t.Range != nil {
		return t.Range
	}
	return nil
}

// GetOperator retrieves the value of the leaf Operator from the SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationPort
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Operator is set, it can
// safely use t.GetOperator() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Operator == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationPort) GetOperator() E_SrlNokiaPacketMatchTypes_Operator {
	if t == nil || t.Operator == 0 {
		return 0
	}
	return t.Operator
}

// GetValue retrieves the value of the leaf Value from the SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationPort
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Value is set, it can
// safely use t.GetValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Value == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationPort) GetValue() SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationPort_Value_Union {
	if t == nil || t.Value == nil {
		return nil
	}
	return t.Value
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationPort
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationPort) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Range.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationPort) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationPort"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationPort) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationPort) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationPort.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationPort) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationPort_Range represents the /srl_nokia-acl/acl/cpm-filter/ipv6-filter/entry/match/destination-port/range YANG schema element.
type SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationPort_Range struct {
	End   SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationPort_Range_End_Union   `path:"end" module:"srl_nokia-acl"`
	Start SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationPort_Range_Start_Union `path:"start" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationPort_Range implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationPort_Range) IsYANGGoStruct() {}

// GetEnd retrieves the value of the leaf End from the SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationPort_Range
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if End is set, it can
// safely use t.GetEnd() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.End == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationPort_Range) GetEnd() SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationPort_Range_End_Union {
	if t == nil || t.End == nil {
		return nil
	}
	return t.End
}

// GetStart retrieves the value of the leaf Start from the SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationPort_Range
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Start is set, it can
// safely use t.GetStart() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Start == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationPort_Range) GetStart() SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationPort_Range_Start_Union {
	if t == nil || t.Start == nil {
		return nil
	}
	return t.Start
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationPort_Range
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationPort_Range) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationPort_Range) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationPort_Range"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationPort_Range) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationPort_Range) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationPort_Range.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationPort_Range) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_Icmp6 represents the /srl_nokia-acl/acl/cpm-filter/ipv6-filter/entry/match/icmp6 YANG schema element.
type SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_Icmp6 struct {
	Code []uint8                                                           `path:"code" module:"srl_nokia-acl"`
	Type SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_Icmp6_Type_Union `path:"type" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_Icmp6 implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_Icmp6) IsYANGGoStruct() {}

// GetCode retrieves the value of the leaf Code from the SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_Icmp6
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Code is set, it can
// safely use t.GetCode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Code == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_Icmp6) GetCode() []uint8 {
	if t == nil || t.Code == nil {
		return nil
	}
	return t.Code
}

// GetType retrieves the value of the leaf Type from the SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_Icmp6
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Type is set, it can
// safely use t.GetType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Type == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_Icmp6) GetType() SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_Icmp6_Type_Union {
	if t == nil || t.Type == nil {
		return nil
	}
	return t.Type
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_Icmp6
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_Icmp6) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_Icmp6) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_Icmp6"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_Icmp6) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_Icmp6) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_Icmp6.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_Icmp6) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourceIp represents the /srl_nokia-acl/acl/cpm-filter/ipv6-filter/entry/match/source-ip YANG schema element.
type SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourceIp struct {
	Address *string `path:"address" module:"srl_nokia-acl"`
	Mask    *string `path:"mask" module:"srl_nokia-acl"`
	Prefix  *string `path:"prefix" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourceIp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourceIp) IsYANGGoStruct() {}

// GetAddress retrieves the value of the leaf Address from the SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourceIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Address is set, it can
// safely use t.GetAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Address == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourceIp) GetAddress() string {
	if t == nil || t.Address == nil {
		return ""
	}
	return *t.Address
}

// GetMask retrieves the value of the leaf Mask from the SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourceIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Mask is set, it can
// safely use t.GetMask() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Mask == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourceIp) GetMask() string {
	if t == nil || t.Mask == nil {
		return ""
	}
	return *t.Mask
}

// GetPrefix retrieves the value of the leaf Prefix from the SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourceIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Prefix is set, it can
// safely use t.GetPrefix() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Prefix == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourceIp) GetPrefix() string {
	if t == nil || t.Prefix == nil {
		return ""
	}
	return *t.Prefix
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourceIp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourceIp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourceIp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourceIp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourceIp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourceIp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourceIp.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourceIp) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourcePort represents the /srl_nokia-acl/acl/cpm-filter/ipv6-filter/entry/match/source-port YANG schema element.
type SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourcePort struct {
	Operator E_SrlNokiaPacketMatchTypes_Operator                                     `path:"operator" module:"srl_nokia-acl"`
	Range    *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourcePort_Range      `path:"range" module:"srl_nokia-acl"`
	Value    SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourcePort_Value_Union `path:"value" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourcePort implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourcePort) IsYANGGoStruct() {}

// GetOrCreateRange retrieves the value of the Range field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourcePort) GetOrCreateRange() *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourcePort_Range {
	if t.Range != nil {
		return t.Range
	}
	t.Range = &SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourcePort_Range{}
	return t.Range
}

// GetRange returns the value of the Range struct pointer
// from SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourcePort. If the receiver or the field Range is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourcePort) GetRange() *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourcePort_Range {
	if t != nil && t.Range != nil {
		return t.Range
	}
	return nil
}

// GetOperator retrieves the value of the leaf Operator from the SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourcePort
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Operator is set, it can
// safely use t.GetOperator() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Operator == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourcePort) GetOperator() E_SrlNokiaPacketMatchTypes_Operator {
	if t == nil || t.Operator == 0 {
		return 0
	}
	return t.Operator
}

// GetValue retrieves the value of the leaf Value from the SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourcePort
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Value is set, it can
// safely use t.GetValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Value == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourcePort) GetValue() SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourcePort_Value_Union {
	if t == nil || t.Value == nil {
		return nil
	}
	return t.Value
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourcePort
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourcePort) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Range.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourcePort) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourcePort"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourcePort) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourcePort) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourcePort.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourcePort) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourcePort_Range represents the /srl_nokia-acl/acl/cpm-filter/ipv6-filter/entry/match/source-port/range YANG schema element.
type SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourcePort_Range struct {
	End   SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourcePort_Range_End_Union   `path:"end" module:"srl_nokia-acl"`
	Start SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourcePort_Range_Start_Union `path:"start" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourcePort_Range implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourcePort_Range) IsYANGGoStruct() {}

// GetEnd retrieves the value of the leaf End from the SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourcePort_Range
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if End is set, it can
// safely use t.GetEnd() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.End == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourcePort_Range) GetEnd() SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourcePort_Range_End_Union {
	if t == nil || t.End == nil {
		return nil
	}
	return t.End
}

// GetStart retrieves the value of the leaf Start from the SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourcePort_Range
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Start is set, it can
// safely use t.GetStart() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Start == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourcePort_Range) GetStart() SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourcePort_Range_Start_Union {
	if t == nil || t.Start == nil {
		return nil
	}
	return t.Start
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourcePort_Range
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourcePort_Range) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourcePort_Range) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourcePort_Range"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourcePort_Range) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourcePort_Range) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourcePort_Range.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourcePort_Range) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CpmFilter_MacFilter represents the /srl_nokia-acl/acl/cpm-filter/mac-filter YANG schema element.
type SrlNokiaAcl_Acl_CpmFilter_MacFilter struct {
	Entry              map[uint32]*SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry `path:"entry" module:"srl_nokia-acl"`
	StatisticsPerEntry *bool                                                 `path:"statistics-per-entry" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CpmFilter_MacFilter implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CpmFilter_MacFilter) IsYANGGoStruct() {}

// NewEntry creates a new entry in the Entry list of the
// SrlNokiaAcl_Acl_CpmFilter_MacFilter struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter) NewEntry(SequenceId uint32) (*SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[uint32]*SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry)
	}

	key := SequenceId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Entry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Entry", key)
	}

	t.Entry[key] = &SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry{
		SequenceId: &SequenceId,
	}

	return t.Entry[key], nil
}

// RenameEntry renames an entry in the list Entry within
// the SrlNokiaAcl_Acl_CpmFilter_MacFilter struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter) RenameEntry(oldK, newK uint32) error {
	if _, ok := t.Entry[newK]; ok {
		return fmt.Errorf("key %v already exists in Entry", newK)
	}

	e, ok := t.Entry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Entry", oldK)
	}
	e.SequenceId = &newK

	t.Entry[newK] = e
	delete(t.Entry, oldK)
	return nil
}

// GetOrCreateEntry retrieves the value with the specified keys from
// the receiver SrlNokiaAcl_Acl_CpmFilter_MacFilter. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter) GetOrCreateEntry(SequenceId uint32) *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry {
	key := SequenceId

	if v, ok := t.Entry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEntry(SequenceId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEntry got unexpected error: %v", err))
	}
	return v
}

// GetEntry retrieves the value with the specified key from
// the Entry map field of SrlNokiaAcl_Acl_CpmFilter_MacFilter. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter) GetEntry(SequenceId uint32) *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry {
	if t == nil {
		return nil
	}

	key := SequenceId

	if lm, ok := t.Entry[key]; ok {
		return lm
	}
	return nil
}

// DeleteEntry deletes the value with the specified keys from
// the receiver SrlNokiaAcl_Acl_CpmFilter_MacFilter. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter) DeleteEntry(SequenceId uint32) {
	key := SequenceId

	delete(t.Entry, key)
}

// AppendEntry appends the supplied SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry struct to the
// list Entry of SrlNokiaAcl_Acl_CpmFilter_MacFilter. If the key value(s) specified in
// the supplied SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry already exist in the list, an error is
// returned.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter) AppendEntry(v *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry) error {
	if v.SequenceId == nil {
		return fmt.Errorf("invalid nil key received for SequenceId")
	}

	key := *v.SequenceId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[uint32]*SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry)
	}

	if _, ok := t.Entry[key]; ok {
		return fmt.Errorf("duplicate key for list Entry %v", key)
	}

	t.Entry[key] = v
	return nil
}

// GetStatisticsPerEntry retrieves the value of the leaf StatisticsPerEntry from the SrlNokiaAcl_Acl_CpmFilter_MacFilter
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if StatisticsPerEntry is set, it can
// safely use t.GetStatisticsPerEntry() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.StatisticsPerEntry == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter) GetStatisticsPerEntry() bool {
	if t == nil || t.StatisticsPerEntry == nil {
		return false
	}
	return *t.StatisticsPerEntry
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CpmFilter_MacFilter
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Entry {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CpmFilter_MacFilter"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CpmFilter_MacFilter.
func (*SrlNokiaAcl_Acl_CpmFilter_MacFilter) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry represents the /srl_nokia-acl/acl/cpm-filter/mac-filter/entry YANG schema element.
type SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry struct {
	Action      *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action `path:"action" module:"srl_nokia-acl"`
	Description *string                                           `path:"description" module:"srl_nokia-acl"`
	Match       *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match  `path:"match" module:"srl_nokia-acl"`
	SequenceId  *uint32                                           `path:"sequence-id" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry) IsYANGGoStruct() {}

// GetOrCreateAction retrieves the value of the Action field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry) GetOrCreateAction() *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action {
	if t.Action != nil {
		return t.Action
	}
	t.Action = &SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action{}
	return t.Action
}

// GetOrCreateMatch retrieves the value of the Match field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry) GetOrCreateMatch() *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match {
	if t.Match != nil {
		return t.Match
	}
	t.Match = &SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match{}
	return t.Match
}

// GetAction returns the value of the Action struct pointer
// from SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry. If the receiver or the field Action is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry) GetAction() *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action {
	if t != nil && t.Action != nil {
		return t.Action
	}
	return nil
}

// GetMatch returns the value of the Match struct pointer
// from SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry. If the receiver or the field Match is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry) GetMatch() *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match {
	if t != nil && t.Match != nil {
		return t.Match
	}
	return nil
}

// GetDescription retrieves the value of the leaf Description from the SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetSequenceId retrieves the value of the leaf SequenceId from the SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SequenceId is set, it can
// safely use t.GetSequenceId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SequenceId == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry) GetSequenceId() uint32 {
	if t == nil || t.SequenceId == nil {
		return 0
	}
	return *t.SequenceId
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Action.PopulateDefaults()
	t.Match.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry struct, which is a YANG list entry.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry) ΛListKeyMap() (map[string]interface{}, error) {
	if t.SequenceId == nil {
		return nil, fmt.Errorf("nil value for key SequenceId")
	}

	return map[string]interface{}{
		"sequence-id": *t.SequenceId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry.
func (*SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action represents the /srl_nokia-acl/acl/cpm-filter/mac-filter/entry/action YANG schema element.
type SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action struct {
	Accept       *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Accept `path:"accept" module:"srl_nokia-acl" yangPresence:"true"`
	CollectStats *bool                                                    `path:"collect-stats" module:"srl_nokia-acl"`
	Drop         *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Drop   `path:"drop" module:"srl_nokia-acl" yangPresence:"true"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action) IsYANGGoStruct() {}

// GetOrCreateAccept retrieves the value of the Accept field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action) GetOrCreateAccept() *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Accept {
	if t.Accept != nil {
		return t.Accept
	}
	t.Accept = &SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Accept{}
	return t.Accept
}

// GetOrCreateDrop retrieves the value of the Drop field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action) GetOrCreateDrop() *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Drop {
	if t.Drop != nil {
		return t.Drop
	}
	t.Drop = &SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Drop{}
	return t.Drop
}

// GetAccept returns the value of the Accept struct pointer
// from SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action. If the receiver or the field Accept is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action) GetAccept() *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Accept {
	if t != nil && t.Accept != nil {
		return t.Accept
	}
	return nil
}

// GetDrop returns the value of the Drop struct pointer
// from SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action. If the receiver or the field Drop is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action) GetDrop() *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Drop {
	if t != nil && t.Drop != nil {
		return t.Drop
	}
	return nil
}

// GetCollectStats retrieves the value of the leaf CollectStats from the SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if CollectStats is set, it can
// safely use t.GetCollectStats() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.CollectStats == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action) GetCollectStats() bool {
	if t == nil || t.CollectStats == nil {
		return false
	}
	return *t.CollectStats
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.CollectStats == nil {
		var v bool = false
		t.CollectStats = &v
	}
	t.Accept.PopulateDefaults()
	t.Drop.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action.
func (*SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Accept represents the /srl_nokia-acl/acl/cpm-filter/mac-filter/entry/action/accept YANG schema element.
type SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Accept struct {
	Log       *bool                                                              `path:"log" module:"srl_nokia-acl"`
	RateLimit *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Accept_RateLimit `path:"rate-limit" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Accept implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Accept) IsYANGGoStruct() {}

// GetOrCreateRateLimit retrieves the value of the RateLimit field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Accept) GetOrCreateRateLimit() *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Accept_RateLimit {
	if t.RateLimit != nil {
		return t.RateLimit
	}
	t.RateLimit = &SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Accept_RateLimit{}
	return t.RateLimit
}

// GetRateLimit returns the value of the RateLimit struct pointer
// from SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Accept. If the receiver or the field RateLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Accept) GetRateLimit() *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Accept_RateLimit {
	if t != nil && t.RateLimit != nil {
		return t.RateLimit
	}
	return nil
}

// GetLog retrieves the value of the leaf Log from the SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Accept
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Log is set, it can
// safely use t.GetLog() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Log == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Accept) GetLog() bool {
	if t == nil || t.Log == nil {
		return false
	}
	return *t.Log
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Accept
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Accept) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Log == nil {
		var v bool = false
		t.Log = &v
	}
	t.RateLimit.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Accept) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Accept"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Accept) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Accept) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Accept.
func (*SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Accept) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Accept_RateLimit represents the /srl_nokia-acl/acl/cpm-filter/mac-filter/entry/action/accept/rate-limit YANG schema element.
type SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Accept_RateLimit struct {
	Policer          *string `path:"policer" module:"srl_nokia-acl"`
	SystemCpuPolicer *string `path:"system-cpu-policer" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Accept_RateLimit implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Accept_RateLimit) IsYANGGoStruct() {}

// GetPolicer retrieves the value of the leaf Policer from the SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Accept_RateLimit
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Policer is set, it can
// safely use t.GetPolicer() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Policer == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Accept_RateLimit) GetPolicer() string {
	if t == nil || t.Policer == nil {
		return ""
	}
	return *t.Policer
}

// GetSystemCpuPolicer retrieves the value of the leaf SystemCpuPolicer from the SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Accept_RateLimit
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SystemCpuPolicer is set, it can
// safely use t.GetSystemCpuPolicer() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SystemCpuPolicer == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Accept_RateLimit) GetSystemCpuPolicer() string {
	if t == nil || t.SystemCpuPolicer == nil {
		return ""
	}
	return *t.SystemCpuPolicer
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Accept_RateLimit
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Accept_RateLimit) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Accept_RateLimit) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Accept_RateLimit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Accept_RateLimit) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Accept_RateLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Accept_RateLimit.
func (*SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Accept_RateLimit) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Drop represents the /srl_nokia-acl/acl/cpm-filter/mac-filter/entry/action/drop YANG schema element.
type SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Drop struct {
	Log *bool `path:"log" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Drop implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Drop) IsYANGGoStruct() {}

// GetLog retrieves the value of the leaf Log from the SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Drop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Log is set, it can
// safely use t.GetLog() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Log == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Drop) GetLog() bool {
	if t == nil || t.Log == nil {
		return false
	}
	return *t.Log
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Drop
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Drop) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Log == nil {
		var v bool = false
		t.Log = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Drop) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Drop"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Drop) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Drop) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Drop.
func (*SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Drop) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match represents the /srl_nokia-acl/acl/cpm-filter/mac-filter/entry/match YANG schema element.
type SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match struct {
	DestinationMac *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_DestinationMac `path:"destination-mac" module:"srl_nokia-acl"`
	Ethertype      SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_Ethertype_Union `path:"ethertype" module:"srl_nokia-acl"`
	SourceMac      *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_SourceMac      `path:"source-mac" module:"srl_nokia-acl"`
	Vlan           *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_Vlan           `path:"vlan" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match) IsYANGGoStruct() {}

// GetOrCreateDestinationMac retrieves the value of the DestinationMac field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match) GetOrCreateDestinationMac() *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_DestinationMac {
	if t.DestinationMac != nil {
		return t.DestinationMac
	}
	t.DestinationMac = &SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_DestinationMac{}
	return t.DestinationMac
}

// GetOrCreateSourceMac retrieves the value of the SourceMac field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match) GetOrCreateSourceMac() *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_SourceMac {
	if t.SourceMac != nil {
		return t.SourceMac
	}
	t.SourceMac = &SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_SourceMac{}
	return t.SourceMac
}

// GetOrCreateVlan retrieves the value of the Vlan field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match) GetOrCreateVlan() *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_Vlan {
	if t.Vlan != nil {
		return t.Vlan
	}
	t.Vlan = &SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_Vlan{}
	return t.Vlan
}

// GetDestinationMac returns the value of the DestinationMac struct pointer
// from SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match. If the receiver or the field DestinationMac is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match) GetDestinationMac() *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_DestinationMac {
	if t != nil && t.DestinationMac != nil {
		return t.DestinationMac
	}
	return nil
}

// GetSourceMac returns the value of the SourceMac struct pointer
// from SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match. If the receiver or the field SourceMac is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match) GetSourceMac() *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_SourceMac {
	if t != nil && t.SourceMac != nil {
		return t.SourceMac
	}
	return nil
}

// GetVlan returns the value of the Vlan struct pointer
// from SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match. If the receiver or the field Vlan is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match) GetVlan() *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_Vlan {
	if t != nil && t.Vlan != nil {
		return t.Vlan
	}
	return nil
}

// GetEthertype retrieves the value of the leaf Ethertype from the SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ethertype is set, it can
// safely use t.GetEthertype() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ethertype == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match) GetEthertype() SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_Ethertype_Union {
	if t == nil || t.Ethertype == nil {
		return nil
	}
	return t.Ethertype
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.DestinationMac.PopulateDefaults()
	t.SourceMac.PopulateDefaults()
	t.Vlan.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match.
func (*SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_DestinationMac represents the /srl_nokia-acl/acl/cpm-filter/mac-filter/entry/match/destination-mac YANG schema element.
type SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_DestinationMac struct {
	Address *string `path:"address" module:"srl_nokia-acl"`
	Mask    *string `path:"mask" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_DestinationMac implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_DestinationMac) IsYANGGoStruct() {}

// GetAddress retrieves the value of the leaf Address from the SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_DestinationMac
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Address is set, it can
// safely use t.GetAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Address == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_DestinationMac) GetAddress() string {
	if t == nil || t.Address == nil {
		return ""
	}
	return *t.Address
}

// GetMask retrieves the value of the leaf Mask from the SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_DestinationMac
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Mask is set, it can
// safely use t.GetMask() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Mask == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_DestinationMac) GetMask() string {
	if t == nil || t.Mask == nil {
		return ""
	}
	return *t.Mask
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_DestinationMac
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_DestinationMac) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_DestinationMac) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_DestinationMac"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_DestinationMac) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_DestinationMac) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_DestinationMac.
func (*SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_DestinationMac) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_SourceMac represents the /srl_nokia-acl/acl/cpm-filter/mac-filter/entry/match/source-mac YANG schema element.
type SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_SourceMac struct {
	Address *string `path:"address" module:"srl_nokia-acl"`
	Mask    *string `path:"mask" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_SourceMac implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_SourceMac) IsYANGGoStruct() {}

// GetAddress retrieves the value of the leaf Address from the SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_SourceMac
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Address is set, it can
// safely use t.GetAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Address == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_SourceMac) GetAddress() string {
	if t == nil || t.Address == nil {
		return ""
	}
	return *t.Address
}

// GetMask retrieves the value of the leaf Mask from the SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_SourceMac
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Mask is set, it can
// safely use t.GetMask() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Mask == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_SourceMac) GetMask() string {
	if t == nil || t.Mask == nil {
		return ""
	}
	return *t.Mask
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_SourceMac
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_SourceMac) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_SourceMac) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_SourceMac"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_SourceMac) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_SourceMac) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_SourceMac.
func (*SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_SourceMac) ΛBelongingModule() string {
	return "srl_nokia-acl"
}
